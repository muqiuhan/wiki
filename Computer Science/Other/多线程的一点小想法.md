#multi-thread

标准的做法是：如果计算机有 32 个核心，那么开一个 FIFO 队列，把要计算的数据扔到这个队列里，然后开 36 个线程，每个线程去队列中取数据，算完一个再去队列中取一下个数据....直到队列中没数据。

CPU 密集型任务比 CPU 核心数 (如果 CPU 有超线程技术，可以按算上超线程的核心数) 略多几个是最快的，过多的线程反而会更慢，没有空闲的核心，过多的线程只能等待，并没有并行运算效果，反而线程不停的切来切去，浪费性能，通常每次切换过程需要耗费大约 1000 个 CPU 时钟周期。

略多几个的原因是，CPU 在真正运算开始前，需要等待数据被装入寄存器，而数据从内存装入寄存器，也需要一些时间，略多几个，可以让 CPU 在等待数据就绪时，~~切换到数据已经就绪的线程上开始运算。~~ (多发射的乱序执行也是解决内存速度跟不上cpu的一种有效手段，但是并不是切换到另一个线程)

如果数据在内存中连续，数据量不大 (相对CPU高速缓存) ，那么装载数据到寄存器的开销就会比较小，就可以附加少一点的线程，比如 1~2 个就够了，反之，数据分散，缓存命中率低，就需要多几个线程，比如 6~8 个。

另外，还可以考虑使用 SIMD 加速计算，如果数据量再多，还可以考虑CUDA-GPU加速。