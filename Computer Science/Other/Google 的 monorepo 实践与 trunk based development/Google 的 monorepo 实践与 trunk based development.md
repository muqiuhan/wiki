#git #software-engineering 
## Intro.

早期的 Google 员工决定使用通过集中式源代码控制系统管理的共享代码库。这种方法已经为 Google 服务了超过 16 年，如今 Google 的绝大多数软件资产继续存储在单一的、共享的存储库中。与此同时，Google 软件开发人员的数量稳步增加，Google 代码库的规模呈指数级增长。因此，用于托管代码库的技术也有了显著的发展。

![[Pasted image 20250102153026.png]]

Google使用自主开发的版本控制系统来托管一个大型 monorepo，该代码库对公司中的大多数软件开发人员可见并供其使用。这个集中式系统是 Google 许多开发人员工作流程的基础。除此之外还有“trunk-based development”策略以及构建工作流和保持 Google 代码库健康的支持系统，包括用于静态分析、代码清理和简化代码审查等软件。
### Google 的规模
Google代码库包含大约10亿个文件，在 Google 18 年的历史中大约有 3500 万次提交，该存储库包含 86TB 的数据，包括大约 900 万个源文件，20 亿行代码。

2014年，谷歌存储库中大约每周都涉及 25 万个文件约 1500 万行代码的更改。这个存储库中的内容被来自世界各国数十个分公司的 25,000 多名谷歌软件开发人员共享。在一个常规的工作日中，他们向代码库提交的更改高达 16,000 项，另外 24,000 项更改由自动化系统提交。每天，存储库处理数十亿个文件读取请求，在流量高峰期间，每秒查询率约为 800,000次，平均每个工作日约为每秒 500,000 次。这些流量大部分来自谷歌的分布式构建和测试系统。

![[Pasted image 20250102153707.png]]

![[Pasted image 20250102153716.png]]

2012年10月，Google 的中央存储库增加了对 Windows 和 Mac 用户的支持（在此之前仅支持Linux），每周提交图显示，直到2012年，提交率一直由人类用户主导，当时谷歌转向了自主的源码控制实现。

![[Pasted image 20250102153837.png]]

管理这种规模的存储库及其工作活动对谷歌来说一直是一个持续的挑战。尽管进行了几年的实验，谷歌还是没能找到一个商业可用或开源的版本控制系统来支持这种规模的单个存储库。于是出现了一个为存储、版本控制这个代码库而构建的专有系统，代号为 Piper。

## 背景

在阐述使用 monorepo 的优缺点之前，需要一些关于Google工具和工作流程的背景知识。

### Piper 和 CitC
Piper存储一个大型存储库，并在标准的 Google 基础架构之上实现。Piper 分布在全球 10 个 Google 数据中心中，依靠 Paxos 算法来保证跨 replicas 的一致性。这种架构提供了高度的冗余（在 Paxos 算法中，"redundancy" 通常指的是系统中为了提高可靠性和容错能力而引入的冗余机制。），并有助于优化 Google 软件开发人员的使用体验。此外，缓存和异步操作对开发人员屏蔽了大部分网络延迟（这很重要，因为 Google 基于云的工具链的全部 feature 需要开发人员在线使用。）

在 Piper 发布之前的 10 多年里，谷歌一直依赖于一个托管在一台机器上的主要 Perforce实例，以及定制的缓存基础设施。持续增大的存储库是 Google 开发 Piper 的动机。

由于谷歌的源代码是公司最重要的资产之一，安全性也是 Piper 设计中的一个关键考虑因素。Piper 支持文件级权限控制。大多数存储库对所有 Piper 用户都是可见的；然而，重要的配置文件或包括关键业务算法在内的文件会得到更严格的控制。此外，对 Piper 中文件的读写访问都有记录。如果敏感数据意外地提交给 Piper，可以很轻松的删掉有问题的文件。日志允许管理员在删除有问题的文件之前确定是否有人访问了该文件。

在 Piper 工作流中，开发人员在更改之前先在存储库中创建文件的本地副本。这些文件存储在开发人员拥有的工作区中。Piper 工作区就相当于 Apache Subversion 中的工作副本、Git 中的本地克隆或 Perforce 中的客户端。Piper 存储库中的更新可以根据需要拉入工作区并与正在进行的工作合并。工作区的快照可以与其他开发人员共享以进行重新查看。工作区中的文件只有在完成谷歌代码审查过程后才会提交到中央存储库。

![[Pasted image 20250102155121.png]]

所有对文件的写入都以快照的形式存储在 CitC 中，这样就可以根据需要重新覆盖以前的工作。快照可以被显式命名、恢复或标记以供审查。CitC 工作区可以在任何可以连接到基于云的存储系统的机器上使用，这使切换到另一台机器上无缝的继续工作变得方便。

开发人员还能够在 CitC 工作区中查看彼此的工作。在云中存储所有正在进行的工作是谷歌工作流过程的一个重要元素。

一些工作流利用 CitC 使软件开发人员能够更高效地使用大型代码库。例如，当发送更改以进行代码审查时，开发人员可以启用自动提交选项，这在代码作者和审查者处于不同时区时特别有用。当审查被标记为完成时，测试将运行；如果通过，代码将被提交到存储库，而无需进一步的人工干预。

Piper 也可以在没有 CitC 的情况下使用。开发人员可以将 Piper 工作区存储在他们的本地机器上。Piper 与 Git 的互操作性较为有限。如今，超过 80% 的Piper用户使用 CitC，由于 CitC 提供的许多优势，采用率持续增长。

Piper 和 CitC 使得在谷歌这种规模的代码量上使用单一的、整体的存储库成为可能。这些系统的设计和架构都受到谷歌采用的 `Trunk-based development.` 开发范式的严重影响。

## Trunk-based development.

Google的 "Trunk-Based Development"（TBD）策略是一种软件开发方法，其中开发者频繁地将代码变更集成到一个共享的主分支（称为trunk或mainline）中，而不是在长期存在的特性分支上工作，这种方法强调持续交付工作的软件，与敏捷方法论相辅相成。

### TBD的关键原则

- 主分支是代码库最可靠的来源，允许开发者定期集成变更以维护稳定性。
- 开发者在一天中多次将代码变更集成到主分支，减少在单独分支上花费的时间，并允许早期发现和解决集成问题。
- 专注于对代码进行小的、自包含的变更，这种方法将工作分解成更小的部分，有助于减少复杂性、最小化冲突，并加快集成和审查过程。
- 使用特性开关可以将代码部署与新功能的发布分开，允许逐步推出新功能，进行A/B测试，必要时容易回滚。
- 定期稳定主分支是维护其可发布状态的常见做法。团队分配专门时间来解决集成问题、解决冲突以及修复任何回归或缺陷。
- 作为持续集成过程的一部分，定期进行自动化测试，如单元测试和集成测试。这种方法让团队能够快速识别和解决回归、兼容性和功能问题。

TBD 鼓励持续集成，开发者频繁将变更合并到主线中。这种方法确保代码定期集成，有助于早期识别和解决集成问题，减少大型和复杂合并的风险，并使团队能够尽早发现问题。通过在共享主干上工作更有效地协作。多个团队成员可以同时在不同功能上工作，无需另开长时间线的特性分支。这种开发策略使团队能够将较小的、增量变更交付到生产环境中。

TBD 这种迭代方法促进了来自用户和利益相关者的快速反馈，使根据他们的反馈进行适应和整合变更变得更加容易。由于长时间线的特性分支可能导致代码冲突和复杂性显著增加。相比之下，TBD 通过最小化分支分离的时间来保持代码库的可维护性。
### 特性开关 (Feature Toggles)
也称为功能标志，是 TBD 中用于分离代码部署和功能发布的工具。它们允许团队在不改变代码或只修改少量代码的情况下改变系统行为，从而控制功能的发布、权限策略、测试策略和控制突发事件等。

- 团队可以逐步推出新功能，进行 A/B 测试，并在必要时轻松回滚。例如，在开发一个新用户界面时，可以通过特性开关在生产环境中隐藏该界面，直到其实现完成。
- 和分支抽象（Branch-by-Abstraction）技术结合使用，允许团队在不中断现有功能的情况下，逐步替换旧的实现。这种技术使得新旧代码可以并行存在，直到新代码完全准备好发布。
- 特性开关可以解决多个开关之间的依赖问题，例如，可以控制一个开关为真，则另一个开关不能为真。此外，它们还可以在开关变化时触发副作用，如数据库更新或远程API 调用，这通过所谓的“开关伴侣”（toggle companions）实现。

### 发布分支
发布分支的管理是TBD中的另一个重要方面，特别是在需要隔离不兼容的开发或延迟发布功能时。

通常，实施TBD的团队会在发布前几天拉出一个发布分支，以保留线上环境的代码，同时不影响其他开发继续往主干分支上提交代码。这种方式允许团队在计划发布的间隙进行bug修复。

根据不兼容策略，发布分支不应该继续承载新功能开发。发布分支的目的是隔离不兼容的代码，而不是作为新功能开发的地方。

在某些情况下，发布分支在发布后会被删除。这是为了保持代码库的清洁和集中管理，避免旧的发布分支成为未来的负担。

对于高效的持续交付团队，如果他们在生产环境中发现了bug，他们可以选择向前推进策略，即直接在主干分支上修复bug，然后从主干分支发布到生产环境，这样可以忽略发布分支。

![[Pasted image 20250102162058.png]]

## Diamond Dependency Problem

钻石依赖问题（Diamond Dependency Problem）是一个在软件工程中常见的依赖管理问题，尤其在处理多层次依赖关系时。这个问题通常发生在以下情况：当有两个或更多的依赖项共享同一个公共依赖项，并且这些依赖项需要这个公共依赖项的不同版本时。

具体来说，钻石依赖问题可以通过一个简单的图形来解释：
```
      A
     / \
    B   C
     \ /
      D
```

在这个图形中，组件A依赖于组件B和C，而B和C又都依赖于组件D。但是，如果B需要D的版本1，而C需要D的版本2，那么组件A就面临一个问题：它无法同时满足B和C的依赖要求。这就形成了一个所谓的“钻石形状”的依赖结构，因为从A向下看，B和C在D处相遇，形成了钻石的四个顶点。

在Google的实践中，由于所有代码都存储在同一个代码库中，钻石依赖问题基本可以避免。因为当一个团队需要增加功能时，所有团队都会接收到增加的新功能，保持所有人处于依赖项的 HEAD 版。在这种模型中，版本号的概念并不存在，因为所有团队都使用同一版本的代码。这种方法减少了版本冲突的可能性，并简化了依赖管理。
![[Pasted image 20250102162554.png]]

## Refs.
- [Why Google Stores Billions of Lines of Code in a Single Repository](https://dl.acm.org/doi/pdf/10.1145/2854146)
- [版本分支管理标准 - Trunk Based Development 主干开发模型](https://cloud.tencent.com/developer/article/1505551)
- [《Software Engineering at Google》中文版-谷歌的软件工程](https://geekdaxue.co/books/Software-Engineering-at-Google)
- [What is a diamond dependency conflict?](https://github.com/GoogleCloudPlatform/cloud-opensource-java/diffs/1?base_sha=aa48adecbc4a7e63d9c6d9b27a7bf8809a30a438&head_user=garrettjonesgoogle&name=master&pull_number=1253&qualified_name=refs%2Fheads%2Fmaster&sha1=aa48adecbc4a7e63d9c6d9b27a7bf8809a30a438&sha2=980288e5355d90d61fe7d552bcdd468cc390c92a&short_path=bfe1c71&unchanged=expanded&w=false)
- [Why I Prefer Trunk-Based Development](https://koenvangilst.nl/blog/trunkbased-development)
- [Using Release Feature Toggles for Trunk-Based Development](https://edgamat.com/2022/03/27/Using-Release-Feature-Toggles.html)