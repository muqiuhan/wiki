#svelte #web #compiler

在 svelte 源码里，使用了 [`acorn`](https://github.com/acornjs/acorn) parser 将 javascript 编译成 ast 树，然后对 Javascript 的语义解释过程做了额外的工作：

- 编译赋值语句时，除了生成对应的赋值逻辑，额外生成数据更新逻辑代码
    
- 编译变量声明时，变量被编译成上下文数组
    
- 编译模板时，标记依赖，并对每个变量引用生成更新逻辑
    

这就是编译型框架，与传统前端框架的区别：把运行时的逻辑提前在编译期就完成。所以自然而然的，运行时逻辑很轻量级，很显然是有利于页面的首屏和渲染性能的。

### 组件的底层实现

每一个 .svelte 文件代表一个 svelte 的组件。

通过 svelte 的编译，最终会转换为下图所示的组件的结构

![[Pasted image 20241115111951.png]]

每一个 svelte 的组件类，都继承了 `SvelteComponent`。

svelte 组件使用 `create`, `mount`, `patch`, `destroy` 这四个方法实现对 DOM 视图的操作。

- `create` 负责组件 dom 的创建
    
- `mount` 负责将 dom 挂载到对应的父节点上
    
- `patch` 负责根据数据的变化更新 dom
    
- `destroy` 负责销毁对应的 dom
    

svelte 的组件实例化，是通过 `instance` 方法和组件上下文构成的。

- `instance` 方法是 svelte 组件的构造器。写在 script 里的代码，会被生成在 `instance` 方法里。每个组件实例都会调用一次形成自己的闭包，从而隔离各自的数据，通过 `instance` 方法返回的数组就是上下文。代码中的赋值语句，会被生成为数据更新逻辑。变量定义会被收集生成上下文数组。
- 每个 svelte 组件都会有自己的上下文，上下文存储的就是 script 标签内定义的变量的值。svelte 会为每个组件实例内定义的数据生成上下文，按照变量的声明顺序保存在一个名为 `ctx` 数组内。

![[Pasted image 20241115112012.png]]

### 模板编译

例如有如下 Svelte 代码:
```svelte
<h1>Hello world!</h1>
```

编译后:

```js
/* App.svelte generated by Svelte v3.59.1 */
import {
  SvelteComponent,
  detach,
  element,
  init,
  insert,
  noop,
  safe_not_equal
} from "svelte/internal";

function create_fragment(ctx) {
  let h1;

  return {
    c() {
      h1 = element("h1");
      h1.textContent = "Hello world!";
    },
    m(target, anchor) {
      insert(target, h1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) detach(h1);
    }
  };
}

class App extends SvelteComponent {
  constructor(options) {
    super();  
    init(this, options, null, create_fragment, safe_not_equal, {});
  }
}

export default App;
```


很明显，组件编译之后，会返回一个继承了`SvelteComponent`的类，并且在构造函数中执行了`init`方法，它的其中一个参数是组件中定义的`create_fragment`函数。

这个函数会返回一个对象，包含组件对应的的`create` `mount` `update` `delete`操作。由于上面的代码中是个静态的字符串，所以`p`对应的值为`noop`即`no operate`没有操作。

接下来加点料:
```svelte
<script>
let count = 0
</script>
<h1 on:click={() => count++}>Hello world!</h1>
```

编译结果:
```js
function create_fragment(ctx) {
  let h1;
  let mounted;
  let dispose;
  
  return {
    c() {
      h1 = element("h1");
      h1.textContent = "Hello world!";
    },
    m(target, anchor) {
      insert(target, h1, anchor);
      if (!mounted) {
        dispose = listen(h1, "click", /*click_handler*/ ctx[1]);
        mounted = true;
      }
    },
    // ...
    d(detaching) {
      if (detaching) detach(h1);
      mounted = false;
      dispose();
    }
  };
}

function instance($$self, $$props, $$invalidate) {
  let count = 0;
  const click_handler = () => $$invalidate(0, count++, count);
  return [count, click_handler];
}
```

我们可以看到在`mounted`之后使用`listen`方法新增了一个针对`h1`的`click`方法的监听事件，并且在`delete`阶段移除监听事件。

同时多了个实例方法`instance`，它的返回值是`count`的实际值，以及修改`count`的处理函数。

再改改:
```svelte
<script>
let count = 0
</script>
<h1 on:click={() => count++}>Hello world!{count}</h1>
```

编译结果:
```js
function create_fragment(ctx) {
  let h1;
  let t0;
  let t1;
  let mounted;
  let dispose;
  
  return {
    c() {
      h1 = element("h1");
      h1.textContent = "Hello world!";
      t0 = text("Hello world!");
      t1 = text(/*count*/ ctx[0]);
    },
    m(target, anchor) {
      insert(target, h1, anchor);
      append(h1, t0);
      append(h1, t1);
      if (!mounted) {
        dispose = listen(h1, "click", /*click_handler*/ ctx[1]);
        mounted = true;
      }
    },
    // ...
    p(ctx, [dirty]) {
      if (dirty & /*count*/ 1) set_data(t1, /*count*/ ctx[0]);
    },
    d(detaching) {
      if (detaching) detach(h1);
      mounted = false;
      dispose();
    }
  };
}
```

#### dirty 脏标记

svelte 通过位运算(bitmask)对变量的改变进行脏标记

每个变量都被分配一个位值，可以用于在 `ctx` 上下文数据里取得变量对应的值，也可以通过位运算对变量改动进行标记和检查。

比如 `name` 的位值是 `1`，那 `name` 的值可以通过 `ctx[1]` 取得。

通过 `dirty |= 1` 设置 `name` 已经改动的状态，再通过 `dirty & 1` 判断 `name` 是否改动。

Javascript 的位运算可以有 32 位。 svelte 支持每个组件里对 32 个变量标记改动。

一般一个组件不应该定义过多的变量。当然如果定义变量多于 32 个，无非就是拿两个位标记变量，凑成 64 位，以此类推。

![[Pasted image 20241115112612.png]]

设置位：`bitmask |= 1 << (n-1)`

检测位：`if (bitmask & (1 << (n-1)))`

| 变量     | 位置  | 位值         |
| ------ | --- | ---------- |
| name   | 1   | 1<<(1-1)=1 |
| age    | 2   | 1<<(2-1)=2 |
| school | 3   | 1<<(3-1)=4 |

#### 视图的创建

前端框架创建视图的方式有几种，比如虚拟 dom，字符串模板，过程式创建。

svelte 采用的是过程式创建。

举个例子，假设我想要通过纯 js 的方式创建一个如下的 web ui：

![[Pasted image 20241115112039.png]]

我们可能会写下这样的代码：

```js
const todoListNode = document.createElement('ul');
const todos = [1,2,3];
for (const todo of todos) {
    const itemNode = document.createElement('li');
    itemNode.textContent = `item ${todo}`;
    todoListNode.appendChild(itemNode);
}
```

而 svelte 生成的视图代码就很类似我们手动编写的 js 代码。

这部分创建 dom 的代码，会生成为组件内部的 `create` 函数， `mount` 函数，`patch` 函数。

下面我们来看一下模板编译过程。

- 首先解析 svelte 模板并生成模板 AST
    
- 然后遍历模板 AST
    
- 如果碰到普通的 html tag 或者文本，输出 dom 创建语句（`dom.createElement`)
    - 如果碰到变量
    - 转换为上下文引用方式并输出取值语句（如： `name` 被生成为` ctx[/** name */0]`)
        - 在 `patch` 函数中生成对应的更新语句
    - 如果碰到 if 模板
    - 获取 condition 语句，输出选择函数 `select_block` （子模板选择器）
        - 获取 condition 为 `true` 的模板片段，输出 `if_block` 子模板构建函数
        - 获取 condition 为 `false` 的模板片段，输出 `else_block` 子模板构建函数
    - 如果碰到 each 模板
    - 获取循环模板片段，生成块构建函数 `create_each_block`
        - 根据循环内变量引用，生成循环实例上下文获取 `get_each_block_context`
- 生成 key获取函数 `get_key`
    
- 生成基于key更新列表的 `patch` 逻辑函数 `update_keyed_each`
    

![[Pasted image 20241115112127.png]]

##### 子模板构建函数

svelte 会把 if 模板， each 模板中的逻辑分支，抽取成子模板，并为其生成独立的模板实例（包含创建，挂载，更新，销毁等生命周期）

#### 视图更新

视图更新时通过 `patch` 函数来完成的。

下图是模板解析过程中 `patch` 函数的逻辑：

```scss
function patch(ctx, [dirty]) {
  if (dirty & /*name*/ 1) set_data(t1, /*name*/ ctx[0]);
  if (dirty & /*age*/ 2) set_data(t4, /*age*/ ctx[1]);
  if (dirty & /*school*/ 4) set_data(t6, /*school*/ ctx[2]);
}
```

通过 `dirty` 位检查变量是否发生更新，如果发生更新调用 dom 操作函数对 dom 进行局部更新。上面例子的 `set_data` 函数作用是给 dom 设置 `innerText`。根据数据更新的视图位置的不同，还会有 `set_props` 之类的更新 dom 属性的函数等。

#### 条件分支的处理

条件分支例子：

```svelte
<script>
   let isLogin = false;
	const login = () => {
		isLogin = true;
	}
	const logout = () => {
		isLogin = false;
	}
</script>

{#if !isLogin}
<button on:click={login}>
	login
</button>
{:else}
<div>
	hello, xxx
	<button on:click={logout}>logout</button>
</div>
{/if}
```

![[Pasted image 20241115112203.png]]

1. 条件分支的判断语句会生成 `select_block` 函数，用于判断条件，并根据条件返回条件判断为真的子模板 (`if_block`) 或者条件判断为假的子模板 (`else_block`)

```js
// 根据条件返回对应的block构造函数
function select_block(ctx, dirty) {
  if (!/*isLogin*/ ctx[0]) return if_block;
  return else_block;
}
// 选择block构造函数
let current_block = select_block(ctx, -1);
// 返回子模板实例，跟组件类似，提供create，mount，patch等生命周期
let block = current_block(ctx);
```

2. 条件逻辑分支会生成独立的子模板构造函数

if block示例

```js
// 子模板构造函数
function if_block(ctx) {
  let button;
  let mounted;
  let dispose;

  return {
    // 创建block
    create() {
      button = element("button");
      button.textContent = "login";
    },
    // 挂载block
    mount(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        mounted = true;
      }
    },
    // 销毁block
    destroy(detaching) {
      if (detaching) detach(button);
      mounted = false;
      dispose();
    }
  };
}
```

3. if分支如何挂载及更新

if 分支的创建：

![[Pasted image 20241115112230.png]]

if 分支的更新：

![[Pasted image 20241115112241.png]]
#### 循环模板的处理

svelte 的循环模板跟条件分支模板一样，也会生成迭代逻辑的子模板，每一个循环迭代都是子模板的实例，并且拥有独立的上下文。

主要由4部分组成：

1. 循环迭代构建函数 `create_each_block`
    
2. 循环迭代实例上下文获取函数 `get_each_block_context`
    
3. 循环迭代 `key` 获取函数 `get_key`
    
4. 基于 `key` 更新列表的 `patch` 逻辑函数 `update_keyed_each`
    

### 编译过程

- svelte 调用 acorn 生成 JS AST 树
    
- 遍历 AST 找到赋值语句
    
- 为赋值语句生成数据响应式代码
    

![[Pasted image 20241115112450.png]]

例如：

```svelte
<script>
    let name = 'world';
    const changeName = () => {
        name = 'yyb';
    }
</script>
```

编译结果：

```js
function instance($$self, $$props, $$invalidate) {
	let name = 'world';

	const changeName = () => {
		$$invalidate(0, name = 'yyb');
	};

	return [name];
}
```

#### `$$invalidate`

每个数据的赋值语句，svelte 都会生成对 `invalidate` 的调用, `invalidate` 的调用主要做的是对某个改动的变量进行标记，然后在微任务中调用patch函数，根据变量改动的脏标记进行局部更新

数据赋值触发视图更新：

![[Pasted image 20241115112544.png]]

## 运行时

### `init` 

在进入运行时，首先执行`init`方法，该方法大致流程如下：

- 初始化状态
- 初始化周期函数
- 执行`instance`方法，在回调函数中标记 __脏组件__ (`dirty_components`)
- 执行所有`beforeUpdate`生命周期的函数
- 执行创建片段`create_fragment`函数
- 挂载当前组件并执行`create_fragement`返回的`m（mounted）`方法
- 执行`flush`方法

```js
export function init(
  component,
  options,
  instance,
  create_fragment,
  not_equal,
  props,
  append_styles,
  dirty = [-1]
) {
  const parent_component = current_component;
  set_current_component(component);

  const $$: T$$ = component.$$ = {
    fragment: null,
    ctx: [],

    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),

    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),

    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };

  append_styles && append_styles($$.root);

  let ready = false;

  $$.ctx = instance
    ? instance(component, options.props || {}, (i, ret, ...rest) => {
        const value = rest.length ? rest[0] : ret;
        if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
            if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
            if (ready) make_dirty(component, i);
        }
        return ret;
    })
    : [];

  $$.update();
  ready = true;
  run_all($$.before_update);

  // `false` as a special case of no DOM component
  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;

  if (options.target) {
    if (options.hydrate) {
        start_hydrating();
        const nodes = children(options.target);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        $$.fragment && $$.fragment!.l(nodes);
        nodes.forEach(detach);
    } else {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        $$.fragment && $$.fragment!.c();
    }

    if (options.intro) transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }

  set_current_component(parent_component);
}
```

### `flush` 方法

`flush` 的方法主要做了一件事：
遍历需要更新的组件（`dirty_components`），然后更新它，并且调用`afterUpdate`方法:

```js
export function flush() {
  // Do not reenter flush while dirty components are updated, as this can
  // result in an infinite loop. Instead, let the inner flush handle it.
  // Reentrancy is ok afterwards for bindings etc.
  if (flushidx !== 0) {
    return;
  }

  const saved_component = current_component;

  do {
    // first, call beforeUpdate functions
    // and update components
    try {
        while (flushidx < dirty_components.length) {
            const component = dirty_components[flushidx];
            flushidx++;
            set_current_component(component);
            update(component.$$);
        }
    } catch (e) {
        // reset dirty state to not end up in a deadlocked state and then rethrow
        dirty_components.length = 0;
        flushidx = 0;
        throw e;
    }

    set_current_component(null);

    dirty_components.length = 0;
    flushidx = 0;

    // then, once components are updated, call
    // afterUpdate functions. This may cause
    // subsequent updates...
    for (let i = 0; i < render_callbacks.length; i += 1) {
        const callback = render_callbacks[i];

        if (!seen_callbacks.has(callback)) {
            // ...so guard against infinite loops
            seen_callbacks.add(callback);

            callback();
        }
    }

    render_callbacks.length = 0;
  } while (dirty_components.length);

  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }

  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
```

再来看看具体的更新操作`update`函数做了啥

- 首先执行所有的`before_update`方法
- 然后执行`create_fragment`返回的`p（update）`方法

```js
function update($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);

        $$.after_update.forEach(add_render_callback);
    }
}
```

总结,在运行时:

1. 初始化状态、初始化周期函数
2. 执行`instance`方法，在回调函数中标记`脏组件`
3. 执行所有`beforeUpdate`生命周期的函数
4. 执行创建片段`create_fragment`函数
5. 挂载当前组件并执行`create_fragement`返回的`m（mounted）`方法
6. 执行`flush`方法
7. 执行所有的`before_update`方法
8. 执行`create_fragment`返回的`p（update）`方法
9. 最后，执行`afterUpdate`方法

## Svelte 编译器

- [https://github.com/sveltejs/svelte/blob/main/packages/svelte/src/compiler/index.js](https://github.com/sveltejs/svelte/blob/main/packages/svelte/src/compiler/index.js)
```js
/**
 * `compile` converts your `.svelte` source code into a JavaScript module that exports a component
 *
 * @param {string} source The component source code
 * @param {CompileOptions} options The compiler options
 * @returns {CompileResult}
 */
export function compile(source, options) {
	source = remove_bom(source);
	state.reset_warning_filter(options.warningFilter);
	const validated = validate_component_options(options, '');
	state.reset(source, validated);

	let parsed = _parse(source);

	const { customElement: customElementOptions, ...parsed_options } = parsed.options || {};

	/** @type {ValidatedCompileOptions} */
	const combined_options = {
		...validated,
		...parsed_options,
		customElementOptions
	};

	if (parsed.metadata.ts) {
		parsed = {
			...parsed,
			fragment: parsed.fragment && remove_typescript_nodes(parsed.fragment),
			instance: parsed.instance && remove_typescript_nodes(parsed.instance),
			module: parsed.module && remove_typescript_nodes(parsed.module)
		};
	}

	const analysis = analyze_component(parsed, source, combined_options);
	const result = transform_component(analysis, source, combined_options);
	result.ast = to_public_ast(source, parsed, options.modernAst);
	return result;
}
```

从这里看, Svelte的编译过程可以分为三个主要阶段：

1. **Parse 解析**
2. **Analyze 分析**
3. **Transform 转换**

 velte 文件的 Script、HTML 和 CSS 代码被分开以形成单个组件对象:
![[Pasted image 20241115115009.png]]
在`Parser`构造函数内部， [`fragment`](https://github.com/sveltejs/svelte/blob/main/packages/svelte/src/compiler/phases/1-parse/state/fragment.js) 函数用于递归地解析自身:
```js
/** @param {Parser} parser */
export default function fragment(parser) {
	if (parser.match('<')) {
		return element;
	}

	if (parser.match('{')) {
		return tag;
	}

	return text;
}
```

fragment 根据条件返回 `element` `tag` `text` 等函数, 这个返回值会被调用以从源代码中提取信息。

包含在`script`标签中的区域通过[`read_script`](https://github.com/sveltejs/svelte/blob/main/packages/svelte/src/compiler/phases/1-parse/read/script.js)进行解析:

```js
/**
 * @param {Parser} parser
 * @param {number} start
 * @param {Array<AST.Attribute | AST.SpreadAttribute | Directive>} attributes
 * @returns {AST.Script}
 */
export function read_script(parser, start, attributes) {
...
	const source =
		parser.template.slice(0, script_start).replace(regex_not_newline_characters, ' ') + data;
	parser.read(regex_starts_with_closing_script_tag);

	/** @type {Program} */
	let ast;

	try {
		ast = acorn.parse(source, parser.ts);
	} catch (err) {
		parser.acorn_error(err);
	}
...
}
```

其他区域使用 Svelte Compiler 自己的解析逻辑。当遇到`style`标签时，会使用[`read_style`](https://github.com/sveltejs/svelte/blob/main/packages/svelte/src/compiler/phases/1-parse/read/style.js):

```js
/**
 * @param {Parser} parser
 * @param {number} start
 * @param {Array<AST.Attribute | AST.SpreadAttribute | Directive>} attributes
 * @returns {Css.StyleSheet}
 */
export default function read_style(parser, start, attributes) {
	const content_start = parser.index;
	const children = read_body(parser, '</style');
	const content_end = parser.index;

	parser.read(/^<\/style\s*>/);

	return {
		type: 'StyleSheet',
		start,
		end: parser.index,
		attributes,
		children,
		content: {
			start: content_start,
			end: content_end,
			styles: parser.template.slice(content_start, content_end),
			comment: null
		}
	};
}
```

其他类似的也都和 `read_style` 放在一起.

最终会生成一个这样的 JSON:
```json
{
  html: { type, start, end, children }
  css: { type, start, end, attributes, children, content }
  instance: { type, start, end, context, content }
  module: { type, start, end, context, content }
}
```

### 分析和跟踪组件内部的依赖关系

从创建的 AST 中提取用于执行组件的各种操作的信息:
![[Pasted image 20241115115845.png]]

参考[源码](https://github.com/sveltejs/svelte/blob/main/packages/svelte/src/compiler/phases/2-analyze/index.js#L398)，组件的主要属性可以总结如下：
```js
const analysis = {
root: scope_root,
module,
instance,
template,
stylesheet: new Stylesheet({...}),
// Various compile options
runes,
warnings,
reactive_statements: new Map(),
binding_groups: new Map(),
slot_names: new Set(),
...
};
```

`ScopeRoot`是一个充当组件最高[作用域](https://developer.mozilla.org/ko/docs/Glossary/Scope)的对象。在内部，它使用`Set`数据结构来确保变量和函数等标识符的唯一性。

遍历 instance script 和 module script 的 AST 来识别**变量被引用的所有区域**，从而了解变量可能发生变化的所有情况。在此过程中，将创建 script 的较低作用域，引用 `scope_root` 为变量分配唯一标识符.

instance script 和 module script 的区别是:

- module 定义组件之间共享的状态和逻辑, 可以使用[`<script context="module">`](https://learn.svelte.dev/tutorial/sharing-code)声明, 但不能包含 `reactive` 的代码
- instance 定义组件的唯一状态和逻辑.

其他的基本没啥讲的, `stylesheet` 会根据收集到的`analysis`信息执行一些优化任务:
- 重复的全局 CSS 选择器和组件范围内未使用的选择器将被删除。
- 组件范围内使用的 CSS 选择器被哈希为`.svelte-xxx`格式，防止与同名选择器发生冲突。

### Final Traversel

最后会根据获得的`analysis`信息，再次遍历 AST 来优化组件状态:

```js
walk(
  /** @type {import('#compiler').SvelteNode} \*/ (ast),
  /** @type {import('./types').AnalysisState} \*/ (state),
  merge(
    set_scope(scopes),
    validation_runes,
    runes_scope_tweaker,
    common_visitors,
  ),
);
```

- `validation_runes` 检查不正确的赋值或更新表达式, 验证变量的声明和导出并检查新的`reactive`语法`runes`的有效性。
- `runes_scope_tweaker` 调整作用域, 设置使用特定模式的变量声明的作用域和绑定类型, 并将变量或函数移动到实例之外而不改变状态。
- `common_visitors` 处理`directive`和`binding`相关指令和一般 HTML 或 Svelte 特定元素, 并处理与事件相关的属性并确定是否需要事件委托或提升。

### 转换

最后，Svelte编译器经过一个转换过程来生成渲染代码。

![[Pasted image 20241115120819.png]]

在这个过程中，SSR（服务器端渲染）和 CSR（客户端渲染）的代码生成逻辑是不同的。编译器使用两个函数`server_component`和`client_component`来创建针对每种场景优化的代码, 就像这样:

```js
const program =
  options.generate === 'server'
    ? server_component(analysis, options)
    : client_component(source, analysis, options);

```

在 SSR 中，组件仅渲染一次，并且组件没有生命周期。
因此， `server_component`专注于创建[`template literals`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals) 。它使用`javascript_visitors`和`template_visitors`等访问者添加代码块。

在 CSR 中，需要与 DOM 不断交互，并且组件需要有生命周期。
因此， `client_component`由更加多样化和复杂的访问者组成。即使相同的`javascript_visitors`也包含遍历过程中函数的附加处理逻辑。

## REFERENCE
- [svelte/compiler](https://svelte.dev/docs/svelte-compiler)
- [Svelte — What made me meet you like this](https://blog.kalan.dev/en/series/svelte-series/1)
- [🚀Svelte原理和进阶看这篇就够了🚀](https://juejin.cn/post/7235628080219078693)
- [How Does the Svelte Compiler Work?](https://bepyan.me/en/post/svelte-compiler-operation)
- [一文讲透前端新秀 svelte](https://juejin.cn/post/7185433911437033531)