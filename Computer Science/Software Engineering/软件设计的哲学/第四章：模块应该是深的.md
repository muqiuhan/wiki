#software-engineering #aposd2e #reading 

管理软件复杂性最重要的技术之一就是将系统设计成开发人员在任何给定时间只需要面对整体复杂性的一小部分。这种方法称为 _模块化设计_。

## 模块化设计

在模块化设计中，软件系统被分解为相对独立的 _模块_ 集合。模块可以采用多种形式，例如类、子系统或服务。在理想的世界中，每个模块都将完全独立于其他模块：开发人员可以在任何模块中工作，而无需了解任何其他模块。在这个世界里，系统的复杂性就是其中最糟糕的模块的复杂性。

但是这种理想是无法实现的。模块必须通过调用彼此的函数或方法来协同工作。结果，模块必须相互了解。模块之间将存在 _依赖关系_：如果一个模块发生更改，则可能需要更改其他模块以进行匹配。

为了识别和管理依赖关系，我们将每个模块分为两个部分：_接口_ 和 _实现_。接口包含了开发人员在使用这个模块时必须知道的所有内容。接口描述模块“做什么”，实现是模块具体“怎么做”。

## 接口中应该有什么？

模块的接口包含两种信息：形式化信息和非形式化信息。接口的形式化部分在代码中明确指定，并且其中一些可以通过编程语言检查其正确性。非形式化的元素无法以编程语言可以理解或执行的方式进行指定，只能使用注释来描述，而编程语言并不能确保描述是完整或准确的，对于大多数接口，非形式化的部分要比形式化的部分更大和更复杂。

> 明确指定接口的好处之一是，它可以准确指示开发人员使用关联模块所需要知道的内容。

## 抽象

_抽象_ 这个术语与模块化设计的思想紧密相关。**抽象是实体的简化视图，其中省略了不重要的细节。**

在模块化编程中，每个模块以其接口的形式提供抽象。该接口提供了模块功能的简化视图；从模块抽象的角度来看，实现的细节并不重要，因此在接口中将其省略。

在抽象的定义中，“不重要”一词至关重要。从抽象中忽略的不重要的细节越多越好。但是，只能在细节确实不重要的情况下才可以将其从抽象中省略。

设计抽象的关键就是要识别什么是重要的，并在设计过程中将重要的信息最小化。

## 深模块

最好的模块是那些提供强大功能但具有简单接口的模块。我用“深”一词来描述这样的模块。为了形象化深度的概念，假设每个模块都由一个矩形表示，如图 4.1 所示。每个矩形的面积与模块实现的功能成比例。矩形的顶部边缘代表模块的接口；边缘的长度表示接口的复杂性。最好的模块很深：它们在简单的接口后隐藏了许多功能。深模块是一个很好的抽象，因为其内部复杂性的很小一部分对其用户可见：

![[Pasted image 20250302105848.png]]

模块的深度是一种考虑成本与收益的方式。模块提供的好处是其功能。模块的成本（就系统复杂性而言）是其接口。模块的接口代表了模块强加给系统其余部分的复杂性：接口越小越简单，引入的复杂性就越小。

> 浅模块是一个接口相对于其提供的功能而言较为复杂的模块。浅模块在对抗复杂性方面无济于事，因为它们提供的好处（不必了解它们在内部如何工作）被学习和使用其接口的成本所抵消。小模块往往很浅。

## 多类症

“深”类的价值在今天并未得到广泛认可。编程中的传统观点是，类应该 _小_ 而不是深。学生们经常被教导说，类的设计中最重要的事情是将较大的类分成较小的类。

“类应该小”的极端做法是我称之为 _多类症_ 的综合症，这是由于错误地认为“类是好的，所以类越多越好”所导致的。

“如果想要更多的功能，请引入更多的类。”这种多类症的做法会导致每个类自身都很简单，但是却增加了整个系统的复杂性。小类不会贡献太多功能，因此必须有很多小类，但每个小类都有自己的接口。这些接口的累积会在系统层级产生巨大的复杂性。由于每个类都需要样板代码，小类也容易导致冗长的编程风格。

## 结论

通过将模块的接口与其实现分开，我们可以将实现的复杂性对系统的其余部分隐藏起来。模块的用户只需要了解模块接口提供的抽象。在设计类和其他模块时，最重要的事情是使它们足够深，以使它们具有适用于常见用例的简单接口，但仍提供重要的功能。这样就能够最大化地隐藏掉复杂性。