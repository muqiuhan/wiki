#software-engineering #aposd2e #reading 

## 复杂性的定义

**复杂性是指那些与软件系统相关的而且让系统难以理解和修改的任何事物。** 复杂性可以采取多种形式。例如，可能很难理解一段代码是如何工作的，可能需要花费很多精力才能实现较小的改进，或者可能不清楚必须修改系统的哪些部分才能进行改进，也可能是在不引入额外问题的情况下很难修复一个代码缺陷。如果一个软件系统难以理解和修改，那它就是复杂的。如果很容易理解和修改，那它就是简单的。

> 人们通常使用“复杂”一词来描述具有复杂功能的大型系统，但是如果这样的系统易于使用，那么就本书而言，它并不复杂。

用粗略的数学方法表征复杂性：

$$
C = \sum_{p}{c_pt_p}
$$


系统的总体复杂性（C）由每个部分的复杂性（cp）乘以开发人员在该部分上花费的时间（tp）加权。将复杂性隔离在一个永远不会被看到的地方几乎和完全消除复杂性一样好。

## 复杂性的体现

- **变更放大**：复杂性的第一个征兆是，看似简单的变更需要在许多不同地方进行代码修改。
- **认知负荷**：复杂性的第二个症状是认知负荷，这是指开发人员需要多少知识才能完成一项任务。
- **未知的未知**: 复杂性的第三个症状是，必须修改哪些代码才能完成任务，或者开发人员必须获得哪些信息才能成功地执行任务，这些都是不明显的。

在复杂性的三种表现形式中，未知的未知是最糟糕的。未知的未知意味着你需要知道一些事情，但是你没有办法找到它是什么，甚至不知道是否存在问题。直到你的修改导致了代码缺陷之前，你都不会发现它。变更放大是令人恼火的，但是只要清楚哪些代码需要修改，一旦更改完成，系统就会工作。同样，高的认知负荷会增加变更的成本，但如果明确要阅读哪些信息，变更仍然可能是正确的。对于未知的未知，不清楚该做什么，或者提出的解决方案是否有效。唯一确定的方法是读取系统中的每一行代码，这对于任何大小的系统都是不可能的。这甚至可能还不够，因为更改还可能依赖于一个从未记录的细微设计决策。

> 良好设计的最重要目标之一就是使系统的更改能够被预见，这与高认知负荷和未知的未知相反。

## 复杂性的原因

> 复杂性是由两件事引起的：依赖性和模糊性。

当无法孤立地理解和修改给定的一段代码时，便存在依赖关系。该代码以某种方式与其他代码相关，如果更改了给定代码，则必须考虑和/或修改其他代码。依赖关系是软件的基本组成部分，不能完全消除。

复杂性的第二个原因是模糊性。当重要的信息不明显时，就会产生模糊性。一个简单的例子是一个变量名。

在许多情况下，模糊性来源于文档的不足。但是，模糊性也是设计问题。如果系统设计简洁明了，则所需的文档将更少。对大量文档的需求通常是表明设计不正确的危险信号。减少模糊性的最佳方法是简化系统设计。

依赖性和模糊性共同构成了“变更放大”“认知负荷”“未知的未知” 三种复杂性表现。依赖性导致变更放大和高认知负荷。模糊性会产生未知的未知，还会增加认知负荷。如果我们找到最小化依赖性和模糊性的设计技术，那么我们就可以降低软件的复杂性。

## 复杂性是增量产生的

复杂性不是由单个灾难性错误引起的；它堆积自许多小块。单个依赖项或模糊项本身不太可能显著影响软件系统的可维护性。之所以会出现复杂性，是因为随着时间的流逝，成千上万的小依赖项和模糊项逐渐形成。最终，这些小问题太多了，以至于对系统的每次更改都会受到其中几个问题的影响。

复杂性的增量本质使其难以控制。可以很容易地说服自己，当前更改所带来的一点点复杂性没什么大不了的。但是，如果每个开发人员对每种更改都采用这种方法，那么复杂性就会迅速累积。一旦积累了复杂性，就很难消除它，因为修复单个依赖项或模糊项本身不会产生很大的变化。

> 为了减缓复杂性的增长，应该在项目的需求时效性和复杂度之间找到一个平衡点，从而在控制项目的复杂性的同时可以保证按时交付。这其中有很多门道，设置“社交”也是寻找这个平衡点的一种方式。例如和产品经理或是甲方交涉。

## 结论

复杂性来自于依赖性和模糊性的积累。随着复杂性的增加，它会导致变更放大、高认知负荷和未知的未知。结果，需要更多的代码修改才能实现每个新功能。此外，开发人员花费更多时间获取足够的信息以安全地进行更改，在最坏的情况下，他们甚至找不到所需的所有信息。最重要的是，复杂性使得修改现有代码库变得困难且危险。