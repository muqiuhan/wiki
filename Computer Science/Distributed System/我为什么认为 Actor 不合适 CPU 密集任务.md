#distributed #actor

从面向对象来说，面向对象中，将世间万物看作一个个对象，从相同对象中总结（抽象）出一个个类，比如人类，猫类等等，但是面向对象理论在落实的编程语言中时，没有考虑到世界线问题，即世界的时间流转问题，举个例子：

课堂上，老师在讲台上讲课（ teacher 对象的 speak 方法正在执行中），下边的学生在说话（student 对象的 speak 也在执行）。从现实生活中看，这个是自然而然的，但是，在计算机世界， 讲课和说话操作都需要在thread 中才能执行。所以，object 和 thread 就有匹配问题了，理论上，你应该为每一个 object 都匹配一个 thread, 毕竟现实中就是这样，老师和学生都有各自的 thread,可以同时执行操作。但是计算机世界中的问题就是不可能为每一个 object 起一个 thread。所以面向对象编程语言在计算机中实现时，线程问题做的就会比较奇怪了。

而 Actor  model 实际上是屏蔽了 thread 概念的（不接触thread,也不需要理解thread概念）。 Actor  model 中假设所有的 Actor 之间的运行是并行的，就和现实世界一样的。老师 Actor 和学生的 Actor 的运行底层是不相关的，相关的是老师在 speak（相当于群发消息），学生也在 speak（单发给同桌或者给后座的人），老师听到有人在说话（接收一个消息），然后老师拿粉笔打了说话的学生（单发一个粉笔头给那个学生）。

由此可见， Actor 是比面向对象更接近现实的模型。

从上一个问题来看， Actor 模型比oo更接近现实世界，但是，落实在计算机中时，就涉及到， Actor 怎么执行的问题。因为计算机中没有那么多的thread, 所以 Actor 在实现时，必然是通过少量的 thread 来执行大量的 Actor 实体。 即在一个 thread 中分时执行多个 Actor 。当然，这是开发 Actor 模型的人需要关注的问题，用 Actor 模型的人可以不关注。

所以，这里就引出了这个问题：如果在 Actor 中执行 CPU 密集任务会怎么样？

结论就是，CPU 密集任务把 Actor 的底层执行机制给拖垮了，thread 在执行一个 Actor 时，因耗时太长，并占用大量 CPU 资源，导致其他 Actor 无法执行。 Actor 的执行机制出现断档， Actor 世界出现 stop the world。STW 问题对于 Actor 本身不会有啥影响，反正世界都停了，无非就是多等一会儿。但是对于我们这个上帝来说，这个 Actor 世界已经不能流畅运行了。

所以，不管是 go, 还是 akka,或者 vert.x，都会提醒你，不要在 Actor 或类 Actor 实例中执行 block 太长的任务。

所以，怎么解决这个问题呢？
答案是：使用异步。
异步操作就可以把一个 block 变成不 block 的任务，从而在 Actor 世界中实现目标。

最后，再考虑一下用 Actor 模型来执行 CPU 密集任务的问题。

如果在 Actor 中执行一个 CPU 密集任务，首先会导致其他 Actor 的执行被推迟，其次，系统本身的 Actor （比如 log, monitor 等）也会推迟。如果能接受这个影响，那么用 Actor 来执行 CPU 密集任务也没有问题。

另一种方案是，把CPU密集 Actor 放到单独的 executor 中，与其他 Actor 分离，充分利用多线程特性