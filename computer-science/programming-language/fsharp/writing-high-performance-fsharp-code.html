<!DOCTYPE html> <html><head>
		<title>Writing high performance Fsharp code</title>
		<base href="../../../">
		<meta id="root-path" root-path="../../../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="韩暮秋的个人维基 - Writing high performance Fsharp code">
		<meta property="og:title" content="Writing high performance Fsharp code">
		<meta property="og:description" content="韩暮秋的个人维基 - Writing high performance Fsharp code">
		<meta property="og:type" content="website">
		<meta property="og:url" content="https://muqiuhan.github.io/wiki/computer-science/programming-language/fsharp/writing-high-performance-fsharp-code.html">
		<meta property="og:image" content="https://www.bartoszsypytkowski.com/content/images/2021/02/class-vs-struct-layout.png">
		<meta property="og:site_name" content="韩暮秋的个人维基">
		<meta name="author" content="韩暮秋"><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="https://muqiuhan.github.io/wiki/lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="lib/scripts/pixi.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="lib/scripts/minisearch.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="preload" href="lib/styles/other-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/other-plugins.css"></noscript><link rel="stylesheet" href="lib/styles/theme.css"><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript></head><body class="publish css-settings-manager theme-light show-inline-title show-ribbon outliner-plugin-dnd h2-underline"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="Writing high performance Fsharp code"><p dir="auto">Writing high performance Fsharp code</p></h1><div class="el-p"><p dir="auto"><a href="?query=tag:fsharp" class="tag" target="_blank" rel="noopener nofollow">#fsharp</a> <a href="?query=tag:fp" class="tag" target="_blank" rel="noopener nofollow">#fp</a></p></div><div class="el-p"><p dir="auto">While this post is addressed to F# .NET developers, it introduces much wider concepts starting from hardware architecture to overall .NET runtime and JIT compiler optimizations. It shouldn't be a surprise - optimizing the application performance requires us to understand the relationships between our high level code and what actually happens on the hardware.</p></div><div class="el-p"><p dir="auto">There's a popular opinion that F# code must be slower than equivalent C# code. This opinion is mostly false, however it comes with some rationale. Usually comparison doesn't use <strong>equivalent</strong> code in both languages, and F# is generally more high level and declarative in nature. "Idiomatic" F# code doesn't always play well with .NET virtual machine. Writing code that is high level, declarative and fast on .NET platform is not an easy task.</p></div><div class="el-p"><p dir="auto">In the examples below we'll use some common tools that will help us get better insight into nature of F# code:</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><a data-tooltip-position="top" aria-label="https://sharplab.io/?ref=bartoszsypytkowski.com" rel="noopener nofollow" class="external-link" href="https://sharplab.io/?ref=bartoszsypytkowski.com" target="_blank">Sharplab</a> allows us to easily inspect generated JIT intermediate representation, assembly or even equivalent C# code (which sometimes is approximate, since not all IL idioms are representable in C#) for a given F# snippet. For assembly code usually some extra mangling with params may be necessary for code to be generated as SharpLab sometimes cannot introspect F# core lib code.</li>
<li data-line="1" dir="auto"><a data-tooltip-position="top" aria-label="https://github.com/SergeyTeplyakov/ObjectLayoutInspector?ref=bartoszsypytkowski.com" rel="noopener nofollow" class="external-link" href="https://github.com/SergeyTeplyakov/ObjectLayoutInspector?ref=bartoszsypytkowski.com" target="_blank">Object Layout Inspector</a> lets us see how structs and classes will actually be represented in memory.</li>
<li data-line="2" dir="auto"><a data-tooltip-position="top" aria-label="https://benchmarkdotnet.org/articles/overview.html?ref=bartoszsypytkowski.com" rel="noopener nofollow" class="external-link" href="https://benchmarkdotnet.org/articles/overview.html?ref=bartoszsypytkowski.com" target="_blank">BenchmarkDotNet</a> is very popular library for writing micro benchmarks. We'll use it to show heap allocations and execution times of our code.</li>
</ul></div><div class="el-p"><p dir="auto">A correct profiling of the executing application is crucial before starting any work on optimizing the code - there's no sense in shaving last possible CPU cycles out of the function that's executed for 0.1% of the time.</p></div><div class="el-p"><p dir="auto">Keep in mind that for most day-to-day business applications, first way to solve performance problems is to reduce obvious mistakes (eg. replacing multiple I/O requests with one, writing more efficient database query etc.). If that was not the case, next step for satisfactory solution can be simply writing more imperative code - to make it easier to reason about for the compiler rather than human - or picking better-suited data structures. This is especially prevalent in F#, where we can observe pervasive usage of types like <code>'t list</code> (tip: if you're looking which collection to use and want good performance, F# list is almost never a good answer). Here we're about to go deeper, into area where we're about to compete with the prefabricated data types and algorithms.</p></div><div class="el-h2 heading-wrapper"><h2 data-heading="Understand memory layout of value types" dir="auto" class="heading" id="Understand_memory_layout_of_value_types"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Understand memory layout of value types</h2><div class="heading-children"><div class="el-p"><p dir="auto">One of the big performance gains, that .NET runtime uses to take advantage over other managed virtual machines (like JVM) in race for ultimate performance, often comes from using value types. So if we're about to go fast, we first need to understand how they work.</p></div><div class="el-p"><p dir="auto">.NET structs represent types, which are not allocated separately on the managed memory heap, but rather inlined within the containing scope (instance of the class in case of fields, thread stack for variables, etc.). This means that usually they are cheaper and easier to access in high-allocation scenarios.</p></div><div class="el-p"><p dir="auto"><img alt="class-vs-struct-layout" src="https://www.bartoszsypytkowski.com/content/images/2021/02/class-vs-struct-layout.png" referrerpolicy="no-referrer"></p></div><div class="el-p"><p dir="auto">Historically, F# code was not very promising, when it comes to utilizing value types. Nowadays we got things like struct tuples - <code>struct('a * 'b)</code> which unfortunately are not widely used in F# even though in practice they should be preferable choice when working with tuples - and <code>[&lt;Struct&gt;]</code> attribute, that can be used on records and discriminated unions (we'll return to them later), making use of them became much more feasible.</p></div><div class="el-p"><p dir="auto">However this doesn't necessarily mean, that replacing all reference types with value types will make our code magically go faster. In fact, this may be quite opposite. Why? Imagine what happens when we want to pass a record as a parameter. How is it done? Usually passing object to a function happens by copying reference to that object, which is either 4B or 8B depending on our OS being x86 or x64, and therefore fits perfectly into standard CPU register.</p></div><div class="el-pre"><pre class="language-fsharp" tabindex="0"><code data-line="0" class="language-fsharp is-loaded"><span class="token keyword">type</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span>
  <span class="token keyword">class</span>
    <span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token class-name">DefaultValue</span><span class="token punctuation">&gt;]</span></span> <span class="token keyword">val</span> <span class="token keyword">mutable</span> x<span class="token punctuation">:</span> <span class="token class-name">int</span>
    <span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token class-name">DefaultValue</span><span class="token punctuation">&gt;]</span></span> <span class="token keyword">val</span> <span class="token keyword">mutable</span> y<span class="token punctuation">:</span> <span class="token class-name">int</span>
    <span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token class-name">DefaultValue</span><span class="token punctuation">&gt;]</span></span> <span class="token keyword">val</span> <span class="token keyword">mutable</span> z<span class="token punctuation">:</span> <span class="token class-name">int</span>
  <span class="token keyword">end</span>

<span class="token keyword">let</span> print <span class="token punctuation">(</span>value<span class="token punctuation">:</span> 't<span class="token punctuation">)</span> <span class="token operator">=</span> System<span class="token punctuation">.</span>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// sub rsp, 0x28</span>
            <span class="token comment">// mov rcx, 0x7ff91b23d1a8</span>
            <span class="token comment">// call 0x00007ff9730aade0 ; allocate A on the heap</span>
print a     <span class="token comment">// mov rdx, rax            ; copy reference to a to the stack</span>
            <span class="token comment">// mov rcx, 0x7ff91b23d5f8</span>
            <span class="token comment">// call _.print[[System.__Canon, System.Private.CoreLib]](System.__Canon)</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">Now what if we're using structs? For reference types we copy object's reference on the stack - since reference is just a single address, it always can fit into register and be done within a single operation. For value types, we copy entire value instead. If they don't fit into register, we'll have to copy them over in multiple steps.</p></div><div class="el-pre"><pre class="language-fsharp" tabindex="0"><code data-line="0" class="language-fsharp is-loaded"><span class="token keyword">type</span> <span class="token class-name">B</span> <span class="token operator">=</span>
  <span class="token keyword">struct</span>
    <span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token class-name">DefaultValue</span><span class="token punctuation">&gt;]</span></span> <span class="token keyword">val</span> <span class="token keyword">mutable</span> x<span class="token punctuation">:</span> <span class="token class-name">int</span>
    <span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token class-name">DefaultValue</span><span class="token punctuation">&gt;]</span></span> <span class="token keyword">val</span> <span class="token keyword">mutable</span> y<span class="token punctuation">:</span> <span class="token class-name">int</span>
    <span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token class-name">DefaultValue</span><span class="token punctuation">&gt;]</span></span> <span class="token keyword">val</span> <span class="token keyword">mutable</span> z<span class="token punctuation">:</span> <span class="token class-name">int</span>
  <span class="token keyword">end</span>

<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// sub rsp, 0x38</span>
            <span class="token comment">// xor eax, eax       ; zero field b.x</span>
            <span class="token comment">// xor ecx, ecx       ; zero field b.y</span>
            <span class="token comment">// xor edx, edx       ; zero field b.z</span>
print b     <span class="token comment">// lea r8, [rsp+0x28]</span>
            <span class="token comment">// mov [r8], ecx      ; copy field b.x to the stack</span>
            <span class="token comment">// mov [r8+4], eax    ; copy field b.y to the stack</span>
            <span class="token comment">// mov [r8+8], edx    ; copy field b.z to the stack</span>
            <span class="token comment">// lea rcx, [rsp+0x28]</span>
            <span class="token comment">// call _.print[[_+B, _]](B)</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">Each of these steps is a machine instruction that takes time to execute. However, sometimes .NET can optimize that - pointer-sized registers are not only ones available in modern machines. We also have a special purpose SIMD (Single Instruction Multiple Data) ones, that are much bigger and can be used as long as passed data fits into them perfectly.</p></div><div class="el-pre"><pre class="language-fsharp" tabindex="0"><code data-line="0" class="language-fsharp is-loaded"><span class="token keyword">type</span> <span class="token class-name">C</span> <span class="token operator">=</span>
  <span class="token keyword">struct</span>
    <span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token class-name">DefaultValue</span><span class="token punctuation">&gt;]</span></span> <span class="token keyword">val</span> <span class="token keyword">mutable</span> x<span class="token punctuation">:</span> <span class="token class-name">int</span>
    <span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token class-name">DefaultValue</span><span class="token punctuation">&gt;]</span></span> <span class="token keyword">val</span> <span class="token keyword">mutable</span> y<span class="token punctuation">:</span> <span class="token class-name">int</span>
    <span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token class-name">DefaultValue</span><span class="token punctuation">&gt;]</span></span> <span class="token keyword">val</span> <span class="token keyword">mutable</span> z<span class="token punctuation">:</span> <span class="token class-name">int</span>
    <span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token class-name">DefaultValue</span><span class="token punctuation">&gt;]</span></span> <span class="token keyword">val</span> <span class="token keyword">mutable</span> zz<span class="token punctuation">:</span> <span class="token class-name">int</span>
  <span class="token keyword">end</span>
  
<span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// sub rsp, 0x48</span>
            <span class="token comment">// xor eax, eax             ; zero register</span>
            <span class="token comment">// mov [rsp+0x38], rax      ; init fields b.x and b.y together with zero'ed register</span>
            <span class="token comment">// mov [rsp+0x40], rax      ; init fields b.z and b.zz together with zero'ed register</span>
print c     <span class="token comment">// vmovupd xmm0, [rsp+0x38] ; copy all 4 fields together on the stack using SIMD registers</span>
            <span class="token comment">// vmovupd [rsp+0x28], xmm0</span>
            <span class="token comment">// lea rcx, [rsp+0x28]</span>
            <span class="token comment">// call _.print[[_+C, _]](C)</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">Another thing available in .NET, that allows us addressing inefficiencies of passing structs as arguments are so called by-ref parameters. There are 3 types of these, marked using <code>'t inref</code>, <code>'t outref</code> and <code>'t byref</code>:</p></div><div class="el-pre"><pre class="language-fsharp" tabindex="0"><code data-line="0" class="language-fsharp is-loaded"><span class="token keyword">let</span> <span class="token function">print</span><span class="token punctuation">(</span>value<span class="token punctuation">:</span> 't inref<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">..</span><span class="token punctuation">.</span>
<span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
print <span class="token operator">&amp;</span>c <span class="token comment">// lea rcx, [rsp+0x28] ; copy address of the struct head onto the stack</span>
         <span class="token comment">// call _.print[[_+C, _]](C ByRef)</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">Please, don't confuse by-ref parameters with <code>ref</code> data type:</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>'a ref</code> is actually an alias for <code>Ref&lt;'a&gt;</code> class, therefore allocated on the heap and passed by reference. In general, using this class in F# very rarely has sense (outside of writing exemplar, idiomatic code).</li>
<li data-line="1" dir="auto"><code>'a byref</code> is equivalent to C# <code>ref</code> parameter tag - it means that we're passing reference (memory address) to an object or struct. It expects it to be initialized and can be used to change the contents of the underlying value. For this reason F# requires fields and variables passed as <code>byref</code> to be declared with <code>mutable</code> keyword.</li>
<li data-line="2" dir="auto"><code>'a outref</code> is equivalent to C# <code>out</code> parameter tag - it always must be initialized by the end of the function body. This may sound a bit tricky as F# doesn't put that requirement explicitly. If we didn't make that assignment in any of the code branches, F# compiler will simply initialize it for us with default value (just like using <code>Unchecked.defaultof&lt;_&gt;</code>), which sometimes may lead to null reference exceptions.</li>
<li data-line="3" dir="auto"><code>'a inref</code> is the youngest of these and is equivalent of C# <code>in</code> parameter - while in C# structs passed as arguments for that parameters don't have to be tagged, F# will always require to mark passing by ref (using <code>&amp;</code> prefix for passed argument) for any parameter marked with <code>byref</code>/<code>inref</code>/<code>outref</code>. <code>inref</code> is basically an optimization technique for what we saw above - it allows us to pass struct into a function using only its memory address, without copying entire struct contents. Additionally <code>inref</code> says that parameter is treated as read only, so it cannot be modified inside of function body. .NET JIT can utilize this information in some cases to reduce number of safety checks, therefore reducing number of instructions to be executed.</li>
</ul></div><div class="el-p"><p dir="auto">While using by-ref parameters is usually good idea when it comes to writing code targeting complex value types, there are several limitations to it.</p></div><div class="el-p"><p dir="auto">One is that arguments passed using by-ref params cannot be captured by closures/lambdas/anonymous functions, which prevents them from being used in more abstract code:</p></div><div class="el-pre"><pre class="language-fsharp" tabindex="0"><code data-line="0" class="language-fsharp is-loaded"><span class="token comment">// WRONG!</span>
<span class="token keyword">let</span> doSomething <span class="token punctuation">(</span>a<span class="token punctuation">:</span> <span class="token class-name">int</span> inref<span class="token punctuation">)</span> <span class="token operator">=</span>
  <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token number">.10</span><span class="token punctuation">]</span>
  <span class="token operator">|&gt;</span> List<span class="token punctuation">.</span>map <span class="token punctuation">(</span><span class="token keyword">fun</span> x <span class="token operator">-&gt;</span> x <span class="token operator">+</span> a<span class="token punctuation">)</span> <span class="token comment">// `a` is captured by closure, which is compilation error</span>
  
<span class="token comment">// RIGHT</span>
<span class="token keyword">let</span> doSomething <span class="token punctuation">(</span>a<span class="token punctuation">:</span> <span class="token class-name">int</span> inref<span class="token punctuation">)</span> <span class="token operator">=</span>
  <span class="token keyword">let</span> <span class="token keyword">mutable</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">for</span> x<span class="token operator">=</span><span class="token number">10</span> <span class="token keyword">downto</span> <span class="token number">1</span> <span class="token keyword">do</span>
    result <span class="token operator">&lt;-</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token operator">::</span>result
  result
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">This includes problems even for common inlined functions like eg. pipe operator <code>|&gt;</code>. That's the price, we have to pay for speed (at least for now).</p></div><div class="el-p"><p dir="auto">Second issue is that, at the moment by-ref parameters cannot be involved in building nested functions (regardless if they capture the values from function in outer scope or not). This again makes very inconvenient to use them in cases like tail recursive loop pattern:</p></div><div class="el-pre"><pre class="language-fsharp" tabindex="0"><code data-line="0" class="language-fsharp is-loaded"><span class="token comment">// WRONG!</span>
<span class="token keyword">let</span> doSomething <span class="token punctuation">(</span>a<span class="token punctuation">:</span> 'a<span class="token punctuation">)</span> <span class="token operator">=</span>
  <span class="token keyword">let</span> <span class="token keyword">rec</span> loop n <span class="token punctuation">(</span>x<span class="token punctuation">:</span> 'a inref<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token comment">// this nested function won't compile</span>
    <span class="token keyword">if</span> n <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">then</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span> loop <span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>x
  loop <span class="token number">100</span> <span class="token operator">&amp;</span>a

<span class="token comment">// RIGHT</span>
<span class="token keyword">let</span> <span class="token keyword">rec</span> loop n <span class="token punctuation">(</span>x<span class="token punctuation">:</span> 'a inref<span class="token punctuation">)</span> <span class="token operator">=</span>
  <span class="token keyword">if</span> n <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">then</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">else</span> loop <span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>x
  
<span class="token keyword">let</span> doSomething <span class="token punctuation">(</span>a<span class="token punctuation">:</span> 'a<span class="token punctuation">)</span> <span class="token operator">=</span> loop <span class="token number">100</span> <span class="token operator">&amp;</span>a
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-h3 heading-wrapper"><h3 data-heading="Readonly and ref-like structs" dir="auto" class="heading" id="Readonly_and_ref-like_structs"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Readonly and ref-like structs</h3><div class="heading-children"><div class="el-p"><p dir="auto">While we talked about by-ref params, .NET (and latest F#) enable us to do something more - we can define so called by-ref structs and readonly structs:</p></div><div class="el-pre"><pre class="language-fsharp" tabindex="0"><code data-line="0" class="language-fsharp is-loaded"><span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token annotation-content">Struct<span class="token punctuation">;</span> IsByRefLike<span class="token punctuation">;</span> IsReadOnly</span><span class="token punctuation">&gt;]</span></span>
<span class="token keyword">type</span> <span class="token class-name">BufWriter</span><span class="token operator">&lt;</span>'a<span class="token operator">&gt;</span> <span class="token operator">=</span>
  <span class="token comment">// since BufWriter is by-ref struct it can have by-ref types as fields</span>
  <span class="token comment">// otherwise it would result in compilation error</span>
  <span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token class-name">DefaultValue</span><span class="token punctuation">&gt;]</span></span> <span class="token keyword">val</span> buffer<span class="token punctuation">:</span> <span class="token class-name">ReadOnlySpan</span><span class="token operator">&lt;</span>'a<span class="token operator">&gt;</span>
  
<span class="token doc-comment comment">/// F# records and discriminated unions are marked with IsReadOnly by default</span>
<span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token annotation-content">Struct<span class="token punctuation">;</span> IsByRefLike</span><span class="token punctuation">&gt;]</span></span>
<span class="token keyword">type</span> <span class="token class-name">BufWriter</span><span class="token operator">&lt;</span>'a<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span> Buffer<span class="token punctuation">:</span> <span class="token class-name">ReadOnlySpan</span><span class="token operator">&lt;</span>'a<span class="token operator">&gt;</span> <span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><code>[&lt;IsReadOnly&gt;]</code> attribute let's us define given structure as being readonly. For obvious reasons this also means, that corresponding data type cannot contain any <code>mutable</code> fields within.</p></div><div class="el-p"><p dir="auto">It's used as a slight optimization technique - sometimes .NET JIT compiler must guarantee that structs contents will not be modified. To do so, it will conservatively copy that structure, even when it has been passed into function using inref parameter. If struct has been marked with <code>[&lt;IsReadOnly&gt;]</code> attribute, compiler can skip this step and avoid building defensive copies. You can read more about it <a data-tooltip-position="top" aria-label="https://devblogs.microsoft.com/premier-developer/avoiding-struct-and-readonly-reference-performance-pitfalls-with-errorprone-net/?ref=bartoszsypytkowski.com" rel="noopener nofollow" class="external-link" href="https://devblogs.microsoft.com/premier-developer/avoiding-struct-and-readonly-reference-performance-pitfalls-with-errorprone-net/?ref=bartoszsypytkowski.com" target="_blank">here</a>.</p></div><div class="el-p"><p dir="auto"><code>[&lt;IsByRefLike&gt;]</code> is another attribute. We are talking a lot about passing value types using memory location addresses instead of doing deep copies. Marking struct using this attribute is basically saying "I always want to pass this value by reference". This of course comes with severe limitations: it cannot be boxed (moved to managed heap) and for this reason it can never be captured by closures, implement interfaces or be used as field in classes or other non-by-ref structs.</p></div><div class="el-p"><p dir="auto">In terms of F# this basically means that this kind of structs are used mostly for code that is executed right away within the function body, with no computation expressions or other indirections. This usually qualifies them to hot paths in our code, where CPU intensive work is expected and allocations are not welcome, like:</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>for .. in</code> loops - in fact many moderns .NET structures have special variants of <code>GetEnumerator</code> that doesn't allocate any memory and is implemented as by-ref struct. F# also understands that pattern - in fact you can define custom <code>GetEnumerator(): MyEnumerator</code> method for your collection, with <code>MyEnumerator</code> - which can even be a ref struct - having two methods: <code>Current: 'item</code> and <code>MoveNext: unit -&gt; bool</code>, and F# will automatically understand how to use it in loops. You can see an example implementation of it <a data-tooltip-position="top" aria-label="https://github.com/Horusiath/fsharp.core.extensions/blob/62b102e84325e89b0a6c4065b973936c11adee55/src/FSharp.Core.Extensions/Vec.fs?ref=bartoszsypytkowski.com#L147" rel="noopener nofollow" class="external-link" href="https://github.com/Horusiath/fsharp.core.extensions/blob/62b102e84325e89b0a6c4065b973936c11adee55/src/FSharp.Core.Extensions/Vec.fs?ref=bartoszsypytkowski.com#L147" target="_blank">here</a> - it's a part of implementation of persistent vector data type, similar to <a data-tooltip-position="top" aria-label="https://fsprojects.github.io/FSharpx.Collections/PersistentVector.html?ref=bartoszsypytkowski.com" rel="noopener nofollow" class="external-link" href="https://fsprojects.github.io/FSharpx.Collections/PersistentVector.html?ref=bartoszsypytkowski.com" target="_blank">FSharpX persistent vector</a>, but <strong>it's 4.5 times faster and not allocating anything on heap when executed in loops</strong>.</li>
<li data-line="1" dir="auto">Contextual data around byte-shaving operations. All things related to parsing/formatting can make use of that technique to optimize speed and reduce allocations. It's also used inside of all kinds of drivers working with I/O.</li>
</ul></div><div class="el-p"><p dir="auto">While we're using explicit class/struct type definition here, from .NET runtime point of view memory layout for records and struct records is exactly the same (it differs for discriminated unions thou, but we'll cover that soon).</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="Padding" dir="auto" class="heading" id="Padding"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Padding</h3><div class="heading-children"><div class="el-p"><p dir="auto">Another point worth noticing is that .NET have it's own assumptions regarding data size of classes. Let's see that on an example:</p></div><div class="el-pre"><pre class="language-fsharp" tabindex="0"><code data-line="0" class="language-fsharp is-loaded"><span class="token keyword">type</span> <span class="token class-name">A</span> <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token class-name">int</span><span class="token punctuation">;</span> y<span class="token punctuation">:</span> <span class="token class-name">int</span> <span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">B</span> <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token class-name">int</span><span class="token punctuation">;</span> y<span class="token punctuation">:</span> <span class="token class-name">int</span><span class="token punctuation">;</span> z<span class="token punctuation">:</span> <span class="token class-name">int</span> <span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">How do you think, what's the size of <code>A</code> and <code>B</code>? Naively, we could assume that <code>B</code> instance would be 4 bytes bigger than instance of type <code>A</code>. However that's not always true. Let's inspect memory layout of both classes:</p></div><div class="el-p"><p dir="auto"><img alt="padding-1" src="https://www.bartoszsypytkowski.com/content/images/2021/02/padding-1.png" referrerpolicy="no-referrer"></p></div><div class="el-p"><p dir="auto">As you can see both classes start with 16 byte object header and vtable pointer: it's mandatory for every class (and boxed structs). They make things like method overriding or <code>lock</code> calls on objects possible. Then we have actual class content: <code>2 * sizeof(int) = 8 bytes</code> in case of <code>A</code> and <code>3 * sizeof(int) = 12 bytes</code> in case of <code>B</code>. However that's not the end. In case of <code>B</code> you can also see 4 extra bytes of padding. Where does it comes from?</p></div><div class="el-p"><p dir="auto">When managing heap size, .NET GC/allocator makes some simplifications. Namely it assigns blocks of memory that are multiplications of a standard pointer size, which is 4 bytes on 32-bit OS'es and and 8 bytes on 64-bit ones. So, when instantiating objects, GC will always assign them as much space as it's necessary to encapsulate all fields and fit into 4-/8-bytes ceiling: since most servers operate on 64-bits nowadays, we're talking about buckets of 16+8 bytes, 16+16 bytes, 16+24 bytes etc.</p></div><div class="el-p"><p dir="auto">What's interesting, this padding requirement doesn't concern unmanaged structs (value types consisting only of other value types). If we modify our record <code>B</code> to be a struct:</p></div><div class="el-pre"><pre class="language-fsharp" tabindex="0"><code data-line="0" class="language-fsharp is-loaded"><span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token class-name">Struct</span><span class="token punctuation">&gt;]</span></span> <span class="token keyword">type</span> <span class="token class-name">B</span> <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token class-name">int</span><span class="token punctuation">;</span> y<span class="token punctuation">:</span> <span class="token class-name">int</span><span class="token punctuation">;</span> z<span class="token punctuation">:</span> <span class="token class-name">int</span> <span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">, we'll see that it takes only 12 bytes. If we take into account object header, that's over 2.5 less space than in case of class-based record, with no heap allocations and therefore no need to GC it later. Keep in mind that adding a reference type (eg. string) as struct field will cause it to add padding again. In that case the space saving comes from lack of object header/vtable pointer.</p></div><div class="el-p"><p dir="auto">Now, if necessary we could also apply padding to structs manually. While in eg. Java you need to add redundant extra fields to do that, in .NET we can hint the runtime about the expected struct size:</p></div><div class="el-pre"><pre class="language-fsharp" tabindex="0"><code data-line="0" class="language-fsharp is-loaded"><span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token annotation-content">Struct<span class="token punctuation">;</span> </span><span class="token class-name">StructLayout</span><span class="token annotation-content"><span class="token punctuation">(</span>LayoutKind<span class="token punctuation">.</span>Auto<span class="token punctuation">,</span> Size<span class="token operator">=</span><span class="token number">16</span><span class="token punctuation">)</span></span><span class="token punctuation">&gt;]</span></span> 
<span class="token keyword">type</span> <span class="token class-name">B</span> <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token class-name">int</span><span class="token punctuation">;</span> y<span class="token punctuation">:</span> <span class="token class-name">int</span><span class="token punctuation">;</span> z<span class="token punctuation">:</span> <span class="token class-name">int</span> <span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><code>StructLayout</code> has many useful properties i.e. it opens the door to manually define the position of each record field within the type. It also exposes the <code>Size</code> property, which we can use to manually say what's the expected size of our struct - in that case when creating it, runtime will explicitly add extra bytes for padding. But what would we need it for? We answer that <a data-tooltip-position="top" aria-label="https://www.bartoszsypytkowski.com/writing-high-performance-f-code/#falsesharing" rel="noopener nofollow" class="external-link" href="https://www.bartoszsypytkowski.com/writing-high-performance-f-code/#falsesharing" target="_blank">shortly</a>.</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="CPU cache lines" dir="auto" class="heading" id="CPU_cache_lines"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>CPU cache lines</h3><div class="heading-children"><div class="el-p"><p dir="auto">We need to go a little bit deeper and step into hardware territory. Junior programmers often are taught to think about computer memory as a single homogenous block. That's a convenient lie, especially since languages - even as low level like C - rarely expose any primitives to operate on it. From computer architecture classes, you could learn that memory is split into several layers - from RAM to L1-L3 caches.</p></div><div class="el-p"><p dir="auto"><img alt="CPU-architecture" src="https://www.bartoszsypytkowski.com/content/images/2021/02/CPU-architecture.svg" referrerpolicy="no-referrer"></p></div><div class="el-p"><p dir="auto">Thing is that, access time to L1 can be several dozens times faster than to main memory (RAM). For this reason, when data residing in main memory is about to be used by the CPU, it's first loaded into cache. Hardware does a little bet here: it comes into assumption that most of the data used together resides in the main memory closely to each other. For that reason it doesn't just load a single object reference - it doesn't even know what is it - but instead an entire following block of data, so called <strong>cache line</strong>. On modern hardware, cache lines are usually 64 bytes long.</p></div><div class="el-p"><p dir="auto">One of the reasons, why we talked about structs for so long is that collections of entities like <code>A[]</code> behave very differently depending on <code>A</code> being a class or a struct:</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">If <code>A</code> is a <strong>class</strong>, it means that <code>A[]</code> contains only references to objects, which actual contents may reside in totally different places of memory. Given nature of .NET GC, when they are created on different threads, you may be pretty sure they will not be placed together. This means that when iterating over them, you may need to load them many times from different places in memory.</li>
<li data-line="1" dir="auto">If <code>A</code> is a <strong>struct</strong>, then <code>A[]</code> will contain inlined values of <code>A</code>, with all their contents stored sequentially next to each other.</li>
</ul></div><div class="el-p"><p dir="auto">There's one thing about the cache lines, that can cause misleading results during microbenchmarking of the code. Consider simple operation like sum of the list values: <code>intList |&gt; List.sum</code>. Let's run it twice and check the results:</p></div><div class="el-table" dir="ltr" style="overflow-x: auto;"><table>
<thead>
<tr>
<th dir="ltr">Method</th>
<th dir="ltr">Mean</th>
<th dir="ltr">Error</th>
<th dir="ltr">StdDev</th>
<th dir="ltr">Gen 0</th>
<th dir="ltr">Gen 1</th>
<th dir="ltr">Gen 2</th>
<th dir="ltr">Allocated</th>
</tr>
</thead>
<tbody>
<tr>
<td dir="ltr">TestA</td>
<td dir="ltr">1.408 us</td>
<td dir="ltr">0.0132 us</td>
<td dir="ltr">0.0117 us</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
</tr>
<tr>
<td dir="ltr">TestB</td>
<td dir="ltr">3.964 us</td>
<td dir="ltr">0.0189 us</td>
<td dir="ltr">0.0158 us</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
</tr>
</tbody>
</table></div><div class="el-p"><p dir="auto">In both cases we're talking about the exactly same code over preallocated lists (so list initialization is not part of the benchmark), yet second example takes almost 3 times longer to execute. What has changed then? When setting up the test case I added extra allocation of an object in between appending nodes of the list like so:</p></div><div class="el-pre"><pre class="language-fsharp" tabindex="0"><code data-line="0" class="language-fsharp is-loaded">caseA <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token number">.1024</span><span class="token punctuation">]</span> <span class="token comment">// dataset for TestA</span>
<span class="token keyword">for</span> i <span class="token operator">=</span> <span class="token number">1024</span> <span class="token keyword">downto</span> <span class="token number">1</span> <span class="token keyword">do</span>
    caseB <span class="token operator">&lt;-</span> i<span class="token operator">::</span>caseB <span class="token comment">// dataset for TestB</span>
    unused <span class="token operator">&lt;-</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> i<span class="token punctuation">;</span> y <span class="token operator">=</span> i<span class="token punctuation">;</span> z <span class="token operator">=</span> i <span class="token punctuation">}</span><span class="token operator">::</span>unused
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">Since F# list is implemented as a linked list, it means that its nodes are allocated on a heap and linked together. In first case, even thou suboptimal, those list nodes were still allocated in continuous space in memory, making more efficient use of cache line loads. In second case, our list was fragmented over much bigger space of memory. If elements of our list are value types, we can squash them together by using <code>List.</code> operations over it or just map it into an array. This however won't work for reference types, as we'll only move pointers alone, while objects themselves will stay in their old place.</p></div><div class="el-p"><p dir="auto">Another way to improve performance of some operations is to revert the field order of the elements stored in collection, eg:</p></div><div class="el-pre"><pre class="language-fsharp" tabindex="0"><code data-line="0" class="language-fsharp is-loaded"><span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token class-name">Struct</span><span class="token punctuation">&gt;]</span></span> <span class="token keyword">type</span> <span class="token class-name">Point3D</span> <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token class-name">int</span><span class="token punctuation">;</span> y<span class="token punctuation">:</span> <span class="token class-name">int</span><span class="token punctuation">;</span> z<span class="token punctuation">:</span> <span class="token class-name">int</span><span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">ContainerA</span><span class="token punctuation">(</span>input<span class="token punctuation">:</span> <span class="token class-name">Point3D</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span>
  <span class="token keyword">member</span> this<span class="token punctuation">.</span>SumX <span class="token operator">=</span> input <span class="token operator">|&gt;</span> Array<span class="token punctuation">.</span>sumBy <span class="token punctuation">(</span><span class="token keyword">fun</span> a <span class="token operator">-&gt;</span> a<span class="token punctuation">.</span>x<span class="token punctuation">)</span>
  <span class="token keyword">member</span> this<span class="token punctuation">.</span>Item index <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token punctuation">[</span>index<span class="token punctuation">]</span>

<span class="token keyword">type</span> <span class="token class-name">ContainerB</span><span class="token punctuation">(</span>input<span class="token punctuation">:</span> <span class="token class-name">Point3D</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span>
  <span class="token keyword">let</span> x <span class="token operator">=</span> input <span class="token operator">|&gt;</span> Array<span class="token punctuation">.</span>map <span class="token punctuation">(</span><span class="token keyword">fun</span> a <span class="token operator">-&gt;</span> a<span class="token punctuation">.</span>x<span class="token punctuation">)</span>
  <span class="token keyword">let</span> y <span class="token operator">=</span> input <span class="token operator">|&gt;</span> Array<span class="token punctuation">.</span>map <span class="token punctuation">(</span><span class="token keyword">fun</span> a <span class="token operator">-&gt;</span> a<span class="token punctuation">.</span>y<span class="token punctuation">)</span>
  <span class="token keyword">let</span> z <span class="token operator">=</span> input <span class="token operator">|&gt;</span> Array<span class="token punctuation">.</span>map <span class="token punctuation">(</span><span class="token keyword">fun</span> a <span class="token operator">-&gt;</span> a<span class="token punctuation">.</span>z<span class="token punctuation">)</span>
  <span class="token keyword">member</span> this<span class="token punctuation">.</span>SumX <span class="token operator">=</span> Array<span class="token punctuation">.</span>sum x
  <span class="token keyword">member</span> this<span class="token punctuation">.</span>Item index <span class="token operator">=</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span> y <span class="token operator">=</span> y<span class="token punctuation">.</span><span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span> z <span class="token operator">=</span> z<span class="token punctuation">.</span><span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">Now, depending on which operation we care about more - accessing a single element, or computing sum of X coordinates - one or another implementation will have more sense. This approach is even more prevalent if we look into world of databases - a big contributor to performance difference between OLTP databases (oriented towards standard transactional workloads) and OLAP databases (oriented towards analytical data processing) comes exactly from laying out data on a disk by rows vs by columns.</p></div><div class="el-p"><p dir="auto"><em>PS: In case of <code>ContainerB</code> we can add even better optimization techniques in form of <a data-tooltip-position="top" aria-label="https://www.bartoszsypytkowski.com/writing-high-performance-f-code/#makeuseofvectorization" rel="noopener nofollow" class="external-link" href="https://www.bartoszsypytkowski.com/writing-high-performance-f-code/#makeuseofvectorization" target="_blank">vectorization</a>, which we'll cover further down the blog post.</em></p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="False sharing" dir="auto" class="heading" id="False_sharing"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>False sharing</h3><div class="heading-children"><div class="el-p"><p dir="auto">Now the next thing is that L1-L2 caches are residing closely to CPU cores. In fact, as we've shown, every core has it's own cache. This comes with it's own problems: since every CPU has it's own copy of a value, they occasionally need to synchronize and invalidate their caches when that value is accessed from different cores. This is an expensive operation, which we want to avoid.</p></div><div class="el-p"><p dir="auto">When such accidental sharing may happen? It's not easy to detect in micro benchmarks, and usually needs a dose of profiling and good old fashion trial and error of actual application code. IMO that's why optimizations in this area are not applied so often. Some tips to help build our intuition are:</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">This can happen when two adjacent fields of the same object are concurrently accessed and modified from different threads. Thing is that unless you configure your types with <code>[&lt;StructLayout(LayoutKind.Explicit)&gt;]</code> you won't know if two fields defined in code one after another will be placed in adjacent memory cells by .NET runtime. Using <a data-tooltip-position="top" aria-label="https://github.com/SergeyTeplyakov/ObjectLayoutInspector?ref=bartoszsypytkowski.com" rel="noopener nofollow" class="external-link" href="https://github.com/SergeyTeplyakov/ObjectLayoutInspector?ref=bartoszsypytkowski.com" target="_blank">Object Layout Inspector</a> can help you validate your assumptions here.</li>
<li data-line="1" dir="auto">It can also happen that two different objects/structs will be placed closely inside of collection. This is mostly common for array-backed collections (as they keep elements continuously in memory block) and with small structs (as you may fit more of them inside of single cache line).</li>
</ol></div><div class="el-p"><p dir="auto">We can sometimes reduce risk of false sharing in 2nd case and making it more predictable, by defining type size explicitly to fit exactly into boundaries of cache lines eg. 64B (it's enough to have a class with 6 references/12 int fields or a struct with 8 references/16 int fields). If you know that your objects can be accessed concurrently, but don't fit nicely into into cache lines, you may add extra padding by using <code>[&lt;StructLayout(LayoutKind.Auto, Size=64)&gt;]</code> in your struct definition. While memory usage increases, the overall application performance may improve.</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="Using structs and collections together" dir="auto" class="heading" id="Using_structs_and_collections_together"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Using structs and collections together</h3><div class="heading-children"><div class="el-p"><p dir="auto">So far, we only talked about structs in terms of singular elements - when talking about collections, we got pretty much used to the fact, that we have to allocate. This however is not always the case. .NET has a long history of allowing users to allocate collections on stack rather than heap - in C# it's related with <code>stackalloc</code> keyword, in F# it's bit more verbose:</p></div><div class="el-pre"><pre class="language-fsharp" tabindex="0"><code data-line="0" class="language-fsharp is-loaded"><span class="token keyword">open</span> FSharp<span class="token punctuation">.</span>NativeInterop

<span class="token keyword">let</span> <span class="token keyword">inline</span> stackalloc<span class="token operator">&lt;</span>'a <span class="token keyword">when</span> 'a<span class="token punctuation">:</span> <span class="token class-name">unmanaged</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>length<span class="token punctuation">:</span> <span class="token class-name">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Span<span class="token operator">&lt;</span>'a<span class="token operator">&gt;</span> <span class="token operator">=</span>
  <span class="token keyword">let</span> p <span class="token operator">=</span> NativePtr<span class="token punctuation">.</span>stackalloc<span class="token operator">&lt;</span>'a<span class="token operator">&gt;</span> length <span class="token operator">|&gt;</span> NativePtr<span class="token punctuation">.</span>toVoidPtr
  Span<span class="token operator">&lt;</span>'a<span class="token operator">&gt;</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> length<span class="token punctuation">)</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">What we returned here is a <code>Span&lt;'a&gt;</code> - a by-ref struct type (meaning: it cannot be used in closures or as a field in most types), that allows us to address its elements just like they existed on the heap. In general, you should avoid allocating too much memory on the stack (in .NET stacks have fixed size that by default is limited to 1MB per thread, allocating over it will cause irrecoverable StackOverflowException). Most common case for using these are short parsing methods, that can be used on the hot paths without producing garbage to be collected later:</p></div><div class="el-pre"><pre class="language-fsharp" tabindex="0"><code data-line="0" class="language-fsharp is-loaded"><span class="token doc-comment comment">/// Parse Protocol Buffers style variable length uint32.</span>
<span class="token keyword">let</span> readVarUInt32 <span class="token punctuation">(</span>reader<span class="token punctuation">:</span> <span class="token class-name">Reader</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> uint32 <span class="token operator">=</span>
  <span class="token comment">// var int for 32 bit values is never encoded on more than 5 bytes</span>
  <span class="token keyword">let</span> buffer <span class="token operator">=</span> stackalloc<span class="token operator">&lt;</span>byte<span class="token operator">&gt;</span> <span class="token number">5</span> 
  <span class="token keyword">let</span> read <span class="token operator">=</span> reader<span class="token punctuation">.</span>Read buffer
  <span class="token keyword">if</span> read <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token keyword">then</span> failwith <span class="token string">"trying to read var int from empty stream"</span>
  <span class="token keyword">else</span>
    <span class="token keyword">let</span> buffer <span class="token operator">=</span> buffer<span class="token punctuation">.</span><span class="token function">Slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> read<span class="token punctuation">)</span>
    <span class="token keyword">let</span> <span class="token keyword">mutable</span> decoded <span class="token operator">=</span> <span class="token number">0u</span>
    <span class="token keyword">let</span> <span class="token keyword">mutable</span> i <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">let</span> <span class="token keyword">mutable</span> cont <span class="token operator">=</span> <span class="token keyword">true</span>
    <span class="token keyword">while</span> cont <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> buffer<span class="token punctuation">.</span>Length <span class="token keyword">do</span>
      <span class="token keyword">let</span> b<span class="token punctuation">:</span> <span class="token class-name">byte</span> <span class="token operator">=</span> buffer<span class="token punctuation">.</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span>
      decoded <span class="token operator">&lt;-</span> decoded <span class="token operator">|||</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uint32 <span class="token punctuation">(</span>b <span class="token operator">&amp;&amp;&amp;</span> 0x7Fuy<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;&lt;</span> i <span class="token operator">*</span> <span class="token number">7</span><span class="token punctuation">)</span>
      i <span class="token operator">&lt;-</span> i <span class="token operator">+</span> <span class="token number">1</span>
      <span class="token keyword">if</span> b <span class="token operator">&lt;</span> 0x80uy <span class="token keyword">then</span>  <span class="token comment">// check if most significant bit is set</span>
        cont <span class="token operator">&lt;-</span> <span class="token keyword">false</span> <span class="token comment">// stop condition reached    </span>
    reader<span class="token punctuation">.</span>Advance i
    decoded
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">Even though we did create a buffer (to avoid cost of multiple virtual calls to <code>reader.Read</code> method), in practice we didn't allocate anything that has to be later collected by the GC.</p></div><div class="el-p"><p dir="auto">Unfortunately we cannot use spans everywhere eg. as fields of ordinary classes, but there are still situations where we might want to have collections without GC. This often desirable in case of huge number of collections, that most of the time are very small (eg. <a data-tooltip-position="top" aria-label="https://www.bartoszsypytkowski.com/the-state-of-a-state-based-crdts/#noteaboutvectorclocks" rel="noopener nofollow" class="external-link" href="https://www.bartoszsypytkowski.com/the-state-of-a-state-based-crdts/#noteaboutvectorclocks" target="_blank">vector clocks</a>). We can imagine such non-allocating collection like:</p></div><div class="el-pre"><pre class="language-fsharp" tabindex="0"><code data-line="0" class="language-fsharp is-loaded"><span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token class-name">IsReadOnly</span><span class="token punctuation">&gt;]</span></span>
<span class="token keyword">type</span> <span class="token class-name">HybridMap</span><span class="token operator">&lt;</span>'k<span class="token punctuation">,</span> 'v<span class="token operator">&gt;</span> <span class="token operator">=</span>
    <span class="token keyword">struct</span>
       <span class="token keyword">let</span> count<span class="token punctuation">:</span> <span class="token class-name">int</span>  <span class="token comment">// size: 4B</span>
       <span class="token comment">// null by default, initialized once we pass over 3 entries</span>
       <span class="token comment">// size: 8B (reference)</span>
       <span class="token keyword">let</span> inner<span class="token punctuation">:</span> <span class="token class-name">Map</span><span class="token operator">&lt;</span>'k<span class="token punctuation">,</span>'v<span class="token operator">&gt;</span>
       <span class="token comment">// inline first 3 entries. size: 48B = 3 * (8B+8B) (assume reference type)</span>
       <span class="token keyword">let</span> entry0<span class="token punctuation">:</span> <span class="token class-name">KeyValuePair</span><span class="token operator">&lt;</span>'k<span class="token punctuation">,</span>'v<span class="token operator">&gt;</span>   
       <span class="token keyword">let</span> entry1<span class="token punctuation">:</span> <span class="token class-name">KeyValuePair</span><span class="token operator">&lt;</span>'k<span class="token punctuation">,</span>'v<span class="token operator">&gt;</span>
       <span class="token keyword">let</span> entry2<span class="token punctuation">:</span> <span class="token class-name">KeyValuePair</span><span class="token operator">&lt;</span>'k<span class="token punctuation">,</span>'v<span class="token operator">&gt;</span>
    <span class="token keyword">end</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">With map like this, adding first 3 elements produce no garbage. Why only 3? Just like mentioned previously, we prefer our structs to fit into cache lines and this way (assuming both <code>'k</code> and <code>'v</code> types are classes) we'll still not surpass 64B (on 64bit OS) or 32B (on 32bit one).</p></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="Discriminated unions as value types" dir="auto" class="heading" id="Discriminated_unions_as_value_types"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Discriminated unions as value types</h2><div class="heading-children"><div class="el-p"><p dir="auto">Discriminated unions are somewhat special citizens, in a sense they have to be represented in terms of .NET reference types (classes) or value types (structs). It means that depending on how they are defined (with or without <code>[&lt;Struct&gt;]</code> attribute), their in memory representation may be very different.</p></div><div class="el-p"><p dir="auto"><img alt="class-vs-struct-union-1" src="https://www.bartoszsypytkowski.com/content/images/2021/02/class-vs-struct-union-1.png" referrerpolicy="no-referrer"></p></div><div class="el-p"><p dir="auto">A thing you can see in both situations is that fields order in both cases doesn't reflect order in which they were defined. That's because .NET runtime can reorder them in any type unless explicitly forbidden by using <code>[&lt;StructLayout(LayoutKind.Explicit)&gt;]</code> attribute. Moreover, using this attribute is forbidden in case of discriminated unions.</p></div><div class="el-p"><p dir="auto">Another thing, that you may have noticed is how DUs are represented. A class-based discriminated union is basically equivalent to an empty abstract class with each case being a sealed class inheriting from it. Struct based DU is more complicated. Many other languages with algebraic data types optimize the size according to formula <code>sizeof(tag field) + max([sizeof(ADT case)])</code>. But not F# - what we see here is <code>sizeof(int) + sum([sizeof(ADT case)])</code>:</p></div><div class="el-p"><p dir="auto"><img alt="rust-vs-fsharp-adt-1" src="https://www.bartoszsypytkowski.com/content/images/2021/02/rust-vs-fsharp-adt-1.png" referrerpolicy="no-referrer"></p></div><div class="el-p"><p dir="auto">The reason behind this is a limtation of .NET platform - while technically it's possible to use <a data-tooltip-position="top" aria-label="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.layoutkind?view=net-5.0&amp;ref=bartoszsypytkowski.com" rel="noopener nofollow" class="external-link" href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.layoutkind?view=net-5.0&amp;ref=bartoszsypytkowski.com" target="_blank">LayoutKind.Explicit</a> to implement F# in similar manner to i.e. Rust, it works only as long as we don't try to use it together with generics: .NET cannot make safe guesses in that situation. In result, used memory space for struct-based DU is a sum of all fields defined all cases. For this reason good candidates for struct DU's are usually the ones with very small overall number of fields. F# standard library makes good use of these in form of <code>Result&lt;'t,'e&gt;</code> and <code>'t voption</code> types.</p></div><div class="el-p"><p dir="auto">Options have somewhat special treatment when it comes to F#. While value options work pretty much in ordinary way, class-based ones have some special magic in them. We could imagine them as:</p></div><div class="el-pre"><pre class="language-fsharp" tabindex="0"><code data-line="0" class="language-fsharp is-loaded"><span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token class-name">Struct</span><span class="token punctuation">&gt;]</span></span>
<span class="token keyword">type</span> <span class="token class-name">ValueOption</span><span class="token operator">&lt;</span>'t<span class="token operator">&gt;</span> <span class="token operator">=</span>
  <span class="token operator">|</span> ValueNone
  <span class="token operator">|</span> ValueSome <span class="token keyword">of</span> value<span class="token punctuation">:</span>'t
  
<span class="token keyword">type</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span>'t<span class="token operator">&gt;</span> <span class="token operator">=</span> 
  <span class="token punctuation">{</span> Value<span class="token punctuation">:</span> 't <span class="token punctuation">}</span>
  <span class="token keyword">static</span> <span class="token keyword">member</span> Some value <span class="token operator">=</span> <span class="token punctuation">{</span> Value <span class="token operator">=</span> value <span class="token punctuation">}</span>
  <span class="token keyword">static</span> <span class="token keyword">member</span> None <span class="token operator">=</span> Unchecked<span class="token punctuation">.</span>defaultof<span class="token operator">&lt;</span>Option<span class="token operator">&lt;</span>'t<span class="token operator">&gt;&gt;</span> <span class="token comment">// null</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">This means, that value option will always have to be initialized and use <code>sizeof(int) + sizeof('t)</code> bytes in memory, while standard option may get optimized away into uninitialized instance (null), which size is always <code>sizeof(IntPtr)</code>. So, while you still need to pay for allocating new object for cases where option indeed has value, in some cases where you're working with collections of mostly <code>None</code> values, it may turn out that using standard options is actually more effective approach.</p></div><div class="el-p"><p dir="auto">A common scenario, where option types are used is when we're dealing with failable operations like trying to find element in a map (which may not be there) or parsing an int. In that case keep in mind:</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">Using <code>option</code> is the most expensive approach, as eventual success means allocating an extra intermediate object.</li>
<li data-line="1" dir="auto">Using <code>voption</code> is much cheaper, but at the moment .NET doesn't really know how to pass value types using registers alone, so returning <code>voption</code> may mean copying it through stack in multiple steps, even though we avoided GC allocations.</li>
<li data-line="2" dir="auto">In practice, the best performing solution is using straight old pattern - popular in C# - of try function definition ending up with <code>'t outref -&gt; bool</code> signature. It can be found in most .NET collections (both F# and C#), as well as parsing methods. In fact this pattern is so popular, that F# can automatically derive tuple out of it eg. <code>let (ok, value) = map.TryGetValue(key)</code>. Under normal circumstances this tuple would mean heap allocations, however if you won't capture it and propagate further, but instead use its contents right away like i.e. in <code>match</code> expression, it will let F# compiler to skip allocating an object.</li>
</ul></div><div class="el-p"><p dir="auto">One of the patterns sometimes used by F# programmers is to add more type info to value by wrapping it into DU:</p></div><div class="el-pre"><pre class="language-fsharp" tabindex="0"><code data-line="0" class="language-fsharp is-loaded"><span class="token keyword">type</span> <span class="token class-name">Mileage</span> <span class="token operator">=</span> Mileage <span class="token keyword">of</span> <span class="token class-name">int</span> 
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">Patterns like this one are generally devastating for performance - we're allocating 24B of garbage on the heap for every <code>int</code> used. Using units of measure or even type aliases is much better option, since both of them have only compile time representation and are erased by the compiler, they never introduce a runtime overhead.</p></div><div class="el-pre"><pre class="language-fsharp" tabindex="0"><code data-line="0" class="language-fsharp is-loaded"><span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token class-name">Measure</span><span class="token punctuation">&gt;]</span></span> <span class="token keyword">type</span> <span class="token class-name">miles</span>
<span class="token keyword">type</span> <span class="token class-name">Mileage</span> <span class="token operator">=</span> int<span class="token operator">&lt;</span>miles<span class="token operator">&gt;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="Learn to work with virtual calls" dir="auto" class="heading" id="Learn_to_work_with_virtual_calls"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Learn to work with virtual calls</h2><div class="heading-children"><div class="el-p"><p dir="auto">Did you even wonder, when function is about to call a method on interface parameter, how does it actually know, where to find the method of the underlying object implementing that interface? Runtime resolves actual method to be called by jumping to virtual table of that object (pointer to <em>vtable</em> is part of object header), finding the address of corresponding method (function can have pointers too!) and calling it. As you may imagine all of that indirections can take time. If you think, you're safe because you're not doing object method calls but using module functions instead, check twice - in practice many of them are being inlined as non-static methods.</p></div><div class="el-p"><p dir="auto"><img alt="virtual-call-dispatch-1" src="https://www.bartoszsypytkowski.com/content/images/2021/02/virtual-call-dispatch-1.png" referrerpolicy="no-referrer"></p></div><div class="el-p"><p dir="auto">But how much longer does it actually take? Let's take an example code:</p></div><div class="el-pre"><pre class="language-fsharp" tabindex="0"><code data-line="0" class="language-fsharp is-loaded"><span class="token doc-comment comment">/// interface we want to test</span>
<span class="token keyword">type</span> <span class="token class-name">Stub</span> <span class="token operator">=</span> <span class="token keyword">abstract</span> <span class="token keyword">member</span> DoNothing<span class="token punctuation">:</span> <span class="token class-name">unit <span class="token operator">-&gt;</span> unit</span>
<span class="token doc-comment comment">/// class implementing an interface</span>
<span class="token keyword">type</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span>
  <span class="token keyword">member</span> _<span class="token punctuation">.</span><span class="token function">DoNothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">interface</span> <span class="token class-name">Stub</span> <span class="token keyword">with</span> <span class="token keyword">member</span> this<span class="token punctuation">.</span><span class="token function">DoNothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> this<span class="token punctuation">.</span><span class="token function">DoNothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  
<span class="token doc-comment comment">/// struct implementing an interface</span>
<span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token class-name">Struct</span><span class="token punctuation">&gt;]</span></span>
<span class="token keyword">type</span> <span class="token class-name">B</span> <span class="token operator">=</span>
  <span class="token keyword">member</span> _<span class="token punctuation">.</span><span class="token function">DoNothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">interface</span> <span class="token class-name">Stub</span> <span class="token keyword">with</span> <span class="token keyword">member</span> this<span class="token punctuation">.</span><span class="token function">DoNothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> this<span class="token punctuation">.</span><span class="token function">DoNothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token class-name">MemoryDiagnoser</span><span class="token punctuation">&gt;]</span></span>
<span class="token keyword">type</span> <span class="token class-name">Benchmark</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span>
  <span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token class-name">DefaultValue</span><span class="token punctuation">&gt;]</span></span> <span class="token keyword">val</span> <span class="token keyword">mutable</span> a<span class="token punctuation">:</span> <span class="token class-name">A</span>
  <span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token class-name">DefaultValue</span><span class="token punctuation">&gt;]</span></span> <span class="token keyword">val</span> <span class="token keyword">mutable</span> b<span class="token punctuation">:</span> <span class="token class-name">B</span>
  
  <span class="token keyword">static</span> <span class="token keyword">let</span> execute <span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token class-name">Stub</span><span class="token punctuation">)</span> <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">DoNothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">static</span> <span class="token keyword">let</span> executeGeneric <span class="token punctuation">(</span>x<span class="token punctuation">:</span> #Stub<span class="token punctuation">)</span> <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">DoNothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
  <span class="token keyword">static</span> <span class="token keyword">let</span> executeDirect <span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token class-name">A</span><span class="token punctuation">)</span> <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">DoNothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
  <span class="token keyword">static</span> <span class="token keyword">let</span> executeDirect2 <span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token class-name">B</span><span class="token punctuation">)</span> <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">DoNothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
  
  <span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token class-name">GlobalSetup</span><span class="token punctuation">&gt;]</span></span>
  <span class="token keyword">member</span> this<span class="token punctuation">.</span><span class="token function">Setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span>
    this<span class="token punctuation">.</span>a <span class="token operator">&lt;-</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    this<span class="token punctuation">.</span>b <span class="token operator">&lt;-</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        
  <span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token class-name">Benchmark</span><span class="token annotation-content"><span class="token punctuation">(</span>Baseline<span class="token operator">=</span><span class="token keyword">true</span><span class="token punctuation">)</span></span><span class="token punctuation">&gt;]</span></span> <span class="token keyword">member</span> this<span class="token punctuation">.</span><span class="token function">ExecuteClassDirect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> executeDirect this<span class="token punctuation">.</span>a
  <span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token class-name">Benchmark</span><span class="token punctuation">&gt;]</span></span> <span class="token keyword">member</span> this<span class="token punctuation">.</span><span class="token function">ExecuteClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> execute this<span class="token punctuation">.</span>a
  <span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token class-name">Benchmark</span><span class="token punctuation">&gt;]</span></span> <span class="token keyword">member</span> this<span class="token punctuation">.</span><span class="token function">ExecuteClassGeneric</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> executeGeneric this<span class="token punctuation">.</span>a
  <span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token class-name">Benchmark</span><span class="token punctuation">&gt;]</span></span> <span class="token keyword">member</span> this<span class="token punctuation">.</span><span class="token function">ExecuteStructDirect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> executeDirect2 this<span class="token punctuation">.</span>b
  <span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token class-name">Benchmark</span><span class="token punctuation">&gt;]</span></span> <span class="token keyword">member</span> this<span class="token punctuation">.</span><span class="token function">ExecuteStruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> execute this<span class="token punctuation">.</span>b
  <span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token class-name">Benchmark</span><span class="token punctuation">&gt;]</span></span> <span class="token keyword">member</span> this<span class="token punctuation">.</span><span class="token function">ExecuteStructGeneric</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> executeGeneric this<span class="token punctuation">.</span>b
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">Example run from BenchmarkDotNet could give us following results:</p></div><div class="el-table" dir="ltr" style="overflow-x: auto;"><table>
<thead>
<tr>
<th dir="ltr">Method</th>
<th dir="ltr">Mean</th>
<th dir="ltr">Error</th>
<th dir="ltr">StdDev</th>
<th dir="ltr">Ratio</th>
<th dir="ltr">RatioSD</th>
<th dir="ltr">Gen 0</th>
<th dir="ltr">Gen 1</th>
<th dir="ltr">Gen 2</th>
<th dir="ltr">Allocated</th>
</tr>
</thead>
<tbody>
<tr>
<td dir="ltr">ExecuteClassDirect</td>
<td dir="ltr">0.0356 ns</td>
<td dir="ltr">0.0056 ns</td>
<td dir="ltr">0.0052 ns</td>
<td dir="auto">1.00</td>
<td dir="auto">0.00</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
</tr>
<tr>
<td dir="ltr">ExecuteClass</td>
<td dir="ltr">2.2623 ns</td>
<td dir="ltr">0.0259 ns</td>
<td dir="ltr">0.0242 ns</td>
<td dir="auto">65.00</td>
<td dir="auto">10.58</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
</tr>
<tr>
<td dir="ltr">ExecuteClassGeneric</td>
<td dir="ltr">2.6341 ns</td>
<td dir="ltr">0.0193 ns</td>
<td dir="ltr">0.0150 ns</td>
<td dir="auto">71.95</td>
<td dir="auto">8.88</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
</tr>
<tr>
<td dir="ltr">ExecuteStructDirect</td>
<td dir="ltr">0.0244 ns</td>
<td dir="ltr">0.0165 ns</td>
<td dir="ltr">0.0154 ns</td>
<td dir="auto">0.68</td>
<td dir="auto">0.40</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
</tr>
<tr>
<td dir="ltr">ExecuteStruct</td>
<td dir="ltr">8.6782 ns</td>
<td dir="ltr">0.1040 ns</td>
<td dir="ltr">0.0972 ns</td>
<td dir="auto">249.37</td>
<td dir="auto">41.07</td>
<td dir="auto">0.0076</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
<td dir="ltr">24 B</td>
</tr>
<tr>
<td dir="ltr">ExecuteStructGeneric</td>
<td dir="ltr">0.6525 ns</td>
<td dir="ltr">0.0282 ns</td>
<td dir="ltr">0.0264 ns</td>
<td dir="auto">18.69</td>
<td dir="auto">2.75</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
</tr>
</tbody>
</table></div><div class="el-p"><p dir="auto">There are couple of interesting observations to be made here:</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">In both cases when either struct or class type parameter is known exactly, the call itself is almost instantaneous (in fact for <code>ExecuteStructDirect</code> method you should receive warning about entire call being optimized away). That's because runtime can say directly which version of the method is going to be called and skip the dispatch to type's virtual table. We call this devirtualization - a process, when runtime is able to replace virtual call dispatch with a direct function call. This is also the reason why you <strong>should not</strong> pass objects by interface parameters i.e. <code>'t seq</code> instead of <code>'t[]</code> any time when performance matters.</li>
<li data-line="1" dir="auto">While there exists a small difference between a class instance being called via interface or as generic argument, this is not what we're after. In both cases we can observe similar results - it's because .NET 5 runtime doesn't really specialize generic method calls for reference types. At the moment it can happen <strong>sometimes</strong> for sealed classes. This means, that usually calling by interface (either explicitly or by using generic type parameter) will require virtual table dispatch anyway.</li>
<li data-line="2" dir="auto">Passing struct as parameter into a function that expects interface requires boxing - it means that this structure is copied onto heap (hence we can see allocations), prefixed with a header that includes a vtable pointer. From here struct methods look very similar to classes. All of this extra work causes the entire call to be even more expensive. Sometimes when we know that we're about to pass a struct into some callback expecting a generic object (<a data-tooltip-position="top" aria-label="https://docs.microsoft.com/en-us/dotnet/api/system.threading.timer.-ctor?view=net-5.0&amp;ref=bartoszsypytkowski.com#System_Threading_Timer__ctor_System_Threading_TimerCallback_System_Object_System_Int32_System_Int32_" rel="noopener nofollow" class="external-link" href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.timer.-ctor?view=net-5.0&amp;ref=bartoszsypytkowski.com#System_Threading_Timer__ctor_System_Threading_TimerCallback_System_Object_System_Int32_System_Int32_" target="_blank">Timer</a> can be such example) multiple times, it may we worth to eagerly box it ahead and pass boxed version instead, reducing number of allocations. This may also be a sign that reference type is preferred over struct.</li>
<li data-line="3" dir="auto">An interesting thing happens, once we pass a struct as generic argument. As you can see, this call is several times faster than generic call on the class instance. This is because for structs, .NET JIT uses a generic code specialization - it basically emits machine code for this method call, dedicated for handling this particular type of struct when it's passed as a generic type argument. Since this is specialized branch of code, we don't need to check for vtable every time, as we already can say what function implementation is going to be called.</li>
</ol></div><div class="el-p"><p dir="auto">Generic function specialization may sound a little similar to SRTP (statically resolved type parameters - generics which are erased by F# compiler at compile time), but it's performed by .NET runtime itself. Unlike SRTP, it doesn't prolong our compile times (and .NET JIT is really fast at machine code generation) and can be composed in much better way - you can pass generic functions as parameters themselves over many levels of function calls and let .NET runtime optimize them in a wider context.</p></div><div class="el-p"><p dir="auto">In some cases we can leverage .NET behavior to introduce something aligned to zero-cost abstractions in our code - it's a term forged by Rust programming language, meaning that we can write abstract code that's as fast as equivalent code written by hand. While .NET and F# offer it in limited scope, we can still use it. Example:</p></div><div class="el-pre"><pre class="language-fsharp" tabindex="0"><code data-line="0" class="language-fsharp is-loaded"><span class="token keyword">type</span> <span class="token class-name">Hasher</span><span class="token operator">&lt;</span>'t<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token keyword">abstract</span> Hash<span class="token punctuation">:</span> 't <span class="token operator">-&gt;</span> int
<span class="token keyword">let</span> <span class="token keyword">inline</span> hash<span class="token operator">&lt;</span>'h<span class="token punctuation">,</span> 't <span class="token keyword">when</span> 'h<span class="token punctuation">:</span> <span class="token class-name">struct</span> <span class="token keyword">and</span> 'h <span class="token operator">:&gt;</span> <span class="token class-name">Hasher</span><span class="token operator">&lt;</span>'t<span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span>value<span class="token punctuation">:</span> 't<span class="token punctuation">)</span> <span class="token operator">=</span>
  Unchecked<span class="token punctuation">.</span>defaultof<span class="token operator">&lt;</span>'h<span class="token operator">&gt;</span><span class="token punctuation">.</span>Hash value

<span class="token comment">// we should introduce interface for equality check as well</span>

<span class="token keyword">type</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>'t<span class="token punctuation">,</span> 'h <span class="token keyword">when</span> 'h<span class="token punctuation">:</span> <span class="token class-name">struct</span> <span class="token keyword">and</span> 'h <span class="token operator">:&gt;</span> <span class="token class-name">Hasher</span><span class="token operator">&lt;</span>'t<span class="token operator">&gt;&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span>
  <span class="token keyword">member</span> this<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>item<span class="token punctuation">:</span> 't<span class="token punctuation">)</span> <span class="token operator">=</span>
    <span class="token keyword">let</span> h <span class="token operator">=</span> hash<span class="token operator">&lt;</span>'h<span class="token punctuation">,</span> _<span class="token operator">&gt;</span> item <span class="token comment">// 'h cannot be inferred as it has no input parameter</span>
    <span class="token comment">// ... rest of the implementation</span>

<span class="token keyword">module</span> StringHashers <span class="token operator">=</span>
  
  <span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token class-name">Struct</span><span class="token punctuation">&gt;]</span></span>
  <span class="token keyword">type</span> <span class="token class-name">InvariantCultureIgnoreCase</span> <span class="token operator">=</span>
    <span class="token keyword">interface</span> <span class="token class-name">Hasher</span><span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token keyword">with</span>
      <span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token class-name">MethodImpl</span><span class="token annotation-content"><span class="token punctuation">(</span>MethodImplOptions<span class="token punctuation">.</span>AggressiveInlining<span class="token punctuation">)</span></span><span class="token punctuation">&gt;]</span></span>
      <span class="token keyword">member</span> this<span class="token punctuation">.</span><span class="token function">Hash</span><span class="token punctuation">(</span>key<span class="token punctuation">:</span> <span class="token class-name">string</span><span class="token punctuation">)</span> <span class="token operator">=</span> StringComparer<span class="token punctuation">.</span>InvariantCultureIgnoreCase<span class="token punctuation">.</span>GetHashCode key
  
<span class="token keyword">open</span> StringHashers  
<span class="token keyword">let</span> map <span class="token operator">=</span> HashSet<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> InvariantCultureIgnoreCase<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">Here we managed to introduce two improvements:</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">Our collection is safer that ordinary .NET <code>HashSet&lt;'t&gt;</code>, as we included information about what hashing method we use. Traditional <code>HashSet&lt;'t&gt;</code> can take <code>IEqualityComparer&lt;'t&gt;</code> as a parameter, but doesn't expose it at type level. That means, that <code>a.Union(b)</code> operation may yield different result than <code>b.Union(a)</code> when <code>a</code> and <code>b</code> use different comparers and we don't get any warnings.</li>
<li data-line="1" dir="auto">Our collection is also faster, because we provided a precise definition of what hashing method we use at the type level. As mentioned before, this allows .NET runtime to specialize <code>HashSet&lt;'t,'h&gt;</code> methods over <code>'h</code>, since it's a struct type. <code>Unchecked.defaultof&lt;'h&gt;</code> used here is a pattern that we can use, as we cannot provide static classes (or F# modules) as generic type parameters. However we can provide a struct with no fields instead - it's in-memory representation is 0 bytes, and since it's not boxed (we're providing it as a generic value), .NET will elide its existence completely and compile it to the exact method call (no virtual dispatch is necessary here).</li>
</ol></div><div class="el-p"><p dir="auto">If you're interested more with this approach, I can recommend <a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=UybGH0xL5ns&amp;ref=bartoszsypytkowski.com" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=UybGH0xL5ns&amp;ref=bartoszsypytkowski.com" target="_blank">this presentation</a> by Frederico Lois.</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="Make use of vectorization" dir="auto" class="heading" id="Make_use_of_vectorization"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Make use of vectorization</h2><div class="heading-children"><div class="el-p"><p dir="auto">We already mentioned registers. As you may (or may not) know, modern day processors offer general purpose registers up to 64bit size. But that's not end of the story. You might have stumbled upon term SIMD (Single Instruction Multiple Data), which was already used here - it's a technique that allows to apply the same operation to multiple values at once. It's a basis for efficient graphical processing and number crunching - hence it's a core building block for GPU programs (eg. shaders).</p></div><div class="el-p"><p dir="auto">However pretty much every modern day CPU also have dedicated registers - varying in size from 128, 256 to 512 bits atm. of writing this post - that can also be used for this purpose. Their API has been wrapped and exposed in .NET, and it's sometimes used for common operations i.e. finding substrings in provided text or copying structs of certain sizes (we saw that already). Sometimes we call the process of making code use these specialized registers, vectorization.</p></div><div class="el-p"><p dir="auto">You can also use them on your own. Let's a simple function that's supposed to check if value can be found within given array:</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">Since vectorized operations can work only over vectors, we first need to create a vector filled in all places with value we try to find.</li>
<li data-line="1" dir="auto">Next, instead of checking array elements one by one, we load entire chunk of it (as much as we can fit into the vector), and compare it with a previously constructed comparator. This comparison is done over all pairwise vector elements in one instruction.</li>
<li data-line="2" dir="auto">Since we have to compare all vectors contents or none at all, we need to fallback to standard comparison of elements one by one, once an array remainder is smaller than vector's capacity.</li>
</ol></div><div class="el-pre"><pre class="language-fsharp" tabindex="0"><code data-line="0" class="language-fsharp is-loaded"><span class="token preprocessor property">#r </span><span class="token string">"nuget: System.Numerics.Vectors"</span>
<span class="token keyword">open</span> System<span class="token punctuation">.</span>Numerics

<span class="token keyword">let</span> <span class="token keyword">inline</span> contains <span class="token punctuation">(</span>value<span class="token punctuation">:</span> 't<span class="token punctuation">)</span> <span class="token punctuation">(</span>array<span class="token punctuation">:</span> 't<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span>
  <span class="token keyword">let</span> chunkSize <span class="token operator">=</span> Vector<span class="token operator">&lt;</span>'t<span class="token operator">&gt;</span><span class="token punctuation">.</span>Count
  <span class="token doc-comment comment">/// ' Use SIMD registers to compare chunks of array at once</span>
  <span class="token keyword">let</span> <span class="token keyword">rec</span> fast <span class="token punctuation">(</span>cmp<span class="token punctuation">:</span> <span class="token class-name">Vector</span><span class="token operator">&lt;</span>'t<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>array<span class="token punctuation">:</span> 't<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>i<span class="token punctuation">:</span> <span class="token class-name">int</span><span class="token punctuation">)</span> <span class="token operator">=</span>
    <span class="token keyword">if</span> i <span class="token operator">&gt;</span> array<span class="token punctuation">.</span>Length <span class="token operator">-</span> chunkSize <span class="token keyword">then</span> slow value array i
    <span class="token keyword">elif</span> Vector<span class="token punctuation">.</span><span class="token function">EqualsAny</span><span class="token punctuation">(</span>cmp<span class="token punctuation">,</span> <span class="token function">Vector</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">then</span> <span class="token keyword">true</span> <span class="token comment">// compare entire chunk at once</span>
    <span class="token keyword">else</span> fast cmp array <span class="token punctuation">(</span>i<span class="token operator">+</span>chunkSize<span class="token punctuation">)</span>
    
  <span class="token doc-comment comment">/// if array remainer size doesn't fit into SIMD register</span>
  <span class="token doc-comment comment">/// fallback to check array items one by one</span>
  <span class="token keyword">and</span> slow <span class="token punctuation">(</span>value<span class="token punctuation">:</span> 't<span class="token punctuation">)</span> <span class="token punctuation">(</span>array<span class="token punctuation">:</span> 't<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>i<span class="token punctuation">:</span> <span class="token class-name">int</span><span class="token punctuation">)</span> <span class="token operator">=</span>
    <span class="token keyword">if</span> i <span class="token operator">&gt;=</span> array<span class="token punctuation">.</span>Length <span class="token keyword">then</span> <span class="token keyword">false</span>
    <span class="token keyword">elif</span> array<span class="token punctuation">.</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> value <span class="token keyword">then</span> <span class="token keyword">true</span>
    <span class="token keyword">else</span> slow value array <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
    
  <span class="token comment">// create vector of 't filled with value copies on all positions</span>
  <span class="token keyword">let</span> cmp <span class="token operator">=</span> <span class="token function">Vector</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
  fast cmp array <span class="token number">0</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">Limitation here is that this operation works only on numbers - the smaller they are in size, the more of them can we compare at once. But is it fast? Let's check it and compare against standard F# <code>Array.contains 900 [|1..1000|]</code>:</p></div><div class="el-table" dir="ltr" style="overflow-x: auto;"><table>
<thead>
<tr>
<th dir="ltr">Method</th>
<th dir="ltr">Mean</th>
<th dir="ltr">Error</th>
<th dir="ltr">StdDev</th>
<th dir="ltr">Ratio</th>
<th dir="ltr">Gen 0</th>
<th dir="ltr">Gen 1</th>
<th dir="ltr">Gen 2</th>
<th dir="ltr">Allocated</th>
</tr>
</thead>
<tbody>
<tr>
<td dir="ltr">Array.contains</td>
<td dir="ltr">1,067.2 ns</td>
<td dir="ltr">4.58 ns</td>
<td dir="ltr">4.28 ns</td>
<td dir="auto">1.00</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
</tr>
<tr>
<td dir="ltr">'vectorized contains'</td>
<td dir="ltr">271.1 ns</td>
<td dir="ltr">1.79 ns</td>
<td dir="ltr">1.68 ns</td>
<td dir="auto">0.25</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
</tr>
</tbody>
</table></div><div class="el-p"><p dir="auto">It's 4 times performance improvement simply by using vectorized operations. There are <a data-tooltip-position="top" aria-label="https://docs.microsoft.com/en-us/dotnet/api/system.numerics.vector?view=net-5.0&amp;ref=bartoszsypytkowski.com" rel="noopener nofollow" class="external-link" href="https://docs.microsoft.com/en-us/dotnet/api/system.numerics.vector?view=net-5.0&amp;ref=bartoszsypytkowski.com" target="_blank">dozens of operations</a> defined in high-level <code>Vector</code> API. Knowledge on how to make an advantage of SIMD is basis for modern day design and implementation of data structures and algorithms.</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="Immutable code and atomic updates" dir="auto" class="heading" id="Immutable_code_and_atomic_updates"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Immutable code and atomic updates</h2><div class="heading-children"><div class="el-p"><p dir="auto">Immutable data structures are prevalent technique of writing programs in functional paradigm and F# is no exception here. Thing is, that immutable structures, be it records or collections, introduce an extra overhead related to copying parts of the code in use. This can be reduced by writing structures that take advantage of <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Persistent_data_structure?ref=bartoszsypytkowski.com" rel="noopener nofollow" class="external-link" href="https://en.wikipedia.org/wiki/Persistent_data_structure?ref=bartoszsypytkowski.com" target="_blank">structural sharing</a> - which deserves its own blog post - but in general .NET doesn't provide optimizations that could make executing single-threaded, large scale immutable code faster than its mutable equivalent.</p></div><div class="el-p"><p dir="auto">Often advantage of having immutable data types is not performance related - they just offer simpler way to analyze and debug program, which has fewer moving parts, as you can compare snapshots of previous/current/expected states with each other.</p></div><div class="el-p"><p dir="auto">One of the bigger advantages - which we're also going to use soon - it's natural idempotency of such structures. Aside of being useful in testing (some of the model checkers and property-based tests make extensive use of it), we can also use it to improve performance. It's not usually visible in simple code microbenchmarking, but rather when we need to combine several different operations at once.</p></div><div class="el-p"><p dir="auto">Example: imagine, that you have a dictionary, that needs to be updated concurrently, but also checked for size from time to time. In .NET we could simply implement it by using <code>ConcurrentDictionary&lt;'k,'v&gt;</code>, but there's a catch - have you ever wondered, how mutable concurrent dictionary ensures, that during counting process a dictionary size has not changed? Well it does it in the simplest way - it locks entire dictionary until counting completes.</p></div><div class="el-pre"><pre class="language-fsharp" tabindex="0"><code data-line="0" class="language-fsharp is-loaded"><span class="token keyword">open</span> System
<span class="token keyword">open</span> System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Concurrent

<span class="token keyword">let</span> map <span class="token operator">=</span> ConcurrentDictionary<span class="token operator">&lt;</span>_<span class="token punctuation">,</span>_<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 1st set of workers tries can try to add value to a map</span>
<span class="token keyword">let</span> write k v <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">AddOrUpdate</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> Func<span class="token operator">&lt;</span>_<span class="token punctuation">,</span>_<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token keyword">fun</span> _ <span class="token operator">-&gt;</span> v<span class="token punctuation">)</span><span class="token punctuation">,</span> Func<span class="token operator">&lt;</span>_<span class="token punctuation">,</span>_<span class="token punctuation">,</span>_<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token keyword">fun</span> _ _ <span class="token operator">-&gt;</span> v<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// another worker performs operation over the elements of the map</span>
<span class="token keyword">let</span> count <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> map<span class="token punctuation">.</span>Count
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">This issue doesn't really exists in immutable collections, since there's no risk of changing the collection as it's being iterated - we can simply iterate over old (possibly outdated) snapshot of data, but we won't stop the field/variable from being updated.</p></div><div class="el-pre"><pre class="language-fsharp" tabindex="0"><code data-line="0" class="language-fsharp is-loaded"><span class="token comment">// shared mutable field</span>
<span class="token keyword">let</span> map <span class="token operator">=</span> ref Map<span class="token punctuation">.</span>empty

<span class="token keyword">let</span> write k v <span class="token operator">=</span> map <span class="token operator">:=</span> Map<span class="token punctuation">.</span>add k v <span class="token operator">!</span>map

<span class="token keyword">let</span> count <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> Map<span class="token punctuation">.</span>count <span class="token operator">!</span>map
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">Now, the question would be - is it safe? Well... no. Modifying contents of F# ref cells (or even static mutable members) is not threadsafe operation. But we can make it so. How? Old school way would be to fall back to OS-level primitives like semaphores and mutexes, but we still can actually make them faster, thanks to the idempotency of immutable collections.</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="Atomic Compare and Swap" dir="auto" class="heading" id="Atomic_Compare_and_Swap"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Atomic Compare and Swap</h3><div class="heading-children"><div class="el-p"><p dir="auto">We'll again fallback to hardware intrinsic operations, this time exposed as part of <a data-tooltip-position="top" aria-label="https://docs.microsoft.com/en-us/dotnet/api/system.threading.volatile?view=net-5.0&amp;ref=bartoszsypytkowski.com" rel="noopener nofollow" class="external-link" href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.volatile?view=net-5.0&amp;ref=bartoszsypytkowski.com" target="_blank">Volatile</a> and <a data-tooltip-position="top" aria-label="https://docs.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-5.0&amp;ref=bartoszsypytkowski.com" rel="noopener nofollow" class="external-link" href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-5.0&amp;ref=bartoszsypytkowski.com" target="_blank">Interlocked</a> classes. We can use first to make sure that our reads and writes are invalidating field values that might be accidentally reordered or cached by other CPU cores. Just like .NET runtime feels free to reorder our fields in defined types, it - of even CPU itself - can decide to reorder our operations if it deems it to be more efficient. The latter provides a set of operations, which can be executed within single processor instruction - without worrying that OS may decide to switch threads in between leaving our shared variable in undefined state.</p></div><div class="el-p"><p dir="auto">The most powerful method in that toolbox is compare-and-swap in .NET known as <code>Interlocked.CompareExchange</code>, which enables to atomically swap register-sized value or reference to a new one, but only if the existing reference at the moment of swap is equal to expected one. What's important here, we're doing reference-based comparison (basically comparing pointer addresses), not structural one that we know as default in F#.</p></div><div class="el-p"><p dir="auto">Now, here's how can we use that operation to replace locks:</p></div><div class="el-pre"><pre class="language-fsharp" tabindex="0"><code data-line="0" class="language-fsharp is-loaded"><span class="token keyword">let</span> <span class="token keyword">mutable</span> map <span class="token operator">=</span> Map<span class="token punctuation">.</span>empty

<span class="token keyword">let</span> <span class="token keyword">rec</span> write k v <span class="token operator">=</span>
  <span class="token keyword">let</span> prev <span class="token operator">=</span> Volatile<span class="token punctuation">.</span>Read <span class="token operator">&amp;</span>map <span class="token comment">// read most up-to-date value</span>
  <span class="token keyword">let</span> next <span class="token operator">=</span> Map<span class="token punctuation">.</span>add k v prev   <span class="token comment">// update operation</span>
  <span class="token keyword">if</span> obj<span class="token punctuation">.</span><span class="token function">ReferenceEquals</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> Interlocked<span class="token punctuation">.</span><span class="token function">CompareExchange</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>map<span class="token punctuation">,</span> next<span class="token punctuation">,</span> prev<span class="token punctuation">)</span><span class="token punctuation">)</span> 
  <span class="token keyword">then</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// we successfully updated the map</span>
  <span class="token keyword">else</span> write k v <span class="token comment">// retry</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">What we basically try to do is to retrieve the most recent value, update it and store back using <code>Interlocked.CompareExchange</code>. This operation returns a previously stored value, which should be the same reference as the one, we got prior to making an update. If it's different, it means that another thread concurrently swapped it while we were making an update. It's very rare situation, even when lock contention is fairly high, but if it happens, we just retry a whole operation.</p></div><div class="el-p"><p dir="auto">Here, we're using <code>Map.add</code> but in practice this could be any function <code>'t -&gt; 't</code>, as long as it satisfies few conditions:</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">A reference returned by update function must be different than the input - otherwise our <code>if</code> expression will never be able to reach the stop condition. It's one reason, why we prefer immutable data types here.</li>
<li data-line="1" dir="auto">Update must be idempotent. In case of concurrent conflict, only one of the sides will win, while other will have to repeat, and we don't want to i.e. insert the same item to our list multiple times. That's another reason for using immutable collections.</li>
<li data-line="2" dir="auto">Update action should be fairly fast. No I/O operations, no number crunching. The longer it takes to execute, the less useful this pattern becomes, as risk of retries grows and their cost may outweigh the cost of acquiring the lock.</li>
</ol></div><div class="el-p"><p dir="auto">All of this puts some strong restrictions on the code that can be used with this pattern, nonetheless it's still used pretty often - especially in combination with standard locking mechanism, where we first try to optimistically use <code>Interlocked</code> primitives to acquire fast locks and on failure fallback to heavier ones. This is how "slim" locks work as well as thread safe queues and unbounded channels (eg. <code>BlockingQueue</code>).</p></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="Inlining" dir="auto" class="heading" id="Inlining"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Inlining</h2><div class="heading-children"><div class="el-p"><p dir="auto">Inlining is a popular optimization technique, were instead of making function call, we directly emit function body in the outer function. This allows us to avoid costs like putting invocation arguments on the stack or jumps related to returning from function. In F# and .NET, there are several situations, where that happens:</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">F# function itself can be marked using <code>inline</code> attribute. This will trigger F# code to literally imprint the function body at the callsite. This means that encapsulation rules of such functions must respect .NET encapsulation (eg. you cannot have public inline function calling private function in its body). Like in many other languages, F# <code>inline</code> is optimistic - in some cases when function cannot be inlined eg. because it has been passed as parameter to another non-inlined function, inlining won't occur.</li>
<li data-line="1" dir="auto">Any function can be forced to be inlined at runtime level by using <code>[&lt;MethodImpl(MethodImplOptions.AggressiveInlining)&gt;]</code> attribute. It will tell JIT to emit machine code directly at callsite. This option does not have limitations of F# <code>inline</code> keyword, however it's not always able to introduce some of the optimizations, F# compiler is capable of.</li>
<li data-line="2" dir="auto">Most of the time inlining happens without our precise knowledge. It can be done by the JIT compiler itself over any function not marked with <code>[&lt;MethodImpl(MethodImplOptions.NoInlining)&gt;]</code> attribute. It's based on a set of heuristic rules, one of which being size of the calling and called functions body - the smaller they are, the higher chance for inlining to happen. Additionally at the current moment, code that explicitly throws an exception is prevented from being inlined at JIT level, so using <code>NoInlining</code> option can also improve speed of your code in some cases - most popular being exception-driven input assertions inside of functions.</li>
</ol></div><div class="el-p"><p dir="auto">As I mentioned, F# <code>inline</code> sometimes can apply optimizations outside of the scope of JIT optimizer alone. Let's take an example:</p></div><div class="el-pre"><pre class="language-fsharp" tabindex="0"><code data-line="0" class="language-fsharp is-loaded"><span class="token keyword">type</span> <span class="token class-name">AtomicRef</span><span class="token operator">&lt;</span>'t <span class="token keyword">when</span> 't<span class="token punctuation">:</span> <span class="token class-name">not</span> <span class="token keyword">struct</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>initValue<span class="token punctuation">:</span> 't<span class="token punctuation">)</span> <span class="token operator">=</span>
  <span class="token keyword">let</span> <span class="token keyword">mutable</span> value <span class="token operator">=</span> initValue
  <span class="token keyword">member</span> this<span class="token punctuation">.</span>Value <span class="token keyword">with</span> <span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token class-name">MethodImpl</span><span class="token annotation-content"><span class="token punctuation">(</span>MethodImplOptions<span class="token punctuation">.</span>AggressiveInlining<span class="token punctuation">)</span></span><span class="token punctuation">&gt;]</span></span> get <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> Volatile<span class="token punctuation">.</span>Read <span class="token operator">&amp;</span>value
    
  <span class="token annotation"><span class="token punctuation">[&lt;</span><span class="token class-name">MethodImpl</span><span class="token annotation-content"><span class="token punctuation">(</span>MethodImplOptions<span class="token punctuation">.</span>AggressiveInlining<span class="token punctuation">)</span></span><span class="token punctuation">&gt;]</span></span>
  <span class="token keyword">member</span> this<span class="token punctuation">.</span><span class="token function">CompareAndSwap</span><span class="token punctuation">(</span>comparand<span class="token punctuation">:</span> 't<span class="token punctuation">,</span> newValue<span class="token punctuation">:</span> 't<span class="token punctuation">)</span><span class="token punctuation">:</span> bool <span class="token operator">=</span>
    obj<span class="token punctuation">.</span><span class="token function">ReferenceEquals</span><span class="token punctuation">(</span>comparand<span class="token punctuation">,</span> Interlocked<span class="token punctuation">.</span><span class="token function">CompareExchange</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>value<span class="token punctuation">,</span> newValue<span class="token punctuation">,</span> comparand<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">This type is going to present behavior similar to F# ref cell, with the difference that its operations are going to be thread safe in the same sense we described in <a data-tooltip-position="top" aria-label="https://www.bartoszsypytkowski.com/writing-high-performance-f-code/#atomiccompareandswap" rel="noopener nofollow" class="external-link" href="https://www.bartoszsypytkowski.com/writing-high-performance-f-code/#atomiccompareandswap" target="_blank">atomic compare-and-swap section</a>. Now imagine, that we'd like to have a generic updating mechanism:</p></div><div class="el-pre"><pre class="language-fsharp" tabindex="0"><code data-line="0" class="language-fsharp is-loaded"><span class="token keyword">module</span> Atomic

<span class="token keyword">let</span> update <span class="token punctuation">(</span>modify<span class="token punctuation">:</span> 't <span class="token operator">-&gt;</span> 't<span class="token punctuation">)</span> <span class="token punctuation">(</span>atom<span class="token punctuation">:</span> <span class="token class-name">AtomicRef</span><span class="token operator">&lt;</span>'t<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">=</span>
  <span class="token keyword">let</span> <span class="token keyword">mutable</span> old <span class="token operator">=</span> atom<span class="token punctuation">.</span>Value
  <span class="token keyword">let</span> <span class="token keyword">mutable</span> newValue <span class="token operator">=</span> modify old
  <span class="token keyword">while</span> <span class="token keyword">not</span> <span class="token punctuation">(</span>atom<span class="token punctuation">.</span><span class="token function">CompareAndSwap</span><span class="token punctuation">(</span>old<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">do</span>
    old <span class="token operator">&lt;-</span> atom<span class="token punctuation">.</span>Value
    newValue <span class="token operator">&lt;-</span> modify old
  newValue
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">With this we can atomically modify a value within the cell. We could leave it like this, but if you'll benchmark an exemplar snippet like this:</p></div><div class="el-pre"><pre class="language-fsharp" tabindex="0"><code data-line="0" class="language-fsharp is-loaded"><span class="token comment">// benchmark setup</span>
<span class="token keyword">val</span> a <span class="token operator">=</span> AtomicRef <span class="token string">"hello"</span>
<span class="token keyword">val</span> value <span class="token operator">=</span> <span class="token string">"world"</span>

<span class="token comment">// benchmarked function body</span>
a <span class="token operator">|&gt;</span> Atomic<span class="token punctuation">.</span>update <span class="token punctuation">(</span><span class="token keyword">fun</span> _ <span class="token operator">-&gt;</span> value<span class="token punctuation">)</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">You'd discover that this call allocates - It's a result of passing a function argument (in .NET these are realized as objects), that captures <code>value</code> field. Now, we could try to mark <code>Atomic.update</code> function using <code>[&lt;MethodImpl&gt;]</code> attribute <strong>or</strong> use <code>inline</code> keyword. If we'd try to benchmark these however, the results would be slightly different:</p></div><div class="el-table" dir="ltr" style="overflow-x: auto;"><table>
<thead>
<tr>
<th dir="ltr">Method</th>
<th dir="ltr">Mean</th>
<th dir="ltr">Error</th>
<th dir="ltr">StdDev</th>
<th dir="ltr">Ratio</th>
<th dir="ltr">Gen 0</th>
<th dir="ltr">Gen 1</th>
<th dir="ltr">Gen 2</th>
<th dir="ltr">Allocated</th>
</tr>
</thead>
<tbody>
<tr>
<td dir="ltr">'update (raw)'</td>
<td dir="ltr">15.927 ns</td>
<td dir="ltr">0.1795 ns</td>
<td dir="ltr">0.1679 ns</td>
<td dir="auto">1.00</td>
<td dir="auto">0.0076</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
<td dir="ltr">24 B</td>
</tr>
<tr>
<td dir="ltr">'update (jit)'</td>
<td dir="ltr">13.089 ns</td>
<td dir="ltr">0.1224 ns</td>
<td dir="ltr">0.1145 ns</td>
<td dir="auto">0.82</td>
<td dir="auto">0.0076</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
<td dir="ltr">24 B</td>
</tr>
<tr>
<td dir="ltr">'update (inline)'</td>
<td dir="ltr">8.516 ns</td>
<td dir="ltr">0.0743 ns</td>
<td dir="ltr">0.0695 ns</td>
<td dir="auto">0.53</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
<td dir="auto">-</td>
</tr>
</tbody>
</table></div><div class="el-p"><p dir="auto">You may notice, that using attribute might slightly improve speed, but didn't change anything in terms of allocations around capturing lambda parameter. However using F# <code>inline</code> keyword indeed helped here: a lambda argument has been erased, as its behavior was aggressively printed together with inlined function body.</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="Final notes" dir="auto" class="heading" id="Final_notes"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Final notes</h2><div class="heading-children"><div class="el-p"><p dir="auto">It's been a long post, but we just touched a tip of an iceberg here. We're didn't really mention optimizations in the area of I/O operations, different flavors of async code execution or <a data-tooltip-position="top" aria-label="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.unsafe?view=net-5.0&amp;ref=bartoszsypytkowski.com" rel="noopener nofollow" class="external-link" href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.unsafe?view=net-5.0&amp;ref=bartoszsypytkowski.com" target="_blank">dropping .NET safety belt</a> in cases when we wish to omit safe checks even when .NET compiler alone could not. There are also many tricky situations in which one small, seemingly insignificant change in code can throw .NET runtime into pit of deoptimized code. If you're curious about these, you can follow <a data-tooltip-position="top" aria-label="https://twitter.com/badamczewski01?ref=bartoszsypytkowski.com" rel="noopener nofollow" class="external-link" href="https://twitter.com/badamczewski01?ref=bartoszsypytkowski.com" target="_blank">Bartosz Adamczewski</a> on twitter.</p></div><div class="el-p"><p dir="auto">Ultimately, while many of these tips and behaviors may stay with us for years to come, remember that compilers are still actively developed and just like some of these optimizations are not applied on older runtimes like .NET Full Framework, new ones (like smarter escape analysis, new devirtualization rules etc.) may turn some of the warnings presented here obsolete and shift the optimization techniques to enable us writing code that's both fast and high-level.</p></div><div class="mod-footer mod-ui"></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="computer-science/programming-language/fsharp/writing-high-performance-fsharp-code.html#Writing high performance Fsharp code"><div class="tree-item-contents heading-link" heading-name="Writing high performance Fsharp code"><span class="tree-item-title">Writing high performance Fsharp code</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="computer-science/programming-language/fsharp/writing-high-performance-fsharp-code.html#Understand_memory_layout_of_value_types"><div class="tree-item-contents heading-link" heading-name="Understand memory layout of value types"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">Understand memory layout of value types</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="computer-science/programming-language/fsharp/writing-high-performance-fsharp-code.html#Readonly_and_ref-like_structs"><div class="tree-item-contents heading-link" heading-name="Readonly and ref-like structs"><span class="tree-item-title">Readonly and ref-like structs</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="computer-science/programming-language/fsharp/writing-high-performance-fsharp-code.html#Padding"><div class="tree-item-contents heading-link" heading-name="Padding"><span class="tree-item-title">Padding</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="computer-science/programming-language/fsharp/writing-high-performance-fsharp-code.html#CPU_cache_lines"><div class="tree-item-contents heading-link" heading-name="CPU cache lines"><span class="tree-item-title">CPU cache lines</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="computer-science/programming-language/fsharp/writing-high-performance-fsharp-code.html#False_sharing"><div class="tree-item-contents heading-link" heading-name="False sharing"><span class="tree-item-title">False sharing</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="computer-science/programming-language/fsharp/writing-high-performance-fsharp-code.html#Using_structs_and_collections_together"><div class="tree-item-contents heading-link" heading-name="Using structs and collections together"><span class="tree-item-title">Using structs and collections together</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/programming-language/fsharp/writing-high-performance-fsharp-code.html#Discriminated_unions_as_value_types"><div class="tree-item-contents heading-link" heading-name="Discriminated unions as value types"><span class="tree-item-title">Discriminated unions as value types</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/programming-language/fsharp/writing-high-performance-fsharp-code.html#Learn_to_work_with_virtual_calls"><div class="tree-item-contents heading-link" heading-name="Learn to work with virtual calls"><span class="tree-item-title">Learn to work with virtual calls</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/programming-language/fsharp/writing-high-performance-fsharp-code.html#Make_use_of_vectorization"><div class="tree-item-contents heading-link" heading-name="Make use of vectorization"><span class="tree-item-title">Make use of vectorization</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="computer-science/programming-language/fsharp/writing-high-performance-fsharp-code.html#Immutable_code_and_atomic_updates"><div class="tree-item-contents heading-link" heading-name="Immutable code and atomic updates"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">Immutable code and atomic updates</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="computer-science/programming-language/fsharp/writing-high-performance-fsharp-code.html#Atomic_Compare_and_Swap"><div class="tree-item-contents heading-link" heading-name="Atomic Compare and Swap"><span class="tree-item-title">Atomic Compare and Swap</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/programming-language/fsharp/writing-high-performance-fsharp-code.html#Inlining"><div class="tree-item-contents heading-link" heading-name="Inlining"><span class="tree-item-title">Inlining</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/programming-language/fsharp/writing-high-performance-fsharp-code.html#Final_notes"><div class="tree-item-contents heading-link" heading-name="Final notes"><span class="tree-item-title">Final notes</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>