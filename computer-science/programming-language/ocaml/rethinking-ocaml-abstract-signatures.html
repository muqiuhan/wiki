<!DOCTYPE html> <html><head>
		<title>Rethinking OCaml abstract signatures</title>
		<base href="../../../">
		<meta id="root-path" root-path="../../../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="韩暮秋的个人维基 - Rethinking OCaml abstract signatures">
		<meta property="og:title" content="Rethinking OCaml abstract signatures">
		<meta property="og:description" content="韩暮秋的个人维基 - Rethinking OCaml abstract signatures">
		<meta property="og:type" content="website">
		<meta property="og:url" content="https://muqiuhan.github.io/wiki/computer-science/programming-language/ocaml/rethinking-ocaml-abstract-signatures.html">
		<meta property="og:image" content="undefined">
		<meta property="og:site_name" content="韩暮秋的个人维基">
		<meta name="author" content="韩暮秋"><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="https://muqiuhan.github.io/wiki/lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="lib/scripts/pixi.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="lib/scripts/minisearch.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="preload" href="lib/styles/other-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/other-plugins.css"></noscript><link rel="stylesheet" href="lib/styles/theme.css"><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript></head><body class="publish css-settings-manager theme-light show-inline-title show-ribbon outliner-plugin-dnd h2-underline"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="Rethinking OCaml abstract signatures"><p dir="auto">Rethinking OCaml abstract signatures</p></h1><div class="el-p"><p dir="auto"><a href="?query=tag:ocaml" class="tag" target="_blank" rel="noopener nofollow">#ocaml</a> <a href="?query=tag:fp" class="tag" target="_blank" rel="noopener nofollow">#fp</a> <a href="?query=tag:typesystem" class="tag" target="_blank" rel="noopener nofollow">#typesystem</a></p></div><div class="el-p"><p dir="auto">Abstract module types are one of the less understood features of the OCaml module system. They have been one of the obstacles in the on-going effort to specify, and eventually redesign, the module system.</p></div><div class="el-p"><p dir="auto">In this blog post, I (Clément Blaudeau) present an explanation of what are those abstract module types, and propose a slightly restricted version that might be easier to understand and specify while remaining pretty expressive.</p></div><div class="el-p"><p dir="auto">For the past 2 years, I’ve been working on building a new specification for the OCaml module system based on Fω. The goal, besides the theoretical interest, is to eventually redo (the module part of) the typechecker with this approach, which would have several benefits:</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">fix some soundness issues and edge-cases that have appeared and built up over the years, due to unforeseen interactions between features</li>
<li data-line="1" dir="auto">simplify the (notoriously hard) code of the typechecker by removing ad-hoc techniques and hacks (such as the <em>strengthening</em> or the treatment of <em>aliases</em> for instance)</li>
<li data-line="2" dir="auto">provide a clean base to add new and awaited features. Notably, transparent ascription and modular implicits are proposals for OCaml modules stalled by the lack of specification of the module system.</li>
</ul></div><div class="el-p"><p dir="auto">Yet, a key aspect in OCaml development culture is to ensure backward compatibility. Therefore, the new Fω approach I’ve been building should not only subsumes the current typechecker in normal use cases, but actually support <em>all</em> of the features of the module system. For long, <em>abstract signatures</em> (also called <em>abstract module types</em>) were believed to be, at least, <em>problematic</em> for Fω. Hopefully, we found out that a slightly restricted version of the feature was encodable in Fω, and, in passing, made the semantics of abstract signatures much simpler. Thus, only one question remains: does this restricted form actually covers all use cases, i.e., is the restriction backward compatible ?</p></div><div class="el-p"><p dir="auto">Here, we aim at presenting the current state of abstract signatures and our proposed simplification purely from an <strong>OCaml user point of view</strong>, not from the theoretical one. We welcome any feedback, specifically, use cases or potential use cases that significantly differ from our examples.</p></div><div class="el-p"><p dir="auto">We start by introducing abstract signatures through examples. Then, we present the current state of abstract signatures in OCaml: we explain the syntactic approach and the issues associated with it. We argue that it has surprising behaviors and, in its current <em>unrestricted</em> form, it is actually <em>too powerful for its own good</em>. Then, we propose a restriction to make the system <em>predicative</em> which, by decreasing its expressiveness, actually makes it more usable. (Our actual proposal is given in 3.3). We finish by other aspect related to usability (syntax, inference).</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="1. What are abstract signatures ?" dir="auto" class="heading" id="1._What_are_abstract_signatures_?"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1. What are abstract signatures ?</h4><div class="heading-children"><div class="el-p"><p dir="auto">The art of modularity is all about controlling abstraction and interfaces. ML languages offer this control via a <em>module system</em>, which contains a <em>signature</em> language to describe interfaces. Signatures contain <em>declarations</em> (fields): values <code>val x : t</code>, types <code>type t = int</code>, modules <code>module X : S</code>, and module types <code>module type T = S</code>. Type and module type declarations can also be abstract <code>type t</code>, <code>module type T</code>, which serves both to hide implementation details via <em>sealing</em> and to have polymorphic interfaces, using <em>functors</em>.</p></div><div class="el-p"><p dir="auto">Here, we focus on the construct <code>module type T</code>, called <em>abstract module type</em> or <em>abstract signature</em>. We start with examples adapted from <a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/what-are-abstract-module-types-useful-for/10121/3" rel="noopener nofollow" class="external-link" href="https://discuss.ocaml.org/t/what-are-abstract-module-types-useful-for/10121/3" target="_blank">this forum discussion</a>.</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.1 Module-level sealing" dir="auto" class="heading" id="1.1_Module-level_sealing"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1 Module-level sealing</h5><div class="heading-children"><div class="el-p"><p dir="auto">Let’s consider the following scenario. Two modules providing an implementation of UDP (<code>UDP1</code> and <code>UDP2</code>) are developed with different design trade-offs. They both implement a signature with basic send and receive operations. Then, functors are added as layers on top: taking a udp library as input, they return another udp library as an output.</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>Reliable</code> adds sequence numbers to the packets and re-sends missing packets;</li>
<li data-line="1" dir="auto"><code>CongestionControl</code> tracks the rate of missing packets to adapt the throughput to network congestion situations;</li>
<li data-line="2" dir="auto"><code>Encryption</code> encrypts the content of all messages.</li>
</ul></div><div class="el-p"><p dir="auto">A project might need different combinations of the basic libraries and functors, while requiring that <strong>all</strong> combinations use encryption. To enforce this, the solution is to use the module-level <em>sealing</em> of abstract signatures. In practice, the signature of the whole library containing implementations and functors <code>UDPLib</code> (typically, its <code>.mli</code> file) is rewritten to abstract all interfaces except for the output of the <code>Encryption</code> functor.</p></div><div class="el-p"><p dir="auto">module type UDPLib = sig<br>
module type UNSAFE</p></div><div class="el-p"><p dir="auto">  module UDP1 : UNSAFE<br>
module UDP2 : UNSAFE</p></div><div class="el-p"><p dir="auto">  module Reliable : UNSAFE -&gt; UNSAFE<br>
module CongestionControl : UNSAFE -&gt; UNSAFE</p></div><div class="el-p"><p dir="auto">  module Encryption : UNSAFE -&gt;<br>
sig val send : string -&gt; unit (<em> ... </em>) end<br>
end</p></div><div class="el-p"><p dir="auto">Just as type abstraction, signature abstraction can be used to enforce certain code patterns: users of <code>UDPLib</code> will only be able to use the content of modules after calling the <code>Encryption</code> functor, and yet they have the freedom to choose between different implementations and features:</p></div><div class="el-p"><p dir="auto">module UDPKeyHandshake = Encryption(Reliable(UDP1))<br>
module UDPVideoStream  = Encryption(CongestionControl(UDP2))<br>
(<em> etc </em>)</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.2 Module-level polymorphism" dir="auto" class="heading" id="1.2_Module-level_polymorphism"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.2 Module-level polymorphism</h5><div class="heading-children"><div class="el-p"><p dir="auto">Another use is to introduce polymorphism at the module level. Just as polymorphic functions can be used to factor code, module-level polymorphic functors can be used to factor module expressions. If a code happens to often feature functor applications of the form <code>Hashtbl.Make(F(X))</code> or <code>Set.Make(F(X))</code>, one can define the <code>MakeApply</code> functor as follows:</p></div><div class="el-p"><p dir="auto">(<em> Factorizing common expressions </em>)<br>
module type Type = sig module type T end<br>
module MakeApply<br>
(A:Type) (X: A.T)<br>
(B:Type) (F: A.T -&gt; B.T)<br>
(C:Type) (H: sig module Make : B.T -&gt; C.T end) = H.Make(F(X))</p></div><div class="el-p"><p dir="auto">Downstream the code is rewritten into <code>MakeApply(...)(X)(...)(F)(...)(Set)</code> or <code>MakeApply(...)(X)(...)(F)(...)(Hashtbl)</code> Right now, the verbosity of such example would probably be a deal-breaker. We address this aspect at the end. Ignoring the verbosity, this can be useful for maintenance: by channeling all applications through <code>MakeApply</code>, only one place needs to be updated if the arity or order of arguments is changed. Similarly, if several functors expect a <em>constant argument</em> containing – for instance – global variables, a <code>ApplyGv</code> functor can be defined to always provide the right second argument, which can even latter be hidden away to the user of <code>ApplyGv</code>:</p></div><div class="el-p"><p dir="auto">(<em> Constant argument </em>)<br>
module Gv : GlobalVars<br>
module ApplyGv (Y : sig module type A module type B end)<br>
(F : Y.A -&gt; GlobalVars -&gt; Y.B)(X : Y.A) = F(X)(Gv)</p></div><div class="el-p"><p dir="auto">Downstream, code featuring <code>F(X)(GlobalVars)</code> is rewritten into <code>ApplyGv(...)(F)(X)</code> Then, the programmer can hide the <code>GlobalVars</code> module while letting users use <code>ApplyGv</code>, ensuring that global variables are not modified in uncontrolled ways by certain part of the program.</p></div><div class="el-p"><p dir="auto">Finally, polymorphism can also be used by a developer to prevent unwanted dependencies on implementation details. If the body of a functor uses an argument with a submodule <code>X</code>, but actually does not depend on the content of <code>S</code>, abstracting it is a “good practice”.</p></div><div class="el-p"><p dir="auto">module F (Arg : sig ... module X : S ... end) =<br>
... (<em> polymorphism is not enforced </em>)</p></div><div class="el-p"><p dir="auto">module F' (Y: sig module type S end)<br>
(Arg : sig ... module X : Y.S ... end ) =<br>
... (<em> polymorphism is enforced </em>)</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.3 So it’s just normal use cases of abstraction ?" dir="auto" class="heading" id="1.3_So_it’s_just_normal_use_cases_of_abstraction_?"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.3 So it’s just normal use cases of abstraction ?</h5><div class="heading-children"><div class="el-p"><p dir="auto">Fundamentally, these example are not surprising for developers that are used to rely on abstraction to protect invariants and factor code. Their specificity lies in the fact that there are at the module level, and therefore require projects with a certain size and a strong emphasis on modularity to be justified.</p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="2. OCaml’ abstract signatures, an incidental feature ?" dir="auto" class="heading" id="2._OCaml’_abstract_signatures,_an_incidental_feature_?"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2. OCaml’ abstract signatures, an incidental feature ?</h4><div class="heading-children"><div class="el-p"><p dir="auto">The challenge for understanding (and implementing) abstract signatures lies more in the meaning of the module-level <em>polymorphism</em> that they offer than the module level sealing, the latter being pretty straightforward. More specifically, the crux lies in the meaning of the <em>instantiation</em> of an abstract signature variable <code>A</code> by some other signature <code>S</code>, that happens when a polymorphic functor is applied. OCaml follows an <em>unrestricted syntactical approach</em>: <code>A</code> can be instantiated by any (well-formed) signature <code>S</code>. During instantiation, all occurrences of <code>A</code> are just replaced by <code>S</code> ; finally, the resulting signature is <strong>re-interpreted</strong>—as if it were written <em>as is</em> by the user.</p></div><div class="el-p"><p dir="auto">However, this syntactical rewriting interferes with the <em>variant</em> interpretation of signatures, which can lead to surprising behaviors. We discuss this aspect first. The <em>unrestricted</em> aspect leads to the (infamous) <em>Type : Type</em> issue which has some theoretical consequences. We finish this section by mentioning other—more technical—issues.</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.1 Syntactical rewriting" dir="auto" class="heading" id="2.1_Syntactical_rewriting"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.1 Syntactical rewriting</h5><div class="heading-children"><div class="el-p"><p dir="auto">The first key issue of this approach comes from the fact that signatures in OCaml have a variant interpretation: abstract fields (1) have a different meaning (sealing or polymorphism) depending on whether they occur in positive or negative positions, and (2) abstract fields open new scopes, i.e.&nbsp;duplicating an abstract type field introduces two different abstract types. Overall, OCaml signatures can be thought of as having <em>implicit quantifiers</em>: using a signature in positive or negative position changes its implicit quantifiers (from existential to universal) while duplicating a signature duplicates the quantifiers (and therefore introduces new incompatible abstract types).</p></div><div class="el-p"><p dir="auto">Therefore, when instantiating an abstract signature with a signature that has abstract fields, the user must be aware of this, and mentally infer the meaning of the resulting signature. To illustrate how it can be confusing, let’s revisit the first motivating example and let’s assume that the developer actually want to expose part of the interface of the raw <code>UDP</code> libraries. One might be tempted to instantiate <code>UNSAFE</code> with something along the following lines:</p></div><div class="el-p"><p dir="auto">module type UDPLib_expose = sig<br>
include UDPLib with module type UNSAFE =<br>
sig<br>
module type CORE_UNSAFE<br>
module Unsafe : CORE_UNSAFE (<em> this part remains abstract </em>)<br>
module Safe : sig ... end (<em> this part is exposed </em>)<br>
end<br>
end</p></div><div class="el-p"><p dir="auto">This returns :</p></div><div class="el-p"><p dir="auto">module type UDPLib_expose =  sig<br>
module type UNSAFE =<br>
sig<br>
module type CORE_UNSAFE<br>
module Unsafe : CORE_UNSAFE<br>
module Safe : sig ... end<br>
end<br>
module UDP1 : UNSAFE<br>
module UDP2 : UNSAFE<br>
module Reliable : UNSAFE -&gt; UNSAFE<br>
module CongestionControl : UNSAFE -&gt; UNSAFE<br>
module Encryption : UNSAFE -&gt; sig val send : string -&gt; unit (<em> ... </em>) end<br>
end</p></div><div class="el-p"><p dir="auto">However, the syntactical rewriting and reinterpretation of this signature in the negative positions produces a counter-intuitive result. For instance, if we expand the signature of the argument for the functor <code>Reliable</code> (for instance) we see:</p></div><div class="el-p"><p dir="auto">module Reliable :<br>
sig<br>
module type CORE_UNSAFE<br>
module Unsafe : CORE_UNSAFE<br>
module Safe : sig ... end<br>
end -&gt; UNSAFE</p></div><div class="el-p"><p dir="auto">This means that the functor actually has to be <em>polymorphic</em> in the underlying implementation of <code>CORE_UNSAFE</code>, rather than using the internal details, which has the <strong>opposite meaning</strong> as before. If the user wants to hide a <em>shared</em> unsafe core, accessible to the functor when they were defined and then abstracted away, the following pattern may be used instead:</p></div><div class="el-p"><p dir="auto">module type UDPLib_expose' = sig<br>
module type CORE_UNSAFE<br>
include UDPLib with module type UNSAFE = sig<br>
module type CORE_UNSAFE = CORE_UNSAFE<br>
module Unsafe : CORE_UNSAFE<br>
module Safe : sig ... end<br>
end<br>
end</p></div><div class="el-p"><p dir="auto">Doing so, the instantiated signature does not contain abstract fields and therefore its variant reinterpretation will not introduce unwanted polymorphism. This observation is at the core of the proposal of this post.</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.2 `Type : Type` and impredicativity" dir="auto" class="heading" id="2.2_`Type_:_Type`_and_impredicativity"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.2 <code>Type : Type</code> and impredicativity</h5><div class="heading-children"><div class="el-p"><p dir="auto">Abstract module types are impredicative: a signature containing an abstract signature can be instantiated by itself. One can trick the subtyping algorithm into an infinite loop of instantiating an abstract signature by itself, as shown by <a data-tooltip-position="top" aria-label="https://sympa.inria.fr/sympa/arc/caml-list/1999-07/msg00027.html" rel="noopener nofollow" class="external-link" href="https://sympa.inria.fr/sympa/arc/caml-list/1999-07/msg00027.html" target="_blank">Andreas Rosseberg</a>, adapting an example from <a data-tooltip-position="top" aria-label="https://doi.org/10.1145/174675.176927" rel="noopener nofollow" class="external-link" href="https://doi.org/10.1145/174675.176927" target="_blank">Harper and Lillibridge (POPL ’94)</a>. This also allows type-checking of (non-terminating) programs with an absurd type, as shown by the encoding of the Girard’s paradox done by <a data-tooltip-position="top" aria-label="https://github.com/lpw25/girards-paradox/tree/master" rel="noopener nofollow" class="external-link" href="https://github.com/lpw25/girards-paradox/tree/master" target="_blank">Leo White</a>.</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.3 Other issues" dir="auto" class="heading" id="2.3_Other_issues"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.3 Other issues</h5><div class="heading-children"><div class="el-p"><p dir="auto">The current implementation of the typechecker does not handle abstract signatures correctly in some scenarios. It’s unclear if they are just bugs or pose theoretical challenges.</p></div><div class="el-h6 heading-wrapper"><h6 data-heading="2.3.1 Invalid module aliases" dir="auto" class="heading" id="2.3.1_Invalid_module_aliases"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.3.1 Invalid module aliases</h6><div class="heading-children"><div class="el-p"><p dir="auto">Inside a functor, module aliases are disallowed between the parameter and the body (for soundness reasons, due to coercive subtyping). However, this check can be bypassed by using an abstract signature that is then instantiated with an alias. If we try to use it to produce a functor that exports its argument as an alias, the typechecker crashes. This is discussed in <a data-tooltip-position="top" aria-label="https://github.com/ocaml/ocaml/issues/11441" rel="noopener nofollow" class="external-link" href="https://github.com/ocaml/ocaml/issues/11441" target="_blank">#11441</a></p></div><div class="el-p"><p dir="auto">(<em> crashes the typechecker in current OCaml </em>)<br>
module F (Type : sig module type T end)(Y : Type.T) = Y</p></div><div class="el-p"><p dir="auto">module Crash (Y : sig end) =<br>
F(struct module type T = sig module X = Y end end)</p></div></div></div><div class="el-h6 heading-wrapper"><h6 data-heading="2.3.2 Loss of applicativity" dir="auto" class="heading" id="2.3.2_Loss_of_applicativity"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.3.2 Loss of applicativity</h6><div class="heading-children"><div class="el-p"><p dir="auto">The use of abstract signatures clashes with applicativity of functors, as discussed <a data-tooltip-position="top" aria-label="https://github.com/ocaml/ocaml/issues/12204" rel="noopener nofollow" class="external-link" href="https://github.com/ocaml/ocaml/issues/12204" target="_blank">in #12204</a>.</p></div></div></div><div class="el-h6 heading-wrapper"><h6 data-heading="2.3.3 Invalid signatures and avoidance" dir="auto" class="heading" id="2.3.3_Invalid_signatures_and_avoidance"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.3.3 Invalid signatures and avoidance</h6><div class="heading-children"><div class="el-p"><p dir="auto">Another known issue is that the typechecker can abstract a signature when it contains unreachable type fields (types pointing to anonymous modules). This can lead to the production of <em>invalid signatures</em> : signatures that are refused by the typechecker when re-entered back in.</p></div><div class="el-p"><p dir="auto">module F (Y: sig type t end) =<br>
struct<br>
module type A = sig<br>
type t = Y.t (<em> this will force the abstraction of all of A </em>)<br>
type u<br>
end<br>
module X : A = struct type t = Y.t type u = int end<br>
type u = X.u<br>
end</p></div><div class="el-p"><p dir="auto">module Test = F(struct type t end)</p></div><div class="el-p"><p dir="auto">(<em> returns </em>)<br>
module Test : sig module type A module X : A type u = X.u end</p></div><div class="el-p"><p dir="auto">Here, the type field <code>type u = X.u</code> is invalid as <code>X</code> has an abstract signature (and therefore, no fields).</p></div></div></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="3. A solution: simple abstract signatures" dir="auto" class="heading" id="3._A_solution:_simple_abstract_signatures"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3. A solution: simple abstract signatures</h4><div class="heading-children"><div class="el-p"><p dir="auto">In this section we explore solutions for fixing the issues of the current approach. The core criticism we make of the OCaml approach is that it is actually <em>too expressive for its own good</em>. Abstract signatures are <em>impredicative</em>: they can be instantiated by themselves. Having impredicative instantiation with variant reinterpretation is hard to track for the user and interacts in very subtle ways with other features of the module system, slowing down its development—and breaking its theoretical properties. To address this, we take the opposite stance and propose to make the system actually <em>predicative</em>: we restrict the set of signatures that can be used to instantiate an abstract signature. This also indirectly addresses the complexity of the variant reinterpretation.</p></div><div class="el-p"><p dir="auto">We start with the simplest solution where instantiation of abstract signatures is restricted to signatures containing no abstract fields. Then, we propose to relax this restriction and allow for signatures that contain abstract <em>type</em> fields (but no abstract module types), which we call <em>simple</em> signatures. This will requires us to briefly discuss the need for module-level sharing.</p></div><div class="el-p"><p dir="auto">In this section we focus on the theoretical aspects, but present them informally with examples. The practical aspects, notably syntax and inference, are discussed in the next section.</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="3.1 No abstraction" dir="auto" class="heading" id="3.1_No_abstraction"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.1 No abstraction</h5><div class="heading-children"><div class="el-p"><p dir="auto">One might wonder why abstract types and abstract signatures syntactically resembles one another and yet, the latter is much more complex than the former. The key lies in the fact that abstract types can only be instantiated by <em>concrete</em> type expressions, without free variables. Informally, this:</p></div><div class="el-p"><p dir="auto">sig<br>
type t<br>
val x : t<br>
val f : t -&gt; t<br>
end with type t = (int * 'a)</p></div><div class="el-p"><p dir="auto">is not allowed, notably because (1) the scope of the abstract type variable <code>'a</code> is unclear, (2) values of type <code>t</code>, like <code>x</code>, would be ill-typed.</p></div><div class="el-p"><p dir="auto">Therefore, a first solution is to <strong>require abstract signatures to be instantiated only by concrete signatures, i.e.&nbsp;signatures with no abstract fields</strong> (neither types nor module types). This circumvents the clash between the rewriting and variant reinterpretation of abstract fields (by disallowing them).</p></div><div class="el-p"><p dir="auto">This is simple and sound but prevents some valid uses of abstract types: in the first example, <code>UNSAFE</code> could not be instantiated with abstract type fields, forcing <code>UDP1</code> and <code>UDP2</code> to have the same type definitions.</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="3.2 The issue of module-level sharing" dir="auto" class="heading" id="3.2_The_issue_of_module-level_sharing"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.2 The issue of module-level sharing</h5><div class="heading-children"><div class="el-p"><p dir="auto">If we want to relax the no-abstraction proposal, some abstract fields will be allowed when instantiating signatures. Then, the question of what sharing (i.e., type equalities) should be kept <em>between different occurrences of the abstract fields</em> arises.</p></div><div class="el-p"><p dir="auto">In OCaml signatures, sharing between two modules is usually expressed <em>at the core-level</em> by rewriting the fields of the signature of the second module to refer to their counterpart in the first one. This cannot be done with abstract signatures, as they have no fields. Instead, the language needs module-level sharing, which in OCaml is very restricted. Indeed, it provides a form of module aliases (only for submodules, not at the top-level of a signature), but aliasing between a functor body and its parameter is not allowed—while it is typically the use-case for abstract signatures in polymorphic functors. Consider the following code:</p></div><div class="el-p"><p dir="auto">(<em> Code </em>)<br>
module F1 (Y: sig module type A module X : A end) = Y.X<br>
module F2 (Y: sig module type A module X : A end) = (Y.X : Y.A)</p></div><div class="el-p"><p dir="auto">Currently, the typechecker cannot distinguish between the two and returns the same signature, while we would expect the first one to keep the sharing between the parameter and the body.</p></div><div class="el-p"><p dir="auto">(<em> Currently, both are given the same type: </em>)<br>
module F1 (Y: sig module type A module X : A end) : A<br>
module F2 (Y: sig module type A module X : A end) : A</p></div><div class="el-p"><p dir="auto">As an example, we can consider the argument for the functors:</p></div><div class="el-p"><p dir="auto">module Y = struct<br>
module type A = sig type t end<br>
module X = struct type t = int end<br>
end</p></div><div class="el-p"><p dir="auto">module Test1 = F1(Y)<br>
module Test2 = F2(Y)</p></div><div class="el-p"><p dir="auto">This returns :</p></div><div class="el-p"><p dir="auto">module Test1 : sig type t end<br>
module Test2 : sig type t end</p></div><div class="el-p"><p dir="auto">While we would expect :</p></div><div class="el-p"><p dir="auto">module Test1 : sig type t = int end<br>
module Test2 : sig type t end</p></div><div class="el-p"><p dir="auto">Two possible extensions would help tackle this issue.</p></div><div class="el-h6 heading-wrapper"><h6 data-heading="Lazy strengthening" dir="auto" class="heading" id="Lazy_strengthening"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Lazy strengthening</h6><div class="heading-children"><div class="el-p"><p dir="auto">A recently proposed experimentation, named <em>lazy strengthening</em>, extends the signature language with an operator <code>S with P</code>, where <code>S</code> is a signature and <code>P</code> a module path. It is interpreted as <code>S</code> strengthened by <code>P</code>, i.e.&nbsp;<code>S</code> in which all abstract fields are rewritten to point to their counterpart in <code>P</code>. Initially considered for performance reasons, it would allow for tracking of type equalities when using abstract signatures.</p></div><div class="el-p"><p dir="auto">(<em> Lazy strengthening would keep type equalities: </em>)<br>
module F1 (Y: sig module type A module X : A end) = Y.A with Y.X</p></div></div></div><div class="el-h6 heading-wrapper"><h6 data-heading="Transparent ascription" dir="auto" class="heading" id="Transparent_ascription"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Transparent ascription</h6><div class="heading-children"><div class="el-p"><p dir="auto">A more involved solution is the use of an extension of aliasing called <em>transparent ascription</em>, where both the alias <em>and</em> the signature are stored in the signature. The signature language would be extended with an operator <code>(= P &lt; S)</code>. The technical implications of this choice are beyond the scope of this discussion.</p></div><div class="el-p"><p dir="auto">(<em> Transparent ascription would keep module equalities: </em>)<br>
module F1 (Y: sig module type A module X : A end) : (= Y.X &lt; Y.A)</p></div></div></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="3.3 Our proposal : _simple_ abstract signatures" dir="auto" class="heading" id="3.3_Our_proposal_:__simple__abstract_signatures"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.3 Our proposal : <em>simple</em> abstract signatures</h5><div class="heading-children"><div class="el-p"><p dir="auto">Maintaining a predicative approach, we propose to <strong>restrict instantiation only by <em>simple</em> signatures, i.e., signatures that may contain abstract type fields, but no abstract module types</strong>. This reintroduces the need to express module-level sharing and the mental gymnastic of variant re-interpretation of abstract type fields. However, it guarantees that all modules sharing the same abstract signature will also share the same structure (same fields) after instantiation, and can only differ in their type fields. We believe this makes for a good compromise.</p></div><div class="el-h6 heading-wrapper"><h6 data-heading="Expressivity (and prenex-form)" dir="auto" class="heading" id="Expressivity_(and_prenex-form)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Expressivity (and prenex-form)</h6><div class="heading-children"><div class="el-p"><p dir="auto">One might wonder how restrictive is this proposal. Specifically, if we consider a simple polymorphic functor as:</p></div><div class="el-p"><p dir="auto">module Apply (Y : sig module type A end) (F : Y.A -&gt; Y.A)(X : Y.A) = F(X)</p></div><div class="el-p"><p dir="auto">The following partial application would be rejected:</p></div><div class="el-p"><p dir="auto">(<em> Rejected as A would be instantiated by <code>sig module type B module X : B -&gt; B end</code> </em>)<br>
module Apply' = Apply(struct module type A = sig module type B module X : B -&gt; B end end)</p></div><div class="el-p"><p dir="auto">However, this could be circumvented by eta-expanding, thus expliciting module type parameters, and instantiating only a simple signature:</p></div><div class="el-p"><p dir="auto">(<em> Accepted as A is instantiated by a signature with no abstract fields </em>)<br>
module Apply'' = functor (Y:sig module type B end) -&gt;<br>
Apply(struct module type A = sig module type B = Y.B module X : B -&gt; B end end)</p></div></div></div><div class="el-h6 heading-wrapper"><h6 data-heading="Higher-abstraction ?" dir="auto" class="heading" id="Higher-abstraction_?"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Higher-abstraction ?</h6><div class="heading-children"><div class="el-p"><p dir="auto">Concrete and simple signatures can be seen as the first two levels of the predicative approach for types declarations. There are no more levels for type declarations, as types cannot be <em>partially abstract</em> (see 3.1). Could it be useful to add even more expressivity and authorize instantiation by a signature containing again an abstract module type field (which would need to be restricted with a level system like <em>universes</em>)? We have found no example where this was useful. Besides, it would add a great layer of complexity.</p></div></div></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="4. Other practical aspects" dir="auto" class="heading" id="4._Other_practical_aspects"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4. Other practical aspects</h4><div class="heading-children"><div class="el-h6 heading-wrapper"><h6 data-heading="Syntax" dir="auto" class="heading" id="Syntax"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Syntax</h6><div class="heading-children"><div class="el-p"><p dir="auto">A key aspect of abstract module types that reduces their usability is the verbosity of the syntax. Rather than having to pass signature as part of a module argument to a polymorphic functor, using a separate notation for module type parameters could be more concise. In practice, abstract signature arguments could be indicated by using brackets instead of parenthesis, and interleaved with normal module arguments, as in this example:</p></div><div class="el-p"><p dir="auto">(<em> At definition </em>)<br>
module MakeApply<br>
[A] (X:A)<br>
[B] (F: A -&gt; B)<br>
[C] (H : sig module Make : B -&gt; C end)<br>
= H.Make(F(X))</p></div><div class="el-p"><p dir="auto">module ApplyGv<br>
[A] [B] (F:A -&gt; GlobalVars -&gt; B) (X:A)<br>
= F(X)(Gv)</p></div><div class="el-p"><p dir="auto">(<em> At the call site </em>)<br>
module M1 = MakeApply<br>
[T] (X)<br>
[Hashtbl.HashedType] (F)<br>
[Hashtbl.S] (Hashtbl)</p></div><div class="el-p"><p dir="auto">module M2 = ApplyGv [A] [B] (F) (X)</p></div><div class="el-p"><p dir="auto">Technically, this is not just syntactic sugar for anonymous parameters due to the fact that OCaml relies on names for applicativity of functors.</p></div></div></div><div class="el-h6 heading-wrapper"><h6 data-heading="Inference" dir="auto" class="heading" id="Inference"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Inference</h6><div class="heading-children"><div class="el-p"><p dir="auto">Following up on the previous point, usability of abstract signatures could even be improved with some form of inference at call sites. Further work is needed to understand to what extend this could be done.</p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="Conclusion" dir="auto" class="heading" id="Conclusion"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Conclusion</h4><div class="heading-children"><div class="el-p"><p dir="auto">We have presented the feature of <em>abstract signatures</em> in OCaml. After showing use cases via examples, we explained the issues associated with the unrestricted syntactical approach. Then, we propose a new specification: <em>simple abstract signatures</em>. In addition to making the behavior of abstract signatures much more predictable for the user, this approach can be fully formalized by translation into Fω (extended with predicative kinds).</p></div><div class="el-p"><p dir="auto">As stated above, our goal here was both to sum up the current state and our proposal, but also to gather feedback from users or potential users. In particular, we want to see if it can indeed cover all use cases, and if we missed other usability problems.</p></div><div class="mod-footer mod-ui"></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="computer-science/programming-language/ocaml/rethinking-ocaml-abstract-signatures.html#Rethinking OCaml abstract signatures"><div class="tree-item-contents heading-link" heading-name="Rethinking OCaml abstract signatures"><span class="tree-item-title">Rethinking OCaml abstract signatures</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="computer-science/programming-language/ocaml/rethinking-ocaml-abstract-signatures.html#1._What_are_abstract_signatures_?"><div class="tree-item-contents heading-link" heading-name="1. What are abstract signatures ?"><span class="tree-item-title">1. 
What are abstract signatures ?
</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="computer-science/programming-language/ocaml/rethinking-ocaml-abstract-signatures.html#1.1_Module-level_sealing"><div class="tree-item-contents heading-link" heading-name="1.1 Module-level sealing"><span class="tree-item-title">1.1 Module-level sealing</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="computer-science/programming-language/ocaml/rethinking-ocaml-abstract-signatures.html#1.2_Module-level_polymorphism"><div class="tree-item-contents heading-link" heading-name="1.2 Module-level polymorphism"><span class="tree-item-title">1.2 Module-level polymorphism</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="computer-science/programming-language/ocaml/rethinking-ocaml-abstract-signatures.html#1.3_So_it’s_just_normal_use_cases_of_abstraction_?"><div class="tree-item-contents heading-link" heading-name="1.3 So it’s just normal use cases of abstraction ?"><span class="tree-item-title">1.3 So it’s just normal use cases of abstraction ?</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="computer-science/programming-language/ocaml/rethinking-ocaml-abstract-signatures.html#2._OCaml’_abstract_signatures,_an_incidental_feature_?"><div class="tree-item-contents heading-link" heading-name="2. OCaml’ abstract signatures, an incidental feature ?"><span class="tree-item-title">2. 
OCaml’ abstract signatures, an incidental feature ?
</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="computer-science/programming-language/ocaml/rethinking-ocaml-abstract-signatures.html#2.1_Syntactical_rewriting"><div class="tree-item-contents heading-link" heading-name="2.1 Syntactical rewriting"><span class="tree-item-title">2.1 Syntactical rewriting</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="computer-science/programming-language/ocaml/rethinking-ocaml-abstract-signatures.html#2.2_`Type_:_Type`_and_impredicativity"><div class="tree-item-contents heading-link" heading-name="2.2 `Type : Type` and impredicativity"><span class="tree-item-title">2.2 <code>Type : Type</code> and impredicativity</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="computer-science/programming-language/ocaml/rethinking-ocaml-abstract-signatures.html#2.3_Other_issues"><div class="tree-item-contents heading-link" heading-name="2.3 Other issues"><span class="tree-item-title">2.3 Other issues</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="6"><a class="tree-link" href="computer-science/programming-language/ocaml/rethinking-ocaml-abstract-signatures.html#2.3.1_Invalid_module_aliases"><div class="tree-item-contents heading-link" heading-name="2.3.1 Invalid module aliases"><span class="tree-item-title">2.3.1 Invalid module aliases</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="6"><a class="tree-link" href="computer-science/programming-language/ocaml/rethinking-ocaml-abstract-signatures.html#2.3.2_Loss_of_applicativity"><div class="tree-item-contents heading-link" heading-name="2.3.2 Loss of applicativity"><span class="tree-item-title">2.3.2 Loss of applicativity</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="6"><a class="tree-link" href="computer-science/programming-language/ocaml/rethinking-ocaml-abstract-signatures.html#2.3.3_Invalid_signatures_and_avoidance"><div class="tree-item-contents heading-link" heading-name="2.3.3 Invalid signatures and avoidance"><span class="tree-item-title">2.3.3 Invalid signatures and avoidance</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="computer-science/programming-language/ocaml/rethinking-ocaml-abstract-signatures.html#3._A_solution:_simple_abstract_signatures"><div class="tree-item-contents heading-link" heading-name="3. A solution: simple abstract signatures"><span class="tree-item-title">3. 
A solution: simple abstract signatures
</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="computer-science/programming-language/ocaml/rethinking-ocaml-abstract-signatures.html#3.1_No_abstraction"><div class="tree-item-contents heading-link" heading-name="3.1 No abstraction"><span class="tree-item-title">3.1 No abstraction</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="computer-science/programming-language/ocaml/rethinking-ocaml-abstract-signatures.html#3.2_The_issue_of_module-level_sharing"><div class="tree-item-contents heading-link" heading-name="3.2 The issue of module-level sharing"><span class="tree-item-title">3.2 The issue of module-level sharing</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="6"><a class="tree-link" href="computer-science/programming-language/ocaml/rethinking-ocaml-abstract-signatures.html#Lazy_strengthening"><div class="tree-item-contents heading-link" heading-name="Lazy strengthening"><span class="tree-item-title">Lazy strengthening</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="6"><a class="tree-link" href="computer-science/programming-language/ocaml/rethinking-ocaml-abstract-signatures.html#Transparent_ascription"><div class="tree-item-contents heading-link" heading-name="Transparent ascription"><span class="tree-item-title">Transparent ascription</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="computer-science/programming-language/ocaml/rethinking-ocaml-abstract-signatures.html#3.3_Our_proposal_:__simple__abstract_signatures"><div class="tree-item-contents heading-link" heading-name="3.3 Our proposal : _simple_ abstract signatures"><span class="tree-item-title">3.3 Our proposal : <em>simple</em> abstract signatures</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="6"><a class="tree-link" href="computer-science/programming-language/ocaml/rethinking-ocaml-abstract-signatures.html#Expressivity_(and_prenex-form)"><div class="tree-item-contents heading-link" heading-name="Expressivity (and prenex-form)"><span class="tree-item-title">Expressivity (and prenex-form)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="6"><a class="tree-link" href="computer-science/programming-language/ocaml/rethinking-ocaml-abstract-signatures.html#Higher-abstraction_?"><div class="tree-item-contents heading-link" heading-name="Higher-abstraction ?"><span class="tree-item-title">Higher-abstraction ?</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="computer-science/programming-language/ocaml/rethinking-ocaml-abstract-signatures.html#4._Other_practical_aspects"><div class="tree-item-contents heading-link" heading-name="4. Other practical aspects"><span class="tree-item-title">4. 
Other practical aspects
</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="6"><a class="tree-link" href="computer-science/programming-language/ocaml/rethinking-ocaml-abstract-signatures.html#Syntax"><div class="tree-item-contents heading-link" heading-name="Syntax"><span class="tree-item-title">Syntax</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="6"><a class="tree-link" href="computer-science/programming-language/ocaml/rethinking-ocaml-abstract-signatures.html#Inference"><div class="tree-item-contents heading-link" heading-name="Inference"><span class="tree-item-title">Inference</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="computer-science/programming-language/ocaml/rethinking-ocaml-abstract-signatures.html#Conclusion"><div class="tree-item-contents heading-link" heading-name="Conclusion"><span class="tree-item-title">Conclusion</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>