<!DOCTYPE html> <html><head>
		<title>Scopes and effect handlers</title>
		<base href="../../../">
		<meta id="root-path" root-path="../../../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="韩暮秋的个人维基 - Scopes and effect handlers">
		<meta property="og:title" content="Scopes and effect handlers">
		<meta property="og:description" content="韩暮秋的个人维基 - Scopes and effect handlers">
		<meta property="og:type" content="website">
		<meta property="og:url" content="https://muqiuhan.github.io/wiki/computer-science/programming-language/ocaml/scopes-and-effect-handlers.html">
		<meta property="og:image" content="undefined">
		<meta property="og:site_name" content="韩暮秋的个人维基">
		<meta name="author" content="韩暮秋"><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="https://muqiuhan.github.io/wiki/lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="lib/scripts/pixi.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="lib/scripts/minisearch.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="preload" href="lib/styles/other-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/other-plugins.css"></noscript><link rel="stylesheet" href="lib/styles/theme.css"><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/supported-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/supported-plugins.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript></head><body class="publish css-settings-manager theme-light show-inline-title show-ribbon outliner-plugin-dnd custom-accent ribbon-default special-h6 float-center"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles">mjx-munder{display:inline-block;text-align:left}mjx-over{text-align:left}mjx-munder:not([limits=false]){display:inline-table}mjx-munder>mjx-row{text-align:left}mjx-under{padding-bottom:.1em}mjx-msub{display:inline-block;text-align:left}mjx-c.mjx-c1D436.TEX-I::before{padding:.705em .76em .022em 0;content:"C"}mjx-c.mjx-c3D::before{padding:.583em .778em .082em 0;content:"="}mjx-c.mjx-c2211.TEX-S2::before{padding:.95em 1.444em .45em 0;content:"∑"}mjx-c.mjx-c1D45D.TEX-I::before{padding:.442em .503em .194em 0;content:"p"}mjx-c.mjx-c1D461.TEX-I::before{padding:.626em .361em .011em 0;content:"t"}mjx-mtext{display:inline-block;text-align:left}mjx-container[jax=CHTML]{line-height:0}mjx-container [space="1"]{margin-left:.111em}mjx-container [space="2"]{margin-left:.167em}mjx-container [space="3"]{margin-left:.222em}mjx-container [space="4"]{margin-left:.278em}mjx-container [space="5"]{margin-left:.333em}mjx-container [rspace="1"]{margin-right:.111em}mjx-container [rspace="2"]{margin-right:.167em}mjx-container [rspace="3"]{margin-right:.222em}mjx-container [rspace="4"]{margin-right:.278em}mjx-container [rspace="5"]{margin-right:.333em}mjx-container [size="s"]{font-size:70.7%}mjx-container [size=ss]{font-size:50%}mjx-container [size=Tn]{font-size:60%}mjx-container [size=sm]{font-size:85%}mjx-container [size=lg]{font-size:120%}mjx-container [size=Lg]{font-size:144%}mjx-container [size=LG]{font-size:173%}mjx-container [size=hg]{font-size:207%}mjx-container [size=HG]{font-size:249%}mjx-container [width=full]{width:100%}mjx-box{display:inline-block}mjx-block{display:block}mjx-itable{display:inline-table}mjx-row{display:table-row}mjx-row>*{display:table-cell}mjx-mtext{display:inline-block}mjx-mstyle{display:inline-block}mjx-merror{display:inline-block;color:red;background-color:#ff0}mjx-mphantom{visibility:hidden}mjx-assistive-mml{top:0;left:0;clip:rect(1px,1px,1px,1px);user-select:none;position:absolute!important;padding:1px 0 0!important;border:0!important;display:block!important;width:auto!important;overflow:hidden!important}mjx-assistive-mml[display=block]{width:100%!important}mjx-math{display:inline-block;text-align:left;line-height:0;text-indent:0;font-style:normal;font-weight:400;font-size:100%;font-size-adjust:none;letter-spacing:normal;border-collapse:collapse;overflow-wrap:normal;word-spacing:normal;white-space:nowrap;direction:ltr;padding:1px 0}mjx-container[jax=CHTML][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=CHTML][display=true][width=full]{display:flex}mjx-container[jax=CHTML][display=true] mjx-math{padding:0}mjx-container[jax=CHTML][justify=left]{text-align:left}mjx-container[jax=CHTML][justify=right]{text-align:right}mjx-msup{display:inline-block;text-align:left}mjx-mi{display:inline-block;text-align:left}mjx-c{display:inline-block}mjx-utext{display:inline-block;padding:.75em 0 .2em}mjx-texatom{display:inline-block;text-align:left}mjx-mo{display:inline-block;text-align:left}mjx-stretchy-h{display:inline-table;width:100%}mjx-stretchy-h>*{display:table-cell;width:0}mjx-stretchy-h>*>mjx-c{display:inline-block;transform:scaleX(1)}mjx-stretchy-h>*>mjx-c::before{display:inline-block;width:initial}mjx-stretchy-h>mjx-ext{overflow:clip visible;width:100%}mjx-stretchy-h>mjx-ext>mjx-c::before{transform:scaleX(500)}mjx-stretchy-h>mjx-ext>mjx-c{width:0}mjx-stretchy-h>mjx-beg>mjx-c{margin-right:-.1em}mjx-stretchy-h>mjx-end>mjx-c{margin-left:-.1em}mjx-stretchy-v{display:inline-block}mjx-stretchy-v>*{display:block}mjx-stretchy-v>mjx-beg{height:0}mjx-stretchy-v>mjx-end>mjx-c{display:block}mjx-stretchy-v>*>mjx-c{transform:scaleY(1);transform-origin:left center;overflow:hidden}mjx-stretchy-v>mjx-ext{display:block;height:100%;box-sizing:border-box;border:0 solid transparent;overflow:visible clip}mjx-stretchy-v>mjx-ext>mjx-c::before{width:initial;box-sizing:border-box}mjx-stretchy-v>mjx-ext>mjx-c{transform:scaleY(500) translateY(.075em);overflow:visible}mjx-mark{display:inline-block;height:0}mjx-c::before{display:block;width:0}.MJX-TEX{font-family:MJXZERO,MJXTEX}.TEX-B{font-family:MJXZERO,MJXTEX-B}.TEX-I{font-family:MJXZERO,MJXTEX-I}.TEX-MI{font-family:MJXZERO,MJXTEX-MI}.TEX-BI{font-family:MJXZERO,MJXTEX-BI}.TEX-S1{font-family:MJXZERO,MJXTEX-S1}.TEX-S2{font-family:MJXZERO,MJXTEX-S2}.TEX-S3{font-family:MJXZERO,MJXTEX-S3}.TEX-S4{font-family:MJXZERO,MJXTEX-S4}.TEX-A{font-family:MJXZERO,MJXTEX-A}.TEX-C{font-family:MJXZERO,MJXTEX-C}.TEX-CB{font-family:MJXZERO,MJXTEX-CB}.TEX-FR{font-family:MJXZERO,MJXTEX-FR}.TEX-FRB{font-family:MJXZERO,MJXTEX-FRB}.TEX-SS{font-family:MJXZERO,MJXTEX-SS}.TEX-SSB{font-family:MJXZERO,MJXTEX-SSB}.TEX-SSI{font-family:MJXZERO,MJXTEX-SSI}.TEX-SC{font-family:MJXZERO,MJXTEX-SC}.TEX-T{font-family:MJXZERO,MJXTEX-T}.TEX-V{font-family:MJXZERO,MJXTEX-V}.TEX-VB{font-family:MJXZERO,MJXTEX-VB}mjx-stretchy-h mjx-c,mjx-stretchy-v mjx-c{font-family:MJXZERO,MJXTEX-S1,MJXTEX-S4,MJXTEX,MJXTEX-A!important}@font-face{font-family:MJXZERO;src:url("lib/fonts/mathjax_zero.woff") format("woff")}@font-face{font-family:MJXTEX;src:url("lib/fonts/mathjax_main-regular.woff") format("woff")}@font-face{font-family:MJXTEX-B;src:url("lib/fonts/mathjax_main-bold.woff") format("woff")}@font-face{font-family:MJXTEX-I;src:url("lib/fonts/mathjax_math-italic.woff") format("woff")}@font-face{font-family:MJXTEX-MI;src:url("lib/fonts/mathjax_main-italic.woff") format("woff")}@font-face{font-family:MJXTEX-BI;src:url("lib/fonts/mathjax_math-bolditalic.woff") format("woff")}@font-face{font-family:MJXTEX-S1;src:url("lib/fonts/mathjax_size1-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S2;src:url("lib/fonts/mathjax_size2-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S3;src:url("lib/fonts/mathjax_size3-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S4;src:url("lib/fonts/mathjax_size4-regular.woff") format("woff")}@font-face{font-family:MJXTEX-A;src:url("lib/fonts/mathjax_ams-regular.woff") format("woff")}@font-face{font-family:MJXTEX-C;src:url("lib/fonts/mathjax_calligraphic-regular.woff") format("woff")}@font-face{font-family:MJXTEX-CB;src:url("lib/fonts/mathjax_calligraphic-bold.woff") format("woff")}@font-face{font-family:MJXTEX-FR;src:url("lib/fonts/mathjax_fraktur-regular.woff") format("woff")}@font-face{font-family:MJXTEX-FRB;src:url("lib/fonts/mathjax_fraktur-bold.woff") format("woff")}@font-face{font-family:MJXTEX-SS;src:url("lib/fonts/mathjax_sansserif-regular.woff") format("woff")}@font-face{font-family:MJXTEX-SSB;src:url("lib/fonts/mathjax_sansserif-bold.woff") format("woff")}@font-face{font-family:MJXTEX-SSI;src:url("lib/fonts/mathjax_sansserif-italic.woff") format("woff")}@font-face{font-family:MJXTEX-SC;src:url("lib/fonts/mathjax_script-regular.woff") format("woff")}@font-face{font-family:MJXTEX-T;src:url("lib/fonts/mathjax_typewriter-regular.woff") format("woff")}@font-face{font-family:MJXTEX-V;src:url("lib/fonts/mathjax_vector-regular.woff") format("woff")}@font-face{font-family:MJXTEX-VB;src:url("lib/fonts/mathjax_vector-bold.woff") format("woff")}mjx-c.mjx-c1D447.TEX-I::before{padding:.677em .704em 0 0;content:"T"}mjx-c.mjx-c1D450.TEX-I::before{padding:.442em .433em .011em 0;content:"c"}mjx-c.mjx-c2C::before{padding:.121em .278em .194em 0;content:","}mjx-c.mjx-c2E::before{padding:.12em .278em 0 0;content:"."}</style><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="Scopes and effect handlers"><p dir="auto">Scopes and effect handlers</p></h1><div class="el-p"><p dir="auto"><a href="?query=tag:ocaml" class="tag" target="_blank" rel="noopener nofollow">#ocaml</a> <a href="?query=tag:fp" class="tag" target="_blank" rel="noopener nofollow">#fp</a> </p></div><div class="el-p"><p dir="auto">This document was written because I learned something surprisingly obvious about effect handlers. It may help others since I haven't seen this blind spot discussed before.</p></div><div class="el-p"><p dir="auto">While this begins with a quick introduction to effects, I am going to skip on a lot of details so you should get your hands dirty if you are not already familiar with the topic. It's really fun and if you want to follow along, this local environment works perfectly:</p></div><div class="el-p"><p dir="auto">$ mkdir effects &amp;&amp; cd effects<br>
effects/ $ opam switch create '.' 'ocaml-variants.4.12.0+domains+effects'<br>
effects/ $ eval $(opam env)</p></div><div class="el-p"><p dir="auto">The effect system makes good use of advanced OCaml features, so I will try to explain them as we go. You may want to read <a rel="noopener nofollow" class="external-link" href="https://github.com/ocamllabs/ocaml-effects-tutorial" target="_blank">https://github.com/ocamllabs/ocaml-effects-tutorial</a> as a better introduction and <a rel="noopener nofollow" class="external-link" href="https://github.com/ocaml-multicore/effects-examples" target="_blank">https://github.com/ocaml-multicore/effects-examples</a> to get hyped. You can also try eio from this local switch.</p></div><div class="el-p"><p dir="auto">But if you are already familiar with those topics, then the trickery is near the end!</p></div><div class="el-p"><p dir="auto">Let's begin! When playing with "pure" effects, you will see this weird pattern a lot: A match within parenthesis, where each case produces a lambda. The initial arguments of the lambda are given at the very end after the parenthesis. Each continue expects to receive the arguments of the lambda and is an opportunity to update them.</p></div><div class="el-p"><p dir="auto">( match ... with<br>
| result -&gt; (<em> executed last </em>)<br>
(fun _xN _yN -&gt; result)</p></div><div class="el-p"><p dir="auto">  | effect (E ...) k -&gt; (<em> in the middle </em>)<br>
(fun x1 y1 -&gt;<br>
...<br>
continue k (response)  x2 y2<br>
...)<br>
)<br>
x0  (<em> initial state </em>)<br>
y0</p></div><div class="el-p"><p dir="auto">As you can see, the flow is a bit reversed but you will get used to it very fast in practice.</p></div><div class="el-p"><p dir="auto">Performing an effect is a lot like raising an exception: The corresponding case in the match will receive the argument of perform and a continuation k.</p></div><div class="el-pre"><pre><code data-line="0">If you ignore k, then the effect behaves exactly like a standard exception.
But you can also call continue k with an argument, in which case the original perform will evaluate to that argument and the program will continue as if the effect never happened.
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">The only catch is that you can only continue the continuation once.</p></div><div class="el-p"><p dir="auto">As a simple example, let's implement a "counter" effect. Each time we perform the Incr effect, we will receive the next natural number:</p></div><div class="el-p"><p dir="auto">effect Incr : int</p></div><div class="el-p"><p dir="auto">let with<em>counter fn =<br>
(match fn () with<br>
| result -&gt;<br>
(fun </em> -&gt; result)</p></div><div class="el-p"><p dir="auto">   | effect Incr k -&gt;<br>
(fun (counter : int) -&gt; continue k counter (counter + 1))<br>
)<br>
0</p></div><div class="el-p"><p dir="auto">The with_counter takes a function as argument and calls it within the match ... with. This ensures that effects performed by fn will be caught and handled.</p></div><div class="el-p"><p dir="auto">Notice how the continue takes both counter and counter + 1? The first one is the response, while the second is updating our counter state for the next time. The initial state of the counter is 0, provided on the very last line.</p></div><div class="el-p"><p dir="auto">Once this function is defined, you can use it as follow: We first set up the with_counter handler, then each perform Incr triggers this effect handler and receive the new value of the counter.</p></div><div class="el-p"><p dir="auto">with_counter (fun () -&gt;<br>
Printf.printf "%i\n" (perform Incr) ; (<em> 0 </em>)<br>
Printf.printf "%i\n" (perform Incr) ; (<em> 1 </em>)<br>
Printf.printf "%i\n" (perform Incr) ; (<em> 2 </em>)<br>
Printf.printf "%i\n" (perform Incr) ; (<em> 3 </em>)<br>
)</p></div><div class="el-p"><p dir="auto">If we forget to wrap this code within with_counter, then we will get an Unhandled exception!</p></div><div class="el-pre"><pre><code data-line="0">Side note: In OCaml there are two cute syntaxes when you have a function that takes a function as a last argument. The most common is the application (@@) operator:

with_counter @@ fun () -&gt;
Printf.printf "%i\n" (perform Incr) ; (* 0 *)
Printf.printf "%i\n" (perform Incr) ; (* 1 *)

But you can also define the ( let@ ) syntax notation:

let ( let@ ) f x = f x ;;

let@ () = with_counter in
Printf.printf "counter = %i\n" (perform Incr) ; (* 0 *)
Printf.printf "counter = %i\n" (perform Incr) ; (* 1 *)

Both can drastically reduce indentation and help clarify your code!
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">Back to effects: If we use multiple with_counter in our code, each one will start from 0 and if we nest them, it's always the nearest one that will handle the Incr effect:</p></div><div class="el-p"><p dir="auto">with_counter (fun () -&gt;<br>
Printf.printf "counter = %i\n" (perform Incr) ;  (<em> 0 </em>)<br>
Printf.printf "counter = %i\n" (perform Incr) ;  (<em> 1 </em>)<br>
with_counter (fun () -&gt;<br>
Printf.printf "nested = %i\n" (perform Incr) ; (<em> 0 </em>)<br>
(<em> we can't ask the outer counter from here </em>)<br>
) ;<br>
Printf.printf "counter = %i\n" (perform Incr) ;  (<em> 2 </em>)<br>
)</p></div><div class="el-p"><p dir="auto">How could we reach the outer counter from the nested one? The question is a bit weird because something is missing: We have no way of telling the system that we want to perform this operation. We would need some way of "naming" which counter we want to increment… such that we could write this code:</p></div><div class="el-p"><p dir="auto">with_counter (fun x -&gt;<br>
Printf.printf "x = %i\n" (x ()) ; (<em> 0 </em>)<br>
Printf.printf "x = %i\n" (x ()) ; (<em> 1 </em>)<br>
with_counter (fun y -&gt;<br>
Printf.printf "y = %i\n" (y ()) ; (<em> 0 </em>)<br>
(<em> we can now ask the outer counter! </em>)<br>
Printf.printf "x = %i\n" (x ()) ; (<em> 2 </em>)<br>
) ;<br>
Printf.printf "x = %i\n" (x ()) ; (<em> 3 </em>)<br>
)</p></div><div class="el-p"><p dir="auto">Let's implement this new with_counter. It's exactly the same code as before, but with a twist: We don't use the global Incr effect anymore, but rather we create a new local effect specific to each counter.</p></div><div class="el-p"><p dir="auto">let with<em>counter fn =<br>
let open struct<br>
effect Local_incr : int<br>
end in<br>
(match fn (fun () -&gt; perform Local_incr) with<br>
| result -&gt;<br>
(fun </em> -&gt; result)</p></div><div class="el-p"><p dir="auto">   | effect Local_incr k -&gt;<br>
(fun (counter : int) -&gt; continue k counter (counter + 1))<br>
)<br>
0</p></div><div class="el-p"><p dir="auto">The let open struct ... end in syntax allow us to dynamically create new types, exceptions, and effects, that will only be available locally. We pass the counter as (fun () -&gt; perform Local_incr) to the user function fn and handle its effects as before. When the user calls x (), it performs the corresponding Local_incr for which there is only one handler available… so there's no confusion as to which counter should be incremented.</p></div><div class="el-p"><p dir="auto">This might not be entirely obvious: when we create multiple counters, we define multiple Local_incr effects that have the same "name" in the code, but at runtime each one will be unique. We setup one effect handler for each of our counter, but since they match on different effects, they can't intercept messages intended to another.</p></div><div class="el-p"><p dir="auto">If all of this makes sense, let's move on to implementing references. This isn't so different from the counter example, since both allow us to query and update state. The big difficulty is that references are not limited to storing int values.. we want them to be polymorphic.</p></div><div class="el-p"><p dir="auto">Here is an example usage, showing that we can create references for different types of values:</p></div><div class="el-p"><p dir="auto">let@ x = with_eref 42 in<br>
let@ y = with_eref "hello" in<br>
Printf.printf "x = %i, y = %S\n" (x.get ()) (y.get ()) ;  (<em>  42, "hello" </em>)<br>
x.put 666 ;<br>
Printf.printf "x = %i, y = %S\n" (x.get ()) (y.get ()) ;  (<em> 666, "hello" </em>)<br>
y.put "bye" ;<br>
Printf.printf "x = %i, y = %S\n" (x.get ()) (y.get ()) ;  (<em> 666, "bye" </em>)</p></div><div class="el-p"><p dir="auto">Once again, we will hide the actual effects from the user: This time there are two operations get and put, so we package them in a record:</p></div><div class="el-p"><p dir="auto">type 'a eref = (<em> the type of an effectful reference holding an ['a] value </em>)<br>
{ get : unit -&gt; 'a<br>
; put : 'a -&gt; unit<br>
}</p></div><div class="el-p"><p dir="auto">The effect handler uses the same trick of locally defined effects as the counter and the code is very similar:</p></div><div class="el-p"><p dir="auto">let with_eref<br>
: type a.  a -&gt; (a eref -&gt; 'b) -&gt; 'b<br>
= fun initial_value fn -&gt;</p></div><div class="el-p"><p dir="auto">  (<em> local effects for this ['a] reference </em>)<br>
let open struct<br>
effect Get : a<br>
effect Put : a -&gt; unit<br>
end in</p></div><div class="el-p"><p dir="auto">  (<em> hide the details from the user </em>)<br>
let eref =<br>
{ get = (fun () -&gt; perform Get)<br>
; put = (fun v -&gt; perform (Put v))<br>
}<br>
in</p></div><div class="el-p"><p dir="auto">  (match fn eref with<br>
| x -&gt;<br>
(fun _ -&gt; x)</p></div><div class="el-p"><p dir="auto">  | effect Get k -&gt;<br>
(fun (current_value : a) -&gt; continue k current_value current_value)</p></div><div class="el-p"><p dir="auto">  | effect (Put new<em>value) k -&gt;<br>
(fun </em> -&gt; continue k () new_value)</p></div><div class="el-p"><p dir="auto">  ) initial_value</p></div><div class="el-p"><p dir="auto">The last lines are pretty important since they define the semantic of our references, but there is nothing new here.</p></div><div class="el-p"><p dir="auto">The main difficulty is convincing the typechecker that references can hold different types of values. It happens on the second line where we specify the type of with_eref:</p></div><div class="el-p"><p dir="auto">let with_eref<br>
: type a.  a -&gt; (a eref -&gt; 'b) -&gt; 'b</p></div><div class="el-p"><p dir="auto">The type a. notation is explicitly introducing the polymorphic type variable a (when we would normally use 'a). Most importantly, this notation binds the type variable a for the rest of the code, so we are able to define local effects that depend on it:</p></div><div class="el-p"><p dir="auto">let open struct<br>
effect Get : a<br>
effect Put : a -&gt; unit<br>
end in</p></div><div class="el-p"><p dir="auto">(You might want to try removing type a and using 'a instead to see the difference!)</p></div><div class="el-pre"><pre><code data-line="0">Side note: There's an alternative notation for binding type variables if we don't want to spell out the full type of the function with_eref, but it comes with a lot of gotchas so I don't recommend it:

let with_eref (type a) fn = ...
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">It's very impressive how algebraic effects are able to benefit from advanced features of OCaml that were not created for them!</p></div><div class="el-p"><p dir="auto">While I hope this introduction was clear… I must now reveal that those examples are actually a really bad use of algebraic effects.</p></div><div class="el-p"><p dir="auto">The counters and references might have given you the wrong idea about algrebraic effects: They are not a real replacement for impure mutable side effects! In fact, they come with a very strong limitation when compared to the standard references of OCaml.</p></div><div class="el-p"><p dir="auto">Remember the Unhandled exception when we try to perform an effect without first setting up a handler?</p></div><div class="el-p"><p dir="auto">let escape = with_eref 42 (fun r -&gt; r) in<br>
escape.put 666</p></div><div class="el-p"><p dir="auto">The effectful reference is created by with_eref… but then it escapes its effect handler. When we then try to update the eref, the Put 666 effect is not handled by anyone and crashes the program.</p></div><div class="el-p"><p dir="auto">In other words, the "pure" references are only usable from within the scope of their handler. A standard OCaml ref on the other hand will always be available… until it is collected by the GC, but at this point if was already clear that it wasn't going to be used again.</p></div><div class="el-p"><p dir="auto">The typesystem can't yet protect us from performing effects outside their handler, so you have to be careful. You might think that it's pretty easy to visually check that escape.get () only happens within the with_eref, but that's exactly why I'm writing this document. It's not!</p></div><div class="el-p"><p dir="auto">In the mean time, the use of algebraic effects to simulate impure references kind of misses the point. Effects are a lot more useful for scripting control flow rather than value flow. Typically, this will involve changing the normal execution of our programs to create enumerators, coroutines, async/await, green thread, etc, as libraries. And it's going to be insanely cool!</p></div><div class="el-p"><p dir="auto">This article is already too long to present a real scheduler as a more interesting use of algebraic effects. But we can cheat and create a really crappy one!</p></div><div class="el-p"><p dir="auto">effect Spawn : (unit -&gt; unit) -&gt; unit</p></div><div class="el-p"><p dir="auto">The Spawn (fun () -&gt; ...) effect is intended to create a new thread of execution that will execute concurrently with the rest of our code:</p></div><div class="el-p"><p dir="auto">let spawn f = perform (Spawn f) ;;</p></div><div class="el-p"><p dir="auto">spawn (fun () -&gt; sleep 60 ; print_endline "A") ;<br>
spawn (fun () -&gt; print_endline "B") ;</p></div><div class="el-p"><p dir="auto">But since we won't do a real scheduler, we'll just evaluate the spawned thread right away before moving on:</p></div><div class="el-p"><p dir="auto">let with_spawn fn =<br>
match fn () with<br>
| v -&gt; v<br>
| effect (Spawn child) k -&gt;<br>
child () ;<br>
continue k ()</p></div><div class="el-p"><p dir="auto">(A real implementation would store the spawned child somewhere, to evaluate it later, with an additional Yield effect to cooperatively switch between threads…)</p></div><div class="el-p"><p dir="auto">It may not be obvious, but even this simple handler has a small bug: A spawned child can't itself perform a Spawn effect! That's easy enough to fix:</p></div><div class="el-p"><p dir="auto">let rec with_spawn fn =<br>
match fn () with<br>
| v -&gt; v<br>
| effect (Spawn child) k -&gt;<br>
with_spawn child ;<br>
continue k ()</p></div><div class="el-p"><p dir="auto">Now let's see how this works with the effectful references we defined before. We are not doing anything fancy, so it's easy to see that the following spawn will execute before we try printing the value of the reference:</p></div><div class="el-p"><p dir="auto">with_spawn @@ fun () -&gt;<br>
with_eref 42 @@ fun x -&gt;<br>
spawn (fun () -&gt; x.put 666) ;<br>
Printf.printf "x = %i\n" (x.get ()) (<em> 666 or 42? </em>)</p></div><div class="el-p"><p dir="auto">Clearly, this should give us 666 right? Well… The function (fun () -&gt; x.put 666) will be executed by the with_spawn handler, outside of the with_eref handler! As a result, its Put 666 effect will not be handled by anyone and will crash with an Unhandled exception. The fact that the function (fun () -&gt; x.put 666) is defined inside the with_eref doesn't matter at all since we performed a spawn effect to evaluate it in the scheduler (1).</p></div><div class="el-p"><p dir="auto">The correct order of effect handlers should be reversed:</p></div><div class="el-p"><p dir="auto">with_eref 42 @@ fun x -&gt;<br>
with_spawn @@ fun () -&gt;<br>
spawn (fun () -&gt; x.put 666) ;<br>
Printf.printf "x = %i\n" (x.get ())</p></div><div class="el-p"><p dir="auto">But that's just weird: we would normally setup the scheduler at the beginning of our main function, then setup the local effect handlers for the shorter lived effects like references.</p></div><div class="el-p"><p dir="auto">And what would be the fix when there's a dynamic number of references? While the following code isn't great with a real scheduler because we don't wait for the threads to terminate before reading their outcome, that's not the reason why it doesn't work here:</p></div><div class="el-p"><p dir="auto">with_spawn @@ fun () -&gt;</p></div><div class="el-p"><p dir="auto">  let rec parmap f acc = function<br>
| [] -&gt;<br>
List.map (fun r -&gt; r.get ()) acc</p></div><div class="el-pre"><pre><code data-line="0">| x::xs -&gt;
    let@ r = with_eref None in
    spawn (fun () -&gt; r.put (Some (f x))) ; (* Unhandled! *)
    parmap f (r :: acc) xs
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">  in<br>
parmap (fun x -&gt; x * x) [1;2;3]</p></div><div class="el-p"><p dir="auto">I want to state again that this is a self-injured issue, the problem doesn't exist with real references.</p></div><div class="el-p"><p dir="auto">But it is however a control flow issue! The with_eref are not executed at the right time during the lifetime of the program… And we can solve this with more effects!</p></div><div class="el-p"><p dir="auto">type 'a cc = { cc : 'b. (('b -&gt; 'a) -&gt; 'a) -&gt; 'b }</p></div><div class="el-p"><p dir="auto">let with_scope (type a) fn =<br>
let open struct<br>
effect Lift : (('b -&gt; a) -&gt; a) -&gt; 'b<br>
end in<br>
match fn { cc = fun s -&gt; perform (Lift s) } with<br>
| v -&gt; v<br>
| effect (Lift s) k -&gt; s (fun x -&gt; continue k x)</p></div><div class="el-p"><p dir="auto">This combines a bit of everything we saw before, and even adds an explicit forall with the type cc. The type trickery is required to maximize the usefulness of this handler, as otherwise the type would be too restrictive for some programs (2).</p></div><div class="el-p"><p dir="auto">This is dark magic from scheme sorcerers, so it's easier to understand what's going on by looking at its usage. The with_scope allow us to add dynamic effect handlers around the scheduler:</p></div><div class="el-p"><p dir="auto">with_scope @@ fun lift -&gt;<br>
with_spawn @@ fun () -&gt;</p></div><div class="el-p"><p dir="auto">  let x =<br>
lift.cc @@ fun return -&gt;<br>
with_eref 42 @@ fun r -&gt; return r<br>
in</p></div><div class="el-p"><p dir="auto">  spawn (fun () -&gt; x.put 666) ; (<em> works! </em>)</p></div><div class="el-p"><p dir="auto">  Printf.printf "x = %i\n" (x.get ()) (<em> 666 </em>)</p></div><div class="el-p"><p dir="auto">The lift.cc will apply the with_eref effect handler at the position of the with_scope, at which point execution will continue normally. When the scheduler executes the spawned function, it does so at the position of the with_spawn… so our reference effects will work correctly since the with_eref was lifted just above!</p></div><div class="el-p"><p dir="auto">So even though it looks like we are using the reference x outside the scope of its with_eref, it actually became globally available. This lifting isn't free however: Even if the variable x can be reclaimed at some point, its referenced value and its effect handler will be held until we exit with_scope.</p></div><div class="el-p"><p dir="auto">In conclusion, you can clearly do some insane stuff with effects!.. But it wasn't obvious to me that it would be so hard to tell when an effect handler is in scope.</p></div><div class="el-p"><p dir="auto">(1) Here's a minimal example of escaping the scope of an event handler. The continuation of A doesn't capture the B effect handler, so its evaluation from C triggers an Unhandled exception:</p></div><div class="el-p"><p dir="auto">effect A : unit<br>
effect B : unit<br>
effect C : (unit, unit) continuation -&gt; unit eff</p></div><div class="el-p"><p dir="auto">let () =<br>
match<br>
match<br>
match perform A ; perform B with<br>
| () -&gt; ()<br>
| effect A k -&gt; perform (C k)<br>
with<br>
| () -&gt; ()<br>
| effect B k -&gt; continue k ()<br>
with<br>
| () -&gt; ()<br>
| effect (C child) k -&gt;<br>
continue child () ; (<em> Unhandled B! </em>)<br>
continue k ()</p></div><div class="el-p"><p dir="auto">this is not a bug with effects, but a feature! they are really one-shot delimited continuation, so keeping the b handler in scope would require duplicating the stack.</p></div><div class="el-p"><p dir="auto">(2) if you add the creation of another reference with a different type, you will quickly discover why we need the forall in cc:</p></div><div class="el-pre"><pre class="language-ocaml" tabindex="0"><code data-line="0" class="language-ocaml is-loaded">  <span class="token keyword">let</span> y <span class="token operator">=</span>
    lift<span class="token punctuation">.</span>cc <span class="token operator">@@</span> <span class="token keyword">fun</span> return <span class="token operator">-&gt;</span>
    with_eref <span class="token string">"hello"</span> <span class="token operator">@@</span> <span class="token keyword">fun</span> r <span class="token operator">-&gt;</span> return r
  <span class="token keyword">in</span>
  <span class="token operator">..</span><span class="token punctuation">.</span>

</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="mod-footer mod-ui"></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="computer-science/programming-language/ocaml/scopes-and-effect-handlers.html#Scopes and effect handlers"><div class="tree-item-contents heading-link" heading-name="Scopes and effect handlers"><span class="tree-item-title">Scopes and effect handlers</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>