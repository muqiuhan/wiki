<!DOCTYPE html> <html><head>
		<title>How to build a plugin system in Rust</title>
		<base href="../../../../">
		<meta id="root-path" root-path="../../../../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="韩暮秋的个人维基 - How to build a plugin system in Rust">
		<meta property="og:title" content="How to build a plugin system in Rust">
		<meta property="og:description" content="韩暮秋的个人维基 - How to build a plugin system in Rust">
		<meta property="og:type" content="website">
		<meta property="og:url" content="https://muqiuhan.github.io/wiki/computer-science/programming-language/rust/how-to-build-a-plugin-system-in-rust/how-to-build-a-plugin-system-in-rust.html">
		<meta property="og:image" content="https://muqiuhan.github.io/wiki/computer-science/programming-language/rust/how-to-build-a-plugin-system-in-rust/attachments/pasted-image-20241220105055.png">
		<meta property="og:site_name" content="韩暮秋的个人维基">
		<meta name="author" content="韩暮秋"><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="https://muqiuhan.github.io/wiki/lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="lib/scripts/pixi.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="lib/scripts/minisearch.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="preload" href="lib/styles/other-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/other-plugins.css"></noscript><link rel="stylesheet" href="lib/styles/theme.css"><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/supported-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/supported-plugins.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript></head><body class="publish css-settings-manager theme-light show-inline-title show-ribbon outliner-plugin-dnd custom-accent ribbon-default special-h6 float-center"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles">mjx-munder{display:inline-block;text-align:left}mjx-over{text-align:left}mjx-munder:not([limits=false]){display:inline-table}mjx-munder>mjx-row{text-align:left}mjx-under{padding-bottom:.1em}mjx-msub{display:inline-block;text-align:left}mjx-c.mjx-c1D436.TEX-I::before{padding:.705em .76em .022em 0;content:"C"}mjx-c.mjx-c3D::before{padding:.583em .778em .082em 0;content:"="}mjx-c.mjx-c2211.TEX-S2::before{padding:.95em 1.444em .45em 0;content:"∑"}mjx-c.mjx-c1D45D.TEX-I::before{padding:.442em .503em .194em 0;content:"p"}mjx-c.mjx-c1D461.TEX-I::before{padding:.626em .361em .011em 0;content:"t"}mjx-mtext{display:inline-block;text-align:left}mjx-container[jax=CHTML]{line-height:0}mjx-container [space="1"]{margin-left:.111em}mjx-container [space="2"]{margin-left:.167em}mjx-container [space="3"]{margin-left:.222em}mjx-container [space="4"]{margin-left:.278em}mjx-container [space="5"]{margin-left:.333em}mjx-container [rspace="1"]{margin-right:.111em}mjx-container [rspace="2"]{margin-right:.167em}mjx-container [rspace="3"]{margin-right:.222em}mjx-container [rspace="4"]{margin-right:.278em}mjx-container [rspace="5"]{margin-right:.333em}mjx-container [size="s"]{font-size:70.7%}mjx-container [size=ss]{font-size:50%}mjx-container [size=Tn]{font-size:60%}mjx-container [size=sm]{font-size:85%}mjx-container [size=lg]{font-size:120%}mjx-container [size=Lg]{font-size:144%}mjx-container [size=LG]{font-size:173%}mjx-container [size=hg]{font-size:207%}mjx-container [size=HG]{font-size:249%}mjx-container [width=full]{width:100%}mjx-box{display:inline-block}mjx-block{display:block}mjx-itable{display:inline-table}mjx-row{display:table-row}mjx-row>*{display:table-cell}mjx-mtext{display:inline-block}mjx-mstyle{display:inline-block}mjx-merror{display:inline-block;color:red;background-color:#ff0}mjx-mphantom{visibility:hidden}mjx-assistive-mml{top:0;left:0;clip:rect(1px,1px,1px,1px);user-select:none;position:absolute!important;padding:1px 0 0!important;border:0!important;display:block!important;width:auto!important;overflow:hidden!important}mjx-assistive-mml[display=block]{width:100%!important}mjx-math{display:inline-block;text-align:left;line-height:0;text-indent:0;font-style:normal;font-weight:400;font-size:100%;font-size-adjust:none;letter-spacing:normal;border-collapse:collapse;overflow-wrap:normal;word-spacing:normal;white-space:nowrap;direction:ltr;padding:1px 0}mjx-container[jax=CHTML][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=CHTML][display=true][width=full]{display:flex}mjx-container[jax=CHTML][display=true] mjx-math{padding:0}mjx-container[jax=CHTML][justify=left]{text-align:left}mjx-container[jax=CHTML][justify=right]{text-align:right}mjx-msup{display:inline-block;text-align:left}mjx-mi{display:inline-block;text-align:left}mjx-c{display:inline-block}mjx-utext{display:inline-block;padding:.75em 0 .2em}mjx-texatom{display:inline-block;text-align:left}mjx-mo{display:inline-block;text-align:left}mjx-stretchy-h{display:inline-table;width:100%}mjx-stretchy-h>*{display:table-cell;width:0}mjx-stretchy-h>*>mjx-c{display:inline-block;transform:scaleX(1)}mjx-stretchy-h>*>mjx-c::before{display:inline-block;width:initial}mjx-stretchy-h>mjx-ext{overflow:clip visible;width:100%}mjx-stretchy-h>mjx-ext>mjx-c::before{transform:scaleX(500)}mjx-stretchy-h>mjx-ext>mjx-c{width:0}mjx-stretchy-h>mjx-beg>mjx-c{margin-right:-.1em}mjx-stretchy-h>mjx-end>mjx-c{margin-left:-.1em}mjx-stretchy-v{display:inline-block}mjx-stretchy-v>*{display:block}mjx-stretchy-v>mjx-beg{height:0}mjx-stretchy-v>mjx-end>mjx-c{display:block}mjx-stretchy-v>*>mjx-c{transform:scaleY(1);transform-origin:left center;overflow:hidden}mjx-stretchy-v>mjx-ext{display:block;height:100%;box-sizing:border-box;border:0 solid transparent;overflow:visible clip}mjx-stretchy-v>mjx-ext>mjx-c::before{width:initial;box-sizing:border-box}mjx-stretchy-v>mjx-ext>mjx-c{transform:scaleY(500) translateY(.075em);overflow:visible}mjx-mark{display:inline-block;height:0}mjx-c::before{display:block;width:0}.MJX-TEX{font-family:MJXZERO,MJXTEX}.TEX-B{font-family:MJXZERO,MJXTEX-B}.TEX-I{font-family:MJXZERO,MJXTEX-I}.TEX-MI{font-family:MJXZERO,MJXTEX-MI}.TEX-BI{font-family:MJXZERO,MJXTEX-BI}.TEX-S1{font-family:MJXZERO,MJXTEX-S1}.TEX-S2{font-family:MJXZERO,MJXTEX-S2}.TEX-S3{font-family:MJXZERO,MJXTEX-S3}.TEX-S4{font-family:MJXZERO,MJXTEX-S4}.TEX-A{font-family:MJXZERO,MJXTEX-A}.TEX-C{font-family:MJXZERO,MJXTEX-C}.TEX-CB{font-family:MJXZERO,MJXTEX-CB}.TEX-FR{font-family:MJXZERO,MJXTEX-FR}.TEX-FRB{font-family:MJXZERO,MJXTEX-FRB}.TEX-SS{font-family:MJXZERO,MJXTEX-SS}.TEX-SSB{font-family:MJXZERO,MJXTEX-SSB}.TEX-SSI{font-family:MJXZERO,MJXTEX-SSI}.TEX-SC{font-family:MJXZERO,MJXTEX-SC}.TEX-T{font-family:MJXZERO,MJXTEX-T}.TEX-V{font-family:MJXZERO,MJXTEX-V}.TEX-VB{font-family:MJXZERO,MJXTEX-VB}mjx-stretchy-h mjx-c,mjx-stretchy-v mjx-c{font-family:MJXZERO,MJXTEX-S1,MJXTEX-S4,MJXTEX,MJXTEX-A!important}@font-face{font-family:MJXZERO;src:url("lib/fonts/mathjax_zero.woff") format("woff")}@font-face{font-family:MJXTEX;src:url("lib/fonts/mathjax_main-regular.woff") format("woff")}@font-face{font-family:MJXTEX-B;src:url("lib/fonts/mathjax_main-bold.woff") format("woff")}@font-face{font-family:MJXTEX-I;src:url("lib/fonts/mathjax_math-italic.woff") format("woff")}@font-face{font-family:MJXTEX-MI;src:url("lib/fonts/mathjax_main-italic.woff") format("woff")}@font-face{font-family:MJXTEX-BI;src:url("lib/fonts/mathjax_math-bolditalic.woff") format("woff")}@font-face{font-family:MJXTEX-S1;src:url("lib/fonts/mathjax_size1-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S2;src:url("lib/fonts/mathjax_size2-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S3;src:url("lib/fonts/mathjax_size3-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S4;src:url("lib/fonts/mathjax_size4-regular.woff") format("woff")}@font-face{font-family:MJXTEX-A;src:url("lib/fonts/mathjax_ams-regular.woff") format("woff")}@font-face{font-family:MJXTEX-C;src:url("lib/fonts/mathjax_calligraphic-regular.woff") format("woff")}@font-face{font-family:MJXTEX-CB;src:url("lib/fonts/mathjax_calligraphic-bold.woff") format("woff")}@font-face{font-family:MJXTEX-FR;src:url("lib/fonts/mathjax_fraktur-regular.woff") format("woff")}@font-face{font-family:MJXTEX-FRB;src:url("lib/fonts/mathjax_fraktur-bold.woff") format("woff")}@font-face{font-family:MJXTEX-SS;src:url("lib/fonts/mathjax_sansserif-regular.woff") format("woff")}@font-face{font-family:MJXTEX-SSB;src:url("lib/fonts/mathjax_sansserif-bold.woff") format("woff")}@font-face{font-family:MJXTEX-SSI;src:url("lib/fonts/mathjax_sansserif-italic.woff") format("woff")}@font-face{font-family:MJXTEX-SC;src:url("lib/fonts/mathjax_script-regular.woff") format("woff")}@font-face{font-family:MJXTEX-T;src:url("lib/fonts/mathjax_typewriter-regular.woff") format("woff")}@font-face{font-family:MJXTEX-V;src:url("lib/fonts/mathjax_vector-regular.woff") format("woff")}@font-face{font-family:MJXTEX-VB;src:url("lib/fonts/mathjax_vector-bold.woff") format("woff")}mjx-c.mjx-c1D447.TEX-I::before{padding:.677em .704em 0 0;content:"T"}mjx-c.mjx-c1D450.TEX-I::before{padding:.442em .433em .011em 0;content:"c"}mjx-c.mjx-c2C::before{padding:.121em .278em .194em 0;content:","}mjx-c.mjx-c2E::before{padding:.12em .278em 0 0;content:"."}</style><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="How to build a plugin system in Rust"><p dir="auto">How to build a plugin system in Rust</p></h1><div class="el-p"><p dir="auto"><a href="?query=tag:rust" class="tag" target="_blank" rel="noopener nofollow">#rust</a> <a href="?query=tag:software-engineering" class="tag" target="_blank" rel="noopener nofollow">#software-engineering</a> </p></div><div class="el-blockquote"><blockquote dir="auto">
<p><a rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems" target="_blank">https://www.arroyo.dev/blog/rust-plugin-systems</a></p>
</blockquote></div><div class="el-p"><p dir="auto">Software used by businesses often needs to be extensible. For Arroyo, a real-time SQL engine, that means supporting user-defined functions (UDFs). But how can we support dynamic, user-written code in a static language like Rust? This post dives deep into the technical details of building a dynamically-linked, FFI-based plugin system in Rust.</p></div><div class="el-p"><p dir="auto">Arroyo is a stream processing engine; users write SQL to build real-time data pipelines. Now SQL is a great language for data processing, supports <a data-tooltip-position="top" aria-label="https://doc.arroyo.dev/sql/scalar-functions" rel="noopener nofollow" class="external-link" href="https://doc.arroyo.dev/sql/scalar-functions" target="_blank">a huge variety of functions</a>, and is adaptable to a wide variety of use cases including <a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/what-is-streaming-sql" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/what-is-streaming-sql" target="_blank">streaming data</a>.</p></div><div class="el-p"><p dir="auto">But as powerful as SQL is, sometimes there's a computation that just isn't easy (or possible) to express as a SQL expression. Maybe you need to parse a custom binary data format, implement a complex aggregation strategy, or call some pre-existing business logic.</p></div><div class="el-p"><p dir="auto">For these cases many SQL engines support <em>user-defined functions</em> (UDFs), which come in several forms: scalar UDFs, UDAFs (aggregate functions, which operate over multiple rows), and UDWFs (window function, which can reference other rows).</p></div><div class="el-p"><p dir="auto">UDFs make SQL engines <em>extensible</em>. They let users customize the system to their needs. This is particularly important for us, as a small startup that can't build all of the functionality every user might want ourselves. But Arroyo is built in Rust—which likes to build static binaries. How can we support dynamic, user-defined behavior?</p></div><div class="el-p"><p dir="auto">Historically, Arroyo supported UDFs via static, Ahead-of-Time (AoT) compilation, but with <a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/why-arrow-and-datafusion" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/why-arrow-and-datafusion" target="_blank">Arroyo 0.10 dropping AoT in favor of interpreted SQL runtime</a> built around <a data-tooltip-position="top" aria-label="https://arrow.apache.org" rel="noopener nofollow" class="external-link" href="https://arrow.apache.org" target="_blank">Apache Arrow</a> and <a data-tooltip-position="top" aria-label="https://datafusion.apache.org/" rel="noopener nofollow" class="external-link" href="https://datafusion.apache.org/" target="_blank">DataFusion</a>, we needed a new strategy. <strong>The result is a dynamically-linked, FFI-based plugin system with support for sync and async functions.</strong></p></div><div class="el-p"><p dir="auto">You can see how this looks from a user perspective in our <a data-tooltip-position="top" aria-label="https://doc.arroyo.dev/sql/udfs" rel="noopener nofollow" class="external-link" href="https://doc.arroyo.dev/sql/udfs" target="_blank">docs</a>, or jump <a data-tooltip-position="top" aria-label="https://github.com/ArroyoSystems/arroyo/tree/master/crates/arroyo-udf" rel="noopener nofollow" class="external-link" href="https://github.com/ArroyoSystems/arroyo/tree/master/crates/arroyo-udf" target="_blank">into the code</a>. The rest of this post will dive deep into how we ended up with this design, the technical details behind it, and what you need to know to build your own FFI-based plugin interface in Rust.</p></div><div class="el-h2 heading-wrapper"><h2 data-heading="The history" dir="auto" class="heading" id="The_history"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>The history</h2><div class="heading-children"><div class="el-p"><p dir="auto">Arroyo has supported UDFs since <a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/arroyo-0-3-0" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/arroyo-0-3-0" target="_blank">0.3</a> and UDAFs since <a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/arroyo-0-6-0" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/arroyo-0-6-0" target="_blank">0.6</a>, and it's become one of our most widely used features. We supported UDFs very early on in part because they were so easy to build into our architecture. Until our recent <a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/arroyo-0-10-0" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/arroyo-0-10-0" target="_blank">0.10</a> release, we relied on ahead-of-time compilation for our pipelines. In short, we would generate Rust code with the data types, expressions, and graph structure of the pipeline, then compile that into a binary which would execute it against the data streams.</p></div><div class="el-p"><p dir="auto">In this paradigm, supporting UDFs was straightforward. For example, a SQL expression like</p></div><div class="el-pre"><pre><code data-line="0">LENGTH(CAST((counter + 5) as TEXT))
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">would be compiled into something like the following Rust code<a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#user-content-fn-1" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#user-content-fn-1" target="_blank">1</a>:</p></div><div class="el-pre"><pre><code data-line="0">(counter + 5).to_string().len()
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">Since we're just generating Rust code, we can slot in a user-provided Rust function easily.</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241220105055.png" src="Pasted image 20241220105055.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241220105055.png" src="computer-science/programming-language/rust/how-to-build-a-plugin-system-in-rust/attachments/pasted-image-20241220105055.png"></span></p></div><div class="el-p"><p dir="auto">The way it worked was this: the Arroyo UI provided an editor where users could write UDF functions as Rust code. A UDF function looked like this:</p></div><div class="el-pre"><pre><code data-line="0">pub fn square(x: i64) -&gt; i64 {
    x * x
}
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">UDFs could also include a special comment at the top to add additional dependencies, in Cargo.toml format:</p></div><div class="el-pre"><pre><code data-line="0">/*
[dependencies]
regex = "1"
*/
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">When a user runs a pipeline with this UDF, the system would parse the function definition, pull out the arguments and return types, map them to the corresponding <a data-tooltip-position="top" aria-label="https://doc.arroyo.dev/sql/data-types" rel="noopener nofollow" class="external-link" href="https://doc.arroyo.dev/sql/data-types" target="_blank">SQL data type</a>, and register it with the SQL planner.</p></div><div class="el-p"><p dir="auto">After planning comes codegen. UDFs source code would be written directly to a <a data-tooltip-position="top" aria-label="http://lib.rs" rel="noopener nofollow" class="external-link" href="http://lib.rs" target="_blank">lib.rs</a> file in a crate, alongside another crate with generated wrapper code, which would then be added a dependency to the pipeline crate. At this point, it's a normal, statically linked Rust function that could be called like any other within the generated expression code.</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="[](https://www.arroyo.dev/blog/rust-plugin-systems#living-dynamically)Living dynamically" dir="auto" class="heading" id="[](https://www.arroyo.dev/blog/rust-plugin-systems#living-dynamically)Living_dynamically"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#living-dynamically" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#living-dynamically" target="_blank"></a>Living dynamically</h2><div class="heading-children"><div class="el-p"><p dir="auto">For Arroyo 0.10, we knew we would need a different strategy, since we were no longer building a static pipeline binary. Instead, expressions would be executed at runtime by a tree-walking interpreter, which would need some way to call out to the UDF code without having it available at compile time.</p></div><div class="el-p"><p dir="auto">At this point, we started looking at prior art in the Rust world, and came across <a data-tooltip-position="top" aria-label="https://nullderef.com/series/rust-plugins/" rel="noopener nofollow" class="external-link" href="https://nullderef.com/series/rust-plugins/" target="_blank">this great blog series</a> on Rust plugins from Mario Ortiz Manero, which we're very indebted to. Unfortunately, it quickly became clear that this was not a solved problem in Rust.</p></div><div class="el-p"><p dir="auto">There are a number of options for how one can invoke user code at runtime:</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="[](https://www.arroyo.dev/blog/rust-plugin-systems#1-embed-a-scripting-language)1. Embed a scripting language" dir="auto" class="heading" id="[](https://www.arroyo.dev/blog/rust-plugin-systems#1-embed-a-scripting-language)1._Embed_a_scripting_language"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#1-embed-a-scripting-language" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#1-embed-a-scripting-language" target="_blank"></a>1. Embed a scripting language</h3><div class="heading-children"><div class="el-p"><p dir="auto">languages like Python and JavaScript can be run dynamically without any pre-compilation, and ir interpreter could be hosted within the engine. Arroyo uses the cross-language-compatible <a data-tooltip-position="top" aria-label="https://arrow.apache.org/" rel="noopener nofollow" class="external-link" href="https://arrow.apache.org/" target="_blank">Apache Arrow</a> data format, so there needn't be any serialization across the language barrier. However, there would still be a significant performance cost compared to our native Rust functions, and this would break backwards-compatibility with existing Rust UDFs.</p></div><div class="el-p"><p dir="auto">This approach is common in applications where plugin performance isn't critical, for example GUI plugins in creative applications where the plugin code is orchestrating rather than processing itself.</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="[](https://www.arroyo.dev/blog/rust-plugin-systems#2-run-udfs-are-a-separate-process-with-rpc-calls)2. Run UDFs are a separate process, with RPC calls" dir="auto" class="heading" id="[](https://www.arroyo.dev/blog/rust-plugin-systems#2-run-udfs-are-a-separate-process-with-rpc-calls)2._Run_UDFs_are_a_separate_process,_with_RPC_calls"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#2-run-udfs-are-a-separate-process-with-rpc-calls" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#2-run-udfs-are-a-separate-process-with-rpc-calls" target="_blank"></a>2. Run UDFs are a separate process, with RPC calls</h3><div class="heading-children"><div class="el-p"><p dir="auto">Each UDF could be compiled as a separate service (or all UDFs for a pipeline could be compiled together into a single service) that runs as a sidecar to the main worker process. When the UDF is invoked during expression evaluation the engine would make an RPC call with the input data and get the return value back.</p></div><div class="el-p"><p dir="auto">There are several advantages to this approach, which isolates user-written code from the engine process. It's able to crash independently, and have its own resource limits for CPU and memory. And by running it in a separate, locked-down container or VM, we could even run potentially malicious UDFs in a cloud environment without concern that they could compromise shared infrastructure.</p></div><div class="el-p"><p dir="auto">The downside again is performance. Even with batching, the overhead of an RPC call is much higher than a pure function call, and requires serialization and deserialization of data. It also adds to the deployment complexity, as this would be other services that need to be managed.</p></div><div class="el-p"><p dir="auto">The RPC approach to plugins is often used when the host seeks to isolate itself from potentially buggy plugin code and to easily support multiple languages; for example text editors today use RPCs via the <a data-tooltip-position="top" aria-label="https://microsoft.github.io/language-server-protocol/" rel="noopener nofollow" class="external-link" href="https://microsoft.github.io/language-server-protocol/" target="_blank">Language Server Protocol</a> and in the data space <a data-tooltip-position="top" aria-label="https://beam.apache.org/" rel="noopener nofollow" class="external-link" href="https://beam.apache.org/" target="_blank">Apache Beam</a> uses RPCs to support cross-language UDFs.</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="[](https://www.arroyo.dev/blog/rust-plugin-systems#3-compile-to-wasm)3. Compile to Wasm" dir="auto" class="heading" id="[](https://www.arroyo.dev/blog/rust-plugin-systems#3-compile-to-wasm)3._Compile_to_Wasm"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#3-compile-to-wasm" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#3-compile-to-wasm" target="_blank"></a>3. Compile to Wasm</h3><div class="heading-children"><div class="el-p"><p dir="auto">Now we're cooking with gas. Web assembly—Wasm—is the hottest thing in cross-language execution. UDF code written in a language like Rust can be compiled into a Wasm binary, which can then be dynamically executed by a Wasm runtime like <a data-tooltip-position="top" aria-label="https://wasmtime.dev/" rel="noopener nofollow" class="external-link" href="https://wasmtime.dev/" target="_blank">Wasmtime</a> or <a data-tooltip-position="top" aria-label="https://www.wasmer.io" rel="noopener nofollow" class="external-link" href="https://www.wasmer.io" target="_blank">Wasmer</a>.</p></div><div class="el-p"><p dir="auto">Wasm is a genuinely exciting technology; it's an assembly-like language that is portable across languages, operating systems, and CPU architectures. In theory this means that a host doesn't need to know or care what the original language of the plugin. In addition to the portability, Wasm runtimes are also designed to be sandboxes, in theory allowing untrusted user code to run without compromising their host. Finally, Wasm supports fine-grained resource management; a host can limit how much CPU and memory a plugin can use.</p></div><div class="el-p"><p dir="auto">All of these are great properties for a UDF system, and I have no doubt that Wasm will be part of how engines solve this problem in the future. Today, though, there are some limitations.</p></div><div class="el-p"><p dir="auto">First, performance. Wasm code is still slower than native (anywhere from 1.5x-3x depending on the task). Beyond the runtime cost, sending data to a Wasm function generally requires copying it into the Wasm memory, which can be substantial overhead for simpler operations.</p></div><div class="el-p"><p dir="auto">Second, compatibility. Not all Rust code can easily be compiled to Wasm. For example, anything that requires linking to a C library will not work out of the box. Many other features of Rust (threads, syscalls, networking, etc.) are not directly supported. The situation for other languages is much worse. For dynamic, GC'd languages like Python the best option today is to <a data-tooltip-position="top" aria-label="https://github.com/pyodide/pyodide" rel="noopener nofollow" class="external-link" href="https://github.com/pyodide/pyodide" target="_blank">compile the interpreter itself to Wasm</a>, but this means that most libraries that rely on C extensions (like numpy, scipy, pandas) won't work without special support.</p></div><div class="el-p"><p dir="auto">In short, today plugin authors need to be very familiar with Wasm and its limitations in order to successfully build more complex UDFs.</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="[](https://www.arroyo.dev/blog/rust-plugin-systems#4-shared-libraries)4. Shared libraries" dir="auto" class="heading" id="[](https://www.arroyo.dev/blog/rust-plugin-systems#4-shared-libraries)4._Shared_libraries"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#4-shared-libraries" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#4-shared-libraries" target="_blank"></a>4. Shared libraries</h3><div class="heading-children"><div class="el-p"><p dir="auto">Shared objects (<code>.dll</code>s on Windows, <code>.so</code> files on Linux, <code>.dylib</code>s on MacOS) are a common way to distribute library code. They can be dynamically linked, meaning that the application code needs only to know the interface at compile time, but not the actual code. They can even be <em>dynamically loaded</em> after program startup.</p></div><div class="el-p"><p dir="auto">Dynamic linking is also a traditional way to implement plugin systems. For example, Digital Audio Workstations like Logic Pro and Ableton support shared-object plugins to implement effects and instruments, with standards like <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Virtual_Studio_Technology" rel="noopener nofollow" class="external-link" href="https://en.wikipedia.org/wiki/Virtual_Studio_Technology" target="_blank">VST</a> and <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Audio_Units" rel="noopener nofollow" class="external-link" href="https://en.wikipedia.org/wiki/Audio_Units" target="_blank">AU</a>. Other creative applications like photo editors and 3d graphics tools have similarly offered plugin interfaces via shared libraries.</p></div><div class="el-p"><p dir="auto">In many ways, this is an obvious choice: functions from shared libraries have almost the same performance as native functions<a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#user-content-fn-2" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#user-content-fn-2" target="_blank">2</a>, and we would have complete compatibility for the wide universe of crates.</p></div><div class="el-p"><p dir="auto">Unfortunately, dynamic linking is quite challenging in Rust. The language <a data-tooltip-position="top" aria-label="https://github.com/rust-lang/rfcs/issues/600" rel="noopener nofollow" class="external-link" href="https://github.com/rust-lang/rfcs/issues/600" target="_blank">lacks a stable ABI</a> (Application <em>Binary</em> Interface), which is the contract between function caller and callees about how variables will be laid out in memory, how structures are laid out, and other low-level details needed to correctly call out to foreign code. This means that shared libraries need to have been compiled with the exactly same compiler version (and possibly compiler options) as the host binary in order to be loadable.</p></div><div class="el-p"><p dir="auto">But there is a workaround: use the C ABI. Unlike Rust, C <em>does</em> have a stable ABI on every major OS and processor architecture. So if we can constrain our plugin interface to only use C-compatible data structures and functions we can safely link against plugins compiled by any Rust compiler. Even better: as the C ABI is the lingua franca in the systems world, many other languages are able to emit it, opening the door to supporting UDFs in a variety of compiled languages.</p></div><div class="el-p"><p dir="auto">This is the path we took for UDFs in Arroyo.</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241220105410.png" src="Pasted image 20241220105410.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241220105410.png" src="computer-science/programming-language/rust/how-to-build-a-plugin-system-in-rust/attachments/pasted-image-20241220105410.png"></span></p></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="Implementing a C interface" dir="auto" class="heading" id="Implementing_a_C_interface"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Implementing a C interface</h2><div class="heading-children"><div class="el-p"><p dir="auto">So how do you go about building a C ABI in Rust? There are a number of limitations and rules to follow to safely call functions over a C FFI boundary.</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="[](https://www.arroyo.dev/blog/rust-plugin-systems#designing-our-types)Designing our types" dir="auto" class="heading" id="[](https://www.arroyo.dev/blog/rust-plugin-systems#designing-our-types)Designing_our_types"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#designing-our-types" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#designing-our-types" target="_blank"></a>Designing our types</h3><div class="heading-children"><div class="el-p"><p dir="auto">The first thing we need to think about is data—the stuff getting passed between the host and plugin code. Rust gives us many powerful tools for modeling data, including structs, enums, tuples, various data structures… and we're going to have to give nearly all of them up. To correctly and reliably pass data over a C FFI boundary, we have to follow some very limiting rules.</p></div><div class="el-p"><p dir="auto"><strong>Rule 1: repr(C)</strong></p></div><div class="el-p"><p dir="auto">Our first issue is that Rust's data layout is ABI dependent, and can (and does) change with different versions of the compiler. So we get to the first rule of building a C interface: <strong>all data needs to be <code>#[repr(C)]</code></strong>.</p></div><div class="el-p"><p dir="auto">At this point I'd like to introduce an extremely helpful resource for anyone straying from the cosy, warm cottage of safe Rust and out into the deep dark night of <code>unsafe</code>: the <a data-tooltip-position="top" aria-label="https://doc.rust-lang.org/nomicon/" rel="noopener nofollow" class="external-link" href="https://doc.rust-lang.org/nomicon/" target="_blank">Rustonomicon</a>. It helpfully disclaims responsibility for potentially “UNLEASHING INDESCRIBABLE HORRORS THAT SHATTER YOUR PSYCHE AND SET YOUR MIND ADRIFT IN THE UNKNOWABLY INFINITE COSMOS.”</p></div><div class="el-p"><p dir="auto">With that warning in mind, its section on data layout and <code>repr</code> can be found <a data-tooltip-position="top" aria-label="https://doc.rust-lang.org/nomicon/data.html" rel="noopener nofollow" class="external-link" href="https://doc.rust-lang.org/nomicon/data.html" target="_blank">here</a>.</p></div><div class="el-p"><p dir="auto">Repr annotations allow developers to specify specific data layouts for structs and enums, where the default is “whatever the Rust compiler wants to do and thinks is efficient.” There are several support layouts, but the rules for <code>repr(C)</code> is pretty simple: just do whatever C does.</p></div><div class="el-p"><p dir="auto">To use alternative representations, we can create a data type (struct or enum) and annotate it like this:</p></div><div class="el-pre"><pre><code data-line="0">#[repr(C)]
struct MyData {
  a: f32,
  b: i64,
  c: u8
}
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">This struct demonstrates why <code>#[repr(C)]</code> is important. Compiling this code using the nightly-only rustc option <code>-Zprint-type-sizes</code> we can see that we end up with completely different layouts for <code>#[repr(Rust)]</code> and <code>#[repr(C)]:</code></p></div><div class="el-pre"><pre><code data-line="0">// #[repr(Rust)]
print-type-size type: `MyData`: 16 bytes, alignment: 8 bytes
print-type-size     field `.b`: 8 bytes
print-type-size     field `.a`: 4 bytes
print-type-size     field `.c`: 1 bytes
 
// #[repr(C)]
print-type-size type: `MyData`: 24 bytes, alignment: 8 bytes
print-type-size     field `.a`: 4 bytes
print-type-size     padding: 4 bytes
print-type-size     field `.b`: 8 bytes, alignment: 8 bytes
print-type-size     field `.c`: 1 bytes
print-type-size     end padding: 7 bytes
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">In fact, the Rust representation is much more efficient, taking up only 16 bytes instead of 24 bytes for the C representation. This is because Rust is free to reorder the fields to reduce the number of padding bytes needed to align to 8 bytes. C on the other hand will always lay out fields in order with predictable padding rules, which we see in the second version.</p></div><div class="el-p"><p dir="auto">That example struct stuck to simple, primitive data types. And that leads into rule number 2:</p></div><div class="el-p"><p dir="auto"><strong>Rule 2: all data must be FFI safe</strong></p></div><div class="el-p"><p dir="auto">While <code>#[repr(C)]</code> allows us to create structs and enums that can be passed across an FFI boundary, that property is not recursive—that is, it controls the layout of fields within the struct, but doesn't affect the representation of the fields themselves.</p></div><div class="el-p"><p dir="auto">In fact, we are quite limited in what data types are FFI safe. This is not a well documented area of Rust, but an incomplete list of FFI safe types includes:</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><strong>Primitive Types</strong>: <strong><code>u8</code></strong>, <strong><code>u16</code></strong>, <strong><code>u32</code></strong>, <strong><code>u64</code></strong>, <strong><code>i8</code></strong>, <strong><code>i16</code></strong>, <strong><code>i32</code></strong>, <strong><code>i64</code></strong>, <strong><code>usize</code></strong>, <strong><code>isize</code></strong>, <strong><code>f32</code></strong>, <strong><code>f64</code></strong>, and <strong><code>bool</code></strong>.</li>
<li data-line="1" dir="auto"><strong>Pointers</strong>: Raw pointers <strong><code>const T</code></strong> and <strong><code>mut T</code>;</strong> safe wrappers for nullable pointers like <strong><code>Option&lt;NonNull&lt;T&gt;&gt;</code></strong></li>
<li data-line="2" dir="auto"><strong>C-compatible Enums</strong>: Enums with explicitly defined <strong><code>repr(C)</code></strong>.</li>
<li data-line="3" dir="auto"><strong>C-compatible Structs</strong>: Structs with <strong><code>repr(C)</code></strong> and containing only FFI-safe types.</li>
<li data-line="4" dir="auto"><strong>Slices</strong>: <strong><code>[T]</code></strong>, <strong><code>const [T]</code></strong>, and <strong><code>mut [T]</code></strong> when length is provided separately.</li>
</ol></div><div class="el-p"><p dir="auto">So no passing <code>String</code>, <code>Vec</code>, <code>HashMap</code>, or random data types from your favorite Rust crate. However, we do have tools for passing some useful types of data with a little bit of transformation. The <a data-tooltip-position="top" aria-label="https://doc.rust-lang.org/std/ffi/index.html" rel="noopener nofollow" class="external-link" href="https://doc.rust-lang.org/std/ffi/index.html" target="_blank">std::ffi</a> package includes CString and CStr which are owned and borrowed null-terminated C-style strings. Similarly, we can pass <code>Vec</code> by converting it into a raw pointer + length + capacity and then back again.</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="[](https://www.arroyo.dev/blog/rust-plugin-systems#exporting-functions)Exporting functions" dir="auto" class="heading" id="[](https://www.arroyo.dev/blog/rust-plugin-systems#exporting-functions)Exporting_functions"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#exporting-functions" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#exporting-functions" target="_blank"></a>Exporting functions</h3><div class="heading-children"><div class="el-p"><p dir="auto">Once we've decided on our data types, we're ready to design our actual API, by exporting C-compatible functions. A C FFI function is a bare Rust function with</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">A <code>#[no_mangle]</code> annotation, which tells rustc to name the symbol as exactly the function name, instead of rewriting it (or “mangling”) to ensure uniqueness and include useful metadata</li>
<li data-line="1" dir="auto">The <code>extern "C"</code> keyword, which tells rustc to export the function for external use using the C ABI</li>
<li data-line="2" dir="auto">All arguments and a return type that are FFI safe<a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#user-content-fn-3" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#user-content-fn-3" target="_blank">3</a>, as described above</li>
</ul></div><div class="el-p"><p dir="auto">So putting that together, we can export a C FFI function with the following definition</p></div><div class="el-pre"><pre><code data-line="0">#[no_mangle]
extern "C" fn add(a: u32, b: u32) -&gt; u32 {
  a + b
}
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><em>Within</em> the plugin code, we can use almost any Rust construct or features, so long as nothing leaks into the type signature.</p></div><div class="el-p"><p dir="auto">The biggest exception is <code>panic</code>. Rust's default panicking behavior is unwinding, which means we travel up the call stack until we hit either a <code>catch_unwind</code> call (which stops the unwinding) or the top stack frame for the thread, in which case the thread exits. But this is a Rust-specific feature, part of the unstable Rust ABI. Unwinding can't cross a C FFI boundary without risking undefined behavior.</p></div><div class="el-p"><p dir="auto">There are two ways to handle this: either we need to compile our plugin code with <code>panic = 'abort'</code> (which causes the process to terminate on panic) or we need to ensure that the plugin cannot panic. But even if we can ensure our own code is panic-free<a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#user-content-fn-4" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#user-content-fn-4" target="_blank">4</a>, how can we make sure our plugin-writing-users do the same?</p></div><div class="el-p"><p dir="auto">One answer is to use a plugin interface with a top-level <code>catch_unwind</code> call that converts panics into an Error enum across the FFI boundary.</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="[](https://www.arroyo.dev/blog/rust-plugin-systems#compiling-our-plugin)Compiling our plugin" dir="auto" class="heading" id="[](https://www.arroyo.dev/blog/rust-plugin-systems#compiling-our-plugin)Compiling_our_plugin"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#compiling-our-plugin" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#compiling-our-plugin" target="_blank"></a>Compiling our plugin</h3><div class="heading-children"><div class="el-p"><p dir="auto">Our plugin will be a library crate that's built as a shared object, in a binary format that depends on our operating system (.so on Linux, .dll on Windows, .dylib on MacOS).</p></div><div class="el-p"><p dir="auto">By default, Rust compiles libraries as an <code>rlib</code> artifact, which is a Rust-specific static library format. To tell it to instead build a dynamic system library that can be linked by other languages, we'll use the <code>cdylib</code> type. This can be specified in a Cargo.toml by setting the <code>lib.crate-type</code> option, like this:</p></div><div class="el-pre"><pre><code data-line="0">[package]
name = "my-plugin"
version = "1.0.0"
edition = "2021"
 
[lib]
crate-type = ["cdylib"]
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="[](https://www.arroyo.dev/blog/rust-plugin-systems#calling-ffi-functions)Calling FFI functions" dir="auto" class="heading" id="[](https://www.arroyo.dev/blog/rust-plugin-systems#calling-ffi-functions)Calling_FFI_functions"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#calling-ffi-functions" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#calling-ffi-functions" target="_blank"></a>Calling FFI functions</h3><div class="heading-children"><div class="el-p"><p dir="auto">There are two different ways we might link and call plugin code across an FFI: at program start time, or dynamically as the program is executing. In either case, we'll use the <code>extern</code> keyword again but without a function body in order to tell the host side what the function signature is.</p></div><div class="el-p"><p dir="auto">If we know the name of the library at compile time, Rust provides built-in support for loading system libraries using the <code>[link]</code> annotation. It looks like this:</p></div><div class="el-pre"><pre><code data-line="0">#[link(name = "my_plugin")]
extern "C" {
    fn add(a: u32, b: u32) -&gt; u32;
}
 
fn main() {
    unsafe { add(1, 5) };
}
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">Rust will look for a shared library with the name <code>my_plugin</code> (for example, on Linux it will look for <code>/usr/lib/my_plugin.so</code>, <code>/usr/local/lib/my_plugin.so</code>, etc.) and attempt to link it at program start time, and will fail if it can't find the library. The function can be called like any other (unsafe) Rust function<a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#user-content-fn-5" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#user-content-fn-5" target="_blank">5</a>.</p></div><div class="el-p"><p dir="auto">But for a plugin system, having to know the name of the library at compile time (and ensuring that it's installed in a system location) is somewhat limiting. Instead, we can turn to dynamic loading.</p></div><div class="el-p"><p dir="auto">The interfaces for dynamic library loading are OS-specific, but there are several crates that can handle the cross-platform boilerplate for us. The two most popular are <a data-tooltip-position="top" aria-label="https://crates.io/crates/libloading" rel="noopener nofollow" class="external-link" href="https://crates.io/crates/libloading" target="_blank">libloading</a> and <a data-tooltip-position="top" aria-label="https://crates.io/crates/dlopen2" rel="noopener nofollow" class="external-link" href="https://crates.io/crates/dlopen2" target="_blank">dlopen2</a>. For Arroyo we decided to use dlopen2 which has a nicer interface and stronger guarantees around thread safety.</p></div><div class="el-p"><p dir="auto">In dlopen2, we can define structs for each of our plugin interfaces. They look like this:</p></div><div class="el-pre"><pre><code data-line="0">#[derive(WrapperApi)]
pub struct PluginInterface {
    add: extern "C" fn(a: u32, b: u32) -&gt; u32,
}
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">A plugin can be loaded and called like this:</p></div><div class="el-pre"><pre><code data-line="0">let container: Container&lt;PluginInterface&gt; = unsafe {
	Container::load(dylib_path).unwrap()
};
 
unsafe { container.add(1, 3) }
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="[](https://www.arroyo.dev/blog/rust-plugin-systems#putting-it-all-together)Putting it all together" dir="auto" class="heading" id="[](https://www.arroyo.dev/blog/rust-plugin-systems#putting-it-all-together)Putting_it_all_together"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#putting-it-all-together" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#putting-it-all-together" target="_blank"></a>Putting it all together</h2><div class="heading-children"><div class="el-p"><p dir="auto">So that was a lot of theory. Let's put it into practice with a complete example! We'll be working off a (very simplified) example plugin system found in <a data-tooltip-position="top" aria-label="https://github.com/mwylde/rust-plugin-tutorial" rel="noopener nofollow" class="external-link" href="https://github.com/mwylde/rust-plugin-tutorial" target="_blank">this repo</a>. Clone it locally to try this out yourself.</p></div><div class="el-p"><p dir="auto">The code is divided into two parts: the <em>plugin</em>, which compiles to a shared object, and the <em>host</em>, which loads the plugin. (In a real system, you'd likely want a few more components, including a common library to share definitions between the plugin and host, and a macro to do code generation, but we're keeping this relatively simple.)</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="[](https://www.arroyo.dev/blog/rust-plugin-systems#designing-the-interface)Designing the interface" dir="auto" class="heading" id="[](https://www.arroyo.dev/blog/rust-plugin-systems#designing-the-interface)Designing_the_interface"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#designing-the-interface" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#designing-the-interface" target="_blank"></a>Designing the interface</h3><div class="heading-children"><div class="el-p"><p dir="auto">Before we can start writing code, we need to decide on the contract between the plugin and the host. For this example, we'll adopt a flexible contract that supports a variable number of arguments of various common data types, as would be needed for a UDF system.</p></div><div class="el-p"><p dir="auto">The plugin interface has two methods:</p></div><div class="el-pre"><pre><code data-line="0">extern "C" fn plugin_metadata() -&gt; PluginMetadata,
 
extern "C" fn plugin_entrypoint(
    args: *const PluginValue, args_len: usize) -&gt; PluginResult
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">The metadata function is called by the host to determine the number and types of the arguments the plugin expects, and the type of the data it returns, while the entrypoint function is called to actually execute the plugin's logic.</p></div><div class="el-p"><p dir="auto">As discussed in detail above, all of our data types need to be FFI-safe. For example, the <code>PluginMetadata</code> type looks like this:</p></div><div class="el-pre"><pre><code data-line="0">#[repr(C)]
#[derive(Copy, Clone)]
pub enum PluginType {
    Bool,
    Int,
    UInt,
    Double,
    String,
}
 
#[repr(C)]
pub struct PluginMetadata {
    // should have a static lifetime
    pub name: *const i8,
    pub arg_types: *const PluginType,
    pub arg_types_len: usize,
    pub return_type: PluginType,
}
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">Note that instead of of passing a String for the name, we pass a <code>*const i8</code>, which represents a null-terminated C-style string. Instead of a <code>Vec&lt;PluginType&gt;</code> for the args, we pass a pointer to some memory and a length.</p></div><div class="el-p"><p dir="auto">For the entrypoint function, we'll need to pass our actual data to the plugin. That relies on an array of values of the type <code>PluginValue</code>:</p></div><div class="el-pre"><pre><code data-line="0">#[repr(C)]
pub enum PluginValue {
    Bool(bool),
    Int(i64),
    UInt(u64),
    Double(f64),
    // All strings are owned by the host
    String(*const i8),
}
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">For primitives, we can use them as-is as all Rust primitives are FFI-safe. However, strings again need special attention. We have two typical options for passing strings: we can pass Rust-style strings (with an array of chars and a length) or C-styles strings (whose end is determined by a null byte). While the former are much safer and generally preferred in modern APIs, for C interfaces the latter is more common as it's more easily supported by languages with a C FFI.</p></div><div class="el-p"><p dir="auto">Beyond the format of the data, we also need to consider ownership<a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#user-content-fn-6" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#user-content-fn-6" target="_blank">6</a>. Once memory is allocated, exactly one part of our code (in this case, one side of the host/plugin divide) needs to own that memory. PluginValues are both created by the host (to provide data) and by the plugin (to return its result), but to simplify the memory management we have documented that in both cases the host owns the memory and is responsible for freeing it. This does mean the plugin code needs to be careful never to create an owned-object from the memory (in this case, a <code>CString</code>) which would free it on drop.</p></div><div class="el-p"><p dir="auto">Finally, we have our return type, which is just an FFI-safe Result type with a CString error message:</p></div><div class="el-pre"><pre><code data-line="0">#[repr(C)]
pub enum PluginResult {
    Ok(PluginValue),
    // Null-terminated c-string; he host is responsible for
    // freeing this value
    Err(*mut i8),
}
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">Now that we have our common interface, let's see how they're used. We'll start with the plugin.</p></div><div class="el-p"><p dir="auto">We're using two different types of raw pointers here: <code>*mut</code> and <code>*const</code>. Why is that? What's the difference? In the context of FFI, the answer is: not much. The choice of <code>mut</code> vs <code>const</code> doesn't affect the generated code, and you can freely cast between them.</p></div><div class="el-p"><p dir="auto">However, they are useful for documenting intent and ownership across an FFI boundary. Using <code>*const</code> tells the calling code that they shouldn't modify the data behind the pointer, and probably shouldn't free it, while <code>*mut</code> indicates that it's ok to modify the data and can also communicate ownership.</p></div><div class="el-p"><p dir="auto">We're playing a bit fast-and-loose here, because we're using a single data type (<code>PluginValue</code>) for both our arguments—which the host creates and owns—and our return value, which the plugin creates but transfers to the host, so we opt for <code>*const</code> to tell the plugin not to modify or free its arguments. However, on the host side we then have to cast it to <code>*mut</code> so that we can take ownership.</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="[](https://www.arroyo.dev/blog/rust-plugin-systems#the-plugin)The plugin" dir="auto" class="heading" id="[](https://www.arroyo.dev/blog/rust-plugin-systems#the-plugin)The_plugin"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#the-plugin" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#the-plugin" target="_blank"></a>The plugin</h3><div class="heading-children"><div class="el-p"><p dir="auto">We're going to implement a simple plugin that takes in two arguments, a string and a number, and will return the string repeated that number of times: <code>f("cool", 3)</code> ⇒ <code>"coolcoolcool"</code> .</p></div><div class="el-p"><p dir="auto">The plugin is responsible for building a shared library, so we need to tell Cargo that's what we want. We do that by specifying the crate type as <code>cdylib</code>, a C-compatible dynamic library. Our Cargo.toml looks like this:</p></div><div class="el-pre"><pre><code data-line="0">[package]
name = "plugin"
version = "0.1.0"
edition = "2021"
 
[lib]
crate-type = ["cdylib"]
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">Next is our src/lib.rs file. This will contain implementations of the plugin interface documented above.</p></div><div class="el-p"><p dir="auto">The first function we need to implement is <code>plugin_metadata()</code>, which is pretty straightforward, telling the host about our arguments and our return type:</p></div><div class="el-pre"><pre><code data-line="0">#[no_mangle]
pub extern "C" fn plugin_metadata() -&gt; PluginMetadata {
    PluginMetadata {
        name: "repeat\0".as_ptr() as *const i8,
        arg_types: [PluginType::String, PluginType::UInt].as_ptr(),
        arg_types_len: 2,
        return_type: PluginType::String,
    }
}
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">Next we'll implement our plugin's unique logic, in this case repeating a string N times. I find it easiest to separate this out from the boilerplate that's involved in converting to and from FFI types, so that when we're developing the logic we can stay in safe, normal Rust land.</p></div><div class="el-pre"><pre><code data-line="0">fn repeat_impl(input: &amp;str, count: u64) -&gt; String {
    input.repeat(count as usize)
}
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">Nice and simple. Unfortunately, we still need the complex code to bridge the FFI and Rust worlds. For this example, it looks like this:</p></div><div class="el-pre"><pre><code data-line="0">#[no_mangle]
pub extern "C" fn plugin_entrypoint(args: *const PluginValue,
                                    args_len: usize) -&gt; PluginResult {
    // first we need to check if the arguments are valid
    if args_len != 2 {
        return plugin_error("args_len should be 2");
    }
 
    let PluginValue::String(string) = (unsafe { &amp;*args.offset(0) }) else {
        return plugin_error("arg0 is invalid; expected String");
    };
 
    let PluginValue::UInt(count) = (unsafe { &amp;*args.offset(1) }) else {
        return plugin_error("arg1 is invalid; expected UInt");
    };
 
    let string = match unsafe { CStr::from_ptr(*string) }.to_str() {
        Ok(value) =&gt; value,
        Err(_) =&gt; {
            return plugin_error("arg0 is invalid; expected valid UTF-8 string");
        }
    };
 
    // then we can call our logic with the converted arguments and re-wrap them
    // in our Result type, catching any panics that might occur so that they
    // don't cross the FFI boundary
    match catch_unwind(|| repeat_impl(string, *count)) {
        Ok(value) =&gt; PluginResult::Ok(
          PluginValue::String(CString::new(value).unwrap().into_raw())),
        Err(_) =&gt; plugin_error("function panicked"),
    }
}
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">Making your users write all of this unsafe boilerplate for every plugin isn't great UX, so you may want to use a macro or just wrapper code (if you don't need to support multiple types). You can see the macro for the Arroyo plugin system <a data-tooltip-position="top" aria-label="https://github.com/ArroyoSystems/arroyo/blob/master/crates/arroyo-udf/arroyo-udf-macros/src/lib.rs" rel="noopener nofollow" class="external-link" href="https://github.com/ArroyoSystems/arroyo/blob/master/crates/arroyo-udf/arroyo-udf-macros/src/lib.rs" target="_blank">here</a>.</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="[](https://www.arroyo.dev/blog/rust-plugin-systems#the-host)The host" dir="auto" class="heading" id="[](https://www.arroyo.dev/blog/rust-plugin-systems#the-host)The_host"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#the-host" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#the-host" target="_blank"></a>The host</h3><div class="heading-children"><div class="el-p"><p dir="auto">The host is a normal Rust application, created with <code>cargo new</code>. It has one dependency, dlopen2, which we'll use to dynamically load our plugin:</p></div><div class="el-pre"><pre><code data-line="0">[dependencies]
dlopen2 = { version = "0.7.0", features = ["derive"] }
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">The meat is in src/main.rs, which builds our binary. We need to repeat the definitions (or include them from a common library), but we'll also include one more, an owned version of PluginValue:</p></div><div class="el-pre"><pre><code data-line="0">pub enum OwnedPluginValue {
    Bool(bool),
    Int(i64),
    UInt(u64),
    Double(f64),
    String(CString),
}
 
impl PluginValue {
    pub fn to_owned(self) -&gt; OwnedPluginValue {
        match self {
            PluginValue::Bool(b) =&gt; OwnedPluginValue::Bool(b),
            PluginValue::Int(i) =&gt; OwnedPluginValue::Int(i),
            PluginValue::UInt(u) =&gt; OwnedPluginValue::UInt(u),
            PluginValue::Double(d) =&gt; OwnedPluginValue::Double(d),
            PluginValue::String(s) =&gt; {
                OwnedPluginValue::String(
                    unsafe { CString::from_raw(s as *mut i8) })
            }
        }
    }
}
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">This owned struct will allow us to ensure that values returned from the plugin (and the arguments we send it) are eventually freed.</p></div><div class="el-p"><p dir="auto">Next, we'll define the plugin interface using dlopen2's <code>WrapperApi</code> macro:</p></div><div class="el-pre"><pre><code data-line="0">#[derive(WrapperApi)]
struct PluginApi {
    plugin_metadata: unsafe extern "C" fn() -&gt; PluginMetadata,
    plugin_entrypoint:
        unsafe extern "C" fn(args: *const PluginValue, args_len: usize)
            -&gt; PluginResult,
}
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">This let's us conveniently bundle up all of the plugin functions into a struct which we can store and pass around our application.</p></div><div class="el-p"><p dir="auto">Now we're ready to load the plugin and call it. I'll spare you the details of CLI argument processing (which you can see in the <a data-tooltip-position="top" aria-label="https://github.com/mwylde/rust-plugin-tutorial/blob/main/host/src/main.rs" rel="noopener nofollow" class="external-link" href="https://github.com/mwylde/rust-plugin-tutorial/blob/main/host/src/main.rs" target="_blank">full example file</a>). Here's the meat of it:</p></div><div class="el-pre"><pre><code data-line="0">// load the plugin via the dlopen2's Container API
let container: Container&lt;PluginApi&gt; =
    unsafe { Container::load(&amp;args[1]) }.expect("Could not load plugin");
 
// get the metadata, which will tell us which arguments to expect
let metadata: PluginMetadata = unsafe { container.plugin_metadata() };
 
// read the arguments from the command line
let mut call_args: Vec&lt;PluginValue&gt; = vec![];
for (i, arg) in args[2..].iter().enumerate() {
    match unsafe { *metadata.arg_types.add(i) } {
        PluginType::Bool =&gt; {
            call_args.push(PluginValue::Bool(
                arg.parse().expect("Invalid bool")))
        }
        ...
    }
}
 
// call the plugin function
let result = unsafe {
    container.plugin_entrypoint(call_args.as_ptr(), call_args.len())
};
 
// take ownership and drop the arguments to free their memory
drop(call_args.into_iter().map(|t| t.to_owned()));
 
// print out the result or error to the user
match result {
    PluginResult::Ok(value) =&gt; {
        println!("Plugin returned: {}", value.to_owned());
    }
    PluginResult::Err(err) =&gt; {
        eprintln!("{}", unsafe { CString::from_raw(err) }.to_string_lossy());
        std::process::exit(1);
    }
}
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="[](https://www.arroyo.dev/blog/rust-plugin-systems#lets-plug-in-some-stuff)Let's plug in some stuff!!!" dir="auto" class="heading" id="[](https://www.arroyo.dev/blog/rust-plugin-systems#lets-plug-in-some-stuff)Let's_plug_in_some_stuff!!!"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#lets-plug-in-some-stuff" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#lets-plug-in-some-stuff" target="_blank"></a>Let's plug in some stuff!!!</h3><div class="heading-children"><div class="el-p"><p dir="auto">Here we are. After more than 5000 words, we're going to actually dynamically load some Rust code.</p></div><div class="el-p"><p dir="auto">If you want to follow along, check out the example repo</p></div><div class="el-pre"><pre><code data-line="0">$ git clone https://github.com/mwylde/rust-plugin-tutorial.git
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">Then we're going to build both the plugin and host</p></div><div class="el-pre"><pre><code data-line="0">$ cd rust-plugin-tutorial/plugin &amp;&amp; cargo build
$ cd ../host &amp;&amp; cargo build
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">Now we should have a dynamic library in <code>plugin/target/debug</code> and a host binary in <code>host/target/debug</code>. The dynamic library will be named something like “libplugin.dylib,” “libplugin.so,” or “libplugin.dll” depending on your operating system. Note which it is, then invoke the host like this:</p></div><div class="el-pre"><pre><code data-line="0">$ host/target/debug/host plugin/target/debug/libplugin.dylib cool 3
Loaded plugin repeat
Plugin returned: coolcoolcool
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">If all went well, you should see the output from your plugin code (and no pesky segfaults).</p></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="[](https://www.arroyo.dev/blog/rust-plugin-systems#wrapping-up)Wrapping up" dir="auto" class="heading" id="[](https://www.arroyo.dev/blog/rust-plugin-systems#wrapping-up)Wrapping_up"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#wrapping-up" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#wrapping-up" target="_blank"></a>Wrapping up</h2><div class="heading-children"><div class="el-p"><p dir="auto">So that's the background for how we built our plugin system, and how you can build your own.</p></div><div class="el-p"><p dir="auto">Recapping a bit:</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">We defined our data types as enums and structs of FFI-safe types</li>
<li data-line="1" dir="auto">We defined a plugin interface, as <code>#[no_mangle] extern "C"</code> functions consuming and returning those data types</li>
<li data-line="2" dir="auto">We used dlopen2 to load and call our plugin interface from the host</li>
</ul></div><div class="el-p"><p dir="auto">In part 2 of this series, we'll cover how this works in a real, production plugin system, including support for async functions. (If you're impatient, all of the code can be found <a data-tooltip-position="top" aria-label="https://github.com/ArroyoSystems/arroyo/tree/6bbc5484e2d9f515ca1c067d23ad0e8ff25f9882/crates/arroyo-udf" rel="noopener nofollow" class="external-link" href="https://github.com/ArroyoSystems/arroyo/tree/6bbc5484e2d9f515ca1c067d23ad0e8ff25f9882/crates/arroyo-udf" target="_blank">here</a>.)</p></div><div class="el-p"><p dir="auto">Questions? Concerns? Issues? Abuse? You can reach me on the <a data-tooltip-position="top" aria-label="https://discord.gg/cjCr5rVmyR" rel="noopener nofollow" class="external-link" href="https://discord.gg/cjCr5rVmyR" target="_blank">Arroyo Discord</a> or at <a data-tooltip-position="top" aria-label="mailto:micah@arroyo.systems" rel="noopener nofollow" class="external-link" href="mailto:micah@arroyo.systems" target="_blank">micah@arroyo.systems</a>.</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="[](https://www.arroyo.dev/blog/rust-plugin-systems#footnote-label)Footnotes" dir="auto" class="heading" id="[](https://www.arroyo.dev/blog/rust-plugin-systems#footnote-label)Footnotes"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#footnote-label" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#footnote-label" target="_blank"></a>Footnotes</h2><div class="heading-children"><div class="el-ol"><ol>
<li data-line="0" dir="auto">This is a bit simplified; the actual compilation has to take into account SQL's complex nullability rules. See a more complete example <a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/why-arrow-and-datafusion#implementing-expressions" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/why-arrow-and-datafusion#implementing-expressions" target="_blank">here</a>. <a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#user-content-fnref-1" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#user-content-fnref-1" target="_blank">↩</a></li>
<li data-line="2" dir="auto">In practice dynamically-linked functions can run a bit slower as they can't be inlined or take advantage of link-time or profile-guided optimizations. <a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#user-content-fnref-2" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#user-content-fnref-2" target="_blank">↩</a></li>
<li data-line="4" dir="auto">The Rust compiler will helpfully warn you if you use a non-FFI-safe type in an <code>extern</code> function <a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#user-content-fnref-3" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#user-content-fnref-3" target="_blank">↩</a></li>
<li data-line="6" dir="auto">Which… of course we all do <a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#user-content-fnref-4" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#user-content-fnref-4" target="_blank">↩</a></li>
<li data-line="8" dir="auto">All FFI functions are inherently unsafe, as Rust can't guarantee anything on the other side of the FFI boundary. For that reason, It's typical to write safe wrappers around FFI functions that ensure the invariants expected by the library are upheld. <a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#user-content-fnref-5" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#user-content-fnref-5" target="_blank">↩</a></li>
<li data-line="10" dir="auto">Rust-haters complain about the lifetime and borrowchecker systems but those issues don't go away just because your compiler doesn't yell at you about it. In C APIs you always need to know who owns a piece of memory and who's responsible for freeing it. But without language support you just have to document it and hope for the best. <a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#user-content-fnref-6" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#user-content-fnref-6" target="_blank">↩</a></li>
</ol></div><div class="mod-footer mod-ui"></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="computer-science/programming-language/rust/how-to-build-a-plugin-system-in-rust/how-to-build-a-plugin-system-in-rust.html#How to build a plugin system in Rust"><div class="tree-item-contents heading-link" heading-name="How to build a plugin system in Rust"><span class="tree-item-title">How to build a plugin system in Rust</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/programming-language/rust/how-to-build-a-plugin-system-in-rust/how-to-build-a-plugin-system-in-rust.html#The_history"><div class="tree-item-contents heading-link" heading-name="The history"><span class="tree-item-title">The history</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="computer-science/programming-language/rust/how-to-build-a-plugin-system-in-rust/how-to-build-a-plugin-system-in-rust.html#[](https://www.arroyo.dev/blog/rust-plugin-systems#living-dynamically)Living_dynamically"><div class="tree-item-contents heading-link" heading-name="[](https://www.arroyo.dev/blog/rust-plugin-systems#living-dynamically)Living dynamically"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title"><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#living-dynamically" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#living-dynamically" target="_blank"></a>Living dynamically</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="computer-science/programming-language/rust/how-to-build-a-plugin-system-in-rust/how-to-build-a-plugin-system-in-rust.html#[](https://www.arroyo.dev/blog/rust-plugin-systems#1-embed-a-scripting-language)1._Embed_a_scripting_language"><div class="tree-item-contents heading-link" heading-name="[](https://www.arroyo.dev/blog/rust-plugin-systems#1-embed-a-scripting-language)1. Embed a scripting language"><span class="tree-item-title"><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#1-embed-a-scripting-language" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#1-embed-a-scripting-language" target="_blank"></a>1. Embed a scripting language</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="computer-science/programming-language/rust/how-to-build-a-plugin-system-in-rust/how-to-build-a-plugin-system-in-rust.html#[](https://www.arroyo.dev/blog/rust-plugin-systems#2-run-udfs-are-a-separate-process-with-rpc-calls)2._Run_UDFs_are_a_separate_process,_with_RPC_calls"><div class="tree-item-contents heading-link" heading-name="[](https://www.arroyo.dev/blog/rust-plugin-systems#2-run-udfs-are-a-separate-process-with-rpc-calls)2. Run UDFs are a separate process, with RPC calls"><span class="tree-item-title"><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#2-run-udfs-are-a-separate-process-with-rpc-calls" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#2-run-udfs-are-a-separate-process-with-rpc-calls" target="_blank"></a>2. Run UDFs are a separate process, with RPC calls</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="computer-science/programming-language/rust/how-to-build-a-plugin-system-in-rust/how-to-build-a-plugin-system-in-rust.html#[](https://www.arroyo.dev/blog/rust-plugin-systems#3-compile-to-wasm)3._Compile_to_Wasm"><div class="tree-item-contents heading-link" heading-name="[](https://www.arroyo.dev/blog/rust-plugin-systems#3-compile-to-wasm)3. Compile to Wasm"><span class="tree-item-title"><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#3-compile-to-wasm" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#3-compile-to-wasm" target="_blank"></a>3. Compile to Wasm</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="computer-science/programming-language/rust/how-to-build-a-plugin-system-in-rust/how-to-build-a-plugin-system-in-rust.html#[](https://www.arroyo.dev/blog/rust-plugin-systems#4-shared-libraries)4._Shared_libraries"><div class="tree-item-contents heading-link" heading-name="[](https://www.arroyo.dev/blog/rust-plugin-systems#4-shared-libraries)4. Shared libraries"><span class="tree-item-title"><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#4-shared-libraries" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#4-shared-libraries" target="_blank"></a>4. Shared libraries</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="computer-science/programming-language/rust/how-to-build-a-plugin-system-in-rust/how-to-build-a-plugin-system-in-rust.html#Implementing_a_C_interface"><div class="tree-item-contents heading-link" heading-name="Implementing a C interface"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">Implementing a C interface</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="computer-science/programming-language/rust/how-to-build-a-plugin-system-in-rust/how-to-build-a-plugin-system-in-rust.html#[](https://www.arroyo.dev/blog/rust-plugin-systems#designing-our-types)Designing_our_types"><div class="tree-item-contents heading-link" heading-name="[](https://www.arroyo.dev/blog/rust-plugin-systems#designing-our-types)Designing our types"><span class="tree-item-title"><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#designing-our-types" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#designing-our-types" target="_blank"></a>Designing our types</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="computer-science/programming-language/rust/how-to-build-a-plugin-system-in-rust/how-to-build-a-plugin-system-in-rust.html#[](https://www.arroyo.dev/blog/rust-plugin-systems#exporting-functions)Exporting_functions"><div class="tree-item-contents heading-link" heading-name="[](https://www.arroyo.dev/blog/rust-plugin-systems#exporting-functions)Exporting functions"><span class="tree-item-title"><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#exporting-functions" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#exporting-functions" target="_blank"></a>Exporting functions</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="computer-science/programming-language/rust/how-to-build-a-plugin-system-in-rust/how-to-build-a-plugin-system-in-rust.html#[](https://www.arroyo.dev/blog/rust-plugin-systems#compiling-our-plugin)Compiling_our_plugin"><div class="tree-item-contents heading-link" heading-name="[](https://www.arroyo.dev/blog/rust-plugin-systems#compiling-our-plugin)Compiling our plugin"><span class="tree-item-title"><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#compiling-our-plugin" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#compiling-our-plugin" target="_blank"></a>Compiling our plugin</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="computer-science/programming-language/rust/how-to-build-a-plugin-system-in-rust/how-to-build-a-plugin-system-in-rust.html#[](https://www.arroyo.dev/blog/rust-plugin-systems#calling-ffi-functions)Calling_FFI_functions"><div class="tree-item-contents heading-link" heading-name="[](https://www.arroyo.dev/blog/rust-plugin-systems#calling-ffi-functions)Calling FFI functions"><span class="tree-item-title"><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#calling-ffi-functions" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#calling-ffi-functions" target="_blank"></a>Calling FFI functions</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="computer-science/programming-language/rust/how-to-build-a-plugin-system-in-rust/how-to-build-a-plugin-system-in-rust.html#[](https://www.arroyo.dev/blog/rust-plugin-systems#putting-it-all-together)Putting_it_all_together"><div class="tree-item-contents heading-link" heading-name="[](https://www.arroyo.dev/blog/rust-plugin-systems#putting-it-all-together)Putting it all together"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title"><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#putting-it-all-together" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#putting-it-all-together" target="_blank"></a>Putting it all together</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="computer-science/programming-language/rust/how-to-build-a-plugin-system-in-rust/how-to-build-a-plugin-system-in-rust.html#[](https://www.arroyo.dev/blog/rust-plugin-systems#designing-the-interface)Designing_the_interface"><div class="tree-item-contents heading-link" heading-name="[](https://www.arroyo.dev/blog/rust-plugin-systems#designing-the-interface)Designing the interface"><span class="tree-item-title"><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#designing-the-interface" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#designing-the-interface" target="_blank"></a>Designing the interface</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="computer-science/programming-language/rust/how-to-build-a-plugin-system-in-rust/how-to-build-a-plugin-system-in-rust.html#[](https://www.arroyo.dev/blog/rust-plugin-systems#the-plugin)The_plugin"><div class="tree-item-contents heading-link" heading-name="[](https://www.arroyo.dev/blog/rust-plugin-systems#the-plugin)The plugin"><span class="tree-item-title"><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#the-plugin" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#the-plugin" target="_blank"></a>The plugin</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="computer-science/programming-language/rust/how-to-build-a-plugin-system-in-rust/how-to-build-a-plugin-system-in-rust.html#[](https://www.arroyo.dev/blog/rust-plugin-systems#the-host)The_host"><div class="tree-item-contents heading-link" heading-name="[](https://www.arroyo.dev/blog/rust-plugin-systems#the-host)The host"><span class="tree-item-title"><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#the-host" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#the-host" target="_blank"></a>The host</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="computer-science/programming-language/rust/how-to-build-a-plugin-system-in-rust/how-to-build-a-plugin-system-in-rust.html#[](https://www.arroyo.dev/blog/rust-plugin-systems#lets-plug-in-some-stuff)Let's_plug_in_some_stuff!!!"><div class="tree-item-contents heading-link" heading-name="[](https://www.arroyo.dev/blog/rust-plugin-systems#lets-plug-in-some-stuff)Let's plug in some stuff!!!"><span class="tree-item-title"><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#lets-plug-in-some-stuff" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#lets-plug-in-some-stuff" target="_blank"></a>Let's plug in some stuff!!!</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/programming-language/rust/how-to-build-a-plugin-system-in-rust/how-to-build-a-plugin-system-in-rust.html#[](https://www.arroyo.dev/blog/rust-plugin-systems#wrapping-up)Wrapping_up"><div class="tree-item-contents heading-link" heading-name="[](https://www.arroyo.dev/blog/rust-plugin-systems#wrapping-up)Wrapping up"><span class="tree-item-title"><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#wrapping-up" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#wrapping-up" target="_blank"></a>Wrapping up</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/programming-language/rust/how-to-build-a-plugin-system-in-rust/how-to-build-a-plugin-system-in-rust.html#[](https://www.arroyo.dev/blog/rust-plugin-systems#footnote-label)Footnotes"><div class="tree-item-contents heading-link" heading-name="[](https://www.arroyo.dev/blog/rust-plugin-systems#footnote-label)Footnotes"><span class="tree-item-title"><a data-tooltip-position="top" aria-label="https://www.arroyo.dev/blog/rust-plugin-systems#footnote-label" rel="noopener nofollow" class="external-link" href="https://www.arroyo.dev/blog/rust-plugin-systems#footnote-label" target="_blank"></a>Footnotes</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>