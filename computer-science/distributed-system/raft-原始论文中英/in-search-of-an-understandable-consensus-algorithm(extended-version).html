<!DOCTYPE html> <html><head>
		<title>In Search of an Understandable Consensus Algorithm(Extended Version)</title>
		<base href="../../../">
		<meta id="root-path" root-path="../../../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="韩暮秋的个人维基 - In Search of an Understandable Consensus Algorithm(Extended Version)">
		<meta property="og:title" content="In Search of an Understandable Consensus Algorithm(Extended Version)">
		<meta property="og:description" content="韩暮秋的个人维基 - In Search of an Understandable Consensus Algorithm(Extended Version)">
		<meta property="og:type" content="website">
		<meta property="og:url" content="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raft-原始论文中英/in-search-of-an-understandable-consensus-algorithm(extended-version).html">
		<meta property="og:image" content="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raft-原始论文中英/pasted-image-20240725172940.png">
		<meta property="og:site_name" content="韩暮秋的个人维基">
		<meta name="author" content="韩暮秋"><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="https://muqiuhan.github.io/wiki/lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="lib/scripts/pixi.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="lib/scripts/minisearch.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="preload" href="lib/styles/other-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/other-plugins.css"></noscript><link rel="stylesheet" href="lib/styles/theme.css"><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/supported-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/supported-plugins.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript></head><body class="publish css-settings-manager theme-light show-inline-title show-ribbon outliner-plugin-dnd custom-accent ribbon-default special-h6 float-center"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles">mjx-munder{display:inline-block;text-align:left}mjx-over{text-align:left}mjx-munder:not([limits=false]){display:inline-table}mjx-munder>mjx-row{text-align:left}mjx-under{padding-bottom:.1em}mjx-msub{display:inline-block;text-align:left}mjx-c.mjx-c1D436.TEX-I::before{padding:.705em .76em .022em 0;content:"C"}mjx-c.mjx-c3D::before{padding:.583em .778em .082em 0;content:"="}mjx-c.mjx-c2211.TEX-S2::before{padding:.95em 1.444em .45em 0;content:"∑"}mjx-c.mjx-c1D45D.TEX-I::before{padding:.442em .503em .194em 0;content:"p"}mjx-c.mjx-c1D461.TEX-I::before{padding:.626em .361em .011em 0;content:"t"}mjx-mtext{display:inline-block;text-align:left}mjx-container[jax=CHTML]{line-height:0}mjx-container [space="1"]{margin-left:.111em}mjx-container [space="2"]{margin-left:.167em}mjx-container [space="3"]{margin-left:.222em}mjx-container [space="4"]{margin-left:.278em}mjx-container [space="5"]{margin-left:.333em}mjx-container [rspace="1"]{margin-right:.111em}mjx-container [rspace="2"]{margin-right:.167em}mjx-container [rspace="3"]{margin-right:.222em}mjx-container [rspace="4"]{margin-right:.278em}mjx-container [rspace="5"]{margin-right:.333em}mjx-container [size="s"]{font-size:70.7%}mjx-container [size=ss]{font-size:50%}mjx-container [size=Tn]{font-size:60%}mjx-container [size=sm]{font-size:85%}mjx-container [size=lg]{font-size:120%}mjx-container [size=Lg]{font-size:144%}mjx-container [size=LG]{font-size:173%}mjx-container [size=hg]{font-size:207%}mjx-container [size=HG]{font-size:249%}mjx-container [width=full]{width:100%}mjx-box{display:inline-block}mjx-block{display:block}mjx-itable{display:inline-table}mjx-row{display:table-row}mjx-row>*{display:table-cell}mjx-mtext{display:inline-block}mjx-mstyle{display:inline-block}mjx-merror{display:inline-block;color:red;background-color:#ff0}mjx-mphantom{visibility:hidden}mjx-assistive-mml{top:0;left:0;clip:rect(1px,1px,1px,1px);user-select:none;position:absolute!important;padding:1px 0 0!important;border:0!important;display:block!important;width:auto!important;overflow:hidden!important}mjx-assistive-mml[display=block]{width:100%!important}mjx-math{display:inline-block;text-align:left;line-height:0;text-indent:0;font-style:normal;font-weight:400;font-size:100%;font-size-adjust:none;letter-spacing:normal;border-collapse:collapse;overflow-wrap:normal;word-spacing:normal;white-space:nowrap;direction:ltr;padding:1px 0}mjx-container[jax=CHTML][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=CHTML][display=true][width=full]{display:flex}mjx-container[jax=CHTML][display=true] mjx-math{padding:0}mjx-container[jax=CHTML][justify=left]{text-align:left}mjx-container[jax=CHTML][justify=right]{text-align:right}mjx-msup{display:inline-block;text-align:left}mjx-mi{display:inline-block;text-align:left}mjx-c{display:inline-block}mjx-utext{display:inline-block;padding:.75em 0 .2em}mjx-texatom{display:inline-block;text-align:left}mjx-mo{display:inline-block;text-align:left}mjx-stretchy-h{display:inline-table;width:100%}mjx-stretchy-h>*{display:table-cell;width:0}mjx-stretchy-h>*>mjx-c{display:inline-block;transform:scaleX(1)}mjx-stretchy-h>*>mjx-c::before{display:inline-block;width:initial}mjx-stretchy-h>mjx-ext{overflow:clip visible;width:100%}mjx-stretchy-h>mjx-ext>mjx-c::before{transform:scaleX(500)}mjx-stretchy-h>mjx-ext>mjx-c{width:0}mjx-stretchy-h>mjx-beg>mjx-c{margin-right:-.1em}mjx-stretchy-h>mjx-end>mjx-c{margin-left:-.1em}mjx-stretchy-v{display:inline-block}mjx-stretchy-v>*{display:block}mjx-stretchy-v>mjx-beg{height:0}mjx-stretchy-v>mjx-end>mjx-c{display:block}mjx-stretchy-v>*>mjx-c{transform:scaleY(1);transform-origin:left center;overflow:hidden}mjx-stretchy-v>mjx-ext{display:block;height:100%;box-sizing:border-box;border:0 solid transparent;overflow:visible clip}mjx-stretchy-v>mjx-ext>mjx-c::before{width:initial;box-sizing:border-box}mjx-stretchy-v>mjx-ext>mjx-c{transform:scaleY(500) translateY(.075em);overflow:visible}mjx-mark{display:inline-block;height:0}mjx-c::before{display:block;width:0}.MJX-TEX{font-family:MJXZERO,MJXTEX}.TEX-B{font-family:MJXZERO,MJXTEX-B}.TEX-I{font-family:MJXZERO,MJXTEX-I}.TEX-MI{font-family:MJXZERO,MJXTEX-MI}.TEX-BI{font-family:MJXZERO,MJXTEX-BI}.TEX-S1{font-family:MJXZERO,MJXTEX-S1}.TEX-S2{font-family:MJXZERO,MJXTEX-S2}.TEX-S3{font-family:MJXZERO,MJXTEX-S3}.TEX-S4{font-family:MJXZERO,MJXTEX-S4}.TEX-A{font-family:MJXZERO,MJXTEX-A}.TEX-C{font-family:MJXZERO,MJXTEX-C}.TEX-CB{font-family:MJXZERO,MJXTEX-CB}.TEX-FR{font-family:MJXZERO,MJXTEX-FR}.TEX-FRB{font-family:MJXZERO,MJXTEX-FRB}.TEX-SS{font-family:MJXZERO,MJXTEX-SS}.TEX-SSB{font-family:MJXZERO,MJXTEX-SSB}.TEX-SSI{font-family:MJXZERO,MJXTEX-SSI}.TEX-SC{font-family:MJXZERO,MJXTEX-SC}.TEX-T{font-family:MJXZERO,MJXTEX-T}.TEX-V{font-family:MJXZERO,MJXTEX-V}.TEX-VB{font-family:MJXZERO,MJXTEX-VB}mjx-stretchy-h mjx-c,mjx-stretchy-v mjx-c{font-family:MJXZERO,MJXTEX-S1,MJXTEX-S4,MJXTEX,MJXTEX-A!important}@font-face{font-family:MJXZERO;src:url("lib/fonts/mathjax_zero.woff") format("woff")}@font-face{font-family:MJXTEX;src:url("lib/fonts/mathjax_main-regular.woff") format("woff")}@font-face{font-family:MJXTEX-B;src:url("lib/fonts/mathjax_main-bold.woff") format("woff")}@font-face{font-family:MJXTEX-I;src:url("lib/fonts/mathjax_math-italic.woff") format("woff")}@font-face{font-family:MJXTEX-MI;src:url("lib/fonts/mathjax_main-italic.woff") format("woff")}@font-face{font-family:MJXTEX-BI;src:url("lib/fonts/mathjax_math-bolditalic.woff") format("woff")}@font-face{font-family:MJXTEX-S1;src:url("lib/fonts/mathjax_size1-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S2;src:url("lib/fonts/mathjax_size2-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S3;src:url("lib/fonts/mathjax_size3-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S4;src:url("lib/fonts/mathjax_size4-regular.woff") format("woff")}@font-face{font-family:MJXTEX-A;src:url("lib/fonts/mathjax_ams-regular.woff") format("woff")}@font-face{font-family:MJXTEX-C;src:url("lib/fonts/mathjax_calligraphic-regular.woff") format("woff")}@font-face{font-family:MJXTEX-CB;src:url("lib/fonts/mathjax_calligraphic-bold.woff") format("woff")}@font-face{font-family:MJXTEX-FR;src:url("lib/fonts/mathjax_fraktur-regular.woff") format("woff")}@font-face{font-family:MJXTEX-FRB;src:url("lib/fonts/mathjax_fraktur-bold.woff") format("woff")}@font-face{font-family:MJXTEX-SS;src:url("lib/fonts/mathjax_sansserif-regular.woff") format("woff")}@font-face{font-family:MJXTEX-SSB;src:url("lib/fonts/mathjax_sansserif-bold.woff") format("woff")}@font-face{font-family:MJXTEX-SSI;src:url("lib/fonts/mathjax_sansserif-italic.woff") format("woff")}@font-face{font-family:MJXTEX-SC;src:url("lib/fonts/mathjax_script-regular.woff") format("woff")}@font-face{font-family:MJXTEX-T;src:url("lib/fonts/mathjax_typewriter-regular.woff") format("woff")}@font-face{font-family:MJXTEX-V;src:url("lib/fonts/mathjax_vector-regular.woff") format("woff")}@font-face{font-family:MJXTEX-VB;src:url("lib/fonts/mathjax_vector-bold.woff") format("woff")}mjx-c.mjx-c1D447.TEX-I::before{padding:.677em .704em 0 0;content:"T"}mjx-c.mjx-c1D450.TEX-I::before{padding:.442em .433em .011em 0;content:"c"}mjx-c.mjx-c2C::before{padding:.121em .278em .194em 0;content:","}mjx-c.mjx-c2E::before{padding:.12em .278em 0 0;content:"."}</style><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="In Search of an Understandable Consensus Algorithm(Extended Version)"><p dir="auto">In Search of an Understandable Consensus Algorithm(Extended Version)</p></h1><div class="el-p"><p dir="auto"><a href="?query=tag:distributed" class="tag" target="_blank" rel="noopener nofollow">#distributed</a> <a href="?query=tag:raft" class="tag" target="_blank" rel="noopener nofollow">#raft</a></p></div><div class="el-p"><p dir="auto">寻找一种可理解的一致性算法(拓展版)</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="作者：斯坦福大学的Diego Ongaro和John Ousterhout" dir="auto" class="heading" id="作者：斯坦福大学的Diego_Ongaro和John_Ousterhout"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>作者：斯坦福大学的Diego Ongaro和John Ousterhout</h5><div class="heading-children"></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="Abstract(摘要)" dir="auto" class="heading" id="Abstract(摘要)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Abstract(摘要)</h2><div class="heading-children"><div class="el-p"><p dir="auto">Raft is a consensus algorithm for managing a replicated log.<br>
It produces a result equivalent to (multi-)Paxos, and it is as efficient as Paxos, but its structure is different from Paxos;<br>
this makes Raft more understandable than Paxos and also provides a better foundation for building practical systems.<br>
In order to enhance understandability, Raft separates the key elements of consensus,<br>
such as leader election, log replication, and safety,<br>
and it enforces a stronger degree of coherency to reduce the number of states that must be considered.<br>
Results from a user study demonstrate that Raft is easier for students to learn than Paxos.<br>
Raft also includes a new mechanism for changing the cluster membership, which uses overlapping majorities to guarantee safety.</p></div><div class="el-p"><p dir="auto">Raft是一种用于管理复制日志的一致性算法。<br>
其和(multi-)Paxos算法作用相同，并且和Paxos一样高效，但其结构与Paxos不同；这使得Raft比起Paxos更容易理解同时也为构建实际可行的系统提供了一个更好的基础。<br>
为了让Raft更容易理解，Raft拆分了有关一致性的关键元素，例如leader选举，日志复制以及安全性等，并通过增强一致性的程度以减少必须被考虑的状态数量。<br>
用户的研究成果表示Raft比起Paxos要更容易让学生进行学习。<br>
Raft还包含了一个改变集群成员的新机制，其使用重叠的大多数(overlapping majorities)来保证安全。</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="1 Introduction(介绍)" dir="auto" class="heading" id="1_Introduction(介绍)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1 Introduction(介绍)</h2><div class="heading-children"><div class="el-p"><p dir="auto">Consensus algorithms allow a collection of machines to work as a coherent group that can survive the failures of some of its members.<br>
Because of this, they play a key role in building reliable large-scale software systems.<br>
Paxos has dominated the discussion of consensus algorithms over the last decade:<br>
most implementations of consensus are based on Paxos or influenced by it,<br>
and Paxos has become the primary vehicle used to teach students about consensus.</p></div><div class="el-p"><p dir="auto">一致性算法允许一个机器的集群作为一个具有一致性的组来进行工作，使得在一些成员出现故障时集群依然能正常工作。<br>
正因为如此，在构建可靠的大规模软件系统时其起到了关键的作用。<br>
Paxos主导了过去十年中关于一致性算法的讨论：<br>
大多数的一致性的实现都给予Paxos或者受其影响，并且Paxos成为了教导学生一致性相关知识的主要工具。</p></div><div class="el-p"><p dir="auto">Unfortunately, Paxos is quite difficult to understand, in spite of numerous attempts to make it more approachable.<br>
Furthermore, its architecture requires complex changes to support practical systems.<br>
As a result, both system builders and students struggle with Paxos.</p></div><div class="el-p"><p dir="auto">不幸的是，Paxos相当难理解，尽管很多人试图让其变得更易理解。<br>
此外，为了支持实际的系统其架构需要进行复杂的改变。<br>
因此，所有的系统构建者和学生都在于Paxos进行斗争。</p></div><div class="el-p"><p dir="auto">After struggling with Paxos ourselves,<br>
we set out to find a new consensus algorithm that could provide a better foundation for system building and education.<br>
Our approach was unusual in that our primary goal was understandability:<br>
could we define a consensus algorithm for practical systems and describe it in a way that is significantly easier to learn than Paxos?<br>
Furthermore, we wanted the algorithm to facilitate the development of intuitions that are essential for system builders.<br>
It was important not just for the algorithm to work, but for it to be obvious why it works.</p></div><div class="el-p"><p dir="auto">在与Paxos斗争后，我们开始着手去寻找一种新的一致性算法，其能够为构建系统和教育提供更好的支持。<br>
我们的方法是不同寻常的，因为我们的主要目标是(增进)可理解性：我们可以为实际的系统定义一个一致性算法并以比Paxos更容易学习的方式去描述它吗？<br>
此外，我们希望该算法能够促进直觉的发展，这对系统构建者来说是必要的。<br>
重要的不仅仅是算法是如何工作的，理解算法为什么能工作也很重要。</p></div><div class="el-p"><p dir="auto">The result of this work is a consensus algorithm called Raft.<br>
In designing Raft we applied specific techniques to improve understandability,<br>
including decomposition (Raft separates leader election, log replication, and safety)<br>
and state space reduction (relative to Paxos, Raft reduces the degree of nondeterminism and the ways servers can be inconsistent with each other).<br>
A user study with 43 students at two universities shows that Raft is significantly easier to understand than Paxos:<br>
after learning both algorithms, 33 of these students were able to answer questions about Raft better than questions about Paxos.</p></div><div class="el-p"><p dir="auto">这项工作的成果是一个名为Raft的一致性算法。<br>
在设计Raft时，我们应用了特别的技术来改善可理解性，包括分解(Raft将leader选举，日志复制和安全性进行了分解)<br>
以及状态空间的缩减(相对于Paxos，Raft缩减了不确定性的程度以及服务器之间彼此不一致的方式)。<br>
一项对两所大学中的43名学生的调查显示Raft比Paxos容易理解的多：在学习了两种算法后，相比回答Paxos相关问题，其中33名学生能更好的回答关于Raft的问题。</p></div><div class="el-p"><p dir="auto">Raft is similar in many ways to existing consensus algorithms (most notably, Oki and Liskov’s Viewstamped Replication),<br>
but it has several novel features:</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>Strong leader:</strong> Raft uses a stronger form of leadership than other consensus algorithms.<br>
For example, log entries only flow from the leader to other servers.<br>
This simplifies the management of the replicated log and makes Raft easier to understand.</li>
<li data-line="3" dir="auto"><strong>Leader election:</strong> Raft uses randomized timers to elect leaders.<br>
This adds only a small amount of mechanism to the heartbeats already required for any consensus algorithm,<br>
while resolving conflicts simply and rapidly.</li>
<li data-line="6" dir="auto"><strong>Membership changes:</strong> Raft’s mechanism for changing the set of servers in the cluster uses a new joint consensus approach<br>
where the majorities of two different configurations overlap during transitions.<br>
This allows the cluster to continue operating normally during configuration changes.</li>
</ul></div><div class="el-p"><p dir="auto">Raft与已有的一致性算法在很多方面都很相似(尤其是Oki和Liskov的Viewstamped Replication算法)，但Raft有几个新颖的功能：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>Strong leader:</strong> Raft使用比其它一致性算法更强力的leader。<br>
举个例子，日志条目仅从leader流向其它服务器。这简化了被复制日志的管理并且使得Raft更加容易被理解。</li>
<li data-line="2" dir="auto"><strong>Leader election:</strong> Raft使用随机计时器来选举leader。<br>
这只在任何一致性算法都需要的心跳检测中增加了少量机制，同时简单且快速的解决冲突。</li>
<li data-line="4" dir="auto"><strong>Membership changes:</strong> Raft用于改变集群中服务器集合的机制使用了一种新的联合的一致性方法，其中两个不同配置的多数在过渡期间是重叠的。<br>
这允许集群在配置改变时继续正常工作。</li>
</ul></div><div class="el-p"><p dir="auto">We believe that Raft is superior to Paxos and other consensus algorithms, both for educational purposes and as a foundation for implementation.<br>
It is simpler and more understandable than other algorithms;<br>
it is described completely enough to meet the needs of a practical system;<br>
it has several open-source implementations and is used by several companies;<br>
its safety properties have been formally specified and proven; and its efficiency is comparable to other algorithms.</p></div><div class="el-p"><p dir="auto">我们认为，无论是处于教育的目的还是作为实际(系统)的实现，Raft都是胜过Paxos和其它一致性算法的。<br>
它比其它算法更加简单和容易理解；<br>
它被详细的描述使得其足以满足实际系统的需要；<br>
它有着几个开源的实现并且被几家公司所使用；<br>
它的安全性已经被正式的认定和证明；并且它的效率与其它算法相当。</p></div><div class="el-p"><p dir="auto">The remainder of the paper introduces the replicated state machine problem (Section 2),<br>
discusses the strengths and weaknesses of Paxos (Section 3),<br>
describes our general approach to understandability (Section 4),<br>
presents the Raft consensus algorithm (Sections 5–8),<br>
evaluates Raft (Section 9), and discusses related work (Section 10).</p></div><div class="el-p"><p dir="auto">本文的剩余部分介绍了复制状态机问题(第2节)，<br>
讨论了Paxos的优缺点(第3节)，<br>
描述了我们使算法易于理解的一般性方法(第4节)，<br>
提出了Raft一致性算法(第5-8节)，<br>
评估了Raft(第9节)，并且讨论了相关的工作(第10节)。</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="2 Replicated state machines(复制状态机)" dir="auto" class="heading" id="2_Replicated_state_machines(复制状态机)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2 Replicated state machines(复制状态机)</h2><div class="heading-children"><div class="el-p"><p dir="auto">Consensus algorithms typically arise in the context of replicated state machines.<br>
In this approach, state machines on a collection of servers compute identical copies of the same state<br>
and can continue operating even if some of the servers are down.<br>
Replicated state machines are used to solve a variety of fault tolerance problems in distributed systems.<br>
For example, large-scale systems that have a single cluster leader, such as GFS, HDFS, and RAMCloud,<br>
typically use a separate replicated state machine to manage leader election and store configuration information<br>
that must survive leader crashes.<br>
Examples of replicated state machines include Chubby and ZooKeeper.</p></div><div class="el-p"><p dir="auto">一致性算法是在复制状态机的背景下产生的。<br>
在这个方法中，服务器集合中的状态机在具有相同状态的完全一致的副本上进行计算，并且即使一些服务器已经宕机也能够持续的工作。<br>
复制状态机被用于在分布式系统中解决一系列的容错问题。<br>
举个例子，有着一个单独集群leader的大规模系统，例如GFS，HDFS以及RAMCloud，通常使用一个单独的复制状态机来管理leader选举和存储在leader崩溃后所必须的配置信息。<br>
复制状态机的例子包括Chubby和ZooKeeper。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240725172940.png" src="Pasted image 20240725172940.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240725172940.png" src="computer-science/distributed-system/raft-原始论文中英/pasted-image-20240725172940.png"></span></p></div><div class="el-p"><p dir="auto">Figure 1: Replicated state machine architecture.<br>
The consensus algorithm manages a replicated log containing state machine commands from clients.<br>
The state machines process identical sequences of commands from the logs, so they produce the same outputs.</p></div><div class="el-p"><p dir="auto">图1：复制状态机的架构。<br>
一致性算法管理包含了来自客户端的状态机指令的复制日志。<br>
状态机以完全相同的顺序处理来自日志的指令，因此它们会产生相同的输出。</p></div><div class="el-p"><p dir="auto">Replicated state machines are typically implemented using a replicated log, as shown in Figure 1.<br>
Each server stores a log containing a series of commands, which its state machine executes in order.<br>
Each log contains the same commands in the same order, so each state machine processes the same sequence of commands.<br>
Since the state machines are deterministic, each computes the same state and the same sequence of outputs.</p></div><div class="el-p"><p dir="auto">复制状态机通常使用复制log(replicated log)来实现，如图1所示。<br>
每个服务器存储着一个包含一系列指令的日志，这些指令在状态机上被顺序执行。<br>
每个日志中包含了以相同顺序排布的相同的指令，因此每个状态机都处理相同的指令序列。<br>
因为状态机是确定性的，每一个状态机都计算出相同的状态以及有着相同的输出序列。</p></div><div class="el-p"><p dir="auto">Keeping the replicated log consistent is the job of the consensus algorithm.<br>
The consensus module on a server receives commands from clients and adds them to its log.<br>
It communicates with the consensus modules on other servers to ensure that every log eventually contains<br>
the same requests in the same order, even if some servers fail.<br>
Once commands are properly replicated, each server’s state machine processes them in log order,<br>
and the outputs are returned to clients.<br>
As a result, the servers appear to form a single, highly reliable state machine.</p></div><div class="el-p"><p dir="auto">保持复制日志的一致性是一致性算法的工作。<br>
服务器中的一致性模块接受来自客户端的指令并且将其加入日志。<br>
它与其它服务器的一致性模块进行通信以确保每一个日志最终以同样的顺序包含同样的请求，即使其中一些服务器故障了。<br>
一旦指令被正确的复制，每一个服务器的状态机都按照日志中的顺序处理这些指令，并将输出返回给客户端。<br>
因此，服务器的集合似乎形成了一个单独的，高度可靠的状态机。</p></div><div class="el-p"><p dir="auto">Consensus algorithms for practical systems typically have the following properties:</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">They ensure safety (never returning an incorrect result) under all non-Byzantine conditions,<br>
including network delays, partitions, and packet loss, duplication, and reordering.</li>
<li data-line="2" dir="auto">They are fully functional (available) as long as any majority of the servers are operational<br>
and can communicate with each other and with clients.<br>
Thus, a typical cluster of five servers can tolerate the failure of any two servers.<br>
Servers are assumed to fail by stopping; they may later recover from state on stable storage and rejoin the cluster.</li>
<li data-line="6" dir="auto">They do not depend on timing to ensure the consistency of the logs:<br>
faulty clocks and extreme message delays can, at worst, cause availability problems.</li>
<li data-line="8" dir="auto">In the common case, a command can complete as soon as a majority of the cluster has responded to a single round of remote procedure calls;<br>
a minority of slow servers need not impact overall system performance.</li>
</ul></div><div class="el-p"><p dir="auto">实际系统中的一致性算法通常具有以下属性：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">它们确保在所有非拜占庭条件下的安全性(永远不返回错误结果)，(非拜占庭条件)包括网络延迟，分区，和丢包，重复以及重新排序。</li>
<li data-line="1" dir="auto">只要大多数服务器能够正常工作并且能够与其它服务器以及客户端互相通信，一致性算法就能发挥其全部的功能(可用性)。<br>
因此，一个典型的有着5台服务器组成的集群能够容忍任意两台服务器出现故障。<br>
假设服务器因为故障而停机；他们可以稍后从稳定的存储状态中恢复并重新加入集群。</li>
<li data-line="4" dir="auto">他们不依赖时间来确保日志的一致性：错误的时钟和极端的消息延迟在最坏的情况下会造成可用性问题。</li>
<li data-line="5" dir="auto">通常情况下，只要集群中的大多数对单轮的远过程调用做出了响应，命令就可以完成。占少数的慢速服务器不会对系统整体性能造成影响。</li>
</ul></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="3 What’s wrong with Paxos?(Paxos存在的问题)" dir="auto" class="heading" id="3_What’s_wrong_with_Paxos?(Paxos存在的问题)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3 What’s wrong with Paxos?(Paxos存在的问题)</h2><div class="heading-children"><div class="el-p"><p dir="auto">Over the last ten years, Leslie Lamport’s Paxos protocol has become almost synonymous with consensus:<br>
it is the protocol most commonly taught in courses, and most implementations of consensus use it as a starting point.<br>
Paxos first defines a protocol capable of reaching agreement on a single decision, such as a single replicated log entry.<br>
We refer to this subset as single-decree Paxos.<br>
Paxos then combines multiple instances of this protocol to facilitate a series of decisions such as a log (multi-Paxos).<br>
Paxos ensures both safety and liveness, and it supports changes in cluster membership.<br>
Its correctness has been proven, and it is efficient in the normal case.</p></div><div class="el-p"><p dir="auto">在过去的十年中，Leslie Lamport的Paxos协议几乎已经成为了一致性算法的代名词：<br>
它是课堂教学中最常用的协议，大多数的一致性算法也将其作为起点。<br>
Paxos首先定义了一个协议，其能够就单个决定达成一致，例如单个日志条目的复制。<br>
我们将这一自己称为single-decree Paxos。<br>
然后Paxos将该协议的多个实例组合起来以达成一系列的决定，例如日志(multi-Paxos)。<br>
Paxos同时保证了安全性和活性，并且支持集群成员的变更。<br>
其正确性已经得到证明，并且在通常情况下是高效的。</p></div><div class="el-p"><p dir="auto">Unfortunately, Paxos has two significant drawbacks.<br>
The first drawback is that Paxos is exceptionally difficult to understand.<br>
The full explanation is notoriously opaque; few people succeed in understanding it, and only with great effort.<br>
As a result, there have been several attempts to explain Paxos in simpler terms.<br>
These explanations focus on the single-decree subset, yet they are still challenging.<br>
In an informal survey of attendees at NSDI 2012, we found few people who were comfortable with Paxos, even among seasoned researchers.<br>
We struggled with Paxos ourselves;<br>
we were not able to understand the complete protocol until after reading several simplified explanations<br>
and designing our own alternative protocol, a process that took almost a year.</p></div><div class="el-p"><p dir="auto">不幸的是，Paxos有着两个明显的缺点。<br>
第一个缺点是Paxos异乎寻常的难理解。<br>
Paxos出了名的难理解，即使在付出了巨大努力的情况下，也很少有人能成功的理解它。<br>
因此，有一些人尝试着用更简单的方式来理解Paxos。<br>
这些解释聚焦于single-decree这一子集，但这仍具有挑战性。<br>
在一项针对NSDI 2012与会者的非正式调查中，我们发现很少有人对Paxos感到满意，即使对于经验丰富的研究员来说也是如此。<br>
我们也与Paxos进行了艰难的斗争；直到阅读了几个简化的解释并设计了我们自己的替代方案后我们才能够理解完整的协议，而这个过程花费了将近一年的时间。</p></div><div class="el-p"><p dir="auto">We hypothesize that Paxos’ opaqueness derives from its choice of the single-decree subset as its foundation.<br>
Single-decree Paxos is dense and subtle:<br>
it is divided into two stages that do not have simple intuitive explanations and cannot be understood independently.<br>
Because of this, it is difficult to develop intuitions about why the single-decree protocol works.<br>
The composition rules for multi-Paxos add significant additional complexity and subtlety.<br>
We believe that the overall problem of reaching consensus on multiple decisions (i.e., a log instead of a single entry)<br>
can be decomposed in other ways that are more direct and obvious.</p></div><div class="el-p"><p dir="auto">我们猜定Paxos晦涩难懂的原因在于作者选择以single-decree这一子集作为Paxos的基础。<br>
Single-decree Paxos是难理解和精巧的：<br>
它被分为了两个阶段，并且没有简单直接的说明，每一阶段也无法单独的理解。<br>
正因如此，很难凭借直觉的理解single-decree协议为什么能够工作。<br>
multi-Paxos的组合规则也显著的增加了复杂性和微妙之处。<br>
我们认为，就多个决定达成一致的总体问题(例如，使用日志而不是单个的entry)能够被分解为其它更直接和更容易理解的方式。</p></div><div class="el-p"><p dir="auto">The second problem with Paxos is that it does not provide a good foundation for building practical implementations.<br>
One reason is that there is no widely agreed-upon algorithm for multi-Paxos.<br>
Lamport’s descriptions are mostly about single-decree Paxos;<br>
he sketched possible approaches to multi-Paxos, but many details are missing.<br>
There have been several attempts to flesh out and optimize Paxos, such as [26], [39], and [13],<br>
but these differ from each other and from Lamport’s sketches.<br>
Systems such as Chubby [4] have implemented Paxos-like algorithms, but in most cases their details have not been published.</p></div><div class="el-p"><p dir="auto">Paxos的第二个问题是它没有为构建实际可行的实现提供一个好的基础。<br>
其中一个原因是对于multi-Paxos没有一个被广泛认同的算法。<br>
Lamport的描述大多数都是关于single-decree Paxos的；他简要的概述了实现multi-Paxos的可行的方法，但缺失了很多的细节。<br>
已经有几个(团队)试图去具体化和优化Paxos，例如[26],[39]和[13],但这些尝试彼此间不同且也不同于Lamport的概述。<br>
像Chubby系统已经实现了类似Paxos的算法，但大多数情况下的细节并没有被公开。</p></div><div class="el-p"><p dir="auto">Furthermore, the Paxos architecture is a poor one for building practical systems;<br>
this is another consequence of the single-decree decomposition.<br>
For example, there is little benefit to choosing a collection of log entries independently and then melding them into a sequential log;<br>
this just adds complexity.<br>
It is simpler and more efficient to design a system around a log,<br>
where new entries are appended sequentially in a constrained order.<br>
Another problem is that Paxos uses a symmetric peer-to-peer approach at its core<br>
(though it eventually suggests a weak form of leadership as a performance optimization).<br>
This makes sense in a simplified world where only one decision will be made, but few practical systems use this approach.<br>
If a series of decisions must be made, it is simpler and faster to first elect a leader, then have the leader coordinate the decisions.</p></div><div class="el-p"><p dir="auto">此外，Paxos的架构在构建实际的系统时表现不佳；这是对single-decree进行分解的另一个结果。<br>
例如，选择一组独立的日志集合并将其合并到一个顺序日志中几乎没有带来什么好处；这只会增加复杂性。<br>
围绕日志来设计系统会更简单和更高效，其中新的日志条目以受约束的顺序追加。<br>
另一个问题是，Paxos使用了一种对称的点对点(P2P)方法作为其核心(尽管最后提出了一种更弱形式的leadership作为性能优化)。<br>
在一个只需要做一次决定的，被简化的世界中这样是行得通的，但很少有实际的系统使用这个方式。<br>
如果有一系列的决定必须要做，首先选举出一个leader，然后leader来协调决策会更简单和更快速。</p></div><div class="el-p"><p dir="auto">As a result, practical systems bear little resemblance to Paxos.<br>
Each implementation begins with Paxos, discovers the difficulties in implementing it,<br>
and then develops a significantly different architecture.<br>
This is time-consuming and error-prone, and the difficulties of understanding Paxos exacerbate the problem.<br>
Paxos’ formulation may be a good one for proving theorems about its correctness,<br>
but real implementations are so different from Paxos that the proofs have little value.</p></div><div class="el-p"><p dir="auto">The following comment from the Chubby implementers is typical:<br>
<em>There are significant gaps between the description of the Paxos algorithm<br>
and the needs of a real-world system. . . . the final system will be based on an unproven protocol [4].</em></p></div><div class="el-p"><p dir="auto">因此，实际的系统与Paxos几乎没有相似之处。<br>
每一个实现都从Paxos出发，发现实现Paxos的困难之处，然后开发出一个与之截然不同的架构。<br>
这既耗费时间又容易出错，并且Paxos的晦涩难懂加剧了这一问题。<br>
Paxos的公式可能可以很好的证明其正确性，但是实际的实现与Paxos是如此的不同，以至于这些证明几乎毫无价值。</p></div><div class="el-p"><p dir="auto">以下Chubby实现者的评论是具有代表性的：<br>
<em>Paxos算法的描述与现实世界系统的需求之间有着巨大的鸿沟....最终的系统将建立在一个未被证明的协议之上。</em></p></div><div class="el-p"><p dir="auto">Because of these problems, we concluded that Paxos does not provide a good foundation either for system building or for education.<br>
Given the importance of consensus in large-scale software systems,<br>
we decided to see if we could design an alternative consensus algorithm with better properties than Paxos.<br>
Raft is the result of that experiment.</p></div><div class="el-p"><p dir="auto">由于这些问题，我们的结论是Paxos并没有为构建系统或是进行教育提供一个好的基础。<br>
考虑到一致性在大规模软件系统中的重要性，我们决定看看我们是否可以设计出一个比起Paxos有着更好特性的一致性算法。<br>
Raft正是这一实验的成果。</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="4 Designing for understandability(为通俗易懂而设计)" dir="auto" class="heading" id="4_Designing_for_understandability(为通俗易懂而设计)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4 Designing for understandability(为通俗易懂而设计)</h2><div class="heading-children"><div class="el-p"><p dir="auto">We had several goals in designing Raft: it must provide a complete and practical foundation for system building,<br>
so that it significantly reduces the amount of design work required of developers;<br>
it must be safe under all conditions and available under typical operating conditions; and it must be efficient for common operations.<br>
But our most important goal—and most difficult challenge—was understandability.<br>
It must be possible for a large audience to understand the algorithm comfortably.<br>
In addition, it must be possible to develop intuitions about the algorithm,<br>
so that system builders can make the extensions that are inevitable in real-world implementations.</p></div><div class="el-p"><p dir="auto">我们在设计Raft时有几个目标：它必须为构建系统提供一个完整的和实际的基础，从而显著的减少开发者设计时所需的工作；<br>
它必须在任何条件下都是安全的并且在典型的工作状态下是可用的；同时它必须在通常工作状态下是高效的。<br>
但我们最重要的目标也是最困难的挑战是使得Raft通俗易懂。<br>
必须尽可能的使大多数人能够轻松的理解该算法。<br>
这样系统构建者才能够在现实世界的实现中进行不可避免的拓展。</p></div><div class="el-p"><p dir="auto">There were numerous points in the design of Raft where we had to choose among alternative approaches.<br>
In these situations we evaluated the alternatives based on understandability:<br>
how hard is it to explain each alternative (for example, how complex is its state space,<br>
and does it have subtle implications?), and how easy will it be for a reader to completely understand the approach and its implications?</p></div><div class="el-p"><p dir="auto">在设计Raft时有很多要点都必须在多个可选方案中抉择。<br>
在这些情况下，我们基于易懂性来评估这些可选方案：<br>
对于每一个可选方案解释起来有多困难(例如，状态空间有多复杂以及是否有微妙的含义？)，以及对于一个读者来说完全理解这个方法和其含义有多容易？</p></div><div class="el-p"><p dir="auto">We recognize that there is a high degree of subjectivity in such analysis; nonetheless, we used two techniques that are generally applicable.<br>
The first technique is the well-known approach of problem decomposition:<br>
wherever possible, we divided problems into separate pieces that could be solved, explained, and understood relatively independently.<br>
For example, in Raft we separated leader election, log replication, safety, and membership changes.</p></div><div class="el-p"><p dir="auto">我们意识到这一分析方式具有高度的主观性；尽管如此，但我们还是使用了两种可行的通用技术。<br>
第一个技术是众所周知的问题分解方法：<br>
在可能的情况下，我们将问题分解为几个部分，使得每一部分都可以被相对独立的解决，解释和理解。<br>
例如，我们将Raft分解为leader选举，日志复制，安全性和成员变更这几个部分。</p></div><div class="el-p"><p dir="auto">Our second approach was to simplify the state space by reducing the number of states to consider,<br>
making the system more coherent and eliminating nondeterminism where possible.<br>
Specifically, logs are not allowed to have holes, and Raft limits the ways in which logs can become inconsistent with each other.<br>
Although in most cases we tried to eliminate nondeterminism, there are some situations where nondeterminism actually improves understandability.<br>
In particular, randomized approaches introduce nondeterminism,<br>
but they tend to reduce the state space by handling all possible choices in a similar fashion(“choose any; it doesn’t matter”).<br>
We used randomization to simplify the Raft leader election algorithm.</p></div><div class="el-p"><p dir="auto">我们的第二种方法是通过减少需要考虑的状态数量以简化状态空间，使系统变得更加连贯并尽可能的消除不确定性。<br>
特别的，日志是不允许存在空洞的，并且Raft限制了使得日志间变得彼此不一致的方式。<br>
尽管在大多数情况下我们试图消除不确定性，但在一些条件下不确定性实际上能提高可理解性。<br>
特别的，随机化方法引入了不确定性，但它们倾向于通过用相似的方式来处理所有可能的选择以减少状态空间("选择任意一个;具体是哪一个则无关紧要")。<br>
我们使用随机化来简化Raft中的leader选举算法。</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="5. The Raft consensus algorithm(Raft一致性算法)" dir="auto" class="heading" id="5._The_Raft_consensus_algorithm(Raft一致性算法)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5. The Raft consensus algorithm(Raft一致性算法)</h2><div class="heading-children"><div class="el-p"><p dir="auto">Raft is an algorithm for managing a replicated log of the form described in Section 2.<br>
Figure 2 summarizes the algorithm in condensed form for reference, and Figure 3 lists key properties of the algorithm;<br>
the elements of these figures are discussed piecewise over the rest of this section.</p></div><div class="el-p"><p dir="auto">Raft是一种管理如第二节所述的复制日志的算法。<br>
图2以简明扼要的总结了算法以供参考，图3列举出了算法的关键特性；这些图中的元素将在本节剩余的部分中进行讨论。</p></div><div class="el-p"><p dir="auto">Raft implements consensus by first electing a distinguished leader,<br>
then giving the leader complete responsibility for managing the replicated log.<br>
The leader accepts log entries from clients,<br>
replicates them on other servers, and tells servers when it is safe to apply log entries to their state machines.<br>
Having a leader simplifies the management of the replicated log.<br>
For example, the leader can decide where to place new entries in the log without consulting other servers,<br>
and data flows in a simple fashion from the leader to other servers.<br>
A leader can fail or become disconnected from the other servers, in which case a new leader is elected.</p></div><div class="el-p"><p dir="auto">Raft通过受限选举出一位distinguished leader，然后让它全权的管理复制日志以实现一致性。<br>
这个leader接受来自客户端的日志条目，将其复制到其它服务器中，并且在日志条目可以被安全的应用在它们的状态机上时通知这些服务器。<br>
拥有一个leader可以简化对复制日志的管理。<br>
例如，leader可以决定新日志条目的位置而无需咨询其它服务器，并且数据流以一种简单的形式由leader流向其它服务器。<br>
leader可能会故障或者与其它服务器失联，这种情况下一位新的leader将会被选举出来。</p></div><div class="el-p"><p dir="auto">Given the leader approach, Raft decomposes the consensus problem into three relatively independent sub-problems,<br>
which are discussed in the subsections that follow:</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>Leader election:</strong> a new leader must be chosen when an existing leader fails (Section 5.2).</li>
<li data-line="1" dir="auto"><strong>Log replication:</strong> the leader must accept log entries from clients and replicate them across the cluster,<br>
forcing the other logs to agree with its own (Section 5.3).</li>
<li data-line="3" dir="auto"><strong>Safety:</strong> the key safety property for Raft is the State Machine Safety Property in Figure 3:<br>
if any server has applied a particular log entry to its state machine,<br>
then no other server may apply a different command for the same log index.<br>
Section 5.4 describes how Raft ensures this property;<br>
the solution involves an additional restriction on the election mechanism described in Section 5.2.</li>
</ul></div><div class="el-p"><p dir="auto">After presenting the consensus algorithm, this section discusses the issue of availability and the role of timing in the system.</p></div><div class="el-p"><p dir="auto">通过引入leader的方法，Raft将一致性问题分解为3个相对独立的子问题，这些子问题将在以下子章节中被讨论：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>leader选举：</strong> 当一位现存的leader故障时必须选出一位新的leader(5.2节)。</li>
<li data-line="1" dir="auto"><strong>日志复制：</strong> leader必须从客户端接收日志条目并且在集群中复制它们，并且强制其它节点的日志与leader保持一致(5.3节)。</li>
<li data-line="2" dir="auto"><strong>安全性：</strong> Raft的关键安全特性就是图3中的状态机的安全特性：如果任一服务器已经将一个特定的日志条目作用于它的状态机，则没有任何服务器可以对相同的日志索引应用不同的指令。<br>
5.4节描述了Raft是如何确保这一特性的；这一解决方案涉及到对5.2节中所描述的选举机制的额外限制。</li>
</ul></div><div class="el-p"><p dir="auto">在展示了一致性算法后，本章节还将讨论可用性问题以及时序在系统中起到的作用。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240725172955.png" src="Pasted image 20240725172955.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240725172955.png" src="computer-science/distributed-system/raft-原始论文中英/pasted-image-20240725172955.png"></span></p></div><div class="el-p"><p dir="auto">A condensed summary of the Raft consensus algorithm (excluding membership changes and log compaction).<br>
The server behavior in the upper-left box is described as a set of rules that trigger independently and repeatedly.<br>
Section numbers such as §5.2 indicate where particular features are discussed.<br>
A formal specification [31] describes the algorithm more precisely.</p></div><div class="el-p"><p dir="auto">关于Raft一致性算法的精简摘要(不包括成员变更和日志压缩)。<br>
左上方框内所描述的服务器行为被描述为一系列独立和重复触发的规则。<br>
章节编号例如§5.2标识了具体讨论该特定功能的章节。<br>
形式化规约以更精确的方式描述该算法。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240725173009.png" src="Pasted image 20240725173009.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240725173009.png" src="computer-science/distributed-system/raft-原始论文中英/pasted-image-20240725173009.png"></span></p></div><div class="el-p"><p dir="auto">Figure 3: Raft guarantees that each of these properties is true at all times.<br>
The section numbers indicate where each property is discussed.</p></div><div class="el-p"><p dir="auto">图3：Raft保证每一个特性在任何时候都是成立的、名副其实的。<br>
章节号标识着每一个特性被讨论的具体章节。</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="5.1 Raft basics(Raft基础)" dir="auto" class="heading" id="5.1_Raft_basics(Raft基础)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.1 Raft basics(Raft基础)</h3><div class="heading-children"><div class="el-p"><p dir="auto">A Raft cluster contains several servers; five is a typical number, which allows the system to tolerate two failures.<br>
At any given time each server is in one of three states: leader, follower, or candidate.<br>
In normal operation there is exactly one leader and all of the other servers are followers.<br>
Followers are passive: they issue no requests on their own but simply respond to requests from leaders and candidates.<br>
The leader handles all client requests (if a client contacts a follower, the follower redirects it to the leader).<br>
The third state, candidate, is used to elect a new leader as described in Section 5.2.<br>
Figure 4 shows the states and their transitions; the transitions are discussed below.</p></div><div class="el-p"><p dir="auto">一个Raft的集群包含几个服务器;通常是5个节点，这样的系统能容忍系统中的2个节点出现故障。<br>
在任一给定的时间内，每个服务器只会处于3种状态中的一种：领导者(leader),追随者(follower)，或者候选者(candidate)。<br>
在通常情况下，只会有1个leader并且其它的服务器都是follower。<br>
Follower都是被动的: 它们自己不会提出请求而只会简单的响应来自leader和candidate的请求。<br>
leader处理所有来自客户端的请求(如果一个客户端与follower进行联络，follower会将其重定向到leader)。<br>
第三种状态，candidate，用于选举出一个如5.2章节所描述的新leader。<br>
图4展示了状态以及状态间的转换关系；转换关系将在下文被讨论。</p></div><div class="el-p"><p dir="auto">Raft divides time into terms of arbitrary length, as shown in Figure 5.<br>
Terms are numbered with consecutive integers.<br>
Each term begins with an election, in which one or more candidates attempt to become leader as described in Section 5.2.<br>
If a candidate wins the election, then it serves as leader for the rest of the term.<br>
In some situations an election will result in a split vote.<br>
In this case the term will end with no leader; a new term (with a new election) will begin shortly.<br>
Raft ensures that there is at most one leader in a given term.</p></div><div class="el-p"><p dir="auto">Raft将时间分割为任意长度的任期(term)，如图5所示。<br>
任期由连续的整数进行编号。<br>
每一个任期都以一次选举开始，其中一个或更多的candidate试图成为leader(如5.2节中所描述的)。<br>
如果一个candidate赢得了选举，然后它将在余下的任期中作为leader。<br>
在一些情况下一次选举可能会导致分裂的投票结果。<br>
在这种情况下，任期将在没有leader的情况下结束; 一个新的任期(伴随者一个新的选举)将很快开始。<br>
Raft保证了在一个给定的任期内最多只会有一个leader。</p></div><div class="el-p"><p dir="auto"><img src="https://img2023.cnblogs.com/blog/1506329/202307/1506329-20230713200905466-706345890.png" referrerpolicy="no-referrer"></p></div><div class="el-p"><p dir="auto">Figure 4: Server states. Followers only respond to requests from other servers.<br>
If a follower receives no communication, it becomes a candidate and initiates an election.<br>
A candidate that receives votes from a majority of the full cluster becomes the new leader.<br>
Leaders typically operate until they fail.</p></div><div class="el-p"><p dir="auto">图4：服务器状态。<br>
follower只能响应来自其它服务器的请求。<br>
如果follower没有收到通信，它将成为一名candidate并且初始化一场选举。<br>
一位candidate收到了来自整个集群中的大多数投票则成为新的leader。<br>
leader通常持续工作直到它们发生故障。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240725173021.png" src="Pasted image 20240725173021.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240725173021.png" src="computer-science/distributed-system/raft-原始论文中英/pasted-image-20240725173021.png"></span></p></div><div class="el-p"><p dir="auto">Figure 5: Time is divided into terms, and each term begins with an election.<br>
After a successful election, a single leader manages the cluster until the end of the term.<br>
Some elections fail, in which case the term ends without choosing a leader.<br>
The transitions between terms may be observed at different times on different servers.</p></div><div class="el-p"><p dir="auto">图5：时间以任期进行划分，每一个任期都以一次选举开始。<br>
在成功的选举之后，一个leader管理集群直到任期结束。<br>
有些选举失败了，在这种情况下任期结束时并没有选出一个leader。<br>
可以在不同服务器的不同时间上观察到任期的转换。</p></div><div class="el-p"><p dir="auto">Different servers may observe the transitions between terms at different times,<br>
and in some situations a server may not observe an election or even entire terms.<br>
Terms act as a logical clock [14] in Raft, and they allow servers to detect obsolete information such as stale leaders.<br>
Each server stores a current term number, which increases monotonically over time.<br>
Current terms are exchanged whenever servers communicate;<br>
if one server’s current term is smaller than the other’s, then it updates its current term to the larger value.<br>
If a candidate or leader discovers that its term is out of date, it immediately reverts to follower state.<br>
If a server receives a request with a stale term number, it rejects the request.</p></div><div class="el-p"><p dir="auto">不同服务器可能会在不同的时间上观察到任期之间的状态转换，并且在一些情况下一个服务器可能不会观察到一次选举甚至整个任期。<br>
任期在Raft中充当逻辑时钟，并且它们允许服务器检测到过时的信息比如之前的、老leader。<br>
每一个服务器存储了一个当前任期的编号，其随着时间单调增加。<br>
每当服务器之间互相通信时，它们都会互相交换当前的任期(编号);如果一个服务器的当前任期(编号)小于其它的服务器，则其将会将当前的任期(编号)更新为那个更大的值。<br>
如果一个candidate或者leader发现它们的任期(编号)已经过时，它将立即将自己恢复为follower的状态。<br>
如果一个服务器接受到一个带有过时任期编号的请求，它将拒绝这一请求。</p></div><div class="el-p"><p dir="auto">Raft servers communicate using remote procedure calls(RPCs), and the basic consensus algorithm requires only two types of RPCs.<br>
RequestVote RPCs are initiated by candidates during elections (Section 5.2),<br>
and AppendEntries RPCs are initiated by leaders to replicate log entries and to provide a form of heartbeat (Section 5.3).<br>
Section 7 adds a third RPC for transferring snapshots between servers.<br>
Servers retry RPCs if they do not receive a response in a timely manner, and they issue RPCs in parallel for best performance.</p></div><div class="el-p"><p dir="auto">Raft服务器使用远过程调用(RPC)进行通信，并且基本的一致性算法只需要两种类型的RPC。<br>
请求投票的RPC由candidate在选举期间发起(第5.2节)，拓展条目的RPC由leader发起，用于日志条目的复制以及提供心跳机制(第5.3节)。<br>
第7节加入了第三种RPC用于在服务器间传输快照。<br>
如果服务器在给定的时间内没有收到响应，则会对RPC进行重试，并且它们会发起并行的rpc以获得最好的性能。</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="5.2 Leader election(leader选举)" dir="auto" class="heading" id="5.2_Leader_election(leader选举)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.2 Leader election(leader选举)</h3><div class="heading-children"><div class="el-p"><p dir="auto">Raft uses a heartbeat mechanism to trigger leader election. When servers start up, they begin as followers.<br>
A server remains in follower state as long as it receives valid RPCs from a leader or candidate.<br>
Leaders send periodic heartbeats (AppendEntries RPCs that carry no log entries) to all followers in order to maintain their authority.<br>
If a follower receives no communication over a period of time called the election timeout,<br>
then it assumes there is no viable leader and begins an election to choose a new leader.</p></div><div class="el-p"><p dir="auto">Raft使用心跳机制来触发leader选举。当服务器启动时，它们会成为follower。<br>
只要服务器能从leader或者candidate处接收到有效的RPC请求，它们就将保持follower状态。<br>
leader向所有follower发送周期性的心跳(不携带日志条目的AppendEntries RPC)来维持它的权威性。<br>
如果一个follower在一段被成为选举超时的时间段内未接收到任何通信，则它假设当前没有可用的leader并且发起选举来选择一个新的leader。</p></div><div class="el-p"><p dir="auto">To begin an election, a follower increments its current term and transitions to candidate state.<br>
It then votes for itself and issues RequestVote RPCs in parallel to each of the other servers in the cluster.<br>
A candidate continues in this state until one of three things happens:<br>
(a) it wins the election,<br>
(b) another server establishes itself as leader, or<br>
(c) a period of time goes by with no winner.<br>
These outcomes are discussed separately in the paragraphs below.</p></div><div class="el-p"><p dir="auto">为了开始一轮选举，follower增加它当前的任期值并且转换为candidate状态。<br>
然后它将选票投给它自己并且向集群中的其它服务器并行的发起请求投票的RPC(RequestVote RPCs)。<br>
一个candidate会一直保持这种状态直到以下三种情况之一发生：<br>
(a) 它赢得此次选举 (b) 另一个服务器将自己确认为leader，或者 (c) 一段时间后没有产生胜利者。<br>
下文中的各个段落将分别讨论这些结果。</p></div><div class="el-p"><p dir="auto">A candidate wins an election if it receives votes from a majority of the servers in the full cluster for the same term.<br>
Each server will vote for at most one candidate in a given term, on a first-come-first-served basis<br>
(note: Section 5.4 adds an additional restriction on votes).<br>
The majority rule ensures that at most one candidate can win the election for a particular term (the Election Safety Property in Figure 3).<br>
Once a candidate wins an election, it becomes leader.<br>
It then sends heartbeat messages to all of the other servers to establish its authority and prevent new elections.</p></div><div class="el-p"><p dir="auto">如果一个candidate在同一个任期内接收到了整个集群中大多数服务器的投票，其将赢得这次选举。<br>
每个服务器在给定的某一任期内将会基于先来先服务的原则(first-come-first-served)投票给至多一位candidate(第5.4节对投票增加了额外的限制)。<br>
多数规则确保了对于一个特定的任期，最多只会有一名candidate能够赢得选举(图3中选举的安全特性)。<br>
一旦一个candidate赢得了一次选举，它将成为leader。<br>
然后它向其它服务器发送心跳信息以建立权威并且阻止新的选举。</p></div><div class="el-p"><p dir="auto">While waiting for votes, a candidate may receive an AppendEntries RPC from another server claiming to be leader.<br>
If the leader’s term (included in its RPC) is at least as large as the candidate’s current term,<br>
then the candidate recognizes the leader as legitimate and returns to follower state.<br>
If the term in the RPC is smaller than the candidate’s current term, then the candidate rejects the RPC and continues in candidate state.</p></div><div class="el-p"><p dir="auto">在等待投票时，一个candidate可能会接受到来自自称是leader的其它服务器的AppendEntries RPC。<br>
如果leader的任期(包含在它的RPC中)大于或等于candidate的当前任期，那么candidate承认该leader是合法的并且返回到follower状态。<br>
如果RPC中的任期小于candidate的当前任期，candidate将会拒绝这一RPC并且继续保持candidate的状态。</p></div><div class="el-p"><p dir="auto">The third possible outcome is that a candidate neither wins nor loses the election:<br>
if many followers become candidates at the same time, votes could be split so that no candidate obtains a majority.<br>
When this happens, each candidate will time out and start a new election by incrementing its term<br>
and initiating another round of RequestVote RPCs.<br>
However, without extra measures split votes could repeat indefinitely.</p></div><div class="el-p"><p dir="auto">第三种可能的结果是一个candidate既没有赢得选举也没有输掉选举：<br>
如果许多follower都在同一时间成为了candidate，投票可能会被瓜分导致没有candidate获得大多数的选票。<br>
当这种情况发生时，每一个candidate都将会超时并且通过增加它的任期值并且初始化另一轮的RequestVote RPCs以开始一轮新的选举。<br>
然而，如果不采取额外的措施，分裂的投票可能会无限的重复。</p></div><div class="el-p"><p dir="auto">Raft uses randomized election timeouts to ensure that split votes are rare and that they are resolved quickly.<br>
To prevent split votes in the first place, election timeouts are chosen randomly from a fixed interval (e.g., 150–300ms).<br>
This spreads out the servers so that in most cases only a single server will time out;<br>
it wins the election and sends heartbeats before any other servers time out.<br>
The same mechanism is used to handle split votes.<br>
Each candidate restarts its randomized election timeout at the start of an election, and it waits for that timeout to elapse before<br>
starting the next election; this reduces the likelihood of another split vote in the new election.<br>
Section 9.3 shows that this approach elects a leader rapidly.</p></div><div class="el-p"><p dir="auto">Raft使用随机化的选举超时时间来确保分裂的投票很少会发生并使得它们能够被迅速的解决。<br>
为了防止一开始就出现分裂的投票，选举的超时时间是从一个固定的间隔中被随机选取的(例如150-300ms)。<br>
这打散了服务器使得在大多数情况下只有单独一个服务器将会超时；它赢得选举并且在其它服务器超时之前发送心跳(译者注：超时后自己就会在别的服务器没反应过来前发起新一轮任期更大的投票，让别人都投给它来赢得选举)。<br>
同样的机制也被用于解决分裂的投票。<br>
每个candidate在一轮选举开始时会重新随机的设置其选举超时时间，并且在下一轮选举前等待直到超时；这减少了在新的选举中再一次出现分裂投票的可能性。<br>
第9.3节展示了该方法能迅速的选举出一个leader。</p></div><div class="el-p"><p dir="auto">Elections are an example of how understandability guided our choice between design alternatives.<br>
Initially we planned to use a ranking system: each candidate was assigned a unique rank, which was used to select between competing candidates.<br>
If a candidate discovered another candidate with higher rank,<br>
it would return to follower state so that the higher ranking candidate could more easily win the next election.<br>
We found that this approach created subtle issues around availability<br>
(a lower-ranked server might need to time out and become a candidate again if a higher-ranked server fails,<br>
but if it does so too soon, it can reset progress towards electing a leader).<br>
We made adjustments to the algorithm several times, but after each adjustment new corner cases appeared.<br>
Eventually we concluded that the randomized retry approach is more obvious and understandable.</p></div><div class="el-p"><p dir="auto">选举是一个可理解性如何指导我们在可选设计间进行选择的例子。<br>
最初，我们计划使用等级系统(ranking system)：每一个candidate都被分配一个唯一的等级，其用于在彼此竞争的candidate做选择。<br>
如果一个candidate发现了一个具有更高等级的candidate，它将返回到follower状态因此更好等级的candidate将更容易赢得下一次选举。<br>
但我们发现这个方法在可用性方面存在微妙的问题(如果一个高等级的服务器故障了，则一个低等级的服务器可能需要超时并再次成为candidate，但如果这样做的太早，它将会重置选举leader的进度)。<br>
我们对算法进行了数次调整，但每次调整后都出现了新的困境。<br>
最终我们得出结论，随机化重试的方法更直观且更容易被理解。</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="5.3 Log replication(日志复制)" dir="auto" class="heading" id="5.3_Log_replication(日志复制)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.3 Log replication(日志复制)</h3><div class="heading-children"><div class="el-p"><p dir="auto">Once a leader has been elected, it begins servicing client requests.<br>
Each client request contains a command to be executed by the replicated state machines.<br>
The leader appends the command to its log as a new entry,<br>
then issues AppendEntries RPCs in parallel to each of the other servers to replicate the entry.<br>
When the entry has been safely replicated (as described below),<br>
the leader applies the entry to its state machine and returns the result of that execution to the client.<br>
If followers crash or run slowly, or if network packets are lost,<br>
the leader retries AppendEntries RPCs indefinitely (even after it has responded to the client)<br>
until all followers eventually store all log entries.</p></div><div class="el-p"><p dir="auto">一旦一个leader被选举出来，它将开始服务于客户端的请求。<br>
每一个客户端的请求都包含了一个被用于在复制状态机上执行的指令。<br>
leader将指令作为一个新的条目追加到其日志中，然后向其它的每个服务器发起并行的AppendEntries RPC令它们复制这一条目。<br>
当条目已被安全的被复制(如下所述)，leader在它的状态机上应用这一条目并且将执行的结果返回给客户端。<br>
如果follower崩溃了或者运行的很慢，或者网络丢包，leader会无限的重试AppendEntries RPC(即使在响应了客户端的请求之后)，<br>
直到所有的follower最终都存储了所有的日志条目。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240725173038.png" src="Pasted image 20240725173038.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240725173038.png" src="computer-science/distributed-system/raft-原始论文中英/pasted-image-20240725173038.png"></span></p></div><div class="el-p"><p dir="auto">Figure 6: Logs are composed of entries, which are numbered sequentially.<br>
Each entry contains the term in which it was created (the number in each box) and a command for the state machine.<br>
An entry is considered committed if it is safe for that entry to be applied to state machines.</p></div><div class="el-p"><p dir="auto">图6：日志由按照顺序编号的条目组成。<br>
每一个条目都包含它被创建时的任期(框中的数字)以及用于状态机的指令。<br>
如果条目已经安全的被作用于状态机，则该条目被视为已提交。</p></div><div class="el-p"><p dir="auto">Logs are organized as shown in Figure 6.<br>
Each log entry stores a state machine command along with the term number when the entry was received by the leader.<br>
The term numbers in log entries are used to detect inconsistencies between logs and to ensure some of the properties in Figure 3.<br>
Each log entry also has an integer index identifying its position in the log.</p></div><div class="el-p"><p dir="auto">日志如图6所示的方式被组织。<br>
每一个日志条目存储了一个状态机的指令，以及从leader处接受条目时的任期编号。<br>
日志条目中的任期编号被用于检测日志间的不一致，并且用于保证图3中的一些特性。<br>
每个日志条目也有一个整数的索引标识其在日志中的位置。</p></div><div class="el-p"><p dir="auto">The leader decides when it is safe to apply a log entry to the state machines; such an entry is called committed.<br>
Raft guarantees that committed entries are durable and will eventually be executed by all of the available state machines.<br>
A log entry is committed once the leader that created the entry has replicated it on a majority of the servers (e.g., entry 7 in Figure 6).<br>
This also commits all preceding entries in the leader’s log, including entries created by previous leaders.<br>
Section 5.4 discusses some subtleties when applying this rule after leader changes,<br>
and it also shows that this definition of commitment is safe.<br>
The leader keeps track of the highest index it knows to be committed,<br>
and it includes that index in future AppendEntries RPCs (including heartbeats) so that the other servers eventually find out.<br>
Once a follower learns that a log entry is committed, it applies the entry to its local state machine (in log order).</p></div><div class="el-p"><p dir="auto">leader决定何时能安全的在状态机上应用日志条目；这样的条目被称作已提交的日志。<br>
Raft保证已提交的条目都会被持久化并且最终将会在所有可用的状态机上被执行。<br>
一旦被创建的条目被大多数服务器所复制，leader就会将其提交(例如，图6中的条目7)。<br>
同时也会提交leader日志中更早之前的所有条目，其中包括被前任leader们所创建的条目。<br>
第5.4节讨论了在leader变更时应用这一规则的微妙之处，同时它也证明了所承诺的定义是安全的。<br>
leader持续的跟踪它已知的被提交日志的最大索引值，并且将索引值包含在未来的AppendEntries RPC中(包括心跳)，以便其它的服务器最终能知道(最大编号的已提交索引)。<br>
一旦一个follower知道一个日志条目已被提交，它便将这一条目应用于本地的状态机(基于日志的顺序)。</p></div><div class="el-p"><p dir="auto">We designed the Raft log mechanism to maintain a high level of coherency between the logs on different servers.<br>
Not only does this simplify the system’s behavior and make it more predictable, but it is an important component of ensuring safety.<br>
Raft maintains the following properties, which together constitute the Log Matching Property in Figure 3:</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">If two entries in different logs have the same index and term, then they store the same command.</li>
<li data-line="1" dir="auto">If two entries in different logs have the same index and term, then the logs are identical in all preceding entries.</li>
</ul></div><div class="el-p"><p dir="auto">我们设计了Raft日志机制，其用于维持不同服务器之间日志的高度一致。<br>
其不仅仅简化了系统的行为，还使得它更加的可预测，同时这也是确保安全性的重要部分。<br>
Raft维护着以下特性，这些特性一并组成了图3中的日志匹配特性(Log Matching Property)：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">如果不同日志中的两个条目有着相同的索引值和任期，则它们存储着相同的指令。</li>
<li data-line="1" dir="auto">如果不同日志中的两个条目有着相同的索引值和任期，则该日志之前的所有条目也都是完全相同的。</li>
</ul></div><div class="el-p"><p dir="auto">The first property follows from the fact that a leader creates at most one entry with a given log index in a given term,<br>
and log entries never change their position in the log.<br>
The second property is guaranteed by a simple consistency check performed by AppendEntries.<br>
When sending an AppendEntries RPC, the leader includes the index and term of the entry in its log that immediately precedes the new entries.<br>
If the follower does not find an entry in its log with the same index and term, then it refuses the new entries.<br>
The consistency check acts as an induction step: the initial empty state of the logs satisfies the Log Matching Property,<br>
and the consistency check preserves the Log Matching Property whenever logs are extended.<br>
As a result, whenever AppendEntries returns successfully,<br>
the leader knows that the follower’s log is identical to its own log up through the new entries.</p></div><div class="el-p"><p dir="auto">第一个特性源自这样一个事实，即一个leader只会在特定任期内的某一索引值下最多只会创建一个条目，并且日志条目在日志中的位置是永远不会改变的。<br>
第二个特性则由AppendEntries执行一个简单的一致性检查来保证。<br>
当发送AppendEntries RPC时，leader将前一个条目的索引和任期包含在新条目中。<br>
如果follower没有找到一个具有相同索引值和任期的日志条目，则它将拒绝这一新条目。<br>
一致性检查就像一个归纳的步骤:初始化时的空状态满足日志匹配的特性(Log Matching Property)，并且每当扩展日志时，一致性检查都会维持日志匹配的特性。<br>
因此，每当AppendEntries返回成功时，通过新的条目leader就知道follower的日志与leader自己的是完全一致的，</p></div><div class="el-p"><p dir="auto">During normal operation, the logs of the leader and followers stay consistent,<br>
so the AppendEntries consistency check never fails.<br>
However, leader crashes can leave the logs inconsistent (the old leader may not have fully replicated all of the entries in its log).<br>
These inconsistencies can compound over a series of leader and follower crashes.<br>
Figure 7 illustrates the ways in which followers’ logs may differ from that of a new leader.<br>
A follower may be missing entries that are present on the leader, it may have extra entries that are not present on the leader, or both.<br>
Missing and extraneous entries in a log may span multiple terms.</p></div><div class="el-p"><p dir="auto">在正常操作期间，leader和follower的日志始终保持一致，因此AppendEntries的一致性检查从来不会失败。<br>
然而，leader奔溃会导致日志的不一致(老的leader可能没有将它所有的日志条目完全复制完成)。<br>
这些不一致可能会随着一系列的leader和follower的崩溃而加剧。<br>
图7说明了follower日志可能与新leader不同的方式。<br>
一个Follower可能缺少了之前leader中才有的条目，也可能拥有一些在新leader中不存在的额外的条目，或者这两种方式皆有。<br>
缺失的或者额外多出的条目可能涉及到多个任期。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240725173049.png" src="Pasted image 20240725173049.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240725173049.png" src="computer-science/distributed-system/raft-原始论文中英/pasted-image-20240725173049.png"></span></p></div><div class="el-p"><p dir="auto">Figure 7: When the leader at the top comes to power, it is possible that any of scenarios (a–f) could occur in follower logs.<br>
Each box represents one log entry; the number in the box is its term.<br>
A follower may be missing entries (a–b), may have extra uncommitted entries (c–d), or both (e–f).<br>
For example, scenario (f) could occur if that server was the leader for term 2, added several entries to its log,<br>
then crashed before committing any of them; it restarted quickly, became leader for term 3, and added a few more entries to its log;<br>
before any of the entries in either term 2 or term 3 were committed, the server crashed again and remained down for several terms.</p></div><div class="el-p"><p dir="auto">图7：当leader获得最高权力上台时，以下任何一种情况(a-f)都可能出现在follower的日志中。<br>
每一个框表示一个日志条目；框中的数字是它的任期。<br>
follower可能会缺少一些条目(a-b)，可能有一些额外的未提交的条目(c-d),或者两种情况皆有(e-f)。<br>
例如，如果一个服务器是任期2的leader，其增加了一些条目到它们的日志中，然后在提交这些日志条目之前崩溃了;<br>
它很快重新启动，成为了任期3的leader，并且增加了几个条目到它的日志中，在提交任期2或者任期3中的任何一个条目之前，这个服务器再次崩溃并且在后几个任期内一直处于停机状态，<br>
则会发生情况(f);</p></div><div class="el-p"><p dir="auto">In Raft, the leader handles inconsistencies by forcing the followers’ logs to duplicate its own.<br>
This means that conflicting entries in follower logs will be overwritten with entries from the leader’s log.<br>
Section 5.4 will show that this is safe when coupled with one more restriction.</p></div><div class="el-p"><p dir="auto">在Raft中，leader通过强制follower复制它的日志来处理不一致问题。<br>
这意味着follower中存在冲突的日志条目将会被来自leader的日志给覆盖。<br>
第5.4节将展示在加上一个限制时，这将会是安全的。</p></div><div class="el-p"><p dir="auto">To bring a follower’s log into consistency with its own, the leader must find the latest log entry where the two logs agree,<br>
delete any entries in the follower’s log after that point, and send the follower all of the leader’s entries after that point.<br>
All of these actions happen in response to the consistency check performed by AppendEntries RPCs.<br>
The leader maintains a nextIndex for each follower, which is the index of the next log entry the leader will send to that follower.<br>
When a leader first comes to power, it initializes all nextIndex values to the index just after the last one in its log (11 in Figure 7).<br>
If a follower’s log is inconsistent with the leader’s,<br>
the AppendEntries consistency check will fail in the next AppendEntries RPC.<br>
After a rejection, the leader decrements nextIndex and retries the AppendEntries RPC.<br>
Eventually nextIndex will reach a point where the leader and follower logs match.<br>
When this happens, AppendEntries will succeed,<br>
which removes any conflicting entries in the follower’s log and appends entries from the leader’s log (if any).<br>
Once AppendEntries succeeds, the follower’s log is consistent with the leader’s, and it will remain that way for the rest of the term.</p></div><div class="el-p"><p dir="auto">为了使得follower的日志与自己的保持一致，leader必须找到两个日志中一致的条目中最新的那个，<br>
删除follower日志中位于该点位之后的所有条目，并且将leader在该点位后的所有条目发送给follower。<br>
所有的这些动作都发生在对AppendEntries RPC的一致性检查工作的响应中。<br>
leader为每一个follower维护了一个nextIndex,这是leader将发送给follower的下一个日志条目的索引编号。<br>
当leader第一次掌权时，其将所有的nextIndex的值初始化为其最后一个日志索引值再加1(图7中的11)。<br>
如果follower的日志与leader的不一致，AppendEntries的一致性检查将会在下一次AppendEntries RPC中失败。<br>
在一次拒绝后，leader将会递减nextIndex并且重试AppendEntries RPC。<br>
最终nextIndex将会到达一个leader与follower的日志想匹配的点位。<br>
当这一情况发生时，AppendEntries将会成功，其将删除follower日志中的所有冲突的条目并且追加来自leader日志中的条目(如果需要的话)。<br>
一旦AppendEntries成功，follower的日志将会与leader一致，并且在本任期内接下来的时间内保持一致。</p></div><div class="el-p"><p dir="auto">If desired, the protocol can be optimized to reduce the number of rejected AppendEntries RPCs.<br>
For example, when rejecting an AppendEntries request,<br>
the follower can include the term of the conflicting entry and the first index it stores for that term.<br>
With this information, the leader can decrement nextIndex to bypass all of the conflicting entries in that term;<br>
one AppendEntries RPC will be required for each term with conflicting entries, rather than one RPC per entry.<br>
In practice, we doubt this optimization is necessary,<br>
since failures happen infrequently and it is unlikely that there will be many inconsistent entries.</p></div><div class="el-p"><p dir="auto">如果有需要的话，协议可以通过减少被拒绝的AppendEntries RPCs数量来进行优化。<br>
例如，当一次AppendEntries请求被拒绝时，follower可以将包含对应任期的冲突条目和存储了对应任期的第一个索引值返回给leader。<br>
有了这些信息，leader递减nextIndex来避开对应任期内的所有冲突的条目;对于每一个任期的冲突条目，将只需要一次AppendEntries RPC，而不是一次RPC(处理)一个条目。<br>
在实践中，我们怀疑这一优化是否是必要的，因为很少发生故障并且不太可能有很多不一致的条目。</p></div><div class="el-p"><p dir="auto">With this mechanism, a leader does not need to take any special actions to restore log consistency when it comes to power.<br>
It just begins normal operation, and the logs automatically converge in response to failures of the AppendEntries consistency check.<br>
A leader never overwrites or deletes entries in its own log (the Leader Append-Only Property in Figure 3).</p></div><div class="el-p"><p dir="auto">有了这一机制，leader将不需要在掌权时使用任何特别的方法来恢复日志的一致性。<br>
它只是开始进行正常的操作，日志便会在响应AppendEntries的一致性检查时自动的趋于一致。<br>
leader从来不会覆盖或者删除它自己的日志(图3中leader的Append-Only特性)。</p></div><div class="el-p"><p dir="auto">This log replication mechanism exhibits the desirable consensus properties described in Section 2:<br>
Raft can accept, replicate, and apply new log entries as long as a majority of the servers are up;<br>
in the normal case a new entry can be replicated with a single round of RPCs to a majority of the cluster;<br>
and a single slow follower will not impact performance.</p></div><div class="el-p"><p dir="auto">这一日志复制机制展示了第2节中所描述的理想的一致性特性。<br>
只要大多数服务器是在线的，Raft便能接收，复制并且应用新的日志条目；<br>
在正常情况下一个新的条目可以通过单轮的RPC复制到集群中的大多数服务器上;并且单独的慢速的follower将不会影响性能。</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="5.4 Safety(安全性)" dir="auto" class="heading" id="5.4_Safety(安全性)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.4 Safety(安全性)</h3><div class="heading-children"><div class="el-p"><p dir="auto">The previous sections described how Raft elects leaders and replicates log entries.<br>
However, the mechanisms described so far are not quite sufficient to ensure<br>
that each state machine executes exactly the same commands in the same order.<br>
For example, a follower might be unavailable while the leader commits several log entries,<br>
then it could be elected leader and overwrite these entries with new ones;<br>
as a result, different state machines might execute different command sequences.</p></div><div class="el-p"><p dir="auto">前面的章节描述了Raft是如何选举leader和复制日志条目的。<br>
然而，目前为止已描述的机制还不足以确保每一个状态机以相同的顺序准确地执行相同的指令。<br>
例如，当leader提交了几个日志条目后一个follower可能会变得不可用，随后follower可以被选举为leader并且用新的条目覆盖这些条目；<br>
因此，不同的状态机可能会执行不同的指令序列。</p></div><div class="el-p"><p dir="auto">This section completes the Raft algorithm by adding a restriction on which servers may be elected leader.<br>
The restriction ensures that the leader for any given term contains all of the entries committed in previous terms<br>
(the Leader Completeness Property from Figure 3).<br>
Given the election restriction, we then make the rules for commitment more precise.<br>
Finally, we present a proof sketch for the Leader Completeness Property<br>
and show how it leads to correct behavior of the replicated state machine.</p></div><div class="el-p"><p dir="auto">这一节通过增加一个对哪些服务器可以被选举为leader的限制来完善Raft算法。<br>
该限制确保leader对于给定的任期，其包含了所有之前任期的已提交条目（图3中的leader Completeness特性）。<br>
有了选举的限制，我们也使得关于提交的规则变得更加清晰。<br>
最后，我们给出了关于Leader Completeness的简要证明，并且展示了它是如何让复制状态机执行正确行为的。</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="5.4.1 Election restriction(选举限制)" dir="auto" class="heading" id="5.4.1_Election_restriction(选举限制)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.4.1 Election restriction(选举限制)</h3><div class="heading-children"><div class="el-p"><p dir="auto">In any leader-based consensus algorithm, the leader must eventually store all of the committed log entries.<br>
In some consensus algorithms, such as Viewstamped Replication [22],<br>
a leader can be elected even if it doesn’t initially contain all of the committed entries.<br>
These algorithms contain additional mechanisms to identify the missing entries and transmit them to the new leader,<br>
either during the election process or shortly afterwards.<br>
Unfortunately, this results in considerable additional mechanism and complexity.<br>
Raft uses a simpler approach where it guarantees<br>
that all the committed entries from previous terms are present on each new leader from the moment of its election,<br>
without the need to transfer those entries to the leader.<br>
This means that log entries only flow in one direction, from leaders to followers,<br>
and leaders never overwrite existing entries in their logs.</p></div><div class="el-p"><p dir="auto">在任何基于leader的一致性算法中，leader必须最终存储所有已提交的日志条目。<br>
在一些一致性算法中，例如Viewstamped Replication，一个leader即使最初不包含所有已提交的条目也能被选举为leader。<br>
这些算法包含了额外的机制来识别缺失的条目并在选举过程中或选举后不久将其传输给新的leader。<br>
不幸的是，这带来了非常多的额外机制和复杂性。<br>
Raft使用了一种更简单的方法来确保每一个新的leader当选时都拥有之前任期的所有已提交的条目，而无需传输这些条目给leader。<br>
这意味着日志条目只会单方向的从leader向follower流动，并且leader从不覆盖它们已存在的条目。</p></div><div class="el-p"><p dir="auto">Raft uses the voting process to prevent a candidate from winning an election unless its log contains all committed entries.<br>
A candidate must contact a majority of the cluster in order to be elected,<br>
which means that every committed entry must be present in at least one of those servers.<br>
If the candidate’s log is at least as up-to-date as any other log in that majority<br>
(where “up-to-date” is defined precisely below), then it will hold all the committed entries.<br>
The RequestVote RPC implements this restriction: the RPC includes information about the candidate’s log,<br>
and the voter denies its vote if its own log is more up-to-date than that of the candidate.</p></div><div class="el-p"><p dir="auto">Raft使用投票机制来防止不包含所有已提交条目的candidate赢得选举。<br>
一个candidate必须与集群中的大多数成员联系后才能当选，这意味着每个提交的条目必须至少存在于其中的至少一个服务器中。<br>
如果candidate的日志至少和其它大多数的日志一样新(何为"最新"(up-to-date)将在下面被定义)，则它将持有所有已提交的条目。<br>
RequestVote RPC中实现了之一限制：RPC包括了candidate的日志信息，并且如果candidate的日志不如投票人(voter)的日志新，则voter将拒绝投票给该candidate。</p></div><div class="el-p"><p dir="auto">Raft determines which of two logs is more up-to-date by comparing the index and term of the last entries in the logs.<br>
If the logs have last entries with different terms, then the log with the later term is more up-to-date.<br>
If the logs end with the same term, then whichever log is longer is more up-to-date.</p></div><div class="el-p"><p dir="auto">Raft通过比较两个日志中最后一个条目的索引和任期来决定谁是最新的。<br>
如果两个日志中最后的条目有着不同的任期，则任期较后的日志是更新的。<br>
如果两个日志中最后的条目有着相同的任期，则较长的(注：索引值更大的)那个日志是更新的。</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="5.4.2 Committing entries from previous terms(来自之前任期的已提交条目)" dir="auto" class="heading" id="5.4.2_Committing_entries_from_previous_terms(来自之前任期的已提交条目)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.4.2 Committing entries from previous terms(来自之前任期的已提交条目)</h3><div class="heading-children"><div class="el-p"><p dir="auto">As described in Section 5.3, a leader knows that an entry from its current term is committed once<br>
that entry is stored on a majority of the servers.<br>
If a leader crashes before committing an entry, future leaders will attempt to finish replicating the entry.<br>
However, a leader cannot immediately conclude that an entry from a previous term is committed once it is stored on a majority of servers.<br>
Figure 8 illustrates a situation where an old log entry is stored on a majority of servers,<br>
yet can still be overwritten by a future leader.</p></div><div class="el-p"><p dir="auto">如5.3节所描述的那样，leader一旦知道当前任期内的一个条目被存储在了大多数的服务器中，就会将其提交。<br>
如果leader在提交一个条目前崩溃了，未来的leader将试图去完成该条目的复制。<br>
然而，leader无法立即得出结论，即一个来自之前任期的条目一旦被大多数服务器所存储就是已被提交的。<br>
图8展示了这样一种情况，一个老的日志条目被存储在了大多数的服务器上，但任然被未来的leader覆盖掉了。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240725173101.png" src="Pasted image 20240725173101.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240725173101.png" src="computer-science/distributed-system/raft-原始论文中英/pasted-image-20240725173101.png"></span></p></div><div class="el-p"><p dir="auto">A time sequence showing why a leader cannot determine commitment using log entries from older terms.<br>
In(a) S1 is leader and partially replicates the log entry at index2.<br>
In (b) S1 crashes; S5 is elected leader for term 3 with votes from S3, S4, and itself, and accepts a different entry at log index 2.<br>
In (c) S5 crashes; S1 restarts, is elected leader, and continues replication.<br>
At this point, the log entry from term 2 has been replicated on a majority of the servers, but it is not committed.<br>
If S1 crashes as in (d), S5 could be elected leader (with votes from S2, S3, and S4) and overwrite the entry with its own entry from term 3.<br>
However, if S1 replicates an entry from its current term on a majority of the servers before crashing, as in (e),<br>
then this entry is committed (S5 cannot win an election).<br>
At this point all preceding entries in the log are committed as well.</p></div><div class="el-p"><p dir="auto">一个时间序列，展示了为什么leader不能使用来自旧任期的日志条目来决定是否已提交。(注：S1-S5是集群中的5台服务器，a-e是时间序列)<br>
在(a)中S1是leader并且部分的复制了位于index2的日志条目。<br>
在(b)中S1崩溃了;S5通过任期3中来自S3，S4和它自己的投票而被选举为leader，并且接受了一个不同的条目在日志index2。<br>
在(c)中S5崩溃了;S1重新启动，被选举为了leader，并且继续复制。<br>
在这个时间点，来自任期2的日志条目已经被复制到了大多数服务器中，但还没有被提交。<br>
如果S1像(d)中那样崩溃了，S5可以被选举为leader(通过来自S2，S3,和S4的投票)并且用它自己的来自任期3的条目进行覆盖。<br>
然而，如果S1在崩溃前复制了来自它当前任期的条目在大多数服务器中，就像(e),则这一条目是已提交的(S5不能赢得选举)。<br>
此时日志中所有之前的条目都已经被提交。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240725173109.png" src="Pasted image 20240725173109.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240725173109.png" src="computer-science/distributed-system/raft-原始论文中英/pasted-image-20240725173109.png"></span></p></div><div class="el-p"><p dir="auto">Figure 9: If S1 (leader for term T) commits a new log entry from its term, and S5 is elected leader for a later term U,<br>
then there must be at least one server (S3) that accepted the log entry and also voted for S5.</p></div><div class="el-p"><p dir="auto">图9：如果S1(任期T的leader)提交了已给来自它任期的新日志条目，并且S5在后面的任期U被选举为leader,<br>
则至少有一个服务器(S3)能够接收该日志条目并且也投票给S5。</p></div><div class="el-p"><p dir="auto">To eliminate problems like the one in Figure 8, Raft never commits log entries from previous terms by counting replicas.<br>
Only log entries from the leader’s current term are committed by counting replicas;<br>
once an entry from the current term has been committed in this way,<br>
then all prior entries are committed indirectly because of the Log Matching Property.<br>
There are some situations where a leader could safely conclude that an older log entry is committed<br>
(for example, if that entry is stored on every server), but Raft takes a more conservative approach for simplicity.</p></div><div class="el-p"><p dir="auto">为了消除像图8中那样的问题，Raft从来不基于副本数量来提交来自之前任期的日志条目。<br>
只有来自leader当前任期的日志条目才基于副本数量被提交，一旦一个来自当前任期的条目以这种方式被提交，则所有之前的条目都将由于Log Matching特性而间接的被提交。<br>
在一些情况下，leader可以安全的断定一个之前的log已经被提交(比如，如果一个entry已经被存储在每一个服务器上了)，但为了简单起见，Raft采取了一种更保守的方法。</p></div><div class="el-p"><p dir="auto">Raft incurs this extra complexity in the commitment rules because log entries retain their original term numbers<br>
when a leader replicates entries from previous terms.<br>
In other consensus algorithms, if a new leader re-replicates entries from prior “terms,” it must do so with its new “term number.”<br>
Raft’s approach makes it easier to reason about log entries, since they maintain the same term number over time and across logs.<br>
In addition, new leaders in Raft send fewer log entries from previous terms<br>
than in other algorithms (other algorithms must send redundant log entries to renumber them before they can be committed).</p></div><div class="el-p"><p dir="auto">Raft向提交规则中引入了额外的复杂性，因为当leader复制来自之前任期的条目时，这些日志条目会保留它原始的任期编号。<br>
在其它一致性算法中，如果一个新的leader要重新复制来自之前任期的条目，它必须使用新的任期编号。<br>
Raft的方法使得更容易理解日志条目，因为它们在不同服务器的日志中自始至终保留了相同的任期编号。<br>
额外的，相比其它算法，raft中的新leader会发送更少的来自之前任期的日志条目(其它算法必须发送冗余的日志条目以对让对应的日志条目在提交前重新进行编号)。</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="5.4.3 Safety argument(安全性参数)" dir="auto" class="heading" id="5.4.3_Safety_argument(安全性参数)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.4.3 Safety argument(安全性参数)</h3><div class="heading-children"><div class="el-p"><p dir="auto">Given the complete Raft algorithm,<br>
we can now argue more precisely that the Leader Completeness Property holds (this argument is based on the safety proof; see Section 9.2).<br>
We assume that the Leader Completeness Property does not hold, then we prove a contradiction.<br>
Suppose the leader for term T (leaderT) commits a log entry from its term, but that log entry is not stored by the leader of some future term.<br>
Consider the smallest term U &gt; T whose leader (leaderU) does not store the entry.</p></div><div class="el-p"><p dir="auto">在给出了完整的Raft算法后，我们可以更加准确的讨论leader的完整性(Completeness)特性是否成立了(这一讨论基于9.2节的安全性证明)。<br>
我们假设leader的Completeness特性不成立，则我们可以推到出矛盾来。<br>
假设任期T的leader(leaderT)提交了一个来自当前任期的日志条目，但该日志条目没有被未来某些任期的leader所存储。<br>
考虑一个大于T的最小任期U，其leader(leaderU)没有存储这个条目。</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">
<p>The committed entry must have been absent from leaderU’s log at the time of its election (leaders never delete or overwrite entries).</p>
</li>
<li data-line="1" dir="auto">
<p>leaderT replicated the entry on a majority of the cluster, and leaderU received votes from a majority of the cluster.<br>
Thus, at least one server (“the voter”) both accepted the entry from leaderT and voted for leaderU, as shown in Figure 9.<br>
The voter is key to reaching a contradiction.</p>
</li>
<li data-line="4" dir="auto">
<p>The voter must have accepted the committed entry from leaderT before voting for leaderU;<br>
otherwise it would have rejected the AppendEntries request from leaderT (its current term would have been higher than T).</p>
</li>
<li data-line="6" dir="auto">
<p>The voter still stored the entry when it voted for leaderU, since every intervening leader contained the entry (by assumption),<br>
leaders never remove entries, and followers only remove entries if they conflict with the leader.</p>
</li>
<li data-line="8" dir="auto">
<p>The voter granted its vote to leaderU, so leaderU’s log must have been as up-to-date as the voter’s.<br>
This leads to one of two contradictions.</p>
</li>
<li data-line="10" dir="auto">
<p>First, if the voter and leaderU shared the same last log term,<br>
then leaderU’s log must have been at least as long as the voter’s, so its log contained every entry in the voter’s log.<br>
This is a contradiction, since the voter contained the committed entry and leaderU was assumed not to.</p>
</li>
<li data-line="13" dir="auto">
<p>Otherwise, leaderU’s last log term must have been larger than the voter’s.<br>
Moreover, it was larger than T, since the voter’s last log term was at least T (it contains the committed entry from term T).<br>
The earlier leader that created leaderU’s last log entry must have contained the committed entry in its log (by assumption).<br>
Then, by the Log Matching Property, leaderU’s log must also contain the committed entry, which is a contradiction.</p>
</li>
<li data-line="17" dir="auto">
<p>This completes the contradiction. Thus, the leaders of all terms greater than T must contain all entries from term T<br>
that are committed in term T.</p>
</li>
<li data-line="19" dir="auto">
<p>The Log Matching Property guarantees that future leaders will also contain entries that are committed indirectly,<br>
such as index 2 in Figure 8(d).</p>
</li>
<li data-line="22" dir="auto">
<p>已提交的条目在leaderU当选时，必须不在leaderU的日志中(leader从来不会删除或者覆盖条目)。</p>
</li>
<li data-line="23" dir="auto">
<p>leaderT将对应条目复制到了集群中的大多数(服务器)中,并且leaderU获得了来自集群中的大多的选票。<br>
因此，至少有一个服务器(作为voter)同时接收到了来自leaderT的条目并且投票给了leaderU.如图9所示。该voter是达成矛盾的关键所在。</p>
</li>
<li data-line="25" dir="auto">
<p>voter必须在投票给leaderU之前接受来自leaderT的已提交的条目;<br>
否则其将拒绝来自leaderT的AppendEntries request(它当前的任期将已经高于T)。</p>
</li>
<li data-line="27" dir="auto">
<p>voter在投票给leaderU时依然存储了该条目，因为每一个介于其中的leader(任期位于T和U之间)都包含了该条目，<br>
leader从不移除条目，并且follower只移除与leader相冲突的条目。</p>
</li>
<li data-line="29" dir="auto">
<p>voter同意投票给leaderU,因此leaderU的日志必须至少与voter是一样新的。这带来了以下两个矛盾中的一个。</p>
</li>
<li data-line="30" dir="auto">
<p>首先，如果voter和leaderU的最后一个日志有着相同的任期，则leaderU的日志必须至少与voter一样长，<br>
因此leaderU的日志包含了voter日志中的每一个条目。<br>
这是矛盾的，因为voter包含了已提交的条目而leaderU被假设为没有包含。</p>
</li>
<li data-line="33" dir="auto">
<p>否则leaderU的最后一个日志的任期就必须比voter要大了。<br>
此外，任期的值也大于T，因为voter的最后一个日志的任期至少是T(其包含了来自任期T的所有已提交条目)。<br>
创建leaderU最后一个日志条目的更早的leader也必须包含这个日志(假设)。<br>
然后，基于Log Matching特性，leaderU的日志必须也包含已提交的条目，这是一个矛盾。</p>
</li>
<li data-line="37" dir="auto">
<p>这就终结了矛盾。因此，所有任期大于T的leader必须包含所有的任期T内的已提交条目。</p>
</li>
<li data-line="38" dir="auto">
<p>Log Matching特性保证了未来的leader也包含间接提交的日志，就像图8中的索引2。</p>
</li>
</ol></div><div class="el-p"><p dir="auto">Given the Leader Completeness Property, we can prove the State Machine Safety Property from Figure 3,<br>
which states that if a server has applied a log entry at a given index to its state machine,<br>
no other server will ever apply a different log entry for the same index.<br>
At the time a server applies a log entry to its state machine,<br>
its log must be identical to the leader’s log up through that entry and the entry must be committed.<br>
Now consider the lowest term in which any server applies a given log index;<br>
the Log Completeness Property guarantees that the leaders for all higher terms will store that same log entry,<br>
so servers that apply the index in later terms will apply the same value.<br>
Thus, the State Machine Safety Property holds.</p></div><div class="el-p"><p dir="auto">通过Leader Completeness特性，我们可以证明来自图3的State Machine Safety(安全状态机)特性，<br>
如果服务器将给定索引日志条目作用于状态机，其它的服务器将不能在相同的索引处应用不同的日志条目。<br>
一旦服务器应用了一个日志条目到其状态机上，其日志必须与传递该条目的leader的日志完全一样，并且这个条目必须被提交。<br>
现在考虑任一服务器应用给定日志索引的最小任期，Log Completeness特性保证了所有更高任期的leader将存储相同的日志条目，所以服务器在最晚任期所应用的索引将作用于相同的值。<br>
因此，State Machine Safety特性是成立的。</p></div><div class="el-p"><p dir="auto">Finally, Raft requires servers to apply entries in log index order.<br>
Combined with the State Machine Safety Property,<br>
this means that all servers will apply exactly the same set of log entries to their state machines, in the same order.</p></div><div class="el-p"><p dir="auto">最后，Raft要求服务器按照日志索引的顺序应用日志条目。<br>
结合State Machine Safety特性，这意味着所有的服务器将精确的以相同的顺序为它们的状态机应用一个相同的日志条目集合。</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="5.5 Follower and candidate crashes(follower和candidate崩溃)" dir="auto" class="heading" id="5.5_Follower_and_candidate_crashes(follower和candidate崩溃)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.5 Follower and candidate crashes(follower和candidate崩溃)</h3><div class="heading-children"><div class="el-p"><p dir="auto">Until this point we have focused on leader failures.<br>
Follower and candidate crashes are much simpler to handle than leader crashes, and they are both handled in the same way.<br>
If a follower or candidate crashes, then future RequestVote and AppendEntries RPCs sent to it will fail.<br>
Raft handles these failures by retrying indefinitely; if the crashed server restarts, then the RPC will complete successfully.<br>
If a server crashes after completing an RPC but before responding, then it will receive the same RPC again after it restarts.<br>
Raft RPCs are idempotent, so this causes no harm.<br>
For example, if a follower receives an AppendEntries request that includes log entries already present in its log,<br>
it ignores those entries in the new request.</p></div><div class="el-p"><p dir="auto">在此之前我们一直聚焦于leader出故障的情况。<br>
follower和candidate的崩溃比起leader的崩溃会更加容易处理，并且它们都以相同的方式被处理。<br>
如果一个follower或者candidate崩溃了，则未来发送给它的投票请求(RequestVote)和AppendEntries RPC的发送将会失败。<br>
Raft通过无限的重试来处理这些失败，如果已崩溃的服务器重启了，则RPC将会成功的完成。<br>
如果服务器在完成了一个RPC但是在进行响应之前崩溃了，则它将会在重启后再一次接受到相同的RPC。<br>
Raft的RPC是幂等的，所以这不会有问题。<br>
例如，如果一个follower接受到的一个AppendEntries请求中包含的日志条目已经在它自己的日志中了，该follower就会在这次新的请求中忽略掉这些条目。</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="5.6 Timing and availability(时间和可用性)" dir="auto" class="heading" id="5.6_Timing_and_availability(时间和可用性)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.6 Timing and availability(时间和可用性)</h3><div class="heading-children"><div class="el-p"><p dir="auto">One of our requirements for Raft is that safety must not depend on timing:<br>
the system must not produce incorrect results just because some event happens more quickly or slowly than expected.<br>
However, availability (the ability of the system to respond to clients in a timely manner) must inevitably depend on timing.<br>
For example, if message exchanges take longer than the typical time between server crashes,<br>
candidates will not stay up long enough to win an election; without a steady leader, Raft cannot make progress.</p></div><div class="el-p"><p dir="auto">我们对Raft的要求之一是安全性不得依赖时间：系统不能因为一些事件比所期望的更快或更慢发生而产生不正确的结果。<br>
然而，可用性(系统及时响应客户端的能力)一定不可避免的依赖于时间。<br>
例如，如果消息交换所花费的时间比服务器崩溃时所花费的时间还长，candidates将无法一直等待以赢得一场选举；没有一个稳定的leader，Raft就无法工作。</p></div><div class="el-p"><p dir="auto">Leader election is the aspect of Raft where timing is most critical.<br>
Raft will be able to elect and maintain a steady leader as long as the system satisfies the following timing requirement:<br>
broadcastTime ≪ electionTimeout ≪ MTBF</p></div><div class="el-p"><p dir="auto">leader选举是Raft关于时间的最关键的方面。<br>
只要系统能满足以下时间的需求，Raft将能够选出并且维持一个稳定的leader：<br>
广播时间(broadcastTime) ≪ 选举超时时间(electionTimeout) ≪ 平均故障间隔时间(MTBF: Mean Time between Failures)</p></div><div class="el-p"><p dir="auto">In this inequality broadcastTime is the average time it takes a server to send RPCs in parallel to every server<br>
in the cluster and receive their responses;<br>
electionTimeout is the election timeout described in Section 5.2;<br>
and MTBF is the average time between failures for a single server.<br>
The broadcast time should be an order of magnitude less than the election timeout so<br>
that leaders can reliably send the heartbeat messages required to keep followers from starting elections;<br>
given the randomized approach used for election timeouts, this inequality also makes split votes unlikely.<br>
The election timeout should be a few orders of magnitude less than MTBF so that the system makes steady progress.<br>
When the leader crashes, the system will be unavailable for roughly the election timeout;<br>
we would like this to represent only a small fraction of overall time.</p></div><div class="el-p"><p dir="auto">在这个不等式中，广播时间是服务器并行发送RPC给集群中的每一个服务器并且接受到它们的响应所花费的时间；<br>
选举超时时间是在5.2节中所描述的选举超时时间；同时MTBF是对于单一服务器在两次故障间隔的平均时间。<br>
广播时间应该比选举超时时间小一个数量级因此leader可以可靠的发送所需的心跳信息来阻止follower开始选举；<br>
考虑到用于选举超时的随机化方法，这个不等式也使得不太可能出现投票分裂。<br>
选举超时时间必须比MTBF低几个数量级才能使得系统能稳定的运行。<br>
当leader崩溃时，系统将有大致等于选举超时时间左右的不可用时间，我们希望这只占用整个(工作)时间的一小部分。</p></div><div class="el-p"><p dir="auto">The broadcast time and MTBF are properties of the underlying system, while the election timeout is something we must choose.<br>
Raft’s RPCs typically require the recipient to persist information to stable storage,<br>
so the broadcast time may range from 0.5ms to 20ms, depending on storage technology.<br>
As a result, the election timeout is likely to be somewhere between 10ms and 500ms.<br>
Typical server MTBFs are several months or more, which easily satisfies the timing requirement.</p></div><div class="el-p"><p dir="auto">广播时间和平均故障间隔时间是底层系统的特性，只有选举超时时间是我们必须选择的。<br>
Raft的RPC通常需要接收方将信息持久化到稳定的存储介质中，所以广播时间可能在0.5ms到20ms之间，这取决于存储技术。<br>
因此，选举时间可能在10ms到500ms之间。<br>
典型的服务器平均故障间隔时间是几个月或者更多，因此对这一时间(的要求)很容易满足。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240725173120.png" src="Pasted image 20240725173120.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240725173120.png" src="computer-science/distributed-system/raft-原始论文中英/pasted-image-20240725173120.png"></span></p></div><div class="el-p"><p dir="auto">Figure 10: Switching directly from one configuration to another is unsafe because different servers will switch at different times.<br>
In this example, the cluster grows from three servers to five.<br>
Unfortunately, there is a point in time where two different leaders can be elected for the same term,<br>
one with a majority of the old configuration (C<em>old</em>) and another with a majority of the new configuration (C<em>new</em>).</p></div><div class="el-p"><p dir="auto">图10：直接将一种配置切换到另一种配置是不安全的因为不同的服务器将会在不同的时间点进行切换。<br>
在这个例子中，集群从3台服务器增长到5台。<br>
不幸的是，这个时间点将会在相同的任期内选举出两个不同的leader，其中之一获得了旧配置中的大多数(C<em>old</em>)同时另一个获得了新配置中的大多数(C<em>new</em>)。</p></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="6 Cluster membership changes(集群成员变更)" dir="auto" class="heading" id="6_Cluster_membership_changes(集群成员变更)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6 Cluster membership changes(集群成员变更)</h2><div class="heading-children"><div class="el-p"><p dir="auto">Up until now we have assumed that the cluster configuration (the set of servers participating in the consensus algorithm) is fixed.<br>
In practice, it will occasionally be necessary to change the configuration,<br>
for example to replace servers when they fail or to change the degree of replication.<br>
Although this can be done by taking the entire cluster off-line, updating configuration files,<br>
and then restarting the cluster, this would leave the cluster unavailable during the changeover.<br>
In addition, if there are any manual steps, they risk operator error.<br>
In order to avoid these issues, we decided to automate configuration changes and incorporate them into the Raft consensus algorithm.</p></div><div class="el-p"><p dir="auto">到目前为止，我们已经假设集群的配置(参与一致性算法的服务器集合)是固定的。<br>
在实践中，偶尔的改变配置是必须的，例如在服务器发生故障时进行替换或者改变复制的程度。<br>
尽管这可以通过使整个集群离线，更新配置文件并且随后重启集群来实现，但这也使得集群在转换过程中变得不可用。<br>
另外，如果有任何的手工步骤，则有管理员操作失误的风险。<br>
为了避免这些问题，我们决定将配置的变更自动化并且将其纳入到Raft一致性算法中。</p></div><div class="el-p"><p dir="auto">For the configuration change mechanism to be safe,<br>
there must be no point during the transition where it is possible for two leaders to be elected for the same term.<br>
Unfortunately, any approach where servers switch directly from the old configuration to the new configuration is unsafe.<br>
It isn’t possible to atomically switch all of the servers at once,<br>
so the cluster can potentially split into two independent majorities during the transition (see Figure 10).</p></div><div class="el-p"><p dir="auto">为了使得配置变更的过程是安全的，在转换的过程中必须保证不能在同一个任期内选举出两个leader。<br>
不幸的是，任何将旧配置直接切换到新配置的方法都是不安全的。<br>
不可能原子性的一次性切换所有的服务器，因此服务器可能在转换期间被切分为两个独立的多数(如图10所示)。</p></div><div class="el-p"><p dir="auto">In order to ensure safety, configuration changes must use a two-phase approach.<br>
There are a variety of ways to implement the two phases.<br>
For example, some systems(e.g., [22]) use the first phase to disable the old configuration so it cannot process client requests;<br>
then the second phase enables the new configuration.<br>
In Raft the cluster first switches to a transitional configuration we call joint consensus;<br>
once the joint consensus has been committed, the system then transitions to the new configuration.<br>
The joint consensus combines both the old and new configurations:</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">Log entries are replicated to all servers in both configurations.</li>
<li data-line="1" dir="auto">Any server from either configuration may serve as leader</li>
<li data-line="2" dir="auto">Agreement (for elections and entry commitment) requires separate majorities from both the old and new configurations.</li>
</ul></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240725173130.png" src="Pasted image 20240725173130.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240725173130.png" src="computer-science/distributed-system/raft-原始论文中英/pasted-image-20240725173130.png"></span></p></div><div class="el-p"><p dir="auto">Figure 11: Timeline for a configuration change.<br>
Dashed lines show configuration entries that have been created but not committed, and solid lines show the latest committed configuration entry.<br>
The leader first creates the C<em>old,new</em> configuration entry in its log and commits it to C<em>old,new</em><br>
(a majority of C<em>old</em> and a majority of C<em>new</em>).<br>
Then it creates the C<em>new</em> entry and commits it to a majority of C<em>new</em>.<br>
There is no point in time in which C<em>old</em> and C<em>new</em> can both make decisions independently.</p></div><div class="el-p"><p dir="auto">图11：配置变更的时间线。<br>
虚线标识配置条目已经被创建但还未被提交，而实现标识最新的已提交的配置条目。<br>
leader首先在它的日志中创建C<em>old,new</em>的配置条目并且向C<em>old,new</em>(C<em>old</em>中的大多数以及C<em>new</em>中的大多数)提交这一日志。<br>
然后它创建C<em>new</em>条目并且向C<em>new</em>中的大多数提交这一条目。<br>
没有任何一个时间点可以让C<em>old</em>和C<em>new</em>都能同时独立的做出决定。</p></div><div class="el-p"><p dir="auto">为了确保安全，配置的变更必须使用一种两阶段的方法。<br>
有很多方法可以实现两阶段。<br>
例如，一些系统通过在一阶段禁用旧的配置因此其无法处理客户端请求，然后二阶段则启用新的配置。<br>
在Raft的集群首先切换到我们成为联合一致(joint consensus)的过渡配置;一旦联合一致已被提交，系统便过度到新的配置。<br>
联合一致结合了旧的和新的配置：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">日志条目都会被复制到在这两种配置中所有的服务器上。</li>
<li data-line="1" dir="auto">新、旧配置中的任一服务器都可以作为leader。</li>
<li data-line="2" dir="auto">(对于选举和条目提交)达成一致需要在新的和旧的配置中分别获得大多数服务器的同意。</li>
</ul></div><div class="el-p"><p dir="auto">The joint consensus allows individual servers to transition between configurations at different times without compromising safety.<br>
Furthermore, joint consensus allows the cluster to continue servicing client requests throughout the configuration change.</p></div><div class="el-p"><p dir="auto">联合一致允许单独的服务器在不同的时间内转换配合而不会在安全性上有所妥协。<br>
此外，联合一致允许集群在配置变更的过程中持续的为客户端的请求提供服务。</p></div><div class="el-p"><p dir="auto">Cluster configurations are stored and communicated using special entries in the replicated log;<br>
Figure 11 illustrates the configuration change process.<br>
When the leader receives a request to change the configuration from C<em>old</em> to C<em>new</em>,<br>
it stores the configuration for joint consensus(C<em>old,new</em> in the figure) as a log entry and replicates that<br>
entry using the mechanisms described previously.<br>
Once a given server adds the new configuration entry to its log, it uses that configuration for all future decisions<br>
(a server always uses the latest configuration in its log, regardless of whether the entry is committed).<br>
This means that the leader will use the rules of C<em>old,new</em> to determine when the log entry for C<em>old,new</em> is committed.<br>
If the leader crashes, a new leader may be chosen under either C<em>old</em> or C<em>old,new</em>,<br>
depending on whether the winning candidate has received C<em>old,new</em>.<br>
In any case, C<em>new</em> cannot make unilateral decisions during this period.</p></div><div class="el-p"><p dir="auto">集群配置通过复制日志中特殊的条目进行存储和通信；图11展示了配置变更的过程。<br>
当leader接受到令配置从C<em>old</em>(旧配置)到C<em>new</em>(新配置)的请求时，<br>
它为了联合一致以一个日志条目的形式存储这个配置(图中的C<em>old,new</em>)并且使用之前所描述的机制复制这个条目。<br>
一旦给定的服务器将新的配置条目加入了它的日志，它将使用这些配置来指定未来所有的决定(一个服务器总是使用它日志中最后的配置，无论该条目是否是已提交的)。<br>
这意味着leader将使用规则C<em>old,new</em>来决定何时提交关于C<em>old,new</em>的日志条目。<br>
如果leader崩溃了，新的leader可能是在C<em>old</em>或者是C<em>old,new</em>下选择出来的，这取决于获胜的candidate是否已经收到了C<em>old,new</em>。<br>
无论如何，C<em>new</em>都不能在这个阶段单独的做出决定。</p></div><div class="el-p"><p dir="auto">Once C<em>old,new</em> has been committed, neither C<em>old</em> nor C<em>new</em> can make decisions without approval of the other,<br>
and the Leader Completeness Property ensures that only servers with the C<em>old,new</em> log entry can be elected as leader.<br>
It is now safe for the leader to create a log entry describing C<em>new</em> and replicate it to the cluster.<br>
Again, this configuration will take effect on each server as soon as it is seen.<br>
When the new configuration has been committed under the rules of C<em>new</em>,<br>
the old configuration is irrelevant and servers not in the new configuration can be shut down.<br>
As shown in Figure 11, there is no time when C<em>old</em> and C<em>new</em> can both make unilateral decisions; this guarantees safety.</p></div><div class="el-p"><p dir="auto">一旦C<em>old,new</em>已经提交，C<em>old</em>或者C<em>new</em>都不能在没有另一方同意的情况下做出决定，<br>
并且Leader Completeness特性确保只有拥有C<em>old,new</em>日志条目的服务器才能被选举为leader。<br>
现在leader可以安全的创建一个描述了C<em>new</em>的日志条目并将其在集群中进行复制。<br>
同样的，该配置将在每一个服务器看到其后立即生效。<br>
当新的配置在C<em>new</em>的规则下被提交，旧的配置将变得无关紧要并且没有在新配置中的服务器将可以被关闭。<br>
如图11所示，C<em>old</em>和C<em>new</em>不能同时做出单独的决定；这保证了安全性。</p></div><div class="el-p"><p dir="auto">There are three more issues to address for reconfiguration.<br>
The first issue is that new servers may not initially store any log entries.<br>
If they are added to the cluster in this state, it could take quite a while for them to catch up,<br>
during which time it might not be possible to commit new log entries.<br>
In order to avoid availability gaps, Raft introduces an additional phase before the configuration change,<br>
in which the new servers join the cluster as non-voting members<br>
(the leader replicates log entries to them, but they are not considered for majorities).<br>
Once the new servers have caught up with the rest of the cluster, the reconfiguration can proceed as described above.</p></div><div class="el-p"><p dir="auto">关于配置变更还存在三个问题需要解决。<br>
第一个问题是，新的服务器可能在初始化时没有存储任何的日志条目。<br>
如果在这种状态下被加入到集群，它可能需要花费很长一段时间才能赶上，在这段时间内都无法提交新的日志条目。<br>
为了避免可用性的差距，Raft在配置变更前引入了一个额外的阶段，新的服务器以无投票权成员(non-voting members)的身份加入集群<br>
(leader复制日志条目给它们，但它们不被认为是大多数的一份子)。<br>
一旦新的服务器能够追上集群中的其它机器，就可以向上述那般执行配置变更。</p></div><div class="el-p"><p dir="auto">The second issue is that the cluster leader may not be part of the new configuration.<br>
In this case, the leader steps down (returns to follower state) once it has committed the C<em>new</em> log entry.<br>
This means that there will be a period of time (while it is committing C<em>new</em>)<br>
when the leader is managing a cluster that does not include itself; it replicates log entries but does not count itself in majorities.<br>
The leader transition occurs when C<em>new</em> is committed<br>
because this is the first point when the new configuration can operate independently (it will always be possible to choose a leader from C<em>new</em>).<br>
Before this point, it may be the case that only a server from C<em>old</em> can be elected leader.</p></div><div class="el-p"><p dir="auto">第二个问题是，集群的leader可能不是新配置中的一员。<br>
在这种情况下，一旦C<em>new</em>日志条目被提交，leader将会退下(返回到follower状态)。<br>
这意味着存在一段时间(在提交C<em>new</em>时)，其中leader管理者一个不包含自己的集群；它复制着日志条目但不把它自己算作大多数中的一员。<br>
当C<em>new</em>被提交时将会发生leader的切换，因为这是新配置可以进行独立操作的第一个点位(总是可以在C<em>new</em>中选择出一个leader)。<br>
在此之前，只有来自C<em>old</em>的服务器才有可能被选举为leader。</p></div><div class="el-p"><p dir="auto">The third issue is that removed servers (those not in C<em>new</em>) can disrupt the cluster.<br>
These servers will not receive heartbeats, so they will time out and start new elections.<br>
They will then send RequestVote RPCs with new term numbers, and this will cause the current leader to revert to follower state.<br>
A new leader will eventually be elected, but the removed servers will time out again and the process will repeat,<br>
resulting in poor availability.</p></div><div class="el-p"><p dir="auto">第三个问题是被移除的服务器(不在C<em>new</em>中)可能会中断集群。<br>
这些服务器将不再接收到心跳，所以它们将会超时而启动新的选举。<br>
然后它们将发送有着新任期编号的RequestVote RPC，并且这将导致当前的leader恢复为follower状态。<br>
最终将会有一名新的leader被选举出来，但是被移除的服务器将会再次超时并且重复这一过程，这将导致系统有着较差的可用性。</p></div><div class="el-p"><p dir="auto">To prevent this problem, servers disregard RequestVote RPCs when they believe a current leader exists.<br>
Specifically, if a server receives a RequestVote RPC within the minimum election timeout of hearing from a current leader,<br>
it does not update its term or grant its vote.<br>
This does not affect normal elections, where each server waits at least a minimum election timeout before starting an election.<br>
However, it helps avoid disruptions from removed servers:<br>
if a leader is able to get heartbeats to its cluster, then it will not be deposed by larger term numbers.</p></div><div class="el-p"><p dir="auto">为了避免这一问题，服务器将会在它们认为当前leader存在时忽略掉RequestVote RPC。<br>
特别的，如果一个服务器在当前leader最小的选举超时时间内接收到一个RequestVote RPC，它将不会更新它的任期或者发起投票。<br>
这不会影响正常的选举，即每一个服务器在开始一轮选举之前至少等待一个最小的选举超时时间。<br>
然而，它有助于避免移除服务器时的混乱：如果一个leader能够提供集群中的心跳，则它将不会被一个更大的任期编号给取代。</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="7 Log compaction(日志压缩)" dir="auto" class="heading" id="7_Log_compaction(日志压缩)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7 Log compaction(日志压缩)</h2><div class="heading-children"><div class="el-p"><p dir="auto">Raft’s log grows during normal operation to incorporate more client requests, but in a practical system, it cannot grow without bound.<br>
As the log grows longer, it occupies more space and takes more time to replay.<br>
This will eventually cause availability problems without some mechanism to discard obsolete information that has accumulated in the log.</p></div><div class="el-p"><p dir="auto">Raft的日志在正常操作期间不断增长以满足更多的客户端请求，但是在实际的系统中，日志不能不加限制的增长。<br>
随着日志不断变长，它将占用更多的空间并且花费更长的事件来进行回放。<br>
如果没有一些机制来剔除日志中所累积的过时的信息，这终将造成可用性问题。</p></div><div class="el-p"><p dir="auto">Snapshotting is the simplest approach to compaction.<br>
In snapshotting, the entire current system state is written to a snapshot on stable storage,<br>
then the entire log up to that point is discarded.<br>
Snapshotting is used in Chubby and ZooKeeper, and the remainder of this section describes snapshotting in Raft.</p></div><div class="el-p"><p dir="auto">快照是最简单的压缩方法。<br>
在快照中，完整的当前系统状态以快照的形式写入稳定的存储中，然后在这个点位之前的整个日志会被丢弃。<br>
快照被用于Chubby和ZooKeeper中，本届的剩余部分将用于描述Raft中的快照。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240725173140.png" src="Pasted image 20240725173140.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240725173140.png" src="computer-science/distributed-system/raft-原始论文中英/pasted-image-20240725173140.png"></span></p></div><div class="el-p"><p dir="auto">Figure 12: A server replaces the committed entries in its log(indexes 1 through 5) with a new snapshot,<br>
which stores just the current state (variables x and y in this example).<br>
The snapshot’s last included index and term serve to position the snapshot in the log preceding entry 6.</p></div><div class="el-p"><p dir="auto">图12：服务器用新的快照代替其日志中已提交的条目(索引1到5)，该快照只存储了当前的状态(本例中的变量x和y)。<br>
快照中的last included index和term用于定位快照中的条目6之前的日志。</p></div><div class="el-p"><p dir="auto">Incremental approaches to compaction, such as log cleaning [36] and log-structured merge trees [30, 5], are also possible.<br>
These operate on a fraction of the data at once, so they spread the load of compaction more evenly over time.<br>
They first select a region of data that has accumulated many deleted and overwritten objects,<br>
then they rewrite the live objects from that region more compactly and free the region.<br>
This requires significant additional mechanism and complexity compared to snapshotting,<br>
which simplifies the problem by always operating on the entire data set.<br>
While log cleaning would require modifications to Raft, state machines can implement LSM trees using the same interface as snapshotting.</p></div><div class="el-p"><p dir="auto">基于增量的压缩方法，例如日志清理和日志结构合并树(LSM tree)也是可行的。<br>
这些操作一次只操作少量的数据，因此它们能随着时间的退役均摊负载。<br>
它们首先选择一片数据区域，其已经积累了很多的被删除和覆盖的对象，然后它们以更加紧凑的方式重写来自这一片区域的存活对象(live objects)并释放这一区域。<br>
与快照压缩相比这显著的引入了额外的机制和复杂度，快照通过始终操作整个数据集合来简化这一问题。<br>
虽然日志清理需要对Raft进行修改，但状态机可以使用与快照相同的接口来实现LSM树。</p></div><div class="el-p"><p dir="auto">Figure 12 shows the basic idea of snapshotting in Raft.<br>
Each server takes snapshots independently, covering just the committed entries in its log.<br>
Most of the work consists of the state machine writing its current state to the snapshot.<br>
Raft also includes a small amount of metadata in the snapshot:<br>
the <em>last included index</em> is the index of the last entry in the log that the snapshot replaces<br>
(the last entry the state machine had applied), and the <em>last included term</em> is the term of this entry.<br>
These are preserved to support the AppendEntries consistency check for the first log entry following the snapshot,<br>
since that entry needs a previous log index and term.<br>
To enable cluster membership changes (Section 6), the snapshot also includes the latest configuration in the log as of last included index.<br>
Once a server completes writing a snapshot, it may delete all log entries up through the last included index, as well as any prior snapshot.</p></div><div class="el-p"><p dir="auto">图12展示了Raft中关于快照的基础思想。<br>
每一个服务器都独立的获得快照，只覆盖它已提交的日志条目。<br>
大部分的工作主要由状态机以快照形式写入它的当前状态组成。<br>
Raft还将少量的元数据包括在了快照中：<br>
<em>last included index</em>是快照代替的日志中的最后一个条目的索引值(状态机已应用的最后一个条目)，并且<em>last included term</em>是这个条目的任期值。<br>
保留这些条目是为了支持快照后面第一个条目的AppendEntries一致性检查，因为这个条目需要前一个日志的索引值和任期值。<br>
要启用集群变更(第6节)，快照还要包括含有<em>last included index</em>日志的最后配置。<br>
一旦一个服务器完成了一个快照的写入，它可能会删除包含<em>last included index</em>之前的所有日志条目，以及之前的任何快照。</p></div><div class="el-p"><p dir="auto">Although servers normally take snapshots independently, the leader must occasionally send snapshots to followers that lag behind.<br>
This happens when the leader has already discarded the next log entry that it needs to send to a follower.<br>
Fortunately, this situation is unlikely in normal operation: a follower that has kept up with the leader would already have this entry.<br>
However, an exceptionally slow follower or a new server joining the cluster(Section 6) would not.<br>
The way to bring such a follower up-to-date is for the leader to send it a snapshot over the network.</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240725173149.png" src="Pasted image 20240725173149.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240725173149.png" src="computer-science/distributed-system/raft-原始论文中英/pasted-image-20240725173149.png"></span></p></div><div class="el-p"><p dir="auto">Figure 13: A summary of the InstallSnapshot RPC.<br>
Snapshots are split into chunks for transmission; this gives the follower a sign of life with each chunk, so it can reset its election timer.</p></div><div class="el-p"><p dir="auto">图13：InstallSnapshot RPC的快照。<br>
快照被分割为块进行传输；每一块都带给了follower其存活的标识，因此follower可以重置其选举计时器。</p></div><div class="el-p"><p dir="auto">尽管服务器通常独立的生成快照，但leader必须偶尔的向落后的follower发送快照。<br>
当leader已经丢弃了需要发送给follower的下一个日志条目时就会发生这种情况。<br>
幸运的是，这种情况不太可能在正常操作中出现：一个跟上了leader的follower已经有了这个条目了。<br>
然而，一个异常慢的follower或者一个新加入集群的服务器(第6节)将没有这个条目。<br>
让这样的一个follower的日志和leader一样新的方法就是通过网络向它发送一个快照。</p></div><div class="el-p"><p dir="auto">The leader uses a new RPC called InstallSnapshot to send snapshots to followers that are too far behind; see Figure 13.<br>
When a follower receives a snapshot with this RPC, it must decide what to do with its existing log entries.<br>
Usually the snapshot will contain new information not already in the recipient’s log.<br>
In this case, the follower discards its entire log; it is all superseded by the snapshot<br>
and may possibly have uncommitted entries that conflict with the snapshot.<br>
If instead the follower receives a snapshot that describes a prefix of its log (due to retransmission or by mistake),<br>
then log entries covered by the snapshot are deleted but entries following the snapshot are still valid and must be retained.</p></div><div class="el-p"><p dir="auto">leader使用一种新的被成为InstallSnapshot的RPC向落后太多的follower发送快照;如图13所示。<br>
当一个follower使用这个RPC接受到一个快照时，它必须决定如何处理它目前已存在的日志条目。<br>
通常，这个快照将包含目前还不在接受者日志中的新信息。<br>
这种情况下，follower将丢弃它全部的日志;其全部被快照所取代，并且被丢弃的日志中可能有着与快照相冲突的但还未提交的条目。<br>
相反，如果follower接受到的快照是它当前日志的前面一部分(由于重传或者出错了)，则被快照所覆盖的日志条目将会被删除但是快照后面的条目依然是有效的并且必须被保留。</p></div><div class="el-p"><p dir="auto">This snapshotting approach departs from Raft’s strong leader principle, since followers can take snapshots without the knowledge of the leader.<br>
However, we think this departure is justified.<br>
While having a leader helps avoid conflicting decisions in reaching consensus,<br>
consensus has already been reached when snapshotting, so no decisions conflict.<br>
Data still only flows from leaders to followers, just followers can now reorganize their data.</p></div><div class="el-p"><p dir="auto">这种快照的方式背离了Raft的强leader原则，因为follower可以在leader不知情的情况下生成快照。<br>
然而，我们认为这种背离是值得的。<br>
虽然由一个leader有助于避免在达成一致时产生决策冲突，但生成快照时是已经达成了一致的，所以不会有决策冲突。<br>
数据依然是仅由leader流向follower，但follower现在可以重新组织它们的数据。</p></div><div class="el-p"><p dir="auto">We considered an alternative leader-based approach in which only the leader would create a snapshot,<br>
then it would send this snapshot to each of its followers.<br>
However, this has two disadvantages.<br>
First, sending the snapshot to each follower would waste network bandwidth and slow the snapshotting process.<br>
Each follower already has the information needed to produce its own snapshots,<br>
and it is typically much cheaper for a server to produce a snapshot from its local state than it is to send and receive one over the network.<br>
Second, the leader’s implementation would be more complex.<br>
For example, the leader would need to send snapshots to followers in parallel with replicating new log entries to them,<br>
so as not to block new client requests.</p></div><div class="el-p"><p dir="auto">我们考虑过另一种基于leader的方法，其只有leader可以创建快照，然后leader将发送快照给每一个follower。<br>
然而，这样做有两个缺点。<br>
首先，发送快照给每一个follower将浪费网络带宽并且减慢快照的处理。<br>
每一个follower已经有了生成它们自己快照所需要的信息，并且通常基于服务器本地状态来生成快照要比它们通过从网络发送和接收快照的开销要更低。<br>
其次，leader也会被实现的更加复杂。<br>
比如，leader将需要并行的发送快照给follower的同时还要令它们复制新的日志条目，以避免阻塞新的客户端请求。</p></div><div class="el-p"><p dir="auto">There are two more issues that impact snapshotting performance.<br>
First, servers must decide when to snapshot.<br>
If a server snapshots too often, it wastes disk bandwidth and energy; if it snapshots too infrequently,<br>
it risks exhausting its storage capacity, and it increases the time required to replay the log during restarts.<br>
One simple strategy is to take a snapshot when the log reaches a fixed size in bytes.<br>
If this size is set to be significantly larger than the expected size of a snapshot,<br>
then the disk bandwidth overhead for snapshotting will be small.</p></div><div class="el-p"><p dir="auto">还有两个问题会影响快照的性能。<br>
首先，服务器必须决定何时生成快照。<br>
如果服务器生成快照太频繁，则将浪费磁盘带宽和能源；如果生成快照太不频繁，则存在耗尽磁盘空间的风险，并且增加重启时回放日志所需的时间。<br>
一种简单的策略时当日志到达一个固定的字节数时生成一个快照。<br>
如果这个大小设置为一个明显大于快照预期大小的值，则用于快照生成的磁盘带宽开销将会很小。</p></div><div class="el-p"><p dir="auto">The second performance issue is that writing a snapshot can take a significant amount of time,<br>
and we do not want this to delay normal operations.<br>
The solution is to use copy-on-write techniques so that new updates can be accepted without impacting the snapshot being written.<br>
For example, state machines built with functional data structures naturally support this.<br>
Alternatively, the operating system’s copy-on-write support (e.g., fork on Linux)<br>
can be used to create an in-memory snapshot of the entire state machine (our implementation uses this approach).</p></div><div class="el-p"><p dir="auto">第二个问题是写入一个快照会花费非常多的时间，并且我们不希望这会延迟正常操作。<br>
解决的方案是使用写时复制(copy-on-write)技术,以便可以在不影响快照的写入的同时接受新的更新。<br>
例如，使用函数式数据结构(functional data structures)构建的状态机能自然的支持这一点。<br>
或者，操作系统的写时复制支持(例如，linux中的fork)可以被用于创建整个状态机的内存快照(我们的实现使用了这个方法)。</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="8 Client interaction(客户端交互)" dir="auto" class="heading" id="8_Client_interaction(客户端交互)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>8 Client interaction(客户端交互)</h2><div class="heading-children"><div class="el-p"><p dir="auto">This section describes how clients interact with Raft,<br>
including how clients find the cluster leader and how Raft supports linearizable semantics [10].<br>
These issues apply to all consensus-based systems, and Raft’s solutions are similar to other systems.</p></div><div class="el-p"><p dir="auto">本节描述了客户端如何与Raft交互，包括客户端如何找到集群leader以及Raft是如何支持线性化语义的。<br>
这些问题适用于所有的基于一致性的系统，同时Raft的解决方案也与其它系统是类似的。</p></div><div class="el-p"><p dir="auto">Clients of Raft send all of their requests to the leader.<br>
When a client first starts up, it connects to a randomly-chosen server.<br>
If the client’s first choice is not the leader,<br>
that server will reject the client’s request and supply information about the most recent leader it has heard from<br>
(AppendEntries requests include the network address of the leader).<br>
If the leader crashes, client requests will time out; clients then try again with randomly-chosen servers.</p></div><div class="el-p"><p dir="auto">Raft的客户端将它们的所有请求发送给leader。<br>
当客户端第一次启动时，它会随机选择一台服务器并进行连接。<br>
如果客户端第一次选择的不是leader，则服务器将会拒绝客户端的请求并且提供关于它听到的最近的leader的信息(AppendEntries的请求中包括了leader的网络地址)。<br>
如果leader崩溃了，客户端的请求将会超时;客户端则会再一次随机选择一台服务器。</p></div><div class="el-p"><p dir="auto">Our goal for Raft is to implement linearizable semantics (each operation appears to execute instantaneously,<br>
exactly once, at some point between its invocation and its response).<br>
However, as described so far Raft can execute a command multiple times:<br>
for example, if the leader crashes after committing the log entry but before responding to the client,<br>
the client will retry the command with a new leader, causing it to be executed a second time.<br>
The solution is for clients to assign unique serial numbers to every command.<br>
Then, the state machine tracks the latest serial number processed for each client, along with the associated response.<br>
If it receives a command whose serial number has already been executed, it responds immediately without re-executing the request.</p></div><div class="el-p"><p dir="auto">我们对于Raft的目标是实现可线性化的语义(每一个操作会立即执行，执行且只执行一次，执行的时机位于请求和响应之间)。<br>
然而，如上所述Raft可以执行执行一条指令多次：例如，如果leader在提交日志条目后但响应客户端之前崩溃了，客户端将会与新的leader重试这条指令，使得该指令被执行了两次。<br>
解决方案是让客户端为每一个指令分配一个唯一的序列号。<br>
然后，状态机追踪为每一个客户端处理的最后的序列号，以及相关的响应。<br>
如果它接受到了一个指令其序列号是已经被执行了的，它将立即返回而不会重新执行该请求。</p></div><div class="el-p"><p dir="auto">Read-only operations can be handled without writing anything into the log.<br>
However, with no additional measures, this would run the risk of returning stale data,<br>
since the leader responding to the request might have been superseded by a newer leader of which it is unaware.<br>
Linearizable reads must not return stale data, and Raft needs two extra precautions to guarantee this without using the log.<br>
First, a leader must have the latest information on which entries are committed.<br>
The Leader Completeness Property guarantees that a leader has all committed entries,<br>
but at the start of its term, it may not know which those are.<br>
To find out, it needs to commit an entry from its term.<br>
Raft handles this by having each leader commit a blank <em>no-op</em> entry into the log at the start of its term.<br>
Second, a leader must check whether it has been deposed before processing a read-only request<br>
(its information may be stale if a more recent leader has been elected).<br>
Raft handles this by having the leader exchange heartbeat messages with a majority of the cluster before responding to read-only requests.<br>
Alternatively, the leader could rely on the heartbeat mechanism to provide a form of lease [9],<br>
but this would rely on timing for safety (it assumes bounded clock skew).</p></div><div class="el-p"><p dir="auto">只读操作可以直接被处理而不需要向日志写入任何东西。<br>
然而，如果没有额外的机制，将会有返回过时数据的风险，因为响应请求的leader可能已经被一个新的leader取代了但它自己却没感知到。<br>
线性化的读必须不返回过时数据，并且Raft需要两个额外的预防措施在不使用日志的前提下保证这一点。<br>
首先，leader必须掌握已提交日志条目的最新信息。<br>
leader完整性属性保证了leader有着所有已提交的条目，但在它任期的开始时，它不知道哪些是已提交的条目。<br>
为了找到哪些是已提交的条目，它需要提交一个来自它自己任期的条目。<br>
Raft通过在leader开始其任期时，让每一个leader提交一个空白的<em>no-op</em>条目来处理这一问题。<br>
其次，leader在处理只读请求时必须检查它是否已经被罢黜退位了(如果最新的leader已经被选出，则它的信息可能已经过时了)。<br>
Raft通过让leader在响应只读请求之前与集群中的大多数交换心跳信息来解决这一问题。<br>
或者，leader可以依赖心跳机制来提供一种租约的形式，但这将会依赖于时钟的安全性(假设时间误差是有限的)。</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="9 Implementation and evaluation(实现与评估)" dir="auto" class="heading" id="9_Implementation_and_evaluation(实现与评估)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9 Implementation and evaluation(实现与评估)</h2><div class="heading-children"><div class="el-p"><p dir="auto">We have implemented Raft as part of a replicated state machine that stores configuration information for RAMCloud [33]<br>
and assists in failover of the RAMCloud coordinator.<br>
The Raft implementation contains roughly 2000 lines of C++ code, not including tests, comments, or blank lines.<br>
The source code is freely available [23].<br>
There are also about 25 independent third-party open source implementations [34] of Raft in various stages of development,<br>
based on drafts of this paper.<br>
Also, various companies are deploying Raft-based systems [34].</p></div><div class="el-p"><p dir="auto">我们已经将Raft实现为复制状态机的一部分，其存储RAMCloud的配置信息并且协助RAMCloud协调者进行故障恢复。<br>
Raft的实现包含了大概2000行的C++代码，不包括测试，备注或者空行。<br>
源代码是免费提供的。<br>
基于本论文的草稿，有大约25个独立的、处于不同开发阶段的Raft三方开源实现。<br>
此外，很多公司也部署了基于Raft的系统。</p></div><div class="el-p"><p dir="auto">The remainder of this section evaluates Raft using three criteria: understandability, correctness, and performance.</p></div><div class="el-p"><p dir="auto">本节的剩余部分用于在三个方面评估Raft: 可理解性，正确性和性能。</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="9.1 Understandability(可理解性)" dir="auto" class="heading" id="9.1_Understandability(可理解性)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.1 Understandability(可理解性)</h3><div class="heading-children"><div class="el-p"><p dir="auto">To measure Raft’s understandability relative to Paxos,<br>
we conducted an experimental study using upper-level undergraduate and graduate students in<br>
an Advanced Operating Systems course at Stanford University and a Distributed Computing course at U.C. Berkeley.<br>
We recorded a video lecture of Raft and another of Paxos, and created corresponding quizzes.<br>
The Raft lecture covered the content of this paper except for log compaction;<br>
the Paxos lecture covered enough material to create an equivalent replicated state machine, including single-decree Paxos,<br>
multi-decree Paxos, reconfiguration, and a few optimizations needed in practice (such as leader election).<br>
The quizzes tested basic understanding of the algorithms and also required students to reason about corner cases.<br>
Each student watched one video, took the corresponding quiz, watched the second video, and took the second quiz.<br>
About half of the participants did the Paxos portion first<br>
and the other half did the Raft portion first in order to account for both individual differences in performance<br>
and experience gained from the first portion of the study.<br>
We compared participants’ scores on each quiz to determine whether participants showed a better understanding of Raft.</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240725173202.png" src="Pasted image 20240725173202.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240725173202.png" src="computer-science/distributed-system/raft-原始论文中英/pasted-image-20240725173202.png"></span></p></div><div class="el-p"><p dir="auto">Figure 14: A scatter plot comparing 43 participants’ performance on the Raft and Paxos quizzes.<br>
Points above the diagonal (33) represent participants who scored higher for Raft.</p></div><div class="el-p"><p dir="auto">图14：比较43名参与者在Raft和Paxos测验中表现的散点图。<br>
位于对角线之上的(33个)参与者是Raft分数更高的。</p></div><div class="el-p"><p dir="auto">为了测量Raft相对于Paxos的可理解性，我们对来自斯坦福大学的高级操作系统课程和加州大学伯克利分校的分布式系统课程的高水平本科生和研究生组织了一场学习实验。<br>
我们录制了Raft和Paxos的视频讲座，并且制作了相对应的测验。<br>
Raft的讲座覆盖了本文除日志压缩以外的内容，Paxos的讲座覆盖了相当于创建一个等效的复制状态机的足够多的材料，包括single-decree Paxos，multi-decree Paxos，<br>
刷新配置，以及实践中所需要的一小部分优化(例如leader选举)。<br>
测验测试了学生对算法的基础理解同时也需要学生能推理出极端的case。<br>
每个学生观看第一个视频，然后做相应的测验，再看第二个视频，然后再做第二个视频对应的测验。<br>
为解释本实验第一次学习时获得的经验和表现上的差异，大约一般的实验者先做Paxos那部分的而另一半实验者则先做Raft的那部分。<br>
我们比较了实验者在每一次测验中的分数来确定实现者是否展现出了对Raft有着更好的裂解。</p></div><div class="el-p"><p dir="auto">We tried to make the comparison between Paxos and Raft as fair as possible.<br>
The experiment favored Paxos in two ways: 15 of the 43 participants reported having some prior experience with Paxos,<br>
and the Paxos video is 14% longer than the Raft video.<br>
As summarized in Table 1, we have taken steps to mitigate potential sources of bias.<br>
All of our materials are available for review [28, 31].</p></div><div class="el-p"><p dir="auto">我们尝试着使得Paxos和Raft之间的比较尽可能的公平。<br>
该实验在两方面有利于Paxos：43名实验者中的15名报告说曾经有着一些关于Paxos的经验，同时Paxos的视频比Raft的视频要长14%。<br>
如表1所示，我们已经采取措施来减少潜在的来源偏差。<br>
我们所有的材料都是可以审查的。</p></div><div class="el-p"><p dir="auto">On average, participants scored 4.9 points higher on the Raft quiz than on the Paxos quiz<br>
(out of a possible 60 points, the mean Raft score was 25.7 and the mean Paxos score was 20.8);<br>
Figure 14 shows their individual scores.<br>
A paired t-test states that, with 95% confidence,<br>
the true distribution of Raft scores has a mean at least 2.5 points larger than the true distribution of Paxos scores.</p></div><div class="el-p"><p dir="auto">平均而言，参与者在Raft测验中的得分要比Paxos的测验中的得分要高4.9分(换算成60分制，意味着Raft的测验分数为25.7同时Paxos的测验分数为20.8)<br>
图14展示了它们各自的分数。<br>
配队t-test表名，有95%的置信度下，Raft的真实分数分布比Paxos的真实分数分布至少要高2.5分。</p></div><div class="el-p"><p dir="auto">We also created a linear regression model that predicts a new student’s quiz scores based on three factors:<br>
which quiz they took, their degree of prior Paxos experience, and the order in which they learned the algorithms.<br>
The model predicts that the choice of quiz produces a 12.5-point difference in favor of Raft.<br>
This is significantly higher than the observed difference of 4.9 points, because many of the actual students had prior Paxos experience,<br>
which helped Paxos considerably, whereas it helped Raft slightly less.<br>
Curiously, the model also predicts scores 6.3 points lower on Raft for people that have already taken the Paxos quiz;<br>
although we don’t know why, this does appear to be statistically significant.</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240725173212.png" src="Pasted image 20240725173212.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240725173212.png" src="computer-science/distributed-system/raft-原始论文中英/pasted-image-20240725173212.png"></span></p></div><div class="el-p"><p dir="auto">Figure 15: Using a 5-point scale, participants were asked(left) which algorithm they felt<br>
would be easier to implement in a functioning, correct, and efficient system,<br>
and (right) which would be easier to explain to a CS graduate student.</p></div><div class="el-p"><p dir="auto">图15：使用5分支，参与者被问到(左侧)他们感觉使用哪种算法更容易去实现一个正常工作的，正确的，和有效的系统，<br>
同时(右侧)是哪种算法对于计算机科学(CS)的研究生来说会更容易解释。</p></div><div class="el-p"><p dir="auto">我们还创建了一个线性回归模型，其用于预测新生基于三个要素的测验成绩：分别是它们参加的测验，它们之前关于Paxos的经验，以及它们学习算法的顺序。<br>
这个模型预测选择的测验中Raft要比Paxos高12.5分。<br>
这明显高于观察到的4.9分的差异，因为实际上很多学生之前有过Paxos的经验，这有助于对Paxos的理解，而对于Raft的帮助则少很多。<br>
奇怪的是，模型还预测已经参加过Paxos测验的人在Raft的实验上将会低6.3分；即使我们不知道为什么，但这似乎具有统计学的意义。</p></div><div class="el-p"><p dir="auto">We also surveyed participants after their quizzes to see which algorithm they felt would be easier to implement or explain;<br>
these results are shown in Figure 15.<br>
An overwhelming majority of participants reported Raft would be easier to implement and explain (33 of 41 for each question).<br>
However, these self-reported feelings may be less reliable than participants’ quiz scores,<br>
and participants may have been biased by knowledge of our hypothesis that Raft is easier to understand.</p></div><div class="el-p"><p dir="auto">我们还在参与者测验后对其进行了调查，询问它们感觉哪种算法更加容易实现或解释；结果如图15所示。<br>
绝大多数参与者表示Raft要更加容易实现和解释(41个被提问者中的33个)<br>
然而，这些自我报告的感受可能不如参与者的测验分数更加可靠，并且参与者可能由于我们假设了Raft更加容易理解而产生偏见。</p></div><div class="el-p"><p dir="auto">A detailed discussion of the Raft user study is available at [31].</p></div><div class="el-p"><p dir="auto">有关Raft用户研究的详细讨论，请参见[31]。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240725173219.png" src="Pasted image 20240725173219.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240725173219.png" src="computer-science/distributed-system/raft-原始论文中英/pasted-image-20240725173219.png"></span></p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="9.2 Correctness(正确性)" dir="auto" class="heading" id="9.2_Correctness(正确性)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.2 Correctness(正确性)</h3><div class="heading-children"><div class="el-p"><p dir="auto">We have developed a formal specification and a proof of safety for the consensus mechanism described in Section 5.<br>
The formal specification [31] makes the information summarized in Figure 2 completely precise using the TLA+ specification language [17].<br>
It is about 400 lines long and serves as the subject of the proof.<br>
It is also useful on its own for anyone implementing Raft.<br>
We have mechanically proven the Log Completeness Property using the TLA proof system [7].<br>
However, this proof relies on invariants that have not been mechanically checked<br>
(for example, we have not proven the type safety of the specification).<br>
Furthermore, we have written an informal proof [31] of the State Machine Safety property which is complete<br>
(it relies on the specification alone) and rela tively precise (it is about 3500 words long).</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240725173227.png" src="Pasted image 20240725173227.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240725173227.png" src="computer-science/distributed-system/raft-原始论文中英/pasted-image-20240725173227.png"></span></p></div><div class="el-p"><p dir="auto">Figure 16: The time to detect and replace a crashed leader.<br>
The top graph varies the amount of randomness in election timeouts, and the bottom graph scales the minimum election timeout.<br>
Each line represents 1000 trials (except for 100 trials for “150–150ms”) and corresponds to a particular choice of election timeouts;<br>
for example, “150–155ms” means that election timeouts were chosen randomly and uniformly between 150ms and 155ms.<br>
The measurements were taken on a cluster of five servers with a broadcast time of roughly 15ms.<br>
Results for a cluster of nine servers are similar.</p></div><div class="el-p"><p dir="auto">图16：检测和替代一个已崩溃leader的时间。<br>
上图是一系列随机化的选举超时时间，下图是缩放后的最小选举超时时间。<br>
每一行代表了对应于一个特定选举超时时间的1000次实验(除了“150-150ms”的100次实验)；<br>
例如，“150-155ms”意味着选举超时时间是在150ms到155ms间随机且均匀选择的。<br>
测量是在一个有着5台机器的集群上进行的，其广播时间大约为15ms。<br>
由9台服务器组成的集群的结果是类似的。</p></div><div class="el-p"><p dir="auto">我们已经为第5节所描述的一致性机制提供了形式化规约和安全性证明。<br>
形式化规约使用TLA+规约语言精确的使用了如图2摘要中的信息。<br>
大约由400行长并且可以作为证明的主体来使用。<br>
对于任何一个想实现Raft的人来说也是有用的。<br>
我们已经使用TLA证明系统机械地证明了Log Completeness特性。<br>
然而，这一证明依赖于尚未被机械地检查地不变量(例如，我们还没有证明规约的类型安全性)。<br>
此外，我们也编写了关于状态机安全特性(State Machine Safety property)的非正式证明，该证明是完整的(仅依赖于规约)并且是相对精确的(大约长3500字)。</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="9.3 Performance(性能)" dir="auto" class="heading" id="9.3_Performance(性能)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>9.3 Performance(性能)</h3><div class="heading-children"><div class="el-p"><p dir="auto">Raft’s performance is similar to other consensus algorithms such as Paxos.<br>
The most important case for performance is when an established leader is replicating new log entries.<br>
Raft achieves this using the minimal number of messages (a single round-trip from the leader to half the cluster).<br>
It is also possible to further improve Raft’s performance.<br>
For example, it easily supports batching and pipelining requests for higher throughput and lower latency.<br>
Various optimizations have been proposed in the literature for other algorithms; many of these could be applied to Raft,<br>
but we leave this to future work.</p></div><div class="el-p"><p dir="auto">Raft的性能与Paxos等其它一致性算法的性能相差无几。<br>
对于性能而言最重要的方面是一个已被选出的leader复制新的日志条目。<br>
Raft通过使用最少数量的消息来实现这一点(从leader到集群中半数机器的单轮往返)。<br>
这也可能进一步的提升Raft的性能。<br>
例如，它可以轻松的支持批处理和流水线(pipelining)请求来获得更高的吞吐量和更低的延迟。<br>
在资料中已经针对其它算法提出了一系列的优化;其中有很多优化也能应用在Raft中，但我们将此留给未来的工作。</p></div><div class="el-p"><p dir="auto">We used our Raft implementation to measure the performance of Raft’s leader election algorithm and answer two questions.<br>
First, does the election process converge quickly?<br>
Second, what is the minimum downtime that can be achieved after leader crashes?</p></div><div class="el-p"><p dir="auto">我们使用我们自己的Raft实现来衡量Raft的leader选举算法性能，并且回答两个问题。<br>
第一，选举过程是否迅速的收敛？<br>
第二，在leader崩溃后可以实现的停机宕机时间是多少？</p></div><div class="el-p"><p dir="auto">To measure leader election, we repeatedly crashed the leader of a cluster of five servers<br>
and timed how long it took to detect the crash and elect a new leader (see Figure 16).<br>
To generate a worst-case scenario, the servers in each trial had different log lengths, so some candidates were not eligible to become leader.<br>
Furthermore, to encourage split votes, our test script triggered<br>
a synchronized broadcast of heartbeat RPCs from the leader before terminating its process<br>
(this approximates the behavior of the leader replicating a new log entry prior to crashing).<br>
The leader was crashed uniformly randomly within its heartbeat interval, which was half of the minimum election timeout for all tests.<br>
Thus, the smallest possible downtime was about half of the minimum election timeout.</p></div><div class="el-p"><p dir="auto">为了测量leader选举的性能，我们反复的令一个五节点集群中的leader崩溃，并且测量集群多久能检测到崩溃并选举出一个新的leader(见图16)。<br>
为了生成最坏的情况，在每次实验中服务器都有着不同的日志长度，因此一些candidate将没有资格成为leader。<br>
此外，为了促进分裂投票的产生，我们的测试脚本在终止leader进程前触发了一次leader的同步RPC心跳广播(这类似于leader在崩溃前复制新的日志条目的行为)。</p></div><div class="el-p"><p dir="auto">The top graph in Figure 16 shows that a small amount of randomization in the election timeout is enough to avoid split votes in elections.<br>
In the absence of randomness, leader election consistently took longer than 10 seconds in our tests due to many split votes.<br>
Adding just 5ms of randomness helps significantly, resulting in a median downtime of 287ms.<br>
Using more randomness improves worst-case behavior: with 50ms of randomness the worstcase completion time (over 1000 trials) was 513ms.</p></div><div class="el-p"><p dir="auto">图16中的上图显示了，只要少量的随机化选举超时时间就足够避免选举时的投票分裂。<br>
在缺乏随机性的情况下，由于许多分裂的投票，在我们的测试中leader选举一直持续了超过10秒钟。<br>
只要增加5ms的随机性就能有显著的帮助，平均的停机时间中位数为287ms。<br>
使用更多的随机性可以改善最坏情况下的行为：有着50ms的随机性时最坏情况下(超过1000次实验)的选举完成时间为513ms。</p></div><div class="el-p"><p dir="auto">The bottom graph in Figure 16 shows that downtime can be reduced by reducing the election timeout.<br>
With an election timeout of 12–24ms, it takes only 35ms on average to elect a leader (the longest trial took 152ms).<br>
However, lowering the timeouts beyond this point violates Raft’s timing requirement:<br>
leaders have difficulty broadcasting heartbeats before other servers start new elections.<br>
This can cause unnecessary leader changes and lower overall system availability.<br>
We recommend using a conservative election timeout such as 150–300ms;<br>
such timeouts are unlikely to cause unnecessary leader changes and will still provide good availability.</p></div><div class="el-p"><p dir="auto">图16中的下图显示，可以通过减少选举超时时间来减少停机时间。<br>
由于选举超时时间为12-24ms，选举出一个leader的平均耗时只需要35ms(最长的一次实验花费了152ms)。<br>
然而，超时时间低于这一位点以下会违反Raft的时间需求：leader很难在其它leader发起新一轮选举前进行心跳广播。<br>
这可能会导致不必要的leader变更以及更低的整体系统可用性。<br>
我们推荐使用一个保守的选举超时时间比如150-300ms；这一超时时间不太可能造成不必要的leader变更并且将仍然提供良好的可用性。</p></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="10 Related work" dir="auto" class="heading" id="10_Related_work"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>10 Related work</h2><div class="heading-children"><div class="el-p"><p dir="auto">There have been numerous publications related to consensus algorithms, many of which fall into one of the following categories:</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">Lamport’s original description of Paxos [15], and attempts to explain it more clearly [16, 20, 21].</li>
<li data-line="1" dir="auto">Elaborations of Paxos, which fill in missing details and modify the algorithm to provide a better foundation for implementation [26, 39, 13].</li>
<li data-line="2" dir="auto">Systems that implement consensus algorithms, such as Chubby [2, 4], ZooKeeper [11, 12], and Spanner [6].<br>
The algorithms for Chubby and Spanner have not been published in detail, though both claim to be based on Paxos.<br>
ZooKeeper’s algorithm has been published in more detail, but it is quite different from Paxos.</li>
<li data-line="5" dir="auto">Performance optimizations that can be applied to Paxos [18, 19, 3, 25, 1, 27].</li>
<li data-line="6" dir="auto">Oki and Liskov’s View-stamped Replication (VR), an alternative approach to consensus developed around the same time as Paxos.<br>
The original description [29] was intertwined with a protocol for distributed transactions,<br>
but the core consensus protocol has been separated in a recent update [22].<br>
VR uses a leader-based approach with many similarities to Raft.</li>
</ul></div><div class="el-p"><p dir="auto">已经有许多与一致性算法有关的出版物了，其中很多都属于以下类目中的一个：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">Lamport对于Paxos的原始描述，并且试图更加清晰的进行解释。</li>
<li data-line="1" dir="auto">对Paxos的细化，其填充了确实的细节并且修改了算法以为实现Paxos提供了一个更好的基础。</li>
<li data-line="2" dir="auto">实现了共识算法的系统，例如Chubby，ZooKeeper和Spanner。<br>
Chubby和Spanner的算法并没有公布细节，即使它们都声称其基于Paxos。<br>
ZooKeeper的算法公布了更多的细节，但其与Paxos截然不同。</li>
<li data-line="5" dir="auto">可用于Paxos的性能优化。</li>
<li data-line="6" dir="auto">Oki和Liskov的Viewstamped Replication (VR)算法，另一种共识算法其被开发的时间点与Paxos相同。<br>
最初的描述与分布式事务的协议混在了一起，但最近的更新中其核心的共识协议已经被分离出来了。<br>
VR采用了一种基于leader的方法,其与Raft存在很多相似之处。</li>
</ul></div><div class="el-p"><p dir="auto">The greatest difference between Raft and Paxos is Raft’s strong leadership:<br>
Raft uses leader election as an essential part of the consensus protocol, and it concentrates as much functionality as possible in the leader.<br>
This approach results in a simpler algorithm that is easier to understand.<br>
For example, in Paxos, leader election is orthogonal to the basic consensus protocol:<br>
it serves only as a performance optimization and is not required for achieving consensus.<br>
However, this results in additional mechanism:<br>
Paxos includes both a two-phase protocol for basic consensus and a separate mechanism for leader election.<br>
In contrast, Raft incorporates leader election directly into the consensus algorithm and uses it as the first of the two phases of consensus.<br>
This results in less mechanism than in Paxos.</p></div><div class="el-p"><p dir="auto">Raft和Paxos最大的区别在于Raft的强领导性：<br>
Raft将leader选举作为共识协议中必要的组成部分，并尽可能的将很多功能集中在leader身上。<br>
这一策略使得Raft成为了一个更简单的算法，其更容易被理解。<br>
例如，在Paxos中，leader选举基本上与基础的一致性协议无关：<br>
其仅仅用于性能优化并且不是实现共识所必须的。<br>
然而，这产生了额外的机制：<br>
Paxos包括了一个用于基础一致性的两阶段协议以及一个单独的用于leader选举的机制。<br>
相比之下，Raft将leader选举直接纳入共识算法中并且将leader选举作为共识的两阶段中的第一个阶段。<br>
这使得Raft比起Paxos有着更少的机制。</p></div><div class="el-p"><p dir="auto">Like Raft, VR and ZooKeeper are leader-based and therefore share many of Raft’s advantages over Paxos.<br>
However, Raft has less mechanism that VR or ZooKeeper because it minimizes the functionality in non-leaders.<br>
For example, log entries in Raft flow in only one direction: outward from the leader in AppendEntries RPCs.<br>
In VR log entries flow in both directions (leaders can receive log entries during the election process);<br>
this results in additional mechanism and complexity.<br>
The published description of ZooKeeper also transfers log entries both to and from the leader,<br>
but the implementation is apparently more like Raft [35].</p></div><div class="el-p"><p dir="auto">与Raft一样，VR和ZooKeeper都是基于leader的并且也共享着很多Raft相对于Paxos的优点。<br>
然而，Raft比起VR或者Zookeeper有着更少的机制，因为它最小化了非leader(non-leaders)的功能。<br>
例如，Raft中的日志条目流向只有一个方向：从leader向外流出的AppendEntries RPC。<br>
在VR中日志条目是双向流动的(leader也可以在选举期间接受日志条目);这引入了额外的机制和复杂度。<br>
ZooKeeper的已公布的描述中也允许日志条目在leader中双向的传输，但其实现明显与Raft更加相似。</p></div><div class="el-p"><p dir="auto">Raft has fewer message types than any other algorithm for consensus-based log replication that we are aware of.<br>
For example, we counted the message types VR and ZooKeeper use for basic consensus and membership<br>
changes (excluding log compaction and client interaction, as these are nearly independent of the algorithms).<br>
VR and ZooKeeper each define 10 different message types, while Raft has only 4 message types (two RPC requests and their responses).<br>
Raft’s messages are a bit more dense than the other algorithms’, but they are simpler collectively.<br>
In addition, VR and ZooKeeper are described in terms of transmitting entire logs during leader changes;<br>
additional message types will be required to optimize these mechanisms so that they are practical.</p></div><div class="el-p"><p dir="auto">Raft的消息类型比任何其它已知的、基于日志复制的共识算法都要少。<br>
例如，我们统计了VR和ZooKeeper用于基础共识和成员变更的消息类型数(不包括日志压缩和客户端交互，因为这些与算法几乎是独立的)。<br>
VR和ZooKeeper都定义了10种不同的消息类型，而Raft只有4种(2种RPC的请求以及它们的响应)。<br>
Raft的消息比其它算法的要稍微紧密一些，但总体上更加简单。<br>
此外，VR和ZooKeeper所描述的在任期转换时需要传输完整的日志;所以在实践中需要额外的消息类型来优化这些机制。</p></div><div class="el-p"><p dir="auto">Raft’s strong leadership approach simplifies the algorithm, but it precludes some performance optimizations.<br>
For example, Egalitarian Paxos (EPaxos) can achieve higher performance under some conditions with a leaderless approach [27].<br>
EPaxos exploits commutativity in state machine commands.<br>
Any server can commit a command with just one round of communication as long as other commands that are proposed concurrently commute with it.<br>
However, if commands that are proposed concurrently do not commute with each other, EPaxos requires an additional round of communication.<br>
Because any server may commit commands, EPaxos balances load well between servers and is able to achieve lower latency than Raft in WAN settings.<br>
However, it adds significant complexity to Paxos.</p></div><div class="el-p"><p dir="auto">Raft的强领导力方法简化了算法，但是也排除了一些性能优化。<br>
例如，Egalitarian Paxos(EPaxos)可以通过无leader的方法在某些条件下可以获得更高的性能。<br>
EPaxos利用了状态机指令的交换性。<br>
只要同时提出的其它指令能够与之交换，任何服务器都可以仅在一轮通信中提交指令。<br>
然而，如果同时发出的指令不能相互交换，则EPaxos需要额外的一轮通信。<br>
因为任何服务器都能够提交指令，EPaxos能够更好的平衡服务器间的负载并且能够达到比Raft的WAN设置更低的延迟。<br>
然而，这显著的增加了Paxos的复杂性。</p></div><div class="el-p"><p dir="auto">Several different approaches for cluster membership changes have been proposed or implemented in other work,<br>
including Lamport’s original proposal [15], VR [22], and SMART [24].<br>
We chose the joint consensus approach for Raft because it leverages the rest of the consensus protocol,<br>
so that very little additional mechanism is required for membership changes.<br>
Lamport’s α-based approach was not an option for Raft because it assumes consensus can be reached without a leader.<br>
In comparison to VR and SMART, Raft’s reconfiguration algorithm has the advantage<br>
that membership changes can occur without limiting the processing of normal requests;<br>
in contrast, VR stops all normal processing during configuration changes,<br>
and SMART imposes an α-like limit on the number of outstanding requests.<br>
Raft’s approach also adds less mechanism than either VR or SMART.</p></div><div class="el-p"><p dir="auto">在其它工作中，几种不同的用于集群成员变更的方法已经被提出或被实现，包括Lamport的原始提案，VR以及SMART。<br>
我们为Raft选择了联合一致的方法，因为它利用了一致性协议的其余部分，因此成员变更只需要增加非常少的额外机制。<br>
Lamport的α-based方法没有被Raft选中，因为它假设可以在没有leader的情况下达成共识。<br>
与VR和SMART相比，Raft的刷新配置的算法有一个优点是可以再不限制正常请求的情况下进行成员变更；<br>
相比之下，VR在配置变更期间停止所有正常的请求处理并且SMART对未完成的请求施加了α-like限制。<br>
Raft的方法相比VR或者SMART也增加了最少的机制。</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="11 Conclusion" dir="auto" class="heading" id="11_Conclusion"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>11 Conclusion</h2><div class="heading-children"><div class="el-p"><p dir="auto">Algorithms are often designed with correctness, efficiency, and/or conciseness as the primary goals.<br>
Although these are all worthy goals, we believe that understandability is just as important.<br>
None of the other goals can be achieved until developers render the algorithm into a practical implementation,<br>
which will inevitably deviate from and expand upon the published form.<br>
Unless developers have a deep understanding of the algorithm and can create intuitions about it,<br>
it will be difficult for them to retain its desirable properties in their implementation.</p></div><div class="el-p"><p dir="auto">算法的设计通常以正确性，效率和/或间接性为主要目标。<br>
尽管这些都是有价值的目标，我们认为可理解性同样重要。<br>
在开发人员将算法转化为一个可行的实现前无法达成任何其它的目标，而实际实现将不可避免的偏离和拓展已发布的形式。<br>
除非开发人员对算法有着很深的理解并且对其产生直觉，否则其将很难在他们的实现中保留理想的特性。</p></div><div class="el-p"><p dir="auto">In this paper we addressed the issue of distributed consensus, where a widely accepted but impenetrable algorithm,<br>
Paxos, has challenged students and developers for many years.<br>
We developed a new algorithm, Raft, which we have shown to be more understandable than Paxos.<br>
We also believe that Raft provides a better foundation for system building.<br>
Using understandability as the primary design goal changed the way we approached the design of Raft;<br>
as the design progressed we found ourselves reusing a few techniques repeatedly,<br>
such as decomposing the problem and simplifying the state space.<br>
These techniques not only improved the understandability of Raft but also made it easier to convince ourselves of its correctness.</p></div><div class="el-p"><p dir="auto">在本文中我们讨论了分布式一致性的问题，一种被广泛接受但难于实现的算法Paxos，在多年来一直在挑战着学生和开发者。<br>
我们开发了一种新的算法，Raft，我们已经展示了其比Paxos更加容易理解。<br>
我们也认为Raft为构建系统提供了一个更好的基础。<br>
以可理解性作为主要实现目标改变了我们设计Raft时的方法；随着设计的近战我们发现我们重复的复用了少量技术，例如分解问题和简化状态空间。<br>
这些技术不仅提高了Raft的可理解性也使得我们更容易相信它的正确性。</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="12 Acknowledgments(致谢)" dir="auto" class="heading" id="12_Acknowledgments(致谢)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>12 Acknowledgments(致谢)</h2><div class="heading-children"><div class="el-p"><p dir="auto">The user study would not have been possible without the support of Ali Ghodsi, David Mazieres,<br>
and the students of CS 294-91 at Berkeley and CS 240 at Stanford.<br>
Scott Klemmer helped us design the user study, and Nelson Ray advised us on statistical analysis.<br>
The Paxos slides for the user study borrowed heavily from a slide deck originally created by Lorenzo Alvisi.<br>
Special thanks go to David Mazi`eres and Ezra Hoch for finding subtle bugs in Raft.<br>
Many people provided helpful feedback on the paper and user study materials,<br>
including Ed Bugnion, Michael Chan, Hugues Evrard,Daniel Giffin, Arjun Gopalan, Jon Howell, Vimalkumar Jeyakumar, Ankita Kejriwal,<br>
Aleksandar Kracun, Amit Levy, Joel Martin, Satoshi Matsushita, Oleg Pesok, David Ramos,<br>
Robbert van Renesse, Mendel Rosenblum, Nicolas Schiper, Deian Stefan, Andrew Stone, Ryan Stutsman,<br>
David Terei, Stephen Yang, Matei Zaharia, 24 anonymous conference reviewers (with duplicates), and especially our shepherd Eddie Kohler.<br>
Werner Vogels tweeted a link to an earlier draft, which gave Raft significant exposure.<br>
This work was supported by the Gigascale Systems Research Center and the Multiscale Systems Center,<br>
two of six research centers funded under the Focus Center Research Program, a Semiconductor Research Corporation program,<br>
by STAR net, a Semiconductor Research Corporation program sponsored by MARCO and DARPA,<br>
by the National Science Foundation under Grant No. 0963859, and by grants from Facebook, Google, Mellanox, NEC, NetApp, SAP,<br>
and Samsung. Diego Ongaro is supported by The Junglee Corporation Stanford Graduate Fellowship.</p></div><div class="mod-footer mod-ui"></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="computer-science/distributed-system/raft-原始论文中英/in-search-of-an-understandable-consensus-algorithm(extended-version).html#In Search of an Understandable Consensus Algorithm(Extended Version)"><div class="tree-item-contents heading-link" heading-name="In Search of an Understandable Consensus Algorithm(Extended Version)"><span class="tree-item-title">In Search of an Understandable Consensus Algorithm(Extended Version)</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="computer-science/distributed-system/raft-原始论文中英/in-search-of-an-understandable-consensus-algorithm(extended-version).html#作者：斯坦福大学的Diego_Ongaro和John_Ousterhout"><div class="tree-item-contents heading-link" heading-name="作者：斯坦福大学的Diego Ongaro和John Ousterhout"><span class="tree-item-title">作者：斯坦福大学的Diego Ongaro和John Ousterhout</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/distributed-system/raft-原始论文中英/in-search-of-an-understandable-consensus-algorithm(extended-version).html#Abstract(摘要)"><div class="tree-item-contents heading-link" heading-name="Abstract(摘要)"><span class="tree-item-title">Abstract(摘要)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/distributed-system/raft-原始论文中英/in-search-of-an-understandable-consensus-algorithm(extended-version).html#1_Introduction(介绍)"><div class="tree-item-contents heading-link" heading-name="1 Introduction(介绍)"><span class="tree-item-title">1 Introduction(介绍)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/distributed-system/raft-原始论文中英/in-search-of-an-understandable-consensus-algorithm(extended-version).html#2_Replicated_state_machines(复制状态机)"><div class="tree-item-contents heading-link" heading-name="2 Replicated state machines(复制状态机)"><span class="tree-item-title">2 Replicated state machines(复制状态机)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/distributed-system/raft-原始论文中英/in-search-of-an-understandable-consensus-algorithm(extended-version).html#3_What’s_wrong_with_Paxos?(Paxos存在的问题)"><div class="tree-item-contents heading-link" heading-name="3 What’s wrong with Paxos?(Paxos存在的问题)"><span class="tree-item-title">3 What’s wrong with Paxos?(Paxos存在的问题)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/distributed-system/raft-原始论文中英/in-search-of-an-understandable-consensus-algorithm(extended-version).html#4_Designing_for_understandability(为通俗易懂而设计)"><div class="tree-item-contents heading-link" heading-name="4 Designing for understandability(为通俗易懂而设计)"><span class="tree-item-title">4 Designing for understandability(为通俗易懂而设计)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="computer-science/distributed-system/raft-原始论文中英/in-search-of-an-understandable-consensus-algorithm(extended-version).html#5._The_Raft_consensus_algorithm(Raft一致性算法)"><div class="tree-item-contents heading-link" heading-name="5. The Raft consensus algorithm(Raft一致性算法)"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">5. 
The Raft consensus algorithm(Raft一致性算法)
</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="computer-science/distributed-system/raft-原始论文中英/in-search-of-an-understandable-consensus-algorithm(extended-version).html#5.1_Raft_basics(Raft基础)"><div class="tree-item-contents heading-link" heading-name="5.1 Raft basics(Raft基础)"><span class="tree-item-title">5.1 Raft basics(Raft基础)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="computer-science/distributed-system/raft-原始论文中英/in-search-of-an-understandable-consensus-algorithm(extended-version).html#5.2_Leader_election(leader选举)"><div class="tree-item-contents heading-link" heading-name="5.2 Leader election(leader选举)"><span class="tree-item-title">5.2 Leader election(leader选举)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="computer-science/distributed-system/raft-原始论文中英/in-search-of-an-understandable-consensus-algorithm(extended-version).html#5.3_Log_replication(日志复制)"><div class="tree-item-contents heading-link" heading-name="5.3 Log replication(日志复制)"><span class="tree-item-title">5.3 Log replication(日志复制)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="computer-science/distributed-system/raft-原始论文中英/in-search-of-an-understandable-consensus-algorithm(extended-version).html#5.4_Safety(安全性)"><div class="tree-item-contents heading-link" heading-name="5.4 Safety(安全性)"><span class="tree-item-title">5.4 Safety(安全性)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="computer-science/distributed-system/raft-原始论文中英/in-search-of-an-understandable-consensus-algorithm(extended-version).html#5.4.1_Election_restriction(选举限制)"><div class="tree-item-contents heading-link" heading-name="5.4.1 Election restriction(选举限制)"><span class="tree-item-title">5.4.1 Election restriction(选举限制)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="computer-science/distributed-system/raft-原始论文中英/in-search-of-an-understandable-consensus-algorithm(extended-version).html#5.4.2_Committing_entries_from_previous_terms(来自之前任期的已提交条目)"><div class="tree-item-contents heading-link" heading-name="5.4.2 Committing entries from previous terms(来自之前任期的已提交条目)"><span class="tree-item-title">5.4.2 Committing entries from previous terms(来自之前任期的已提交条目)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="computer-science/distributed-system/raft-原始论文中英/in-search-of-an-understandable-consensus-algorithm(extended-version).html#5.4.3_Safety_argument(安全性参数)"><div class="tree-item-contents heading-link" heading-name="5.4.3 Safety argument(安全性参数)"><span class="tree-item-title">5.4.3 Safety argument(安全性参数)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="computer-science/distributed-system/raft-原始论文中英/in-search-of-an-understandable-consensus-algorithm(extended-version).html#5.5_Follower_and_candidate_crashes(follower和candidate崩溃)"><div class="tree-item-contents heading-link" heading-name="5.5 Follower and candidate crashes(follower和candidate崩溃)"><span class="tree-item-title">5.5 Follower and candidate crashes(follower和candidate崩溃)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="computer-science/distributed-system/raft-原始论文中英/in-search-of-an-understandable-consensus-algorithm(extended-version).html#5.6_Timing_and_availability(时间和可用性)"><div class="tree-item-contents heading-link" heading-name="5.6 Timing and availability(时间和可用性)"><span class="tree-item-title">5.6 Timing and availability(时间和可用性)</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/distributed-system/raft-原始论文中英/in-search-of-an-understandable-consensus-algorithm(extended-version).html#6_Cluster_membership_changes(集群成员变更)"><div class="tree-item-contents heading-link" heading-name="6 Cluster membership changes(集群成员变更)"><span class="tree-item-title">6 Cluster membership changes(集群成员变更)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/distributed-system/raft-原始论文中英/in-search-of-an-understandable-consensus-algorithm(extended-version).html#7_Log_compaction(日志压缩)"><div class="tree-item-contents heading-link" heading-name="7 Log compaction(日志压缩)"><span class="tree-item-title">7 Log compaction(日志压缩)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/distributed-system/raft-原始论文中英/in-search-of-an-understandable-consensus-algorithm(extended-version).html#8_Client_interaction(客户端交互)"><div class="tree-item-contents heading-link" heading-name="8 Client interaction(客户端交互)"><span class="tree-item-title">8 Client interaction(客户端交互)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="computer-science/distributed-system/raft-原始论文中英/in-search-of-an-understandable-consensus-algorithm(extended-version).html#9_Implementation_and_evaluation(实现与评估)"><div class="tree-item-contents heading-link" heading-name="9 Implementation and evaluation(实现与评估)"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">9 Implementation and evaluation(实现与评估)</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="computer-science/distributed-system/raft-原始论文中英/in-search-of-an-understandable-consensus-algorithm(extended-version).html#9.1_Understandability(可理解性)"><div class="tree-item-contents heading-link" heading-name="9.1 Understandability(可理解性)"><span class="tree-item-title">9.1 Understandability(可理解性)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="computer-science/distributed-system/raft-原始论文中英/in-search-of-an-understandable-consensus-algorithm(extended-version).html#9.2_Correctness(正确性)"><div class="tree-item-contents heading-link" heading-name="9.2 Correctness(正确性)"><span class="tree-item-title">9.2 Correctness(正确性)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="computer-science/distributed-system/raft-原始论文中英/in-search-of-an-understandable-consensus-algorithm(extended-version).html#9.3_Performance(性能)"><div class="tree-item-contents heading-link" heading-name="9.3 Performance(性能)"><span class="tree-item-title">9.3 Performance(性能)</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/distributed-system/raft-原始论文中英/in-search-of-an-understandable-consensus-algorithm(extended-version).html#10_Related_work"><div class="tree-item-contents heading-link" heading-name="10 Related work"><span class="tree-item-title">10 Related work</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/distributed-system/raft-原始论文中英/in-search-of-an-understandable-consensus-algorithm(extended-version).html#11_Conclusion"><div class="tree-item-contents heading-link" heading-name="11 Conclusion"><span class="tree-item-title">11 Conclusion</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/distributed-system/raft-原始论文中英/in-search-of-an-understandable-consensus-algorithm(extended-version).html#12_Acknowledgments(致谢)"><div class="tree-item-contents heading-link" heading-name="12 Acknowledgments(致谢)"><span class="tree-item-title">12 Acknowledgments(致谢)</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>