<!DOCTYPE html> <html><head>
		<title>Folding in Parallel</title>
		<base href="../../">
		<meta id="root-path" root-path="../../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="韩暮秋的个人维基 - Folding in Parallel">
		<meta property="og:title" content="Folding in Parallel">
		<meta property="og:description" content="韩暮秋的个人维基 - Folding in Parallel">
		<meta property="og:type" content="website">
		<meta property="og:url" content="https://muqiuhan.github.io/wiki/computer-science/functional-programming/folding-in-parallel.html">
		<meta property="og:image" content="undefined">
		<meta property="og:site_name" content="韩暮秋的个人维基">
		<meta name="author" content="韩暮秋"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="lib/scripts/pixi.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="lib/scripts/minisearch.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.jpg"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="preload" href="lib/styles/other-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/other-plugins.css"></noscript><link rel="stylesheet" href="lib/styles/theme.css"><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/supported-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/supported-plugins.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript></head><body class="publish css-settings-manager theme-dark show-inline-title show-ribbon oled-black lst-fab-b2-1 is-css-guide list-d-c-d lst-fm-compact lst-prop-super-compact"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="Folding in Parallel"><p dir="auto">Folding in Parallel</p></h1><div><p dir="auto"><a href="?query=tag:fp" class="tag" target="_blank" rel="noopener">#fp</a> </p></div><div><p dir="auto">We describe interesting ways of representing an inherently sequential accumulation (<code>fold</code>) as the composition of a <code>map</code> and a monoid reduction. As the result, some seemingly sequential algorithms can run not just in parallel but embarrassingly in parallel: The input sequence can be arbitrarily partitioned (and recursively sub-partitioned, if desired) among workers, which would run in parallel with no races, dependencies or even memory bank conflicts. Such embarrassing parallelism is ideal for multi-core, GPU or distributed processing.</p></div><div><p dir="auto">The general principle is well-known; also well-known is that its specific applications require ingenuity.</p></div><div><ul>
<li data-line="0" dir="auto"><a data-tooltip-position="top" aria-label="https://okmij.org/ftp/Algorithms/map-monoid-reduce.html#intro" rel="noopener" class="external-link" href="https://okmij.org/ftp/Algorithms/map-monoid-reduce.html#intro" target="_blank">Introduction: Fold v. Monoid Reduction</a></li>
<li data-line="1" dir="auto"><a data-tooltip-position="top" aria-label="https://okmij.org/ftp/Algorithms/map-monoid-reduce.html#trivial" rel="noopener" class="external-link" href="https://okmij.org/ftp/Algorithms/map-monoid-reduce.html#trivial" target="_blank">Fold as map-reduce, trivially</a></li>
<li data-line="2" dir="auto"><a data-tooltip-position="top" aria-label="https://okmij.org/ftp/Algorithms/map-monoid-reduce.html#simple" rel="noopener" class="external-link" href="https://okmij.org/ftp/Algorithms/map-monoid-reduce.html#simple" target="_blank">Fold as map-reduce, more interestingly</a></li>
<li data-line="3" dir="auto"><a data-tooltip-position="top" aria-label="https://okmij.org/ftp/Algorithms/map-monoid-reduce.html#Horner" rel="noopener" class="external-link" href="https://okmij.org/ftp/Algorithms/map-monoid-reduce.html#Horner" target="_blank">Generalized Horner rule</a></li>
<li data-line="4" dir="auto"><a data-tooltip-position="top" aria-label="https://okmij.org/ftp/Algorithms/map-monoid-reduce.html#BM" rel="noopener" class="external-link" href="https://okmij.org/ftp/Algorithms/map-monoid-reduce.html#BM" target="_blank">Boyer-Moore majority voting</a></li>
<li data-line="5" dir="auto"><a data-tooltip-position="top" aria-label="https://okmij.org/ftp/Algorithms/map-monoid-reduce.html#conclusions" rel="noopener" class="external-link" href="https://okmij.org/ftp/Algorithms/map-monoid-reduce.html#conclusions" target="_blank">Conclusions</a></li>
</ul></div><div><hr></div><div class="heading-wrapper"><h2 data-heading="Introduction: Fold v. Monoid Reduction" dir="auto" class="heading" id="Introduction:_Fold_v._Monoid_Reduction"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Introduction: Fold v. Monoid Reduction</h2><div class="heading-children"><div><p dir="auto">At ICFP 2009, Guy Steele gave a keynote calling ``foldl and foldr considered slightly harmful'' and advocating (map)reduce instead.</p></div><div><p dir="auto">Recall, folding over a sequence is an inherently sequential stateful accumulation; using lists for concreteness, it is defined as</p></div><div><pre><code>fold_left  : ('z -&gt; 'a -&gt; 'z) -&gt; 'z -&gt; 'a list -&gt; 'z
fold_right : ('a -&gt; 'z -&gt; 'z) -&gt; 'a list -&gt; 'z -&gt; 'z
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">Actually, there are two operations: the left and the right fold. Their meaning should be clear from the following example:</p></div><div><pre><code>fold_left (+) 0 [1;2;3;4]  ≡ (((0 + 1) + 2) + 3) + 4

fold_right (+) [1;2;3;4] 0 ≡ 1 + (2 + (3 + (4 + 0)))
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">In this case, of the folding function being addition, the results are identical: both expressions sum the list. Generally, left and right folds produce different results: try, for example, subtraction as the folding function. The types of the list elements <code>'a</code> and of the accumulator <code>'z</code> need not be the same: for example,</p></div><div><pre><code>fold_left (fun z _ -&gt; z + 1) 0 l
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">computes the length of any list,</p></div><div><pre><code>fold_left (fun z x -&gt; x :: z) [] l
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">reverses the list <code>l</code> and</p></div><div><pre><code>fold_right (fun x z -&gt; if p x then x::z else z) l []
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">filters the list: omits the elements for which the predicate <code>p</code> returns <code>false</code>. Many other operations on lists (in fact, all of them) can be expressed as folds. Fold is indeed the general pattern of sequential stateful processing of a sequence.</p></div><div><p dir="auto">The are alternative definitions of fold: sometimes the last two arguments of the right fold are swapped. If the arguments of the right folding function are likewise swapped, then the left and the right fold have the same signature. Their behavior, the association pattern, is still different. Olivier Danvy, see below, traces the history of list folds and the argument order.</p></div><div><p dir="auto">For concreteness we showed folds over lists, but similar operations exist over arrays, streams, files, trees, dictionaries and any other collections.</p></div><div><p dir="auto">In this article, by reduce we always mean the reduce over a monoid. A monoid is a set (called `carrier set') with an associative binary operation which has a unit (also called zero) element. Concretely, in OCaml</p></div><div><pre><code>type 'a monoid = {zero: 'a; op: 'a -&gt; 'a -&gt; 'a}
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">where <code>'a</code> is the type of monoid elements, <code>op</code> must be associative and</p></div><div><pre><code>op zero x = op x zero = x
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">must hold for every element <code>x</code> of the monoid. In Google MapReduce, the operation <code>op</code> is also taken to be commutative. We do not impose such requirement.</p></div><div><p dir="auto">Reduce over a sequence (here, a list) is the operation</p></div><div><pre><code>reduce : 'a monoid -&gt; 'a list -&gt; 'a
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">with the behavior that can be illustrated as</p></div><div><pre><code>reduce monoid []  ≡ monoid.zero
reduce monoid [x] ≡ x             (* for any x and monoid *)

reduce {zero=0;op=(+)} [1;2;3;4] ≡ 1 + 2 + 3 + 4
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">One may say that reduce <code>wedges in' the monoid operation between the consecutive elements of the sequence. Since </code>op` is associative, the parentheses are not necessary. Therefore, unlike the left and the right fold, there is only one reduce.</p></div><div><p dir="auto">We shall see that reduce is often pre-composed with map. The two operations may always be fused, into</p></div><div><pre><code>map_reduce : ('a -&gt; 'z) -&gt; 'z monoid -&gt; 'a list -&gt; 'z
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">Nevertheless, we will write map and reduce separately, for clarity&nbsp;-- assuming that actual implementations use the efficient, fused operation.</p></div><div><p dir="auto">Fold has to be evaluated sequentially, because of the data dependency on the accumulator. In fact, the left fold is just another notation for a <code>for</code>-loop:</p></div><div><pre><code>type 'a array_slice = {arr:'a array; from:int; upto:int} 
let fold_left_arr : ('z -&gt; 'a -&gt; 'z) -&gt; 'z -&gt; 'a array_slice -&gt; 'z = 
  fun f z {arr;from;upto} -&gt;
  let acc = ref z in
  for i=from to upto do
    acc := f !acc arr.(i)
  done;
  !acc
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">Here, for variety, we use an array slice as a sequence.</p></div><div><p dir="auto">On the other hand, reduce has a variety of implementations. It may be performed sequentially:</p></div><div><pre><code>let seqreduce_arr (m: 'a monoid) (arrsl: 'a array_slice) : 'a =
  fold_left_arr m.op m.zero arrsl
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">Or it can be done in parallel:</p></div><div><pre><code>let rec parreduce_arr (m: 'a monoid) {arr;from;upto} : 'a =
  match upto+1-from with
  | 0 -&gt; m.zero
  | 1 -&gt; arr.(from)
  | 2 -&gt; m.op arr.(from) arr.(from+1)
  | 3 -&gt; m.op (m.op arr.(from) arr.(from+1)) arr.(from+2)
  | n -&gt; let n' = n / 2 in
         (* Here, the two parreduce_arr invocations can be done in parallel! *)
         m.op 
           (parreduce_arr m {arr;from;upto=from+n'-1})
           (parreduce_arr m {arr;from=from+n';upto})
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">The two <code>parreduce_arr</code> invocations in the recursive case can run in parallel&nbsp;-- embarrassingly in parallel, with no races or even read dependencies. Whether they should be done in parallel is another question&nbsp;-- something that we can decide case-by-case. For example, if the array slice is short, the two <code>parreduce_arr</code> invocations are better done sequentially (since the ever-present overhead of parallel evaluation would dominate.) If the two halves of the slice are reduced also in parallel, we obtain a hierarchical decomposition: binary-tree--like processing.</p></div><div><p dir="auto">We do not have to recursively decompose the slices. We may cut the input array into a sequence of non-overlapping slices, arbitrarily, and assign them to available cores. The cores may do their assigned work as they wish, without any synchronization with the others. At the end, we combine their results using the monoid operation.</p></div><div><p dir="auto">Since the (left or right) fold commits us to sequential evaluation, Guy Steele called it `slightly harmful'. He urged using reduce, as far as possible, because it is flexible and decouples the algorithm from the execution strategy. The strategy (sequential, parallel, distributed) and data partitioning can be chosen later, depending on circumstances and available resources.</p></div><div><p dir="auto">Thus the main question is: can we convert fold into reduce? The rest of the article answers it.</p></div><div><p dir="auto"><strong>References</strong></p></div><div><p dir="auto">Guy Steele: Organizing Functional Code for Parallel execution or, foldl and foldr considered slightly harmful<br>
August 2009 (ICFP 2009, Keynote)</p></div><div><p dir="auto">Olivier Danvy: ``Folding left and right matters: direct style, accumulators, and continuations''<br>
Journal of Functional Programming, vol 33, e2. Functional Pearl, February 2023<br>
Appendix A: A brief history of folding left and right over lists</p></div><div><p dir="auto">According to Danvy, the first instances of <code>fold_left</code> and <code>fold_right</code> were investigated by Christopher Strachey in 1961(!). Reduce is part of APL (Iverson, 1962), where it is called <code>/': hence </code>+/x<code>sums the array</code>x`. Goedel recursor R in System T is a more general version of fold (called now para-fold). Church numerals are folds.</p></div><div><p dir="auto"><a data-tooltip-position="top" aria-label="https://okmij.org/ftp/Algorithms/monoid_reduce.ml" rel="noopener" class="external-link" href="https://okmij.org/ftp/Algorithms/monoid_reduce.ml" target="_blank">monoid_reduce.ml</a>&nbsp;[12K]<br>
Complete code for the article</p></div><div><p dir="auto"><a data-tooltip-position="top" aria-label="https://okmij.org/ftp/Streams.html#zip-folds" rel="noopener" class="external-link" href="https://okmij.org/ftp/Streams.html#zip-folds" target="_blank">How to zip folds</a><br>
A complete library of fold-represented lists, demonstrating that all list processing operations can be expressed as folds</p></div><div><p dir="auto"><a data-tooltip-position="top" aria-label="https://okmij.org/ftp/Scheme/xml.html#Papers" rel="noopener" class="external-link" href="https://okmij.org/ftp/Scheme/xml.html#Papers" target="_blank">Accumulating tree traversals, a better tree fold</a> with applications to XML parsing</p></div></div></div><div class="heading-wrapper"><h2 data-heading="Fold as map-reduce, trivially" dir="auto" class="heading" id="Fold_as_map-reduce,_trivially"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Fold as map-reduce, trivially</h2><div class="heading-children"><div><p dir="auto">The main question is expressing <code>fold_left</code> and <code>fold_right</code> in terms of <code>reduce</code>. In this section we see two trivial answers. In fact, we see that fold can <em>always</em> be expressed in terms of reduce&nbsp;-- but in a way that is not useful or interesting.</p></div><div><p dir="auto">If the folding function, the first argument of fold, is associative (which implies that the type of sequence elements is the same as the accumulator/result type) and has a zero element, then fold is trivially an instance of reduce. We have seen the example already:</p></div><div><pre><code>fold_left (+) 0 l ≡ fold_right (+) l 0 ≡ reduce {op=(+);zero=0} l
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">for any list <code>l</code>.</p></div><div><p dir="auto">The second trivial answer is that a fold can always be expressed in terms of a monoid reduce, unconditionally:</p></div><div><pre><code>let compose_monoid = {op=(fun g h -&gt; fun x -&gt; g (h x)); zero=Fun.id}
fold_right f l z ≡ List.map f l |&gt; reduce compose_monoid |&gt; (|&gt;) z
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">for any <code>f</code>, <code>z</code>, <code>l</code> of the appropriate types. The very similar expression can be written for the left fold (left as an exercise to the reader). The key idea is that function composition is associative.</p></div><div><p dir="auto">Unfortunately, this trivial answer is of little practical use. If <code>f:'a -&gt; 'z -&gt; 'z</code>, then <code>map f l</code> creates a list of <code>'z -&gt; 'z</code> closures, which <code>reduce</code> composes together into a (big) <code>'z -&gt; 'z</code> closure, which is finally applied to <code>z</code>. If the list <code>l</code> is of size <code>N</code>, the result of the reduction is the composition of <code>N</code> closures, and hence has the size proportional to <code>N</code> (with a fairly noticeable proportionality constant: a closure takes several words of heap space). In effect we have built an intermediate data structure of unbounded size. Although composing the closures can be parallelized, the useful work is done only when the big closure composition is finally applied to the initial accumulator <code>z</code>&nbsp;-- at which point the folding function <code>f</code> is applied step-by-step, sequentially, just like in the original <code>fold_right f l z</code>. This trivial reduction of fold only wastes time and space.</p></div><div><p dir="auto">The problem hence is not merely to express fold as reduce, but do so efficiently, without undue and unbounded overhead. Only then we can profitably fold in parallel.</p></div></div></div><div class="heading-wrapper"><h2 data-heading="Fold as map-reduce, more interestingly" dir="auto" class="heading" id="Fold_as_map-reduce,_more_interestingly"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Fold as map-reduce, more interestingly</h2><div class="heading-children"><div><p dir="auto">Thus our problem is to <em>efficiently</em> express fold as reduce, without intermediary data of unbound size and without taking undue time. In other words, if folding can be done in constant time per sequence element and in constant (working) space, so should reduce.</p></div><div><p dir="auto">Sometimes the problem can be solved simply. We have already seen one such case: the folding function is associative and has the unit element. The left and the right fold are instances of reduce then. A little more interesting is the case of the folding function f that can be factored out in terms of two other functions <code>op</code> and <code>g</code> as</p></div><div><pre><code>f z x = op z (g x)
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">for any sequence element <code>x</code> and accumulator <code>z</code>. Here <code>op</code> is an associative operation that has a zero element. As an example, remember finding the length of a list, expressed as fold as</p></div><div><pre><code>List.fold_left (fun z _ -&gt; z + 1) 0 l
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">The folding function indeed factors out</p></div><div><pre><code>z + 1 = z + (Fun.const 1 x)
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">and so length can be re-written as</p></div><div><pre><code>map (Fun.const 1) l |&gt; reduce {op=(+);zero=0}
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">or, as <code>map_reduce</code>. Length, therefore, may be computed in parallel.</p></div><div><p dir="auto">Such a factorization is an instance of the general principle, called ``Conjugate Transform'' in Guy Steele's talk. The principle calls for representing fold as</p></div><div><pre><code>fold_left (f:'z-&gt;'a-&gt;'a) (z:'z) l = map g l |&gt; reduce m |&gt; h
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">and similarly for the right fold. Here <code>m:'u monoid</code> is a monoid for some type <code>'u</code>, and <code>g:'a-&gt;'u</code> and <code>h:'u-&gt;'z</code> are some functions. They generally depend on <code>f</code> and <code>z</code>. Informally, the principle recommends we look for a `<code>bigger'' type </code>'u<code>that can embed both</code>'a<code>and</code>'z` and admits a suitable associative operation with a unit element.</p></div><div><p dir="auto">One may always represent fold in such a way, as we saw in the previous section: we chose <code>compose_monoid</code> as <code>m</code>, with <code>'z-&gt;'z</code> as the type <code>'u</code>.</p></div><div><p dir="auto">The conjugate transform is a principle, or a schema. It does not tell how to actually find the <em>efficient</em> monoid, or if it even exists. In fact, finding the efficient monoid is often non-trivial and requires ingenuity. As an example, consider a subtractive folding, mentioned in passing earlier. Subtraction is not associative and therefore <code>fold_left (-)</code> is not an instance of reduce. A moment of thought however shows that</p></div><div><pre><code>fold_left (-) z l = z - fold_left (+) 0 l = z - reduce {op=(+);zero=0} l
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">In terms of the conjugate transform schema, the function <code>g</code> is negation and <code>h</code> is adding <code>z</code>. The second moment of thought shows that <code>fold_right (-)</code> can not be reduced just as easily (or at all?). Actually, the right-subtractive-folding can also be carried out efficiently in parallel, as a monoid reduction. The reader is encouraged to find this monoid&nbsp;-- to appreciate the difficulty and ingenuity.</p></div></div></div><div class="heading-wrapper"><h2 data-heading="Generalized Horner rule" dir="auto" class="heading" id="Generalized_Horner_rule"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Generalized Horner rule</h2><div class="heading-children"><div><p dir="auto">Horner rule, or schema, is a widely-used sequential algorithm to efficiently evaluate a polynomial. A similar accumulating pattern also frequently occurs in parsing. Although the algorithm is inherently sequential, on the face of it, it turns out representable as a monoid reduction. Our reduction is more general and flexible than the other known ways to parallelize the Horner rule.</p></div><div><p dir="auto">As an illustrating example, we take the conversion of a sequence of digits (most-significant first) to the corresponding number&nbsp;-- a simple parsing operation. It is an accumulating sequential operation and can be written as fold:</p></div><div><pre><code>let digits_to_num = 
  List.fold_left (fun z x -&gt; 10*z + (Char.code x - Char.code '0')) 0
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">For example, <code>digits_to_num ['1'; '7'; '5']</code> gives <code>175</code>. One can easily factor it as a composition of a <code>map</code> and</p></div><div><pre><code>List.fold_left (fun z x -&gt; 10*z + x) 0
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">which is essentially the Horner rule: evaluating the polynomial Σ <code>d</code>i <code>b</code>i at <code>b=10</code>. The folding function <code>fun z x -&gt; 10*z + x</code> is not associative, however.</p></div><div><p dir="auto">Still, there is a way to build a monoid. It is the monoid with the operation</p></div><div><pre><code>let op (x,b1) (y,b2) = (x*b2+y, b1*b2)
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">which is clearly associative (but not commutative):</p></div><div><pre><code>((x,b1) `op` (y,b2)) `op` (z,b3)
= (x*b2+y, b1*b2) `op` (z,b3)
= (x*b2*b3+y*b3+z, b1*b2*b3)
= (x,b1) `op` (y*b3+z,b2*b3)
= (x,b1) `op` ((y,b2) `op` (z,b3))
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">with the unit <code>(0,1)</code>:</p></div><div><pre><code>(x,b) `op` (0,1) = (0,1) `op` (x,b) = (x,b)
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">Therefore, <code>digits_to_num</code> can be written as</p></div><div><pre><code>let digits_to_num = 
    List.map (fun x -&gt; (Char.code x - Char.code '0')) &gt;&gt;
    List.map (fun x -&gt; (x,10)) &gt;&gt;
    reduce {op;zero=(0,1)} &gt;&gt; fst
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">where <code>&gt;&gt;</code> is the left-to-right functional composition. Our construction is also an instance of the conjugate transform, with <code>g</code> being <code>fun x -&gt; (x,10)</code> and and <code>h</code> being <code>fst</code>.</p></div><div><p dir="auto">Thus, the Horner rule can be expressed as map-reduce and can hence be evaluated embarrassingly in parallel.</p></div><div><p dir="auto">Our construction is general and applies to any folding function <code>f : 'z -&gt; 'a -&gt; 'z</code> of the form</p></div><div><pre><code>f z x = m.op (h z) x
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">where <code>m.op</code> is associative and has a zero element (that is, an operation of some monoid <code>m</code>). This factorization looks very similar to the one in the previous section; the difference, however slight, makes finding the monoid quite more difficult. It does exists:</p></div><div><pre><code>let hmonoid (m:'a monoid) : ('a * ('a-&gt;'a)) monoid = 
  {op = (fun (x,h1) (y,h2) -&gt; (m.op (h2 x) y, h1 &gt;&gt; h2));
   zero = (m.zero, Fun.id)}
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">Its carrier is the set of pairs <code>(x,h)</code> of monoid <code>m</code> elements and functions on them. We assume the composition <code>h1&gt;&gt;h2</code> is represented efficiently. For example, when <code>h</code> is a multiplication by a constant, it can be represented by that constant; the composition of such functions is then representable by the product of the corresponding constants.</p></div><div><p dir="auto">The Horner rule has the feel of the parallel prefix problem and the famous parallel scan of Guy Blelloch (PPoPP 2009). Horner rule does not require reporting of intermediate results, however. Our monoid reduction differs from Blelloch's even-odd interleaving. It also differs from monoid-cached trees from Guy Steele's ICFP09 keynote. We do not rely on any special data structures: We can work with plain arrays, partitioning them across available cores.</p></div><div><p dir="auto">Since Horner method is pervasive in polynomial evaluation, there are approaches to parallelize it. The most common is even/odd splitting of polynomial coefficients. Although it may be well suitable for SIMD processing, the even/odd splitting is bad for multicore since it creates read contention (bank conflicts) and wastes cache space. Our monoid reduce lets us assign different memory banks to different cores, for their exclusive, conflict-free access.</p></div><div><p dir="auto">On the other hand, Estrin's scheme may be seen as a very particular instance of our monoid construction: binomial grouping. Our monoid reduction allows for arbitrary grouping, hierarchically if desired, and of not necessarily of the same size.</p></div><div><p dir="auto"><strong>References</strong></p></div><div><p dir="auto"><a data-tooltip-position="top" aria-label="https://okmij.org/ftp/Algorithms/monoid_reduce.ml" rel="noopener" class="external-link" href="https://okmij.org/ftp/Algorithms/monoid_reduce.ml" target="_blank">monoid_reduce.ml</a>&nbsp;[12K]<br>
Complete code for the article</p></div></div></div><div class="heading-wrapper"><h2 data-heading="Boyer-Moore majority voting" dir="auto" class="heading" id="Boyer-Moore_majority_voting"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Boyer-Moore majority voting</h2><div class="heading-children"><div><p dir="auto">Boyer-Moore majority voting is the algorithm for finding the majority element in a sequence&nbsp;-- that is, the element that occurs more than half of the time. The algorithm requires one pass over the sequence and the constant amount of working space. It is important to keep in mind that the return value is the majority element <em>if it exists</em>. The algorithm <em>in general</em> cannot tell if the sequence has majority: if majority does not exist, the return value is an arbitrary element, not necessarily the most frequently occurring. In general, therefore, one needs the second pass over the sequence to count the occurrences of the returned element and verify it is indeed the majority. The second pass may be avoided or be unnecessary in some cases.</p></div><div><p dir="auto">The Boyer-Moore algorithm is called a prototypical streaming algorithm and is inherently sequential. It may be surprising, therefore, that it may be presented as monoid reduction and hence performed just as efficiently in parallel&nbsp;-- in fact, embarrassingly in parallel. The monoid reduction implementation is actually simple. What is complex is convincing ourselves that it indeed works and does the right thing, in all cases.</p></div><div><p dir="auto">The Boyer-Moore algorithm is a state machine processing, ingesting input element-by-element. It can hence be implemented as fold (assuming the input is given as a non-empty list):</p></div><div><pre><code>let bm : 'a list -&gt; 'a = function h::t -&gt; 
  let fsm (c,m) x =
      if c = 0 then (1,x)
      else if m = x then (c+1,m)
      else (c-1,m)
  in List.fold_left fsm (1,h) t &gt;&gt; snd
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">The state is the counter <code>c</code> and the candidate majority <code>m</code>. At the end of the algorithm, when the entire sequence is scanned, <code>m</code> is the majority element (if the sequence has one). If the counter <code>c</code> at the end is more than half of the sequence length, the sequence has majority and <code>m</code> is the majority element. Otherwise, we have to make another pass through the sequence to verify that <code>m</code> is indeed the majority. The verification pass may be unnecessary if we have a prior knowledge that majority exists&nbsp;-- or if we are satisfied with any element if it does not.</p></div><div><p dir="auto">Although the algorithm seems inherently sequential, it can in fact be represented as monoid reduction. The monoid is simple and efficient:</p></div><div><pre><code>let bm_monoid (z:'a) : (int * 'a) monoid = 
  {zero = (0,z);
   op = fun (c1,m1) (c2,m2) -&gt;
     if c1 = 0 then (c2,m2) else
     if c2 = 0 then (c1,m1) else
     if m1 = m2 then (c1+c2,m1) else
     if c1 &gt; c2 then (c1-c2, m1) else
     (c2-c1, m2)}
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">Monoid elements (the carrier set) are pairs: of a natural number <code>c</code> and of a sequence element <code>m</code>. When <code>c</code> is zero, <code>m</code> may be arbitrary; in the above code we use <code>z</code> for such an arbitrary element. We could have avoided specifying it by defining a more sophisticated data type for monoid carrier, or using <code>'a option</code>. The reasoning below would get messier; therefore, we keep the above definition for the sake of clarity.</p></div><div><p dir="auto">One can see that <code>op</code> is commutative and that <code>zero</code> is indeed the zero of <code>op</code>. However, is <code>op</code> associative? That is, is <code>bm_monoid</code> really a monoid? It is easy to check:</p></div><div><pre><code>let m1 = (2,10) and m2 = (3,9) and m3 = (2,8)
op (op m1 m2) m3  ⇝ (1, 8) 
op m1 (op m2 m3)  ⇝ (1, 10)
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">Unfortunately, <code>bm_monoid</code> is not a monoid.</p></div><div><p dir="auto">To cut the suspense, it turns out that <code>bm_monoid</code> is `morally' a monoid, and reduction with it indeed gives the right result, in all cases. Proving it however is not that straightforward.</p></div><div><p dir="auto">For the sake of proof, we extend <code>bm_monoid</code> to:</p></div><div><pre><code>let bm_monoid_ext (z:'a) : (int * 'a * ('a*'a) list) monoid = 
  {zero = (0,z,[]);
   op = fun (c1,m1,l1) (c2,m2,l2) -&gt;
     if c1 = 0 then (c2,m2,l1@l2) else
     if c2 = 0 then (c1,m1,l1@l2) else
     if m1 = m2 then (c1+c2,m1,l1@l2) else
     if c1 &gt; c2 then (c1-c2, m1, repeat c2 (m1,m2) @ l1 @ l2) else
     (c2-c1, m2, repeat c1 (m1,m2) @ l1 @ l2)}
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">Here, the infix operation <code>@</code> is list concatenation and <code>repeat (n:int) (x:'a) : 'a list</code> produces the list with of length <code>n</code> with elements all equal to <code>x</code>.</p></div><div><p dir="auto">The carrier set of <code>bm_monoid_ext</code> is a set of triples: a natural number <code>c</code>, a sequence element <code>m</code>, and a list of pairs with distinct components (that is, <code>fst</code> of any pair is not equal to its <code>snd</code>). We note that <code>op</code> preserves the invariant that all pairs in <code>l</code> have distinct components.</p></div><div><p dir="auto">Let us introduce the relation ≈ on that set, defined as follows: <code>x ≈ y</code> just in case <code>flatten x</code> is equal to <code>flatten y</code> modulo permutation, where</p></div><div><pre><code>let flatten : (int * 'a * ('a*'a) list) -&gt; 'a list = fun (c,m,l) -&gt;
  repeat c m @ List.map fst l @ List.map snd l
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">That is, <code>flatten x</code> collects all elements mentioned within <code>x</code> in a <em>multiset</em>. Therefore, <code>x ≈ y</code> iff the multiset of elements of <code>x</code> is equal to the multiset of elements of <code>y</code>. One easily sees that the relation <code>≈</code> is reflexive, commutative and associative. That is, it is an equivalence relation. It also has useful for us properties, as follows.</p></div><div><p dir="auto">Proposition: <code>bm_monoid_ext</code> is a monoid modulo <code>≈</code>. That is,</p></div><div><pre><code>op (0,z,[]) (c,m,l) ≈ op (c,m,l) (0,z,[]) ≈ (c,m,l)
op (c1,m1,l1) (op (c2,m2,l2) (c3,m3,l3)) ≈ op (op (c1,m1,l1) (c2,m2,l2)) (c3,m3,l3)
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">The associativity property follows from the fact <code>op</code> preserves elements occurring in <code>(c,m,l)</code>, including their multiplicities (and the multiset equality is associative).</p></div><div><p dir="auto">Moreover, <code>≈</code> is <em>adequate</em> for the task of finding the majority.</p></div><div><p dir="auto">Proposition (Adequacy): if <code>(c1,m1,l1) ≈ (c2,m2,l2)</code> and the multiset <code>flatten (c1,m1,l1)</code> has majority, then <code>c1&gt;0</code>, <code>c2&gt;0</code>, and <code>m1=m2</code>. Informally, <code>≈</code> preserves the found majority (if the majority exists). The proposition is the consequence of the fact that majority is invariant to sequence permutation, and the following representation lemma.</p></div><div><p dir="auto">Lemma (Representation): if a sequence (multiset) <code>flatten (c,m,l)</code> has majority, then <code>c&gt;0</code> and <code>m</code> is the majority element.</p></div><div><p dir="auto">For the proof we note that if the list of distinct pairs <code>l</code> has <code>n</code> elements, it has <code>2*n</code> of values. Not all of them are distinct. However, there is no value that occurs more than <code>n</code> times; otherwise, by the pigeonhole principle, some pair in <code>l</code> would have had equal components. Therefore, no value occurring in <code>(c,m,l)</code> that is distinct from <code>m</code> (if <code>c&gt;0</code>) can be the majority element. If the majority exists, it has to be <code>m</code>, and <code>c&gt;0</code>.</p></div><div><p dir="auto">Our proofs are inspired by Boyer and Moore's original proofs. They however used induction (which is appropriate for the sequential algorithm). We, in contrast, used equational reasoning (and the pigeonhole principle) -- but no induction.</p></div><div><p dir="auto">As an aside, it may seem that induction is the only proof method used in computer science&nbsp;-- many widely used textbooks present nothing but induction. In my opinion, induction is overused. Mathematics has many other proof methods.</p></div><div><p dir="auto">The final step is to observe that the part of <code>bm_monoid_ext</code> that we actually care about&nbsp;-- the element <code>m</code> and the count <code>c</code>&nbsp;-- is computed with no regard to the list <code>l</code>. The list is a <code>ghost' list, so to speak, needed only for proving correctness but not for computing the majority. Therefore, we may omit it and recover the </code>bm_monoid`.</p></div><div><p dir="auto">In the upshot, the majority voting may hence be performed as map-reduce: mapping with <code>(fun x -&gt; (1,x))</code> and then reducing over the monoid <code>bm_monoid</code>. It is just as efficient as the original Boyer-Moore algorithm: one pass over the sequence using constant and small working space. However, the input may be split arbitrarily among available workers, who would do the search in parallel, without any interference or dependencies. Majority voting can be done embarrassingly in parallel.</p></div><div><p dir="auto"><strong>References</strong></p></div><div><p dir="auto"><a data-tooltip-position="top" aria-label="%5Bhttps://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm%5D(https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm)" rel="noopener" class="external-link" href="%5Bhttps://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm%5D(https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm)" target="_blank">[https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm)</a></p></div><div><p dir="auto"><a data-tooltip-position="top" aria-label="https://okmij.org/ftp/Algorithms/monoid_reduce.ml" rel="noopener" class="external-link" href="https://okmij.org/ftp/Algorithms/monoid_reduce.ml" target="_blank">monoid_reduce.ml</a>&nbsp;[12K]<br>
Complete code for the article</p></div></div></div><div class="heading-wrapper"><h2 data-heading="Conclusions" dir="auto" class="heading" id="Conclusions"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Conclusions</h2><div class="heading-children"><div><p dir="auto">In his ICFP'09 keynote, Guy Steele exhorted us to use reduce (or, <code>map_reduce</code>) rather than fold, as far as possible. Unlike fold, reduce does not commit us to a particular evaluation strategy. It can be performed sequentially, embarrassingly parallel, or in a tree-like fashion. Like the Σ notation in Math, it specifies what should be summed up, but not how or in which sequence.</p></div><div><p dir="auto">Guy Steele conclusions apply to the present article as well. Especially his final thoughts:</p></div><div><ul>
<li data-line="0" dir="auto">Associative combining operators are a VERY BIG DEAL</li>
<li data-line="1" dir="auto">Inventing (and proving) new combining operators is a very, very big deal</li>
</ul></div><div><hr></div><div class="heading-wrapper"><h3 data-heading="Last updated August 1, 2024" dir="auto" class="heading" id="Last_updated_August_1,_2024"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Last updated August 1, 2024</h3><div class="heading-children"><div><p dir="auto">This site's top page is <a data-tooltip-position="top" aria-label="http://okmij.org/ftp/" rel="noopener" class="external-link" href="http://okmij.org/ftp/" target="_blank"><strong>http://okmij.org/ftp/</strong></a>  </p></div><div><p dir="auto">oleg-at-okmij.org<br>
Your comments, problem reports, questions are very welcome!</p></div><div><p dir="auto">Generated by MarXere</p></div><div class="mod-footer"></div></div></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="computer-science/functional-programming/folding-in-parallel.html#Folding in Parallel"><div class="tree-item-contents heading-link" heading-name="Folding in Parallel"><span class="tree-item-title">Folding in Parallel</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/functional-programming/folding-in-parallel.html#Introduction:_Fold_v._Monoid_Reduction"><div class="tree-item-contents heading-link" heading-name="Introduction: Fold v. Monoid Reduction"><span class="tree-item-title">Introduction: Fold v. Monoid Reduction</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/functional-programming/folding-in-parallel.html#Fold_as_map-reduce,_trivially"><div class="tree-item-contents heading-link" heading-name="Fold as map-reduce, trivially"><span class="tree-item-title">Fold as map-reduce, trivially</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/functional-programming/folding-in-parallel.html#Fold_as_map-reduce,_more_interestingly"><div class="tree-item-contents heading-link" heading-name="Fold as map-reduce, more interestingly"><span class="tree-item-title">Fold as map-reduce, more interestingly</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/functional-programming/folding-in-parallel.html#Generalized_Horner_rule"><div class="tree-item-contents heading-link" heading-name="Generalized Horner rule"><span class="tree-item-title">Generalized Horner rule</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/functional-programming/folding-in-parallel.html#Boyer-Moore_majority_voting"><div class="tree-item-contents heading-link" heading-name="Boyer-Moore majority voting"><span class="tree-item-title">Boyer-Moore majority voting</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="computer-science/functional-programming/folding-in-parallel.html#Conclusions"><div class="tree-item-contents heading-link" heading-name="Conclusions"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">Conclusions</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="computer-science/functional-programming/folding-in-parallel.html#Last_updated_August_1,_2024"><div class="tree-item-contents heading-link" heading-name="Last updated August 1, 2024"><span class="tree-item-title">Last updated August 1, 2024</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>