<!DOCTYPE html> <html><head>
		<title>Understanding Big and Little Endian Byte Order</title>
		<base href="../../../">
		<meta id="root-path" root-path="../../../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="韩暮秋的个人维基 - Understanding Big and Little Endian Byte Order">
		<meta property="og:title" content="Understanding Big and Little Endian Byte Order">
		<meta property="og:description" content="韩暮秋的个人维基 - Understanding Big and Little Endian Byte Order">
		<meta property="og:type" content="website">
		<meta property="og:url" content="https://muqiuhan.github.io/wiki/computer-science/operating-system/understanding-big-and-little-endian-byte-order/understanding-big-and-little-endian-byte-order.html">
		<meta property="og:image" content="https://muqiuhan.github.io/wiki/computer-science/operating-system/understanding-big-and-little-endian-byte-order/attachments/pasted-image-20241220110455.png">
		<meta property="og:site_name" content="韩暮秋的个人维基">
		<meta name="author" content="韩暮秋"><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="https://muqiuhan.github.io/wiki/lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="lib/scripts/pixi.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="lib/scripts/minisearch.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="preload" href="lib/styles/other-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/other-plugins.css"></noscript><link rel="stylesheet" href="lib/styles/theme.css"><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript></head><body class="publish css-settings-manager theme-light show-inline-title show-ribbon outliner-plugin-dnd h2-underline"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="Understanding Big and Little Endian Byte Order"><p dir="auto">Understanding Big and Little Endian Byte Order</p></h1><div class="el-p"><p dir="auto"><a href="?query=tag:os" class="tag" target="_blank" rel="noopener nofollow">#os</a> <a href="?query=tag:arch" class="tag" target="_blank" rel="noopener nofollow">#arch</a></p></div><div class="el-p"><p dir="auto">Problems with byte order are frustrating, and I want to spare you the grief I experienced. Here's the key:</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>Problem: Computers speak different languages, like people.</strong> Some write data "left-to-right" and others "right-to-left".
<ul>
<li data-line="1" dir="auto">A machine can read its own data just fine - problems happen when one computer stores data and a different type tries to read it.</li>
</ul>
</li>
<li data-line="2" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Solutions
<ul>
<li data-line="3" dir="auto">Agree to a common format (i.e., all network traffic follows a single format), or</li>
<li data-line="4" dir="auto">Always include a header that describes the format of the data. If the header appears backwards, it means data was stored in the other format and needs to be converted.</li>
</ul>
</li>
</ul></div><div class="el-h2 heading-wrapper"><h2 data-heading="Numbers vs. Data" dir="auto" class="heading" id="Numbers_vs._Data"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Numbers vs. Data</h2><div class="heading-children"><div class="el-p"><p dir="auto">The most important concept is to recognize the difference between a number and the data that represents it.</p></div><div class="el-p"><p dir="auto">A <strong>number</strong> is an abstract concept, such as a count of something. You have ten fingers. The idea of "ten" doesn't change, no matter what representation you use: ten, 10, diez (Spanish), ju (Japanese), 1010 (binary), X (Roman numeral)... these representations all point to the same concept of "ten".</p></div><div class="el-p"><p dir="auto">Contrast this with data. <strong>Data</strong> is a physical concept, a raw sequence of bits and bytes stored on a computer. <strong>Data has no inherent meaning</strong> and must be interpreted by whoever is reading it.</p></div><div class="el-p"><p dir="auto">Data is like human writing, which is simply marks on paper. There is no inherent meaning in these marks. If we see a line and a circle (like this: |O) we may interpret it to mean "ten".</p></div><div class="el-p"><p dir="auto">But we assumed the marks referred to a number. They could have been the letters "IO", a moon of Jupiter. Or perhaps the Greek goddess. Or maybe an abbreviation for Input/Output. Or someone's initials. Or the number 2 in binary ("10"). The list of possibilities goes on.</p></div><div class="el-p"><p dir="auto">The point is that a single piece of data (|O) can be interpreted in many ways, and the meaning is unclear until someone clarifies the intent of the author.</p></div><div class="el-p"><p dir="auto">Computers face the same problem. They store data, not abstract concepts, and do so using a sequence of 1's and 0's. Later, they read back the 1's and 0's and try to recreate the abstract concept from the raw data. Depending on the assumptions made, the 1's and 0's can mean very different things.</p></div><div class="el-p"><p dir="auto">Why does this problem happen? Well, there's no rule that all computers must use the same language, just like there's no rule all humans need to. Each type of computer is internally consistent (it can read back its own data), but there are no guarantees about how <strong>another</strong> type of computer will interpret the data it created.</p></div><div class="el-p"><p dir="auto"><strong>Basic concepts</strong></p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">Data (bits and bytes, or marks on paper) is meaningless; it must be interpreted to create an abstract concept, like a number.</li>
<li data-line="1" dir="auto">Like humans, computers have different ways to store the same abstract concept. (i.e., we have many ways to say "ten": ten, 10, diez, etc.)</li>
</ul></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="Storing Numbers as Data" dir="auto" class="heading" id="Storing_Numbers_as_Data"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Storing Numbers as Data</h2><div class="heading-children"><div class="el-p"><p dir="auto">Thankfully, most computers agree on a few basic data formats (this was not always the case). This gives us a common starting point which makes our lives a bit easier:</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">A bit has two values (on or off, 1 or 0)</li>
<li data-line="1" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>A byte is a sequence of 8 bits
<ul>
<li data-line="2" dir="auto">The "leftmost" bit in a byte is the biggest. So, the binary sequence 00001001 is the decimal number 9. 00001001 = (23 + 20 = 8 + 1 = 9).</li>
<li data-line="3" dir="auto">Bits are numbered from right-to-left. Bit 0 is the rightmost and the smallest; bit 7 is leftmost and largest.</li>
</ul>
</li>
</ul></div><div class="el-p"><p dir="auto">We can use these basic agreements as a building block to exchange data. If we store and read data one byte at a time, it will work on any computer. The concept of a byte is the same on all machines, and the idea of which byte is first, second, third (Byte 0, Byte 1, Byte 2...) is the same on all machines.</p></div><div class="el-p"><p dir="auto">If computers agree on the order of every byte, what's the problem?</p></div><div class="el-p"><p dir="auto">Well, this is fine for single-byte data, like ASCII text. However, a lot of data needs to be stored using multiple bytes, like integers or floating-point numbers. And there is no agreement on how these sequences should be stored.</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="Byte Example" dir="auto" class="heading" id="Byte_Example"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Byte Example</h2><div class="heading-children"><div class="el-p"><p dir="auto">Consider a sequence of 4 bytes, named W X Y and Z - I avoided naming them A B C D because they are hex digits, which would be confusing. So, each byte has a value and is made up of 8 bits.</p></div><div class="el-p"><p dir="auto"> Byte Name:    W       X       Y       Z<br>
Location:     0       1       2       3<br>
Value (hex):  0x12    0x34    0x56    0x78</p></div><div class="el-p"><p dir="auto">For example, W is an entire byte, 0x12 in hex or 00010010 in binary. If W were to be interpreted as a number, it would be "18" in decimal (by the way, there's nothing saying we have to interpret it as a number - it could be an ASCII character or something else entirely).</p></div><div class="el-p"><p dir="auto">With me so far? We have 4 bytes, W X Y and Z, each with a different value.</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="Understanding Pointers" dir="auto" class="heading" id="Understanding_Pointers"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Understanding Pointers</h2><div class="heading-children"><div class="el-p"><p dir="auto">Pointers are a key part of programming, especially the C programming language. A pointer is a number that references a memory location. It is up to us (the programmer) to interpret the data at that location.</p></div><div class="el-p"><p dir="auto">In C, when you cast a pointer to certain type (such as a char <em> or int </em>), it tells the computer how to interpret the data at that location. For example, let's declare</p></div><div class="el-p"><p dir="auto">void <em>p = 0; // p is a pointer to an unknown data type<br>
// p is a NULL pointer -- do not dereference<br>
char </em>c;     // c is a pointer to a char, usually a single byte</p></div><div class="el-p"><p dir="auto">Note that we can't get the data from p because we don't know its type. p could be pointing at a single number, a letter, the start of a string, your horoscope, an image -- we just don't know how many bytes to read, or how to interpret what's there.</p></div><div class="el-p"><p dir="auto">Now, suppose we write</p></div><div class="el-p"><p dir="auto">c = (char *)p;</p></div><div class="el-p"><p dir="auto">Ah -- now this statement tells the computer to point to the same place as p, and interpret the data as a single character (<code>char</code> is typically a single byte, use <code>uint8_t</code> if not true on your machine). In this case, c would point to memory location 0, or byte W. If we printed c, we'd get the value in W, which is hex 0x12 (remember that W is a whole byte).</p></div><div class="el-p"><p dir="auto">This example does not depend on the type of computer we have -- again, all computers agree on what a single byte is (in the past this was not the case).</p></div><div class="el-p"><p dir="auto">The example is helpful, even though it is the same on all computers -- if we have a pointer to a single byte (char *, a single byte), we can walk through memory, reading off a byte at a time. We can examine any memory location and the endian-ness of a computer won't matter -- every computer will give back the same information.</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="So, What's The Problem?" dir="auto" class="heading" id="So,_What's_The_Problem?"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>So, What's The Problem?</h2><div class="heading-children"><div class="el-p"><p dir="auto">Problems happen when computers try to read multiple bytes. Some data types contain multiple bytes, like long integers or floating-point numbers. A single byte has only 256 values, so can store 0 - 255.</p></div><div class="el-p"><p dir="auto">Now problems start - when you read multi-byte data, where does the biggest byte appear?</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">Big endian machine: Stores data <strong>big-end first</strong>. When looking at multiple bytes, the first byte (lowest address) is the biggest.</li>
<li data-line="1" dir="auto">Little endian machine: Stores data <strong>little-end first</strong>. When looking at multiple bytes, the first byte is <strong>smallest</strong>.</li>
</ul></div><div class="el-p"><p dir="auto">The naming makes sense, eh? Big-endian thinks the big-end is first. (By the way, the big-endian / little-endian naming comes from Gulliver's Travels, where the Lilliputans argue over whether to break eggs on the little-end or big-end. Sometimes computer debates are just as meaningful :-))</p></div><div class="el-p"><p dir="auto">Again, endian-ness does not matter if you have a single byte. If you have one byte, it's the only data you read so there's only one way to interpret it (again, because computers agree on what a byte is).</p></div><div class="el-p"><p dir="auto">Now suppose we have our 4 bytes (W X Y Z) stored the same way on a big-and little-endian machine. That is, memory location 0 is W on both machines, memory location 1 is X, etc.</p></div><div class="el-p"><p dir="auto">We can create this arrangement by remembering that bytes are machine-independent. We can walk memory, one byte at a time, and set the values we need. This will work on any machine:</p></div><div class="el-p"><p dir="auto">c = 0;     // point to location 0 (won't work on a real machine!)<br>
<em>c = 0x12; // Set W's value<br>
c = 1;     // point to location 1<br>
</em>c = 0x34; // Set X's value<br>
...        // repeat for Y and Z; details left to reader</p></div><div class="el-p"><p dir="auto">This code will work on any machine, and we have both set up with bytes W, X, Y and Z in locations 0, 1, 2 and 3.</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="Interpreting Data" dir="auto" class="heading" id="Interpreting_Data"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Interpreting Data</h2><div class="heading-children"><div class="el-p"><p dir="auto">Now let's do an example with multi-byte data (finally!). Quick review: a "short int" is a 2-byte (16-bit) number, which can range from 0 - 65535 (if unsigned). Let's use it in an example:</p></div><div class="el-p"><p dir="auto">short <em>s; // pointer to a short int (2 bytes)<br>
s = 0;    // point to location 0; </em>s is the value</p></div><div class="el-p"><p dir="auto">So, s is a pointer to a short, and is now looking at byte location 0 (which has W). What happens when we read the value at s?</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">Big endian machine: I think a short is two bytes, so I'll read them off: location s is address 0 (W, or 0x12) and location s + 1 is address 1 (X, or 0x34). Since the first byte is biggest (I'm big-endian!), the number must be 256 <em> byte 0 + byte 1, or 256</em>W + X, or 0x1234. I multiplied the first byte by 256 (2^8) because I needed to shift it over 8 bits.<br>
</li>
<li data-line="2" dir="auto">Little endian machine: I don't know what Mr. Big Endian is smoking. Yeah, I agree a short is 2 bytes, and I'll read them off just like him: location s is 0x12, and location s + 1 is 0x34. But in my world, the first byte is the littlest! The value of the short is byte 0 + 256 <em> byte 1, or 256</em>X + W, or 0x3412.<br>
</li>
</ul></div><div class="el-p"><p dir="auto">Keep in mind that both machines start from location s and read memory going upwards. There is no confusion about what location 0 and location 1 mean. There is no confusion that a short is 2 bytes.</p></div><div class="el-p"><p dir="auto">But do you see the problem? The big-endian machine thinks s = 0x1234 and the little-endian machine thinks s = 0x3412. The same exact data gives two different numbers. Probably not a good thing.</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="Yet another example" dir="auto" class="heading" id="Yet_another_example"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Yet another example</h2><div class="heading-children"><div class="el-p"><p dir="auto">Let's do another example with 4-byte integer for "fun":</p></div><div class="el-p"><p dir="auto">int <em>i; // pointer to an int (4 bytes on 32-bit machine)<br>
i = 0;  // points to location zero, so </em>i is the value there</p></div><div class="el-p"><p dir="auto">Again we ask: what is the value at i?</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">Big endian machine: An int is 4 bytes, and the first is the largest. I read 4 bytes (W X Y Z) and W is the largest. The number is 0x12345678.</li>
<li data-line="1" dir="auto">Little endian machine: Sure, an int is 4 bytes, but the first is smallest. I also read W X Y Z, but W belongs way in the back -- it's the littlest. The number is 0x78563412.</li>
</ul></div><div class="el-p"><p dir="auto">Same data, different results - not a good thing. Here's an interactive example using the numbers above, feel free to plug in your own:<br>
<span alt="Pasted image 20241220110455.png" src="Pasted image 20241220110455.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241220110455.png" src="computer-science/operating-system/understanding-big-and-little-endian-byte-order/attachments/pasted-image-20241220110455.png"></span></p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="The NUXI Problem" dir="auto" class="heading" id="The_NUXI_Problem"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>The NUXI Problem</h2><div class="heading-children"><div class="el-p"><p dir="auto">Issues with byte order are sometimes called the NUXI problem: UNIX stored on a big-endian machine can show up as NUXI on a little-endian one.</p></div><div class="el-p"><p dir="auto">Suppose we want to store 4 bytes (U, N, I and X) as two shorts: UN and IX. Each letter is a entire byte, like our WXYZ example above. To store the two shorts we would write:</p></div><div class="el-p"><p dir="auto">short <em>s; // pointer to set shorts<br>
s = 0;    // point to location 0<br>
</em>s = UN;  // store first short: U <em> 256 + N (fictional code)<br>
s = 2;    // point to next location<br>
</em>s = IX;  // store second short: I * 256 + X</p></div><div class="el-p"><p dir="auto">This code is not specific to a machine. If we store "UN" on a machine and ask to read it back, it had better be "UN"! I don't care about endian issues, if we store a value on one machine and read it back on the same machine, it must be the same value.</p></div><div class="el-p"><p dir="auto">However, if we look at memory one byte at a time (using our char * trick), the order could vary. On a big endian machine we see:</p></div><div class="el-p"><p dir="auto">Byte:     U N I X<br>
Location: 0 1 2 3</p></div><div class="el-p"><p dir="auto">Which make sense. U is the biggest byte in "UN" and is stored first. The same goes for IX: I is the biggest, and stored first.</p></div><div class="el-p"><p dir="auto">On a little-endian machine we would see:</p></div><div class="el-p"><p dir="auto">Byte:     N U X I<br>
Location: 0 1 2 3</p></div><div class="el-p"><p dir="auto">And this makes sense also. "N" is the littlest byte in "UN" and is stored first. Again, even though the bytes are stored "backwards" in memory, the little-endian machine <em>knows</em> it is little endian, and interprets them correctly when reading the values back. Also, note that we can specify hex numbers such as x = 0x1234 on any machine. Even a little-endian machine knows what you mean when you write 0x1234, and won't force you to swap the values yourself (you specify the hex number to write, and it figures out the details and swaps the bytes in memory, under the covers. Tricky.).</p></div><div class="el-p"><p dir="auto">This scenario is called the "NUXI" problem because byte sequence UNIX is interpreted as NUXI on the other type of machine. Again, this is only a problem if you exchange data -- each machine is internally consistent.</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="Exchanging Data Between Endian Machines" dir="auto" class="heading" id="Exchanging_Data_Between_Endian_Machines"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Exchanging Data Between Endian Machines</h2><div class="heading-children"><div class="el-p"><p dir="auto">Computers are connected - gone are the days when a machine only had to worry about reading its own data. Big and little-endian machines need to talk and get along. How do they do this?</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="Solution 1: Use a Common Format" dir="auto" class="heading" id="Solution_1:_Use_a_Common_Format"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Solution 1: Use a Common Format</h2><div class="heading-children"><div class="el-p"><p dir="auto">The easiest approach is to agree to a common format for sending data over the network. The standard network order is actually big-endian, but some people get uppity that little-endian didn't win... we'll just call it "network order".</p></div><div class="el-p"><p dir="auto">To convert data to network order, machines call a function hton (host-to-network). On a big-endian machine this won't actually do anything, but we won't talk about that here (the little-endians might get mad).</p></div><div class="el-p"><p dir="auto">But it is important to use hton before sending data, even if you are big-endian. Your program may be so popular it is compiled on different machines, and you want your code to be portable (don't you?).</p></div><div class="el-p"><p dir="auto">Similarly, there is a function ntoh (network to host) used to read data off the network. You need this to make sure you are correctly interpreting the network data into the host's format. You need to know the type of data you are receiving to decode it properly, and the conversion functions are:</p></div><div class="el-p"><p dir="auto"> htons() - "Host to Network Short"<br>
htonl() - "Host to Network Long"<br>
ntohs() - "Network to Host Short"<br>
ntohl() - "Network to Host Long"</p></div><div class="el-p"><p dir="auto">Remember that a single byte is a single byte, and order does not matter.</p></div><div class="el-p"><p dir="auto">These functions are critical when doing low-level networking, such as verifying the checksums in IP packets. If you don't understand endian issues correctly your life will be painful - take my word on this one. Use the translation functions, and know why they are needed.</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="Solution 2: Use a Byte Order Mark (BOM)" dir="auto" class="heading" id="Solution_2:_Use_a_Byte_Order_Mark_(BOM)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Solution 2: Use a Byte Order Mark (BOM)</h2><div class="heading-children"><div class="el-p"><p dir="auto">The other approach is to include a magic number, such as 0xFEFF, before every piece of data. If you read the magic number and it is 0xFEFF, it means the data is in the same format as your machine, and all is well.</p></div><div class="el-p"><p dir="auto">If you read the magic number and it is 0xFFFE (it is backwards), it means the data was written in a format different from your own. You'll have to translate it.</p></div><div class="el-p"><p dir="auto">A few points to note. First, the number isn't really magic, but programmers often use the term to describe the choice of an arbitrary number (the BOM could have been any sequence of different bytes). It's called a byte-order mark because it indicates the byte order the data was stored in.</p></div><div class="el-p"><p dir="auto">Second, the BOM adds overhead to all data that is transmitted. Even if you are only sending 2 bytes of data, you need to include a 2-byte BOM. Ouch!</p></div><div class="el-p"><p dir="auto">Unicode uses a BOM when storing multi-byte data (some Unicode character encodings can have 2, 3 or even 4-bytes per character). XML avoids this mess by storing data in UTF-8 by default, which stores Unicode information one byte at a time. And why is this cool?</p></div><div class="el-p"><p dir="auto">(Repeated for the 56th time) "Because endian issues don't matter for single bytes".</p></div><div class="el-p"><p dir="auto">Right you are.</p></div><div class="el-p"><p dir="auto">Again, other problems can arise with BOM. What if you forget to include the BOM? Do you assume the data was sent in the same format as your own? Do you read the data and see if it looks "backwards" (whatever that means) and try to translate it? What if regular data includes the BOM by coincidence? These situations are not fun.</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="Why Are There Endian Issues at All? Can't We Just Get Along?" dir="auto" class="heading" id="Why_Are_There_Endian_Issues_at_All?_Can't_We_Just_Get_Along?"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Why Are There Endian Issues at All? Can't We Just Get Along?</h2><div class="heading-children"><div class="el-p"><p dir="auto">Ah, what a philosophical question.</p></div><div class="el-p"><p dir="auto">Each byte-order system has its advantages. Little-endian machines let you read the lowest-byte first, without reading the others. You can check whether a number is odd or even (last bit is 0) very easily, which is cool if you're into that kind of thing. Big-endian systems store data in memory the same way we humans think about data (left-to-right), which makes low-level debugging easier.</p></div><div class="el-p"><p dir="auto">But why didn't everyone just agree to one system? Why do certain computers have to try and be different?</p></div><div class="el-p"><p dir="auto">Let me answer a question with a question: Why doesn't everyone speak the same language? Why are some languages written left-to-right, and others right-to-left?</p></div><div class="el-p"><p dir="auto">Sometimes communication systems develop independently, and later need to interact.</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="Epilogue: Parting Thoughts" dir="auto" class="heading" id="Epilogue:_Parting_Thoughts"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Epilogue: Parting Thoughts</h2><div class="heading-children"><div class="el-p"><p dir="auto">Endian issues are an example of the general encoding problem - data needs to represent an abstract concept, and later the concept needs to be created from the data. This topic deserves its own article (or series), but you should have a better understanding of endian issues. More information:</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Endianness" rel="noopener nofollow" class="external-link" href="https://en.wikipedia.org/wiki/Endianness" target="_blank">Wikipedia entry</a></li>
<li data-line="1" dir="auto"><a data-tooltip-position="top" aria-label="http://www.rdrop.com/~cary/html/endian_faq.html" rel="noopener nofollow" class="external-link" href="http://www.rdrop.com/~cary/html/endian_faq.html" target="_blank">Endian Faq</a></li>
</ul></div><div class="mod-footer mod-ui"></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="computer-science/operating-system/understanding-big-and-little-endian-byte-order/understanding-big-and-little-endian-byte-order.html#Understanding Big and Little Endian Byte Order"><div class="tree-item-contents heading-link" heading-name="Understanding Big and Little Endian Byte Order"><span class="tree-item-title">Understanding Big and Little Endian Byte Order</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/operating-system/understanding-big-and-little-endian-byte-order/understanding-big-and-little-endian-byte-order.html#Numbers_vs._Data"><div class="tree-item-contents heading-link" heading-name="Numbers vs. Data"><span class="tree-item-title">Numbers vs. Data</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/operating-system/understanding-big-and-little-endian-byte-order/understanding-big-and-little-endian-byte-order.html#Storing_Numbers_as_Data"><div class="tree-item-contents heading-link" heading-name="Storing Numbers as Data"><span class="tree-item-title">Storing Numbers as Data</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/operating-system/understanding-big-and-little-endian-byte-order/understanding-big-and-little-endian-byte-order.html#Byte_Example"><div class="tree-item-contents heading-link" heading-name="Byte Example"><span class="tree-item-title">Byte Example</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/operating-system/understanding-big-and-little-endian-byte-order/understanding-big-and-little-endian-byte-order.html#Understanding_Pointers"><div class="tree-item-contents heading-link" heading-name="Understanding Pointers"><span class="tree-item-title">Understanding Pointers</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/operating-system/understanding-big-and-little-endian-byte-order/understanding-big-and-little-endian-byte-order.html#So,_What's_The_Problem?"><div class="tree-item-contents heading-link" heading-name="So, What's The Problem?"><span class="tree-item-title">So, What's The Problem?</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/operating-system/understanding-big-and-little-endian-byte-order/understanding-big-and-little-endian-byte-order.html#Interpreting_Data"><div class="tree-item-contents heading-link" heading-name="Interpreting Data"><span class="tree-item-title">Interpreting Data</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/operating-system/understanding-big-and-little-endian-byte-order/understanding-big-and-little-endian-byte-order.html#Yet_another_example"><div class="tree-item-contents heading-link" heading-name="Yet another example"><span class="tree-item-title">Yet another example</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/operating-system/understanding-big-and-little-endian-byte-order/understanding-big-and-little-endian-byte-order.html#The_NUXI_Problem"><div class="tree-item-contents heading-link" heading-name="The NUXI Problem"><span class="tree-item-title">The NUXI Problem</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/operating-system/understanding-big-and-little-endian-byte-order/understanding-big-and-little-endian-byte-order.html#Exchanging_Data_Between_Endian_Machines"><div class="tree-item-contents heading-link" heading-name="Exchanging Data Between Endian Machines"><span class="tree-item-title">Exchanging Data Between Endian Machines</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/operating-system/understanding-big-and-little-endian-byte-order/understanding-big-and-little-endian-byte-order.html#Solution_1:_Use_a_Common_Format"><div class="tree-item-contents heading-link" heading-name="Solution 1: Use a Common Format"><span class="tree-item-title">Solution 1: Use a Common Format</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/operating-system/understanding-big-and-little-endian-byte-order/understanding-big-and-little-endian-byte-order.html#Solution_2:_Use_a_Byte_Order_Mark_(BOM)"><div class="tree-item-contents heading-link" heading-name="Solution 2: Use a Byte Order Mark (BOM)"><span class="tree-item-title">Solution 2: Use a Byte Order Mark (BOM)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/operating-system/understanding-big-and-little-endian-byte-order/understanding-big-and-little-endian-byte-order.html#Why_Are_There_Endian_Issues_at_All?_Can't_We_Just_Get_Along?"><div class="tree-item-contents heading-link" heading-name="Why Are There Endian Issues at All? Can't We Just Get Along?"><span class="tree-item-title">Why Are There Endian Issues at All? Can't We Just Get Along?</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="computer-science/operating-system/understanding-big-and-little-endian-byte-order/understanding-big-and-little-endian-byte-order.html#Epilogue:_Parting_Thoughts"><div class="tree-item-contents heading-link" heading-name="Epilogue: Parting Thoughts"><span class="tree-item-title">Epilogue: Parting Thoughts</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>