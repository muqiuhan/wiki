<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[éŸ©æš®ç§‹çš„ä¸ªäººç»´åŸº]]></title><description><![CDATA[Obsidian digital garden]]></description><link>https://muqiuhan.github.io/wiki/</link><image><url>https://muqiuhan.github.io/wiki/lib/media/favicon.jpg</url><title>éŸ©æš®ç§‹çš„ä¸ªäººç»´åŸº</title><link>https://muqiuhan.github.io/wiki/</link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Fri, 15 Nov 2024 04:45:06 GMT</lastBuildDate><atom:link href="https://muqiuhan.github.io/wiki/lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Fri, 15 Nov 2024 04:45:04 GMT</pubDate><copyright><![CDATA[éŸ©æš®ç§‹]]></copyright><ttl>60</ttl><dc:creator>éŸ©æš®ç§‹</dc:creator><item><title><![CDATA[You donâ€™t Need a Book to Know DDD(Domain-Driven Design)]]></title><description><![CDATA[<a class="tag" href="https://muqiuhan.github.io/wiki/?query=tag:design" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#design</a> <a class="tag" href="https://muqiuhan.github.io/wiki/?query=tag:ddd" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#ddd</a> 
 <br><a href="https://muqiuhan.github.io/wiki?query=tag:design" class="tag" target="_blank" rel="noopener nofollow">#design</a> <a href="https://muqiuhan.github.io/wiki?query=tag:ddd" class="tag" target="_blank" rel="noopener nofollow">#ddd</a><br><img alt="Pasted image 20241115123905.png" src="https://muqiuhan.github.io/wiki/computer-science/design/you-donâ€™t-need-a-book-to-know-ddd(domain-driven-design)/pasted-image-20241115123905.png"><br>It took me a while to figure out the patterns behind DDD, though the most important thing are ubiquitous language and bounded context. In this article, I donâ€™t want to address the philosophical part of DDD, instead I want to dive into the practical implementation of some parts to connect with the philosophy behind it. If you are not familiar with the two most important concepts behind DDD, there are countless articles out there explaining them, just go and search them.<br>Somewhere I read this conclusion of DDD patterns and I found it quite good:<br>
You model your business using Entities (the ID matters) and Value Objects (the values matter). You use Repositories to retrieve and store them. You create them with the help of Factories. If an object is too complex for a single class, youâ€™ll create Aggregates that will bind Entities &amp; Value Objects under the same root. If a business logic doesnâ€™t belong to a given object, youâ€™ll define Services that will manipulate the involved elements. Eventually, when the state of the business changes (a change that matters to business experts), youâ€™ll publish Domain Events to communicate the change.
<br>Breaking down each concept will help piece up the whole picture of DDD.<br>I just use some Rust example, they are very readable I promise!<br><br>Entities are objects that have a distinct identity that runs through time and different states. The identity is usually represented by an ID.<br>// src/entities/user.rs
pub struct User {
    pub id: u32,
    pub username: String,
    pub email: String,
    pub age: u8,
}

impl User {
    pub fn new(id: u32, username: String, email: String, age: u8) -&gt; Self {
        User { id, username, email, age }
    }
}
Copy<br><br>Value objects are objects that are defined by their attributes. They do not have a distinct identity.<br>// src/value_objects/address.rs
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Address {
    pub street: String,
    pub city: String,
    pub zip_code: String,
}

impl Address {
    pub fn new(street: String, city: String, zip_code: String) -&gt; Self {
        Address { street, city, zip_code }
    }
}
Copy<br><br>Repositories are used to retrieve and store entities. They act as a collection of entities.<br>// src/repositories/user_repository.rs
use crate::entities::user::User;

pub struct UserRepository {
    users: Vec&lt;User&gt;,
}

impl UserRepository {
    pub fn new() -&gt; Self {
        UserRepository { users: Vec::new() }
    }

    pub fn add(&amp;mut self, user: User) {
        self.users.push(user);
    }

    pub fn find_by_id(&amp;self, id: u32) -&gt; Option&lt;&amp;User&gt; {
        self.users.iter().find(|&amp;user| user.id == id)
    }
}

Copy<br><br>Factories are used to create complex objects and aggregates.<br>// src/factories/user_factory.rs
use crate::entities::user::User;

pub struct UserFactory;

impl UserFactory {
    pub fn create_user(id: u32, username: String, email: String, age: u8) -&gt; User {
        User::new(id, username, email, age)
    }
}

Copy<br><br>Aggregates are clusters of entities and value objects that are treated as a single unit.<br>// src/aggregates/order.rs
use crate::entities::user::User;
use crate::value_objects::address::Address;

pub struct Order {
    pub id: u32,
    pub user: User,
    pub shipping_address: Address,
}

impl Order {
    pub fn new(id: u32, user: User, shipping_address: Address) -&gt; Self {
        Order { id, user, shipping_address }
    }
}
Copy<br><br>Services contain business logic that doesnâ€™t naturally fit within an entity or value object.<br>// src/services/order_service.rs
use crate::aggregates::order::Order;
use crate::entities::user::User;
use crate::value_objects::address::Address;

pub struct OrderService;

impl OrderService {
    pub fn create_order(user: User, shipping_address: Address) -&gt; Order {
        let order_id = 1; // In a real application, this would be generated
        Order::new(order_id, user, shipping_address)
    }
}

Copy<br>Key Points about Services are:<br>1.Stateless: Services are typically stateless. They do not hold any state themselves but operate on the state of entities and value objects.<br>2.Encapsulation of Business Logic: They encapsulate business logic that spans multiple entities or value objects or that doesnâ€™t fit neatly within a single entity or value object.<br>3.Coordination: They often coordinate interactions between multiple entities and value objects.<br><br>Domain events are used to communicate changes in the state of the business.<br>// src/events/user_registered.rs
pub struct UserRegistered {
    pub user_id: u32,
    pub username: String,
}

impl UserRegistered {
    pub fn new(user_id: u32, username: String) -&gt; Self {
        UserRegistered { user_id, username }
    }
}
Copy<br>They are typically published to an event bus or event store, which can then be used to notify other parts of the system or external systems about these events.<br>Where Domain Events Are Published:<br>1.Event Bus: Domain events are often published to an in-memory event bus within the application. This allows other parts of the application to subscribe to and handle these events. Since it is in-memory, the events are ephemeral and will be lost if the application restarts or crashes. It is suitable for scenarios where events need to be processed quickly and do not require persistence, such as inter-component communication within a single application instance.<br>2.Event Store: For more complex scenarios, domain events can be published to an event store, such as AWS EventBridge, Kafka, or a custom event store. This allows for durable storage and replay of events. Think of it as just:<br>pub struct EventStore {
    file_path: String,
}

Copy<br>An event store can serve as the single source of truth in an event-driven architecture, particularly in the context of event sourcing.<br>In event sourcing, every change to the state of an application is captured as an event and stored in the event store. The current state of the application can be reconstructed by replaying these events.<br>A quick take-away is events are immutable and represent facts that have occurred. Once an event is stored, it is never changed or deleted.<br><img alt="Pasted image 20241115124216.png" src="https://muqiuhan.github.io/wiki/computer-science/design/you-donâ€™t-need-a-book-to-know-ddd(domain-driven-design)/pasted-image-20241115124216.png"><br>3.Message Brokers: Domain events can also be published to message brokers like RabbitMQ or AWS SNS/SQS for asynchronous processing and integration with other systems.<br><br>mod entities {
    pub mod user;
}

mod value_objects {
    pub mod address;
}

mod repositories {
    pub mod user_repository;
}

mod factories {
    pub mod user_factory;
}

mod aggregates {
    pub mod order;
}

mod services {
    pub mod order_service;
}

mod events {
    pub mod user_registered;
}

use entities::user::User;
use value_objects::address::Address;
use repositories::user_repository::UserRepository;
use factories::user_factory::UserFactory;
use services::order_service::OrderService;
use events::user_registered::UserRegistered;

fn main() {
    // Create a user using the factory
    let user = UserFactory::create_user(1, String::from("Alice"), String::from("alice@example.com"), 30);

    // Create a repository and add the user
    let mut user_repo = UserRepository::new();
    user_repo.add(user);

    // Find the user by ID
    if let Some(user) = user_repo.find_by_id(1) {
        println!("User found: {}", user.username);
    }

    // Create an address
    let address = Address::new(String::from("123 Main St"), String::from("Hometown"), String::from("12345"));

    // Create an order using the service
    let order = OrderService::create_order(user.clone(), address);

    // Publish a domain event, typically published to an event bus or event store, 
   // which can then be used to notify other parts of the system or external systems about these events.
    let event = UserRegistered::new(user.id, user.username.clone());
    println!("Domain event: UserRegistered for user {}", event.username);
}
Copy<br>A key point take-away is that factories focus on object creation, while services focus on business logic and operations.]]></description><link>https://muqiuhan.github.io/wiki/computer-science/design/you-donâ€™t-need-a-book-to-know-ddd(domain-driven-design)/you-donâ€™t-need-a-book-to-know-ddd(domain-driven-design).html</link><guid isPermaLink="false">Computer Science/Design/You donâ€™t Need a Book to Know DDD(Domain-Driven Design)/You donâ€™t Need a Book to Know DDD(Domain-Driven Design).md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Fri, 15 Nov 2024 04:42:58 GMT</pubDate><enclosure url="https://muqiuhan.github.io/wiki/computer-science/design/you-donâ€™t-need-a-book-to-know-ddd(domain-driven-design)/pasted-image-20241115123905.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://muqiuhan.github.io/wiki/computer-science/design/you-donâ€™t-need-a-book-to-know-ddd(domain-driven-design)/pasted-image-20241115123905.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ä»äº‹ä»¶é£æš´çœ‹é¢†åŸŸé©±åŠ¨è®¾è®¡]]></title><description><![CDATA[<a class="tag" href="https://muqiuhan.github.io/wiki/?query=tag:design" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#design</a> <a class="tag" href="https://muqiuhan.github.io/wiki/?query=tag:ddd" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#ddd</a> 
 <br><a href="https://muqiuhan.github.io/wiki?query=tag:design" class="tag" target="_blank" rel="noopener nofollow">#design</a> <a href="https://muqiuhan.github.io/wiki?query=tag:ddd" class="tag" target="_blank" rel="noopener nofollow">#ddd</a><br>äº‹ä»¶é£æš´ï¼ˆEvent Stormingï¼‰æ˜¯ä¸€ç§é¢†åŸŸé©±åŠ¨è®¾è®¡ï¼ˆDDDï¼‰çš„å·¥ä½œåŠå®è·µæ–¹æ³•ï¼Œç”±Alberto Brandoliniæå‡ºï¼Œæ—¨åœ¨é€šè¿‡å›¢é˜Ÿåä½œçš„æ–¹å¼å¿«é€Ÿç†è§£å’Œå»ºæ¨¡ä¸šåŠ¡é¢†åŸŸã€‚ä»¥ä¸‹æ˜¯äº‹ä»¶é£æš´åŠç›¸å…³é¢†åŸŸé©±åŠ¨è®¾è®¡ä¸­çš„ä¸€äº›æ ¸å¿ƒæ¦‚å¿µå’ŒçŸ¥è¯†ç‚¹ï¼š<br>
1.&nbsp;é¢†åŸŸï¼ˆDomainï¼‰ï¼šæŒ‡çš„æ˜¯ä¸šåŠ¡ç›¸å…³çŸ¥è¯†çš„é›†åˆï¼Œå¯ä»¥è¿›ä¸€æ­¥åˆ’åˆ†ä¸ºå­åŸŸã€‚<br>
2.&nbsp;å­åŸŸï¼ˆSubdomainï¼‰ï¼šæ˜¯é¢†åŸŸçš„ä¸€éƒ¨åˆ†ï¼Œå¯ä»¥æ˜¯æ ¸å¿ƒåŸŸã€æ”¯æ’‘åŸŸæˆ–é€šç”¨åŸŸã€‚<br>
3.&nbsp;æ ¸å¿ƒåŸŸï¼ˆCore Domainï¼‰ï¼šæŒ‡é¢†åŸŸä¸­æœ€æ ¸å¿ƒçš„éƒ¨åˆ†ï¼Œé€šå¸¸å¯¹åº”ä¼ä¸šçš„æ ¸å¿ƒä¸šåŠ¡ã€‚<br>
4.&nbsp;é€šç”¨è¯­è¨€ï¼ˆUbiquitous Languageï¼‰ï¼šå›¢é˜Ÿæ‰€æœ‰æˆå‘˜ä½¿ç”¨çš„ä¸€ç§è¯­è¨€ï¼Œç”¨äºç¡®ä¿ä¸šåŠ¡å’Œè½¯ä»¶ä¹‹é—´çš„æ²Ÿé€šä¸€è‡´æ€§ã€‚<br>
5.&nbsp;é™ç•Œä¸Šä¸‹æ–‡ï¼ˆBounded Contextï¼‰ï¼šå®šä¹‰äº†ä¸€ç»„è§„åˆ™å’Œåè®®ï¼Œç”¨äºæ˜ç¡®é¢†åŸŸæ¨¡å‹çš„é€‚ç”¨èŒƒå›´ã€‚<br>
6.&nbsp;å®ä½“ï¼ˆEntityï¼‰ï¼šå…·æœ‰å”¯ä¸€æ ‡è¯†å’Œç”Ÿå‘½å‘¨æœŸçš„é¢†åŸŸå¯¹è±¡ã€‚<br>
7.&nbsp;å€¼å¯¹è±¡ï¼ˆValue Objectï¼‰ï¼šæè¿°äº†æŸç§ç‰¹æ€§æˆ–å±æ€§çš„å¯¹è±¡ï¼Œæ²¡æœ‰æ¦‚å¿µæ ‡è¯†ã€‚<br>
8.&nbsp;èšåˆï¼ˆAggregateï¼‰ï¼šä¸€ç»„ç›¸å…³å¯¹è±¡çš„é›†åˆï¼Œç”±ä¸€ä¸ªèšåˆæ ¹ï¼ˆAggregate Rootï¼‰ç»Ÿä¸€ç®¡ç†ã€‚<br>
9.&nbsp;é¢†åŸŸäº‹ä»¶ï¼ˆDomain Eventï¼‰ï¼šé¢†åŸŸä¸­å‘ç”Ÿçš„é‡è¦äº‹ä»¶ï¼Œå¯ä»¥ç”¨äºé€šçŸ¥å…¶ä»–é¢†åŸŸå¯¹è±¡æˆ–è·¨é™ç•Œä¸Šä¸‹æ–‡è¿›è¡Œè§£è€¦å’Œåä½œã€‚<br>
10.&nbsp;å‘½ä»¤ï¼ˆCommandï¼‰ï¼šè¡¨ç¤ºè¦æ‰§è¡Œçš„æ“ä½œï¼Œé€šå¸¸ä¸äº‹ä»¶ä¸€ä¸€å¯¹åº”ã€‚<br>
11.&nbsp;è¯»æ¨¡å‹ï¼ˆRead Modelï¼‰ï¼šä¸ºäº†ä¼˜åŒ–è¯»å–æ“ä½œè€Œè®¾è®¡çš„æ¨¡å‹ï¼Œå¯èƒ½ä¸å†™æ¨¡å‹ä¸åŒã€‚<br>
12.&nbsp;å†³ç­–å‘½ä»¤ï¼ˆDecision Commandï¼‰ï¼šåœ¨äº‹ä»¶é£æš´ä¸­ï¼Œç›´æ¥å¯¼è‡´äº‹ä»¶å‘ç”Ÿçš„å‘½ä»¤ã€‚<br>
13.&nbsp;æˆ˜ç•¥è®¾è®¡ï¼ˆStrategic Designï¼‰ï¼šé«˜å±‚æ¬¡çš„æŠ½è±¡å’Œå½’ç±»ï¼ŒåŒ…æ‹¬ç†æ¸…ä¸Šä¸‹æ–‡å’Œå­åŸŸçš„åˆ’åˆ†ã€‚<br>
14.&nbsp;æˆ˜æœ¯è®¾è®¡ï¼ˆTactical Designï¼‰ï¼šå¯¹ç‰¹å®šä¸Šä¸‹æ–‡ä¸‹çš„æ¨¡å‹è¿›è¡Œè¯¦ç»†è®¾è®¡ï¼ŒåŒ…æ‹¬èšåˆã€å®ä½“å’Œå€¼å¯¹è±¡ã€‚<br>
15.&nbsp;è´«è¡€æ¨¡å‹ï¼ˆAnemic Domain Modelï¼‰ï¼šé¢†åŸŸå¯¹è±¡åªæœ‰å±æ€§åŠå…¶getter/setteræ–¹æ³•çš„çº¯æ•°æ®ç±»ï¼Œä¸šåŠ¡é€»è¾‘é€šè¿‡æœåŠ¡å®ç°ã€‚<br>
16.&nbsp;å……è¡€æ¨¡å‹ï¼ˆRich Domain Modelï¼‰ï¼šé¢†åŸŸå¯¹è±¡åŒ…å«ä¸šåŠ¡é€»è¾‘ï¼Œæ¯ä¸ªå¯¹è±¡éƒ½æ˜¯æ´»è·ƒçš„ã€‚<br>
17.&nbsp;èµ„æºåº“ï¼ˆRepositoryï¼‰ï¼šç”¨äºæ£€ç´¢å’ŒæŒä¹…åŒ–é¢†åŸŸå¯¹è±¡çš„æœºåˆ¶ã€‚<br>
18.&nbsp;æœåŠ¡ï¼ˆServiceï¼‰ï¼šåœ¨æ¨¡å‹ä¸­ç‹¬ç«‹çš„æ“ä½œï¼Œå¯ä»¥æ˜¯é¢†åŸŸæœåŠ¡æˆ–åº”ç”¨æœåŠ¡ã€‚<br>
19.&nbsp;å›ºå®šè§„åˆ™ï¼ˆInvariantï¼‰ï¼šä¸ºè®¾è®¡å…ƒç´ åšå‡ºçš„æ–­è¨€ï¼Œå¿…é¡»ä¸€ç›´ä¿æŒä¸ºçœŸã€‚<br>
äº‹ä»¶é£æš´é€šå¸¸åŒ…æ‹¬ä»¥ä¸‹æ­¥éª¤ï¼š<br>
è¯†åˆ«é¢†åŸŸäº‹ä»¶<br>
ç¡®å®šäº‹ä»¶é¡ºåº<br>
è¯†åˆ«å‘½ä»¤å’Œè§¦å‘å™¨<br>
è¯†åˆ«èšåˆå’Œå®ä½“<br>
åˆ’åˆ†é™ç•Œä¸Šä¸‹æ–‡<br>
è¯†åˆ«é¢†åŸŸæœåŠ¡å’Œèµ„æºåº“<br>
é€šè¿‡è¿™äº›æ­¥éª¤ï¼Œå›¢é˜Ÿå¯ä»¥å…±åŒåˆ›å»ºå‡ºåæ˜ ä¸šåŠ¡é¢†åŸŸçš„é¢†åŸŸæ¨¡å‹ï¼Œä¸ºè½¯ä»¶è®¾è®¡å’Œå¼€å‘æä¾›æŒ‡å¯¼ã€‚]]></description><link>https://muqiuhan.github.io/wiki/computer-science/design/ä»äº‹ä»¶é£æš´çœ‹é¢†åŸŸé©±åŠ¨è®¾è®¡.html</link><guid isPermaLink="false">Computer Science/Design/ä»äº‹ä»¶é£æš´çœ‹é¢†åŸŸé©±åŠ¨è®¾è®¡.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Fri, 15 Nov 2024 04:38:05 GMT</pubDate></item><item><title><![CDATA[Svelte çš„ç¼–è¯‘å™¨å’Œè¿è¡Œæ—¶]]></title><description><![CDATA[<a class="tag" href="https://muqiuhan.github.io/wiki/?query=tag:svelte" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#svelte</a> <a class="tag" href="https://muqiuhan.github.io/wiki/?query=tag:web" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#web</a> <a class="tag" href="https://muqiuhan.github.io/wiki/?query=tag:compiler" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#compiler</a> 
 <br><a href="https://muqiuhan.github.io/wiki?query=tag:svelte" class="tag" target="_blank" rel="noopener nofollow">#svelte</a> <a href="https://muqiuhan.github.io/wiki?query=tag:web" class="tag" target="_blank" rel="noopener nofollow">#web</a> <a href="https://muqiuhan.github.io/wiki?query=tag:compiler" class="tag" target="_blank" rel="noopener nofollow">#compiler</a><br>åœ¨ svelte æºç é‡Œï¼Œä½¿ç”¨äº† <a data-tooltip-position="top" aria-label="https://github.com/acornjs/acorn" rel="noopener nofollow" class="external-link" href="https://github.com/acornjs/acorn" target="_blank"><code></code></a>acorn parser å°† javascript ç¼–è¯‘æˆ ast æ ‘ï¼Œç„¶åå¯¹ Javascript çš„è¯­ä¹‰è§£é‡Šè¿‡ç¨‹åšäº†é¢å¤–çš„å·¥ä½œï¼š<br>
<br>ç¼–è¯‘èµ‹å€¼è¯­å¥æ—¶ï¼Œé™¤äº†ç”Ÿæˆå¯¹åº”çš„èµ‹å€¼é€»è¾‘ï¼Œé¢å¤–ç”Ÿæˆæ•°æ®æ›´æ–°é€»è¾‘ä»£ç <br>

<br>ç¼–è¯‘å˜é‡å£°æ˜æ—¶ï¼Œå˜é‡è¢«ç¼–è¯‘æˆä¸Šä¸‹æ–‡æ•°ç»„<br>

<br>ç¼–è¯‘æ¨¡æ¿æ—¶ï¼Œæ ‡è®°ä¾èµ–ï¼Œå¹¶å¯¹æ¯ä¸ªå˜é‡å¼•ç”¨ç”Ÿæˆæ›´æ–°é€»è¾‘<br>

<br>è¿™å°±æ˜¯ç¼–è¯‘å‹æ¡†æ¶ï¼Œä¸ä¼ ç»Ÿå‰ç«¯æ¡†æ¶çš„åŒºåˆ«ï¼šæŠŠè¿è¡Œæ—¶çš„é€»è¾‘æå‰åœ¨ç¼–è¯‘æœŸå°±å®Œæˆã€‚æ‰€ä»¥è‡ªç„¶è€Œç„¶çš„ï¼Œè¿è¡Œæ—¶é€»è¾‘å¾ˆè½»é‡çº§ï¼Œå¾ˆæ˜¾ç„¶æ˜¯æœ‰åˆ©äºé¡µé¢çš„é¦–å±å’Œæ¸²æŸ“æ€§èƒ½çš„ã€‚<br><br>æ¯ä¸€ä¸ª .svelte æ–‡ä»¶ä»£è¡¨ä¸€ä¸ª svelte çš„ç»„ä»¶ã€‚<br>é€šè¿‡ svelte çš„ç¼–è¯‘ï¼Œæœ€ç»ˆä¼šè½¬æ¢ä¸ºä¸‹å›¾æ‰€ç¤ºçš„ç»„ä»¶çš„ç»“æ„<br><img alt="Pasted image 20241115111951.png" src="https://muqiuhan.github.io/wiki/computer-science/web/svelte/svelte-æ ¸å¿ƒåŸç†/pasted-image-20241115111951.png"><br>æ¯ä¸€ä¸ª svelte çš„ç»„ä»¶ç±»ï¼Œéƒ½ç»§æ‰¿äº† SvelteComponentã€‚<br>svelte ç»„ä»¶ä½¿ç”¨ create, mount, patch, destroy è¿™å››ä¸ªæ–¹æ³•å®ç°å¯¹ DOM è§†å›¾çš„æ“ä½œã€‚<br>
<br>create è´Ÿè´£ç»„ä»¶ dom çš„åˆ›å»º<br>

<br>mount è´Ÿè´£å°† dom æŒ‚è½½åˆ°å¯¹åº”çš„çˆ¶èŠ‚ç‚¹ä¸Š<br>

<br>patch è´Ÿè´£æ ¹æ®æ•°æ®çš„å˜åŒ–æ›´æ–° dom<br>

<br>destroy è´Ÿè´£é”€æ¯å¯¹åº”çš„ dom<br>

<br>svelte çš„ç»„ä»¶å®ä¾‹åŒ–ï¼Œæ˜¯é€šè¿‡ instance æ–¹æ³•å’Œç»„ä»¶ä¸Šä¸‹æ–‡æ„æˆçš„ã€‚<br>
<br>instance æ–¹æ³•æ˜¯ svelte ç»„ä»¶çš„æ„é€ å™¨ã€‚å†™åœ¨ script é‡Œçš„ä»£ç ï¼Œä¼šè¢«ç”Ÿæˆåœ¨ instance æ–¹æ³•é‡Œã€‚æ¯ä¸ªç»„ä»¶å®ä¾‹éƒ½ä¼šè°ƒç”¨ä¸€æ¬¡å½¢æˆè‡ªå·±çš„é—­åŒ…ï¼Œä»è€Œéš”ç¦»å„è‡ªçš„æ•°æ®ï¼Œé€šè¿‡ instance æ–¹æ³•è¿”å›çš„æ•°ç»„å°±æ˜¯ä¸Šä¸‹æ–‡ã€‚ä»£ç ä¸­çš„èµ‹å€¼è¯­å¥ï¼Œä¼šè¢«ç”Ÿæˆä¸ºæ•°æ®æ›´æ–°é€»è¾‘ã€‚å˜é‡å®šä¹‰ä¼šè¢«æ”¶é›†ç”Ÿæˆä¸Šä¸‹æ–‡æ•°ç»„ã€‚
<br>æ¯ä¸ª svelte ç»„ä»¶éƒ½ä¼šæœ‰è‡ªå·±çš„ä¸Šä¸‹æ–‡ï¼Œä¸Šä¸‹æ–‡å­˜å‚¨çš„å°±æ˜¯ script æ ‡ç­¾å†…å®šä¹‰çš„å˜é‡çš„å€¼ã€‚svelte ä¼šä¸ºæ¯ä¸ªç»„ä»¶å®ä¾‹å†…å®šä¹‰çš„æ•°æ®ç”Ÿæˆä¸Šä¸‹æ–‡ï¼ŒæŒ‰ç…§å˜é‡çš„å£°æ˜é¡ºåºä¿å­˜åœ¨ä¸€ä¸ªåä¸º ctx æ•°ç»„å†…ã€‚
<br><img alt="Pasted image 20241115112012.png" src="https://muqiuhan.github.io/wiki/computer-science/web/svelte/svelte-æ ¸å¿ƒåŸç†/pasted-image-20241115112012.png"><br><br>ä¾‹å¦‚æœ‰å¦‚ä¸‹ Svelte ä»£ç :<br>&lt;h1&gt;Hello world!&lt;/h1&gt;
Copy<br>ç¼–è¯‘å:<br>/* App.svelte generated by Svelte v3.59.1 */
import {
  SvelteComponent,
  detach,
  element,
  init,
  insert,
  noop,
  safe_not_equal
} from "svelte/internal";

function create_fragment(ctx) {
  let h1;

  return {
    c() {
      h1 = element("h1");
      h1.textContent = "Hello world!";
    },
    m(target, anchor) {
      insert(target, h1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) detach(h1);
    }
  };
}

class App extends SvelteComponent {
  constructor(options) {
    super();  
    init(this, options, null, create_fragment, safe_not_equal, {});
  }
}

export default App;
Copy<br>å¾ˆæ˜æ˜¾ï¼Œç»„ä»¶ç¼–è¯‘ä¹‹åï¼Œä¼šè¿”å›ä¸€ä¸ªç»§æ‰¿äº†SvelteComponentçš„ç±»ï¼Œå¹¶ä¸”åœ¨æ„é€ å‡½æ•°ä¸­æ‰§è¡Œäº†initæ–¹æ³•ï¼Œå®ƒçš„å…¶ä¸­ä¸€ä¸ªå‚æ•°æ˜¯ç»„ä»¶ä¸­å®šä¹‰çš„create_fragmentå‡½æ•°ã€‚<br>è¿™ä¸ªå‡½æ•°ä¼šè¿”å›ä¸€ä¸ªå¯¹è±¡ï¼ŒåŒ…å«ç»„ä»¶å¯¹åº”çš„çš„create mount update deleteæ“ä½œã€‚ç”±äºä¸Šé¢çš„ä»£ç ä¸­æ˜¯ä¸ªé™æ€çš„å­—ç¬¦ä¸²ï¼Œæ‰€ä»¥på¯¹åº”çš„å€¼ä¸ºnoopå³no operateæ²¡æœ‰æ“ä½œã€‚<br>æ¥ä¸‹æ¥åŠ ç‚¹æ–™:<br>&lt;script&gt;
let count = 0
&lt;/script&gt;
&lt;h1 on:click={() =&gt; count++}&gt;Hello world!&lt;/h1&gt;
Copy<br>ç¼–è¯‘ç»“æœ:<br>function create_fragment(ctx) {
  let h1;
  let mounted;
  let dispose;
  
  return {
    c() {
      h1 = element("h1");
      h1.textContent = "Hello world!";
    },
    m(target, anchor) {
      insert(target, h1, anchor);
      if (!mounted) {
        dispose = listen(h1, "click", /*click_handler*/ ctx[1]);
        mounted = true;
      }
    },
    // ...
    d(detaching) {
      if (detaching) detach(h1);
      mounted = false;
      dispose();
    }
  };
}

function instance($$self, $$props, $$invalidate) {
  let count = 0;
  const click_handler = () =&gt; $$invalidate(0, count++, count);
  return [count, click_handler];
}
Copy<br>æˆ‘ä»¬å¯ä»¥çœ‹åˆ°åœ¨mountedä¹‹åä½¿ç”¨listenæ–¹æ³•æ–°å¢äº†ä¸€ä¸ªé’ˆå¯¹h1çš„clickæ–¹æ³•çš„ç›‘å¬äº‹ä»¶ï¼Œå¹¶ä¸”åœ¨deleteé˜¶æ®µç§»é™¤ç›‘å¬äº‹ä»¶ã€‚<br>åŒæ—¶å¤šäº†ä¸ªå®ä¾‹æ–¹æ³•instanceï¼Œå®ƒçš„è¿”å›å€¼æ˜¯countçš„å®é™…å€¼ï¼Œä»¥åŠä¿®æ”¹countçš„å¤„ç†å‡½æ•°ã€‚<br>å†æ”¹æ”¹:<br>&lt;script&gt;
let count = 0
&lt;/script&gt;
&lt;h1 on:click={() =&gt; count++}&gt;Hello world!{count}&lt;/h1&gt;
Copy<br>ç¼–è¯‘ç»“æœ:<br>function create_fragment(ctx) {
  let h1;
  let t0;
  let t1;
  let mounted;
  let dispose;
  
  return {
    c() {
      h1 = element("h1");
      h1.textContent = "Hello world!";
      t0 = text("Hello world!");
      t1 = text(/*count*/ ctx[0]);
    },
    m(target, anchor) {
      insert(target, h1, anchor);
      append(h1, t0);
      append(h1, t1);
      if (!mounted) {
        dispose = listen(h1, "click", /*click_handler*/ ctx[1]);
        mounted = true;
      }
    },
    // ...
    p(ctx, [dirty]) {
      if (dirty &amp; /*count*/ 1) set_data(t1, /*count*/ ctx[0]);
    },
    d(detaching) {
      if (detaching) detach(h1);
      mounted = false;
      dispose();
    }
  };
}
Copy<br><br>svelte é€šè¿‡ä½è¿ç®—(bitmask)å¯¹å˜é‡çš„æ”¹å˜è¿›è¡Œè„æ ‡è®°<br>æ¯ä¸ªå˜é‡éƒ½è¢«åˆ†é…ä¸€ä¸ªä½å€¼ï¼Œå¯ä»¥ç”¨äºåœ¨ ctx ä¸Šä¸‹æ–‡æ•°æ®é‡Œå–å¾—å˜é‡å¯¹åº”çš„å€¼ï¼Œä¹Ÿå¯ä»¥é€šè¿‡ä½è¿ç®—å¯¹å˜é‡æ”¹åŠ¨è¿›è¡Œæ ‡è®°å’Œæ£€æŸ¥ã€‚<br>æ¯”å¦‚ name çš„ä½å€¼æ˜¯ 1ï¼Œé‚£ name çš„å€¼å¯ä»¥é€šè¿‡ ctx[1] å–å¾—ã€‚<br>é€šè¿‡ dirty |= 1 è®¾ç½® name å·²ç»æ”¹åŠ¨çš„çŠ¶æ€ï¼Œå†é€šè¿‡ dirty &amp; 1 åˆ¤æ–­ name æ˜¯å¦æ”¹åŠ¨ã€‚<br>Javascript çš„ä½è¿ç®—å¯ä»¥æœ‰ 32 ä½ã€‚ svelte æ”¯æŒæ¯ä¸ªç»„ä»¶é‡Œå¯¹ 32 ä¸ªå˜é‡æ ‡è®°æ”¹åŠ¨ã€‚<br>ä¸€èˆ¬ä¸€ä¸ªç»„ä»¶ä¸åº”è¯¥å®šä¹‰è¿‡å¤šçš„å˜é‡ã€‚å½“ç„¶å¦‚æœå®šä¹‰å˜é‡å¤šäº 32 ä¸ªï¼Œæ— éå°±æ˜¯æ‹¿ä¸¤ä¸ªä½æ ‡è®°å˜é‡ï¼Œå‡‘æˆ 64 ä½ï¼Œä»¥æ­¤ç±»æ¨ã€‚<br><img alt="Pasted image 20241115112612.png" src="https://muqiuhan.github.io/wiki/computer-science/web/svelte/svelte-æ ¸å¿ƒåŸç†/pasted-image-20241115112612.png"><br>è®¾ç½®ä½ï¼šbitmask |= 1 &lt;&lt; (n-1)<br>æ£€æµ‹ä½ï¼šif (bitmask &amp; (1 &lt;&lt; (n-1)))<br><br><br>å‰ç«¯æ¡†æ¶åˆ›å»ºè§†å›¾çš„æ–¹å¼æœ‰å‡ ç§ï¼Œæ¯”å¦‚è™šæ‹Ÿ domï¼Œå­—ç¬¦ä¸²æ¨¡æ¿ï¼Œè¿‡ç¨‹å¼åˆ›å»ºã€‚<br>svelte é‡‡ç”¨çš„æ˜¯è¿‡ç¨‹å¼åˆ›å»ºã€‚<br>ä¸¾ä¸ªä¾‹å­ï¼Œå‡è®¾æˆ‘æƒ³è¦é€šè¿‡çº¯ js çš„æ–¹å¼åˆ›å»ºä¸€ä¸ªå¦‚ä¸‹çš„ web uiï¼š<br><img alt="Pasted image 20241115112039.png" src="https://muqiuhan.github.io/wiki/computer-science/web/svelte/svelte-æ ¸å¿ƒåŸç†/pasted-image-20241115112039.png"><br>æˆ‘ä»¬å¯èƒ½ä¼šå†™ä¸‹è¿™æ ·çš„ä»£ç ï¼š<br>const todoListNode = document.createElement('ul');
const todos = [1,2,3];
for (const todo of todos) {
    const itemNode = document.createElement('li');
    itemNode.textContent = `item ${todo}`;
    todoListNode.appendChild(itemNode);
}
Copy<br>è€Œ svelte ç”Ÿæˆçš„è§†å›¾ä»£ç å°±å¾ˆç±»ä¼¼æˆ‘ä»¬æ‰‹åŠ¨ç¼–å†™çš„ js ä»£ç ã€‚<br>è¿™éƒ¨åˆ†åˆ›å»º dom çš„ä»£ç ï¼Œä¼šç”Ÿæˆä¸ºç»„ä»¶å†…éƒ¨çš„ create å‡½æ•°ï¼Œ mount å‡½æ•°ï¼Œpatch å‡½æ•°ã€‚<br>ä¸‹é¢æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹æ¨¡æ¿ç¼–è¯‘è¿‡ç¨‹ã€‚<br>
<br>é¦–å…ˆè§£æ svelte æ¨¡æ¿å¹¶ç”Ÿæˆæ¨¡æ¿ AST<br>

<br>ç„¶åéå†æ¨¡æ¿ AST<br>

<br>å¦‚æœç¢°åˆ°æ™®é€šçš„ html tag æˆ–è€…æ–‡æœ¬ï¼Œè¾“å‡º dom åˆ›å»ºè¯­å¥ï¼ˆdom.createElement)

<br>å¦‚æœç¢°åˆ°å˜é‡
<br>è½¬æ¢ä¸ºä¸Šä¸‹æ–‡å¼•ç”¨æ–¹å¼å¹¶è¾“å‡ºå–å€¼è¯­å¥ï¼ˆå¦‚ï¼š name è¢«ç”Ÿæˆä¸º ctx[/** name */0])

<br>åœ¨ patch å‡½æ•°ä¸­ç”Ÿæˆå¯¹åº”çš„æ›´æ–°è¯­å¥


<br>å¦‚æœç¢°åˆ° if æ¨¡æ¿
<br>è·å– condition è¯­å¥ï¼Œè¾“å‡ºé€‰æ‹©å‡½æ•° select_block ï¼ˆå­æ¨¡æ¿é€‰æ‹©å™¨ï¼‰

<br>è·å– condition ä¸º true çš„æ¨¡æ¿ç‰‡æ®µï¼Œè¾“å‡º if_block å­æ¨¡æ¿æ„å»ºå‡½æ•°
<br>è·å– condition ä¸º false çš„æ¨¡æ¿ç‰‡æ®µï¼Œè¾“å‡º else_block å­æ¨¡æ¿æ„å»ºå‡½æ•°


<br>å¦‚æœç¢°åˆ° each æ¨¡æ¿
<br>è·å–å¾ªç¯æ¨¡æ¿ç‰‡æ®µï¼Œç”Ÿæˆå—æ„å»ºå‡½æ•° create_each_block

<br>æ ¹æ®å¾ªç¯å†…å˜é‡å¼•ç”¨ï¼Œç”Ÿæˆå¾ªç¯å®ä¾‹ä¸Šä¸‹æ–‡è·å– get_each_block_context




<br>ç”Ÿæˆ keyè·å–å‡½æ•° get_key<br>

<br>ç”ŸæˆåŸºäºkeyæ›´æ–°åˆ—è¡¨çš„ patch é€»è¾‘å‡½æ•° update_keyed_each<br>

<br><img alt="Pasted image 20241115112127.png" src="https://muqiuhan.github.io/wiki/computer-science/web/svelte/svelte-æ ¸å¿ƒåŸç†/pasted-image-20241115112127.png"><br><br>svelte ä¼šæŠŠ if æ¨¡æ¿ï¼Œ each æ¨¡æ¿ä¸­çš„é€»è¾‘åˆ†æ”¯ï¼ŒæŠ½å–æˆå­æ¨¡æ¿ï¼Œå¹¶ä¸ºå…¶ç”Ÿæˆç‹¬ç«‹çš„æ¨¡æ¿å®ä¾‹ï¼ˆåŒ…å«åˆ›å»ºï¼ŒæŒ‚è½½ï¼Œæ›´æ–°ï¼Œé”€æ¯ç­‰ç”Ÿå‘½å‘¨æœŸï¼‰<br><br>è§†å›¾æ›´æ–°æ—¶é€šè¿‡ patch å‡½æ•°æ¥å®Œæˆçš„ã€‚<br>ä¸‹å›¾æ˜¯æ¨¡æ¿è§£æè¿‡ç¨‹ä¸­ patch å‡½æ•°çš„é€»è¾‘ï¼š<br>function patch(ctx, [dirty]) {
  if (dirty &amp; /*name*/ 1) set_data(t1, /*name*/ ctx[0]);
  if (dirty &amp; /*age*/ 2) set_data(t4, /*age*/ ctx[1]);
  if (dirty &amp; /*school*/ 4) set_data(t6, /*school*/ ctx[2]);
}
Copy<br>é€šè¿‡ dirty ä½æ£€æŸ¥å˜é‡æ˜¯å¦å‘ç”Ÿæ›´æ–°ï¼Œå¦‚æœå‘ç”Ÿæ›´æ–°è°ƒç”¨ dom æ“ä½œå‡½æ•°å¯¹ dom è¿›è¡Œå±€éƒ¨æ›´æ–°ã€‚ä¸Šé¢ä¾‹å­çš„ set_data å‡½æ•°ä½œç”¨æ˜¯ç»™ dom è®¾ç½® innerTextã€‚æ ¹æ®æ•°æ®æ›´æ–°çš„è§†å›¾ä½ç½®çš„ä¸åŒï¼Œè¿˜ä¼šæœ‰ set_props ä¹‹ç±»çš„æ›´æ–° dom å±æ€§çš„å‡½æ•°ç­‰ã€‚<br><br>æ¡ä»¶åˆ†æ”¯ä¾‹å­ï¼š<br>&lt;script&gt;
   let isLogin = false;
	const login = () =&gt; {
		isLogin = true;
	}
	const logout = () =&gt; {
		isLogin = false;
	}
&lt;/script&gt;

{#if !isLogin}
&lt;button on:click={login}&gt;
	login
&lt;/button&gt;
{:else}
&lt;div&gt;
	hello, xxx
	&lt;button on:click={logout}&gt;logout&lt;/button&gt;
&lt;/div&gt;
{/if}
Copy<br><img alt="Pasted image 20241115112203.png" src="https://muqiuhan.github.io/wiki/computer-science/web/svelte/svelte-æ ¸å¿ƒåŸç†/pasted-image-20241115112203.png"><br>
<br>æ¡ä»¶åˆ†æ”¯çš„åˆ¤æ–­è¯­å¥ä¼šç”Ÿæˆ select_block å‡½æ•°ï¼Œç”¨äºåˆ¤æ–­æ¡ä»¶ï¼Œå¹¶æ ¹æ®æ¡ä»¶è¿”å›æ¡ä»¶åˆ¤æ–­ä¸ºçœŸçš„å­æ¨¡æ¿ (if_block) æˆ–è€…æ¡ä»¶åˆ¤æ–­ä¸ºå‡çš„å­æ¨¡æ¿ (else_block)
<br>// æ ¹æ®æ¡ä»¶è¿”å›å¯¹åº”çš„blockæ„é€ å‡½æ•°
function select_block(ctx, dirty) {
  if (!/*isLogin*/ ctx[0]) return if_block;
  return else_block;
}
// é€‰æ‹©blockæ„é€ å‡½æ•°
let current_block = select_block(ctx, -1);
// è¿”å›å­æ¨¡æ¿å®ä¾‹ï¼Œè·Ÿç»„ä»¶ç±»ä¼¼ï¼Œæä¾›createï¼Œmountï¼Œpatchç­‰ç”Ÿå‘½å‘¨æœŸ
let block = current_block(ctx);
Copy<br>
<br>æ¡ä»¶é€»è¾‘åˆ†æ”¯ä¼šç”Ÿæˆç‹¬ç«‹çš„å­æ¨¡æ¿æ„é€ å‡½æ•°
<br>if blockç¤ºä¾‹<br>// å­æ¨¡æ¿æ„é€ å‡½æ•°
function if_block(ctx) {
  let button;
  let mounted;
  let dispose;

  return {
    // åˆ›å»ºblock
    create() {
      button = element("button");
      button.textContent = "login";
    },
    // æŒ‚è½½block
    mount(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        mounted = true;
      }
    },
    // é”€æ¯block
    destroy(detaching) {
      if (detaching) detach(button);
      mounted = false;
      dispose();
    }
  };
}
Copy<br>
<br>ifåˆ†æ”¯å¦‚ä½•æŒ‚è½½åŠæ›´æ–°
<br>if åˆ†æ”¯çš„åˆ›å»ºï¼š<br><img alt="Pasted image 20241115112230.png" src="https://muqiuhan.github.io/wiki/computer-science/web/svelte/svelte-æ ¸å¿ƒåŸç†/pasted-image-20241115112230.png"><br>if åˆ†æ”¯çš„æ›´æ–°ï¼š<br><img alt="Pasted image 20241115112241.png" src="https://muqiuhan.github.io/wiki/computer-science/web/svelte/svelte-æ ¸å¿ƒåŸç†/pasted-image-20241115112241.png"><br><br>svelte çš„å¾ªç¯æ¨¡æ¿è·Ÿæ¡ä»¶åˆ†æ”¯æ¨¡æ¿ä¸€æ ·ï¼Œä¹Ÿä¼šç”Ÿæˆè¿­ä»£é€»è¾‘çš„å­æ¨¡æ¿ï¼Œæ¯ä¸€ä¸ªå¾ªç¯è¿­ä»£éƒ½æ˜¯å­æ¨¡æ¿çš„å®ä¾‹ï¼Œå¹¶ä¸”æ‹¥æœ‰ç‹¬ç«‹çš„ä¸Šä¸‹æ–‡ã€‚<br>ä¸»è¦ç”±4éƒ¨åˆ†ç»„æˆï¼š<br>
<br>å¾ªç¯è¿­ä»£æ„å»ºå‡½æ•° create_each_block
<br>å¾ªç¯è¿­ä»£å®ä¾‹ä¸Šä¸‹æ–‡è·å–å‡½æ•° get_each_block_context
<br>å¾ªç¯è¿­ä»£ key è·å–å‡½æ•° get_key
<br>åŸºäº key æ›´æ–°åˆ—è¡¨çš„ patch é€»è¾‘å‡½æ•° update_keyed_each
<br><br>
<br>svelte è°ƒç”¨ acorn ç”Ÿæˆ JS AST æ ‘<br>

<br>éå† AST æ‰¾åˆ°èµ‹å€¼è¯­å¥<br>

<br>ä¸ºèµ‹å€¼è¯­å¥ç”Ÿæˆæ•°æ®å“åº”å¼ä»£ç <br>

<br><img alt="Pasted image 20241115112450.png" src="https://muqiuhan.github.io/wiki/computer-science/web/svelte/svelte-æ ¸å¿ƒåŸç†/pasted-image-20241115112450.png"><br>ä¾‹å¦‚ï¼š<br>&lt;script&gt;
    let name = 'world';
    const changeName = () =&gt; {
        name = 'yyb';
    }
&lt;/script&gt;
Copy<br>ç¼–è¯‘ç»“æœï¼š<br>function instance($$self, $$props, $$invalidate) {
	let name = 'world';

	const changeName = () =&gt; {
		$$invalidate(0, name = 'yyb');
	};

	return [name];
}
Copy<br><br>æ¯ä¸ªæ•°æ®çš„èµ‹å€¼è¯­å¥ï¼Œsvelte éƒ½ä¼šç”Ÿæˆå¯¹ invalidate çš„è°ƒç”¨, invalidate çš„è°ƒç”¨ä¸»è¦åšçš„æ˜¯å¯¹æŸä¸ªæ”¹åŠ¨çš„å˜é‡è¿›è¡Œæ ‡è®°ï¼Œç„¶ååœ¨å¾®ä»»åŠ¡ä¸­è°ƒç”¨patchå‡½æ•°ï¼Œæ ¹æ®å˜é‡æ”¹åŠ¨çš„è„æ ‡è®°è¿›è¡Œå±€éƒ¨æ›´æ–°<br>æ•°æ®èµ‹å€¼è§¦å‘è§†å›¾æ›´æ–°ï¼š<br><img alt="Pasted image 20241115112544.png" src="https://muqiuhan.github.io/wiki/computer-science/web/svelte/svelte-æ ¸å¿ƒåŸç†/pasted-image-20241115112544.png"><br><br><br>åœ¨è¿›å…¥è¿è¡Œæ—¶ï¼Œé¦–å…ˆæ‰§è¡Œinitæ–¹æ³•ï¼Œè¯¥æ–¹æ³•å¤§è‡´æµç¨‹å¦‚ä¸‹ï¼š<br>
<br>åˆå§‹åŒ–çŠ¶æ€
<br>åˆå§‹åŒ–å‘¨æœŸå‡½æ•°
<br>æ‰§è¡Œinstanceæ–¹æ³•ï¼Œåœ¨å›è°ƒå‡½æ•°ä¸­æ ‡è®° è„ç»„ä»¶ (dirty_components)
<br>æ‰§è¡Œæ‰€æœ‰beforeUpdateç”Ÿå‘½å‘¨æœŸçš„å‡½æ•°
<br>æ‰§è¡Œåˆ›å»ºç‰‡æ®µcreate_fragmentå‡½æ•°
<br>æŒ‚è½½å½“å‰ç»„ä»¶å¹¶æ‰§è¡Œcreate_fragementè¿”å›çš„mï¼ˆmountedï¼‰æ–¹æ³•
<br>æ‰§è¡Œflushæ–¹æ³•
<br>export function init(
  component,
  options,
  instance,
  create_fragment,
  not_equal,
  props,
  append_styles,
  dirty = [-1]
) {
  const parent_component = current_component;
  set_current_component(component);

  const $$: T$$ = component.$$ = {
    fragment: null,
    ctx: [],

    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),

    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),

    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };

  append_styles &amp;&amp; append_styles($$.root);

  let ready = false;

  $$.ctx = instance
    ? instance(component, options.props || {}, (i, ret, ...rest) =&gt; {
        const value = rest.length ? rest[0] : ret;
        if ($$.ctx &amp;&amp; not_equal($$.ctx[i], $$.ctx[i] = value)) {
            if (!$$.skip_bound &amp;&amp; $$.bound[i]) $$.bound[i](value);
            if (ready) make_dirty(component, i);
        }
        return ret;
    })
    : [];

  $$.update();
  ready = true;
  run_all($$.before_update);

  // `false` as a special case of no DOM component
  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;

  if (options.target) {
    if (options.hydrate) {
        start_hydrating();
        const nodes = children(options.target);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        $$.fragment &amp;&amp; $$.fragment!.l(nodes);
        nodes.forEach(detach);
    } else {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        $$.fragment &amp;&amp; $$.fragment!.c();
    }

    if (options.intro) transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }

  set_current_component(parent_component);
}
Copy<br><br>flush çš„æ–¹æ³•ä¸»è¦åšäº†ä¸€ä»¶äº‹ï¼š<br>
éå†éœ€è¦æ›´æ–°çš„ç»„ä»¶ï¼ˆdirty_componentsï¼‰ï¼Œç„¶åæ›´æ–°å®ƒï¼Œå¹¶ä¸”è°ƒç”¨afterUpdateæ–¹æ³•:<br>export function flush() {
  // Do not reenter flush while dirty components are updated, as this can
  // result in an infinite loop. Instead, let the inner flush handle it.
  // Reentrancy is ok afterwards for bindings etc.
  if (flushidx !== 0) {
    return;
  }

  const saved_component = current_component;

  do {
    // first, call beforeUpdate functions
    // and update components
    try {
        while (flushidx &lt; dirty_components.length) {
            const component = dirty_components[flushidx];
            flushidx++;
            set_current_component(component);
            update(component.$$);
        }
    } catch (e) {
        // reset dirty state to not end up in a deadlocked state and then rethrow
        dirty_components.length = 0;
        flushidx = 0;
        throw e;
    }

    set_current_component(null);

    dirty_components.length = 0;
    flushidx = 0;

    // then, once components are updated, call
    // afterUpdate functions. This may cause
    // subsequent updates...
    for (let i = 0; i &lt; render_callbacks.length; i += 1) {
        const callback = render_callbacks[i];

        if (!seen_callbacks.has(callback)) {
            // ...so guard against infinite loops
            seen_callbacks.add(callback);

            callback();
        }
    }

    render_callbacks.length = 0;
  } while (dirty_components.length);

  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }

  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
Copy<br>å†æ¥çœ‹çœ‹å…·ä½“çš„æ›´æ–°æ“ä½œupdateå‡½æ•°åšäº†å•¥<br>
<br>é¦–å…ˆæ‰§è¡Œæ‰€æœ‰çš„before_updateæ–¹æ³•
<br>ç„¶åæ‰§è¡Œcreate_fragmentè¿”å›çš„pï¼ˆupdateï¼‰æ–¹æ³•
<br>function update($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment &amp;&amp; $$.fragment.p($$.ctx, dirty);

        $$.after_update.forEach(add_render_callback);
    }
}
Copy<br>æ€»ç»“,åœ¨è¿è¡Œæ—¶:<br>
<br>åˆå§‹åŒ–çŠ¶æ€ã€åˆå§‹åŒ–å‘¨æœŸå‡½æ•°
<br>æ‰§è¡Œinstanceæ–¹æ³•ï¼Œåœ¨å›è°ƒå‡½æ•°ä¸­æ ‡è®°è„ç»„ä»¶
<br>æ‰§è¡Œæ‰€æœ‰beforeUpdateç”Ÿå‘½å‘¨æœŸçš„å‡½æ•°
<br>æ‰§è¡Œåˆ›å»ºç‰‡æ®µcreate_fragmentå‡½æ•°
<br>æŒ‚è½½å½“å‰ç»„ä»¶å¹¶æ‰§è¡Œcreate_fragementè¿”å›çš„mï¼ˆmountedï¼‰æ–¹æ³•
<br>æ‰§è¡Œflushæ–¹æ³•
<br>æ‰§è¡Œæ‰€æœ‰çš„before_updateæ–¹æ³•
<br>æ‰§è¡Œcreate_fragmentè¿”å›çš„pï¼ˆupdateï¼‰æ–¹æ³•
<br>æœ€åï¼Œæ‰§è¡ŒafterUpdateæ–¹æ³•
<br><br>
<br><a rel="noopener nofollow" class="external-link" href="https://github.com/sveltejs/svelte/blob/main/packages/svelte/src/compiler/index.js" target="_blank">https://github.com/sveltejs/svelte/blob/main/packages/svelte/src/compiler/index.js</a>
<br>/**
 * `compile` converts your `.svelte` source code into a JavaScript module that exports a component
 *
 * @param {string} source The component source code
 * @param {CompileOptions} options The compiler options
 * @returns {CompileResult}
 */
export function compile(source, options) {
	source = remove_bom(source);
	state.reset_warning_filter(options.warningFilter);
	const validated = validate_component_options(options, '');
	state.reset(source, validated);

	let parsed = _parse(source);

	const { customElement: customElementOptions, ...parsed_options } = parsed.options || {};

	/** @type {ValidatedCompileOptions} */
	const combined_options = {
		...validated,
		...parsed_options,
		customElementOptions
	};

	if (parsed.metadata.ts) {
		parsed = {
			...parsed,
			fragment: parsed.fragment &amp;&amp; remove_typescript_nodes(parsed.fragment),
			instance: parsed.instance &amp;&amp; remove_typescript_nodes(parsed.instance),
			module: parsed.module &amp;&amp; remove_typescript_nodes(parsed.module)
		};
	}

	const analysis = analyze_component(parsed, source, combined_options);
	const result = transform_component(analysis, source, combined_options);
	result.ast = to_public_ast(source, parsed, options.modernAst);
	return result;
}
Copy<br>ä»è¿™é‡Œçœ‹, Svelteçš„ç¼–è¯‘è¿‡ç¨‹å¯ä»¥åˆ†ä¸ºä¸‰ä¸ªä¸»è¦é˜¶æ®µï¼š<br>
<br>Parse&nbsp;è§£æ
<br>Analyze&nbsp;åˆ†æ
<br>Transform&nbsp;è½¬æ¢
<br> velte æ–‡ä»¶çš„ Scriptã€HTML å’Œ CSS ä»£ç è¢«åˆ†å¼€ä»¥å½¢æˆå•ä¸ªç»„ä»¶å¯¹è±¡:<br>
<img alt="Pasted image 20241115115009.png" src="https://muqiuhan.github.io/wiki/computer-science/web/svelte/svelte-æ ¸å¿ƒåŸç†/pasted-image-20241115115009.png"><br>
åœ¨Parseræ„é€ å‡½æ•°å†…éƒ¨ï¼Œ <a data-tooltip-position="top" aria-label="https://github.com/sveltejs/svelte/blob/main/packages/svelte/src/compiler/phases/1-parse/state/fragment.js" rel="noopener nofollow" class="external-link" href="https://github.com/sveltejs/svelte/blob/main/packages/svelte/src/compiler/phases/1-parse/state/fragment.js" target="_blank"><code></code></a>fragment å‡½æ•°ç”¨äºé€’å½’åœ°è§£æè‡ªèº«:<br>/** @param {Parser} parser */
export default function fragment(parser) {
	if (parser.match('&lt;')) {
		return element;
	}

	if (parser.match('{')) {
		return tag;
	}

	return text;
}
Copy<br>fragment æ ¹æ®æ¡ä»¶è¿”å› element tag text ç­‰å‡½æ•°, è¿™ä¸ªè¿”å›å€¼ä¼šè¢«è°ƒç”¨ä»¥ä»æºä»£ç ä¸­æå–ä¿¡æ¯ã€‚<br>åŒ…å«åœ¨scriptæ ‡ç­¾ä¸­çš„åŒºåŸŸé€šè¿‡<a data-tooltip-position="top" aria-label="https://github.com/sveltejs/svelte/blob/main/packages/svelte/src/compiler/phases/1-parse/read/script.js" rel="noopener nofollow" class="external-link" href="https://github.com/sveltejs/svelte/blob/main/packages/svelte/src/compiler/phases/1-parse/read/script.js" target="_blank"><code></code></a>read_scriptè¿›è¡Œè§£æ:<br>/**
 * @param {Parser} parser
 * @param {number} start
 * @param {Array&lt;AST.Attribute | AST.SpreadAttribute | Directive&gt;} attributes
 * @returns {AST.Script}
 */
export function read_script(parser, start, attributes) {
...
	const source =
		parser.template.slice(0, script_start).replace(regex_not_newline_characters, ' ') + data;
	parser.read(regex_starts_with_closing_script_tag);

	/** @type {Program} */
	let ast;

	try {
		ast = acorn.parse(source, parser.ts);
	} catch (err) {
		parser.acorn_error(err);
	}
...
}
Copy<br>å…¶ä»–åŒºåŸŸä½¿ç”¨ Svelte Compiler è‡ªå·±çš„è§£æé€»è¾‘ã€‚å½“é‡åˆ°styleæ ‡ç­¾æ—¶ï¼Œä¼šä½¿ç”¨<a data-tooltip-position="top" aria-label="https://github.com/sveltejs/svelte/blob/main/packages/svelte/src/compiler/phases/1-parse/read/style.js" rel="noopener nofollow" class="external-link" href="https://github.com/sveltejs/svelte/blob/main/packages/svelte/src/compiler/phases/1-parse/read/style.js" target="_blank"><code></code></a>read_style:<br>/**
 * @param {Parser} parser
 * @param {number} start
 * @param {Array&lt;AST.Attribute | AST.SpreadAttribute | Directive&gt;} attributes
 * @returns {Css.StyleSheet}
 */
export default function read_style(parser, start, attributes) {
	const content_start = parser.index;
	const children = read_body(parser, '&lt;/style');
	const content_end = parser.index;

	parser.read(/^&lt;\/style\s*&gt;/);

	return {
		type: 'StyleSheet',
		start,
		end: parser.index,
		attributes,
		children,
		content: {
			start: content_start,
			end: content_end,
			styles: parser.template.slice(content_start, content_end),
			comment: null
		}
	};
}
Copy<br>å…¶ä»–ç±»ä¼¼çš„ä¹Ÿéƒ½å’Œ read_style æ”¾åœ¨ä¸€èµ·.<br>æœ€ç»ˆä¼šç”Ÿæˆä¸€ä¸ªè¿™æ ·çš„ JSON:<br>{
  html: { type, start, end, children }
  css: { type, start, end, attributes, children, content }
  instance: { type, start, end, context, content }
  module: { type, start, end, context, content }
}
Copy<br><br>ä»åˆ›å»ºçš„ AST ä¸­æå–ç”¨äºæ‰§è¡Œç»„ä»¶çš„å„ç§æ“ä½œçš„ä¿¡æ¯:<br>
<img alt="Pasted image 20241115115845.png" src="https://muqiuhan.github.io/wiki/computer-science/web/svelte/svelte-æ ¸å¿ƒåŸç†/pasted-image-20241115115845.png"><br>å‚è€ƒ<a data-tooltip-position="top" aria-label="https://github.com/sveltejs/svelte/blob/main/packages/svelte/src/compiler/phases/2-analyze/index.js#L398" rel="noopener nofollow" class="external-link" href="https://github.com/sveltejs/svelte/blob/main/packages/svelte/src/compiler/phases/2-analyze/index.js#L398" target="_blank">æºç </a>ï¼Œç»„ä»¶çš„ä¸»è¦å±æ€§å¯ä»¥æ€»ç»“å¦‚ä¸‹ï¼š<br>const analysis = {
root: scope_root,
module,
instance,
template,
stylesheet: new Stylesheet({...}),
// Various compile options
runes,
warnings,
reactive_statements: new Map(),
binding_groups: new Map(),
slot_names: new Set(),
...
};
Copy<br>ScopeRootæ˜¯ä¸€ä¸ªå……å½“ç»„ä»¶æœ€é«˜<a data-tooltip-position="top" aria-label="https://developer.mozilla.org/ko/docs/Glossary/Scope" rel="noopener nofollow" class="external-link" href="https://developer.mozilla.org/ko/docs/Glossary/Scope" target="_blank">ä½œç”¨åŸŸ</a>çš„å¯¹è±¡ã€‚åœ¨å†…éƒ¨ï¼Œå®ƒä½¿ç”¨Setæ•°æ®ç»“æ„æ¥ç¡®ä¿å˜é‡å’Œå‡½æ•°ç­‰æ ‡è¯†ç¬¦çš„å”¯ä¸€æ€§ã€‚<br>éå† instance script å’Œ module script çš„ AST æ¥è¯†åˆ«å˜é‡è¢«å¼•ç”¨çš„æ‰€æœ‰åŒºåŸŸï¼Œä»è€Œäº†è§£å˜é‡å¯èƒ½å‘ç”Ÿå˜åŒ–çš„æ‰€æœ‰æƒ…å†µã€‚åœ¨æ­¤è¿‡ç¨‹ä¸­ï¼Œå°†åˆ›å»º script çš„è¾ƒä½ä½œç”¨åŸŸï¼Œå¼•ç”¨ scope_root ä¸ºå˜é‡åˆ†é…å”¯ä¸€æ ‡è¯†ç¬¦.<br>instance script å’Œ module script çš„åŒºåˆ«æ˜¯:<br>
<br>module å®šä¹‰ç»„ä»¶ä¹‹é—´å…±äº«çš„çŠ¶æ€å’Œé€»è¾‘, å¯ä»¥ä½¿ç”¨<a data-tooltip-position="top" aria-label="https://learn.svelte.dev/tutorial/sharing-code" rel="noopener nofollow" class="external-link" href="https://learn.svelte.dev/tutorial/sharing-code" target="_blank"><code></code></a>&lt;script context="module"&gt;å£°æ˜, ä½†ä¸èƒ½åŒ…å« reactive çš„ä»£ç 
<br>instance å®šä¹‰ç»„ä»¶çš„å”¯ä¸€çŠ¶æ€å’Œé€»è¾‘.
<br>å…¶ä»–çš„åŸºæœ¬æ²¡å•¥è®²çš„, stylesheet ä¼šæ ¹æ®æ”¶é›†åˆ°çš„analysisä¿¡æ¯æ‰§è¡Œä¸€äº›ä¼˜åŒ–ä»»åŠ¡:<br>
<br>é‡å¤çš„å…¨å±€ CSS é€‰æ‹©å™¨å’Œç»„ä»¶èŒƒå›´å†…æœªä½¿ç”¨çš„é€‰æ‹©å™¨å°†è¢«åˆ é™¤ã€‚
<br>ç»„ä»¶èŒƒå›´å†…ä½¿ç”¨çš„ CSS é€‰æ‹©å™¨è¢«å“ˆå¸Œä¸º.svelte-xxxæ ¼å¼ï¼Œé˜²æ­¢ä¸åŒåé€‰æ‹©å™¨å‘ç”Ÿå†²çªã€‚
<br><br>æœ€åä¼šæ ¹æ®è·å¾—çš„analysisä¿¡æ¯ï¼Œå†æ¬¡éå† AST æ¥ä¼˜åŒ–ç»„ä»¶çŠ¶æ€:<br>walk(
  /** @type {import('#compiler').SvelteNode} \*/ (ast),
  /** @type {import('./types').AnalysisState} \*/ (state),
  merge(
    set_scope(scopes),
    validation_runes,
    runes_scope_tweaker,
    common_visitors,
  ),
);
Copy<br>
<br>validation_runes æ£€æŸ¥ä¸æ­£ç¡®çš„èµ‹å€¼æˆ–æ›´æ–°è¡¨è¾¾å¼, éªŒè¯å˜é‡çš„å£°æ˜å’Œå¯¼å‡ºå¹¶æ£€æŸ¥æ–°çš„reactiveè¯­æ³•runesçš„æœ‰æ•ˆæ€§ã€‚
<br>runes_scope_tweaker è°ƒæ•´ä½œç”¨åŸŸ, è®¾ç½®ä½¿ç”¨ç‰¹å®šæ¨¡å¼çš„å˜é‡å£°æ˜çš„ä½œç”¨åŸŸå’Œç»‘å®šç±»å‹, å¹¶å°†å˜é‡æˆ–å‡½æ•°ç§»åŠ¨åˆ°å®ä¾‹ä¹‹å¤–è€Œä¸æ”¹å˜çŠ¶æ€ã€‚
<br>common_visitors å¤„ç†directiveå’Œbindingç›¸å…³æŒ‡ä»¤å’Œä¸€èˆ¬ HTML æˆ– Svelte ç‰¹å®šå…ƒç´ , å¹¶å¤„ç†ä¸äº‹ä»¶ç›¸å…³çš„å±æ€§å¹¶ç¡®å®šæ˜¯å¦éœ€è¦äº‹ä»¶å§”æ‰˜æˆ–æå‡ã€‚
<br><br>æœ€åï¼ŒSvelteç¼–è¯‘å™¨ç»è¿‡ä¸€ä¸ªè½¬æ¢è¿‡ç¨‹æ¥ç”Ÿæˆæ¸²æŸ“ä»£ç ã€‚<br><img alt="Pasted image 20241115120819.png" src="https://muqiuhan.github.io/wiki/computer-science/web/svelte/svelte-æ ¸å¿ƒåŸç†/pasted-image-20241115120819.png"><br>åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼ŒSSRï¼ˆæœåŠ¡å™¨ç«¯æ¸²æŸ“ï¼‰å’Œ CSRï¼ˆå®¢æˆ·ç«¯æ¸²æŸ“ï¼‰çš„ä»£ç ç”Ÿæˆé€»è¾‘æ˜¯ä¸åŒçš„ã€‚ç¼–è¯‘å™¨ä½¿ç”¨ä¸¤ä¸ªå‡½æ•°server_componentå’Œclient_componentæ¥åˆ›å»ºé’ˆå¯¹æ¯ç§åœºæ™¯ä¼˜åŒ–çš„ä»£ç , å°±åƒè¿™æ ·:<br>const program =
  options.generate === 'server'
    ? server_component(analysis, options)
    : client_component(source, analysis, options);

Copy<br>åœ¨ SSR ä¸­ï¼Œç»„ä»¶ä»…æ¸²æŸ“ä¸€æ¬¡ï¼Œå¹¶ä¸”ç»„ä»¶æ²¡æœ‰ç”Ÿå‘½å‘¨æœŸã€‚<br>
å› æ­¤ï¼Œ server_componentä¸“æ³¨äºåˆ›å»º<a data-tooltip-position="top" aria-label="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" rel="noopener nofollow" class="external-link" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" target="_blank"><code></code></a>template literals ã€‚å®ƒä½¿ç”¨javascript_visitorså’Œtemplate_visitorsç­‰è®¿é—®è€…æ·»åŠ ä»£ç å—ã€‚<br>åœ¨ CSR ä¸­ï¼Œéœ€è¦ä¸ DOM ä¸æ–­äº¤äº’ï¼Œå¹¶ä¸”ç»„ä»¶éœ€è¦æœ‰ç”Ÿå‘½å‘¨æœŸã€‚<br>
å› æ­¤ï¼Œ client_componentç”±æ›´åŠ å¤šæ ·åŒ–å’Œå¤æ‚çš„è®¿é—®è€…ç»„æˆã€‚å³ä½¿ç›¸åŒçš„javascript_visitorsä¹ŸåŒ…å«éå†è¿‡ç¨‹ä¸­å‡½æ•°çš„é™„åŠ å¤„ç†é€»è¾‘ã€‚<br><br>
<br><a data-tooltip-position="top" aria-label="https://svelte.dev/docs/svelte-compiler" rel="noopener nofollow" class="external-link" href="https://svelte.dev/docs/svelte-compiler" target="_blank">svelte/compiler</a>
<br><a data-tooltip-position="top" aria-label="https://blog.kalan.dev/en/series/svelte-series/1" rel="noopener nofollow" class="external-link" href="https://blog.kalan.dev/en/series/svelte-series/1" target="_blank">Svelte â€” What made me meet you like this</a>
<br><a data-tooltip-position="top" aria-label="https://juejin.cn/post/7235628080219078693" rel="noopener nofollow" class="external-link" href="https://juejin.cn/post/7235628080219078693" target="_blank">ğŸš€SvelteåŸç†å’Œè¿›é˜¶çœ‹è¿™ç¯‡å°±å¤Ÿäº†ğŸš€</a>
<br><a data-tooltip-position="top" aria-label="https://bepyan.me/en/post/svelte-compiler-operation" rel="noopener nofollow" class="external-link" href="https://bepyan.me/en/post/svelte-compiler-operation" target="_blank">How Does the Svelte Compiler Work?</a>
<br><a data-tooltip-position="top" aria-label="https://juejin.cn/post/7185433911437033531" rel="noopener nofollow" class="external-link" href="https://juejin.cn/post/7185433911437033531" target="_blank">ä¸€æ–‡è®²é€å‰ç«¯æ–°ç§€ svelte</a>
]]></description><link>https://muqiuhan.github.io/wiki/computer-science/web/svelte/svelte-æ ¸å¿ƒåŸç†/svelte-çš„ç¼–è¯‘å™¨å’Œè¿è¡Œæ—¶.html</link><guid isPermaLink="false">Computer Science/Web/Svelte/Svelte æ ¸å¿ƒåŸç†/Svelte çš„ç¼–è¯‘å™¨å’Œè¿è¡Œæ—¶.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Fri, 15 Nov 2024 04:38:21 GMT</pubDate><enclosure url="https://muqiuhan.github.io/wiki/computer-science/web/svelte/svelte-æ ¸å¿ƒåŸç†/pasted-image-20241115111951.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://muqiuhan.github.io/wiki/computer-science/web/svelte/svelte-æ ¸å¿ƒåŸç†/pasted-image-20241115111951.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Intro to Databases (for people who donâ€™t know a whole lot about them)]]></title><description><![CDATA[ 
 <br>I was a CS major from an Ivy League university whoâ€™s now a software developer at <a data-tooltip-position="top" aria-label="https://www.brandverity.com/" rel="noopener" class="external-link" href="https://www.brandverity.com/" target="_blank">an awesome company</a> â€” and I donâ€™t know much about databases.<br>Iâ€™m guessing Iâ€™m not the only one. It didnâ€™t seem to be a beginner-friendly subject. The specific class wasnâ€™t required. Any time storage systems were mentioned, they were on a higher level, very theoretical. There seems to be a common issue around CS graduates knowing very little about real-world software development (source control? deployment? huh?), and itâ€™s up to us to figure most of this stuff out after the fact.<br>But Iâ€™m embracing my lack of knowledge on the subject, and blogging is a cool thing. Hereâ€™s hoping for some clarity of thought via writing.<br><br>Besides the fact that it wasnâ€™t super accessible or approachable in college, itâ€™s probably also taken me so long to do any self-learning here because it just seemed so intimidating and mysterious (but this might just be me). I switched from design to CS two years into college with no prior experience, and I was grasping at things that were readily available and that piqued my interest. For whatever reason, databases seemed like a thing that more experienced or â€œsmarterâ€ people were into. â€œBackend workâ€ was something I veered away from, and the word â€œdatabaseâ€ conjured images of highly technical, complicated systems with jargon I just wouldnâ€™t understand. It was much easier to pretend it was ~magic~ and leave it for others to figure out (for now â€” it was always my intention to pick it all up eventually).<br><img src="https://miro.medium.com/v2/resize:fit:998/1*66lYXVFX3rJxRu-8Ze3meg.gif" referrerpolicy="no-referrer"><br>Basically how I viewed data storage and retrieval.<br><br>Google defines database as â€œa structured set of data held in a computer, especially one that is accessible in various ways.â€ At its most basic, a database is just a way of storing and organizing information. Ideally it is organized in such a way that it can be easily accessed, managed, and updated.<br>I like metaphors, so this simple definition of a database for me is like a toolbox. Youâ€™ve got lots of screws, nails, bits, a couple different hammersâ€¦ A toolbox is a storage system that allows you to easily organize and access all of these things. Whenever you need a tool, you go to the toolbox. Maybe you have labels on the drawers â€” those will help you find, say, a cordless power drill. But now you need the right battery for the drill. You look in your â€œbatteryâ€ drawer, but how do you find the one that fits this particular drill? You can run through all of your batteries using trial and error, but that seems inefficient. You think, â€˜Maybe I should store my batteries with their respective drills, link them in some way.â€™ That might be a viable solution. But if you need all of your batteries (because youâ€™re setting up a nice new charging station maybe?), will you have to access each of your drills to get them? Maybe one battery fits multiple drills? Also, toolboxes are great for storing disjointed tools and pieces, but you wouldnâ€™t want to have to take your car apart and store every piece separately whenever you park it in the garage. In that case, you would want to store your car as a single entry in the database (ahem garage), and access its pieces through it.<br><img src="https://miro.medium.com/v2/resize:fit:1180/1*Xfxl8HoQqqg_KtpEsEcskw.jpeg" referrerpolicy="no-referrer"><br>At least I can easily find the alternator this way, right?<br>This example is contrived, but reveals some issues youâ€™ll have to consider when choosing a database or how to store your data within it.<br><br>If you start directionlessly googling â€œdatabasesâ€ (like I did), youâ€™ll soon realize there are several different types and lots of terminology surrounding them. So letâ€™s try and clear up any potential language barriers.<br>While Iâ€™m sure someone has written books on each of these (some of which I should probably read), Iâ€™ll try to keep my definitions relatively simple. These were all terms that I came across while doing this research that I thought could use some quick explanation.<br>
<br>Query  

<br>A query is a single action taken on a database, a request presented in a predefined format. This is typically one of SELECT, INSERT, UPDATE, or DELETE.  
<br>We also use â€˜queryâ€™ to describe a request from a user for information from a database. â€œHey toolbox, could you get me the names of all the tools in the â€˜wrenchesâ€™ drawer?â€ might look something like SELECT ToolName FROM Wrenches.


<br>Transaction<br>
A transaction is a sequence of operations (queries) that make up a single unit of work performed against a database. For example, Rob paying George $20 is a transaction that consists of two UPDATE operations; reducing Robâ€™s balance by $20 and increasing Georgeâ€™s.
<br>ACID: Atomicity, Consistency, Isolation, Durability<br>
In most popular databases, a transaction is only qualified as a transaction if it exhibits the four â€œACIDâ€ properties:<br>
- Atomicity: Each transaction is a unique, atomic unit of work. If one operation fails, data remains unchanged. Itâ€™s all or nothing. Rob will never lose $20 without George being paid.  

<br>Consistency: All data written to the database is subject to any rules defined. When completed, a transaction must leave all data in a consistent state.  
<br>Isolation: Changes made in a transaction are not visible to other transactions until they are complete.  
<br>Durability: Changes completed by a transaction are stored and available in the database, even in the event of a system failure.


<br>Schema<br>
- A database schema is the skeleton or structure of a database; a logical blueprint of how the database is constructed and how things relate to each other (with tables/relations, indices, etc).  

<br>Some schemas are static (defined before a program is written), and some are dynamic (defined by the program or data itself).


<br>DBMS: database management system<br>
<a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Database" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Database" target="_blank">Wikipedia</a> has a great summary: â€œA database management system is a software application that interacts with the user, other applications, and the database itself to capture and analyze data. A general-purpose DBMS is designed to allow the definition, creation, querying, update, and administration of databases.â€ MySQL, PostgreSQL, Oracle â€” these are database management systems.
<br>Middleware<br>
Database-oriented middleware is â€œall the software that connects some application to some database.â€ Some definitions include the DBMS under this category. Middleware might also facilitate access to a DBMS via a web server for example, without having to worry about database-specific characteristics.
<br>Distributed vs Centralized Databases  

<br>As their names imply, a centralized database has only one database file, kept at a single location on a given network; a distributed database is composed of multiple database files stored in multiple physical locations, all controlled by a central DBMS.  
<br>Distributed databases are more complex, and require additional work to keep the data stored up-to-date and to avoid redundancy. However, they provide parallelization (which balances the load between several servers), preventing bottlenecking when a large number of requests come through.  
<br>Centralized databases make data integrity easier to maintain; once data is stored, outdated or inaccurate data (stale data) is no longer available in other places. However, it may be more difficult to retrieve lost or overwritten data in a centralized database, since it lacks easily accessible copies by nature.


<br>Scalability<br>
Scalability is the capability of a database to handle a growing amount of data. There are two types of scalability:  

<br>Vertical scalability is simply adding more capacity to a single machine. Virtually every database is vertically scalable.  
<br>Horizontal scalability refers to adding capacity by adding more machines. The DBMS needs to be able to partition, manage, and maintain data across all machines.


<br><img src="https://miro.medium.com/v2/resize:fit:1400/1*pWp5uSIjn0TgU9pnJe9MzA.png" referrerpolicy="no-referrer"><br>Vertical vs Horizontal Scaling. Little buckets donâ€™t need as much brawn to carry, but they do require better coordination.<br><br>
<br>â€œrelationalâ€  

<br>I highly recommend <a data-tooltip-position="top" aria-label="https://medium.com/@pocztarski/what-if-i-told-you-there-are-no-tables-in-relational-databases-13d31a2f9677#.gtwav0tad" rel="noopener" class="external-link" href="https://medium.com/@pocztarski/what-if-i-told-you-there-are-no-tables-in-relational-databases-13d31a2f9677#.gtwav0tad" target="_blank">this article</a>, which explains, â€œThe word â€˜relationalâ€™ in a â€˜relational databaseâ€™ has nothing to do with relationships. Itâ€™s about relations from relational algebra.â€  
<br>In a relational database, each relation is a set of tuples. Each tuple is a list of attributes, which represents a single item in the database. Each tuple (â€œrowâ€) in a relation (â€œtableâ€) shares the same attributes (â€œcolumnsâ€). Each attribute has a well-defined data type (int, string, etc), defined ahead of time â€” schema in a relational database is static.  
<br>Examples include: Oracle, MySQL, SQLite, PostgreSQL


<br><img src="https://miro.medium.com/v2/resize:fit:700/1*ko1siDrIKwAdrEA1P5o--g.png" referrerpolicy="no-referrer"><br>Thanks, <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Relational_database#Terminology" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Relational_database#Terminology" target="_blank">Wikipedia</a>.<br>
<br>SQL: Structured Query Language<br>
SQL is a programming language based on relational algebra used to manipulate and retrieve data in a relational database. note: In the bullet above, Iâ€™m intentionally separating the relational database terminology (relation, tuple, attribute) from the SQL terminology (table, row, column) in order to provide some clarity and accuracy. Again, see <a data-tooltip-position="top" aria-label="https://medium.com/@pocztarski/what-if-i-told-you-there-are-no-tables-in-relational-databases-13d31a2f9677#.gtwav0tad" rel="noopener" class="external-link" href="https://medium.com/@pocztarski/what-if-i-told-you-there-are-no-tables-in-relational-databases-13d31a2f9677#.gtwav0tad" target="_blank">this post</a> for more details on this.
<br>Illustrative Example:<br>
We could store all the data behind a blog in a relational database. One relation will represent our blog posts, each of which will have â€˜post_titleâ€™ and â€˜post_contentâ€™ attributes as well as a unique â€˜post_idâ€™ (a primary key). Another relation might store all of the comments on a blog. Each item here will also have attributes like â€˜comment_authorâ€™, â€˜comment_contentâ€™, and â€˜comment_idâ€™ (again, a primary key), as well as its own â€˜post_id.â€™ This attribute is a foreign key, and tells us which blog post each comment â€œrelatesâ€ to. When we want to open a webpage for post #2 for example, we might say to the database: â€œselect everything from the â€˜postsâ€™ table where the ID of the post is 2,â€ and then â€œselect everything from the comments table where the â€˜post_idâ€™ is 2.â€
<br>JOIN operations<br>
- A JOIN operation combines rows from multiple tables in one query. There are a few different types of joins and reasons for using them, but t<a data-tooltip-position="top" aria-label="http://www.sql-join.com/" rel="noopener" class="external-link" href="http://www.sql-join.com/" target="_blank">his page</a> provides good explanations and examples.<br>
- These operations are typically only used with relational databases and so are mentioned often when characterizing â€œrelationalâ€ functionality.
<br>**Normalization and Denormalization  

<br>Normalization** is the process of organizing the relations and attributes of a relational database in a way that reduces redundancy and improves data integrity (accurate, consistent, up-to-date data). Data might be arranged based on dependencies between attributes, for example â€” we might prevent repeating information by using JOIN operations.  
<br>Denormalization then, is the process of adding redundant data in order to speed up complex queries. We might include the data from one table in another to eliminate the second table and reduce the number of JOIN operations.


<br>ORM: Object-Relational Mapping<br>
ORM is a technique for translating the logical representation of objects (as in object-oriented programming) into a more atomized form that is capable of being stored in a relational database (and back again when they are retrieved). I wonâ€™t go into more detail here, but itâ€™s good to know it exists.
<br><br>
<br>â€œnon-relationalâ€<br>
At itâ€™s simplest, a non-relational database is one that doesnâ€™t use the relational model; no relations (tables) with tuples (rows) and attributes (columns). This title covers a pretty wide range of models, typically grouped into four categories: key-value stores, graph stores, column stores, and document stores.
<br><img src="https://miro.medium.com/v2/resize:fit:1280/1*Pq8DSf6o1z2N-Qc30yAoPA.jpeg" referrerpolicy="no-referrer"><br>No tables.<br>
<br>Illustrative Example:  

<br>When we set up our blog posts and comments in a relational database, it worked in the same way as the drawers of our toolbox. But, much like our drill and battery example, does it make sense to always store our blog posts in one place, and comments in another? Theyâ€™re clearly related, and itâ€™s probably rare that weâ€™d want to look at a postâ€™s comments without also wanting the post itself. If we used a non-relational database, opening a webpage for post #2 might look something like this: â€œselect post #2 and everything related to it.â€ In this case, that would mean a â€˜titleâ€™ and â€˜contentâ€™, as well as a list of comments. And since weâ€™re no longer constrained by rows always sharing the same columns, we can associate any arbitrary data with any blog posts as well â€” maybe some have tags, others images, or as your blog grows, youâ€™d like some of your new posts to link to live Twitter streams. With the non-relational model, we donâ€™t need to know ahead of time that all of our blog posts have the same attributes, and as we add attributes to newer items, we are not required to also add that â€œcolumnâ€ to all previous items as well.  
<br>This model also works well for the car example from earlier in this post. If you have three cars in your garage, it doesnâ€™t make sense to store all of their tires together, seats together, radiators togetherâ€¦ Instead, you store an entire car and everything related to it in its own â€œdocument.â€  
<br>However, there may be a downside to this. If you wanted to know how many seats (or comments, or batteries) you have total, you may have to go through every car and count each seat individually. There are ways around this of course, but itâ€™s less trivial than just opening up the â€œseatsâ€ drawer and checking your total, especially on much larger scales.


<br>NoSQL<br>
â€œNoSQLâ€ originally referred to â€œnon-SQLâ€ or â€œnon-relationalâ€ when describing a database. Sometimes â€œNoSQLâ€ is also meant to mean â€œNot only SQLâ€, to emphasize that they donâ€™t prohibit SQL or SQL-like query languages; they just avoid functionality like relation/table schemas and JOIN operations.
<br>Key-Value Store  

<br>Key-value stores donâ€™t use the pre-defined structure of relational databases, but instead treat all of their data as a single collection of items. For example, a screwdriver in our toolbox might have attributes like â€œdrive_typeâ€, â€œlengthâ€, and â€œsizeâ€, but a hammer may only have one attribute: â€œsizeâ€. Instead of storing (often empty) â€œdrive_typeâ€ and â€œlengthâ€ fields for every item in your toolbox, a â€œhammer_01â€ key will return only the information relevant to it.  
<br>Success with this model lies in its simplicity. Like a map or a dictionary, each key-value pair defines a link between some unique â€œkeyâ€ (like a name, ID, or URL) and its â€œvalueâ€ (an image, a file, a string, int, list, etc). There are no fields, so the entire value must be updated if changes are made. Key-value stores are generally fast, scalable, and flexible.  
<br>Examples include: Dynamo, MemcacheDB, Redis


<br>Graph Store  

<br>Graph stores are a little more complicated.Using graph structures, this type of database is made for dealing with interconnected data â€” think social media connections, a family tree, or a food chain. Items in the database are represented by â€œnodesâ€, and â€œedgesâ€ directly represent the relationships between them. Both nodes and edges can store additional â€œpropertiesâ€: id, name, type, etc.


<br><img src="https://miro.medium.com/v2/resize:fit:1232/1*pK3tfUnVRfdCeUtS76ixAQ.png" referrerpolicy="no-referrer"><br>Something <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Graph_database#Description" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Graph_database#Description" target="_blank">like this</a>.<br>
<br>
The strength of a graph database is in traversing the connections between items, but their scalability is limited.  

<br>
Examples include: Allegro, OrientDB, Virtuoso

<br>
Column Store  

<br>Row-oriented databases describe single items as rows, and store all the data in a particular tableâ€™s rows together: â€˜hammer_01â€™, â€˜mediumâ€™, â€˜blueâ€™; â€˜hammer_02â€™, â€˜largeâ€™, â€˜yellowâ€™. A column store, on the other hand, generally stores all the values of a particular column together: â€˜hammer_01â€™, â€˜hammer_02â€™; â€˜mediumâ€™, â€˜largeâ€™; â€˜blueâ€™, â€˜yellowâ€™.  
<br>This can definitely get confusing, but the two map data very differently. In a row-oriented system, the primary key is the row ID, mapped to its data. In the column-oriented system, the primary key is the data, mapping back to row IDs. This allows for some very quick aggregations like totals and averages.  
<br>Examples include: Accumulo, Cassandra, HBase


<br>
Document Store  

<br>Document stores treat all information for a given item in the database as a single instance in the database (each of which can have its own structure and attributes, like other non-relational databases). These â€œdocumentsâ€ can generally be thought of as sets of key-value pairs: {ToolName: â€œhammer_01â€, Size: â€œmediumâ€, Color: â€œblueâ€}  
<br>Documents can be independent units, which makes performance and horizontal scalability better, and unstructured data can be stored easily.  
<br>Examples include: Apache CouchDB, MongoDB, Azure DocumentDB.


<br>
Object or Object-Oriented Database<br>
Not as common as other non-relational databases, an object or object-oriented database is ones in which data is represented in the form of â€œobjectsâ€ (with attributes and methods) as used in object-oriented programming. This type might be used in place of a relational database and ORM, and may make sense when the data is complex or there are complex many-to-many relationships involved. Beware its language dependence and difficulty with ad-hoc queries though.

<br><br>Now that we know some stuff about databases, how can we apply that knowledge? How do you compare/test/benchmark different databases? What does it look like when theyâ€™re actually implemented, or when you have many working together?<br>All of this and more coming soon in blog post dos.]]></description><link>https://muqiuhan.github.io/wiki/computer-science/database/intro-to-databases-(for-people-who-donâ€™t-know-a-whole-lot-about-them).html</link><guid isPermaLink="false">Computer Science/Database/Intro to Databases (for people who donâ€™t know a whole lot about them).md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Fri, 10 May 2024 09:55:39 GMT</pubDate><enclosure url="https://miro.medium.com/v2/resize:fit:998/1*66lYXVFX3rJxRu-8Ze3meg.gif" length="0" type="image/gif"/><content:encoded>&lt;figure&gt;&lt;img src="https://miro.medium.com/v2/resize:fit:998/1*66lYXVFX3rJxRu-8Ze3meg.gif"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Introduction to Actors]]></title><description><![CDATA[ 
 <br>Actor æ¨¡å‹ä¸ºç¼–å†™å¹¶å‘å’Œåˆ†å¸ƒå¼ç³»ç»Ÿæä¾›äº†æ›´é«˜çº§åˆ«çš„æŠ½è±¡ã€‚å®ƒä½¿å¼€å‘äººå‘˜ä¸å¿…æ˜¾å¼ç®¡ç†çº¿ç¨‹ï¼ˆä¾‹å¦‚åŠ é”ï¼‰ï¼Œä»è€Œæ›´å®¹æ˜“ç¼–å†™æ­£ç¡®çš„å¹¶å‘å’Œå¹¶è¡Œç³»ç»Ÿã€‚<br>é¦–å…ˆä»ä¸€ä¸ªç®€å•çš„ä¾‹å­å¼€å§‹:<br>```scala3
Copy<br>object HelloWorld:<br>
final case class Greet(whom: String, replyTo: ActorRef[Greeted])<br>
final case class Greeted(whom: String, from: ActorRef[Greet])<br>def apply(): Behavior[Greet] =
    Behaviors.receive { (context, message) =&gt;
        context.log.info("Hello {}!", message.whom)
        message.replyTo ! Greeted(message.whom, context.self)
        Behaviors.same
    }
end apply
Copy<br>end HelloWorld<br>

Copy]]></description><link>https://muqiuhan.github.io/wiki/computer-science/distributed-system/akka/introduction-to-actors/introduction-to-actors.html</link><guid isPermaLink="false">Computer Science/Distributed System/akka/Introduction to Actors/Introduction to Actors.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Tue, 14 May 2024 14:35:01 GMT</pubDate></item><item><title><![CDATA[In Search of an Understandable Consensus Algorithm(Extended Version)]]></title><description><![CDATA[ 
 <br>å¯»æ‰¾ä¸€ç§å¯ç†è§£çš„ä¸€è‡´æ€§ç®—æ³•(æ‹“å±•ç‰ˆ)<br><br><br>Raft is a consensus algorithm for managing a replicated log.<br>
It produces a result equivalent to (multi-)Paxos, and it is as efficient as Paxos, but its structure is different from Paxos;<br>
this makes Raft more understandable than Paxos and also provides a better foundation for building practical systems.<br>
In order to enhance understandability, Raft separates the key elements of consensus,<br>
such as leader election, log replication, and safety,<br>
and it enforces a stronger degree of coherency to reduce the number of states that must be considered.<br>
Results from a user study demonstrate that Raft is easier for students to learn than Paxos.<br>
Raft also includes a new mechanism for changing the cluster membership, which uses overlapping majorities to guarantee safety.<br>Raftæ˜¯ä¸€ç§ç”¨äºç®¡ç†å¤åˆ¶æ—¥å¿—çš„ä¸€è‡´æ€§ç®—æ³•ã€‚<br>
å…¶å’Œ(multi-)Paxosç®—æ³•ä½œç”¨ç›¸åŒï¼Œå¹¶ä¸”å’ŒPaxosä¸€æ ·é«˜æ•ˆï¼Œä½†å…¶ç»“æ„ä¸Paxosä¸åŒï¼›è¿™ä½¿å¾—Raftæ¯”èµ·Paxosæ›´å®¹æ˜“ç†è§£åŒæ—¶ä¹Ÿä¸ºæ„å»ºå®é™…å¯è¡Œçš„ç³»ç»Ÿæä¾›äº†ä¸€ä¸ªæ›´å¥½çš„åŸºç¡€ã€‚<br>
ä¸ºäº†è®©Raftæ›´å®¹æ˜“ç†è§£ï¼ŒRaftæ‹†åˆ†äº†æœ‰å…³ä¸€è‡´æ€§çš„å…³é”®å…ƒç´ ï¼Œä¾‹å¦‚leaderé€‰ä¸¾ï¼Œæ—¥å¿—å¤åˆ¶ä»¥åŠå®‰å…¨æ€§ç­‰ï¼Œå¹¶é€šè¿‡å¢å¼ºä¸€è‡´æ€§çš„ç¨‹åº¦ä»¥å‡å°‘å¿…é¡»è¢«è€ƒè™‘çš„çŠ¶æ€æ•°é‡ã€‚<br>
ç”¨æˆ·çš„ç ”ç©¶æˆæœè¡¨ç¤ºRaftæ¯”èµ·Paxosè¦æ›´å®¹æ˜“è®©å­¦ç”Ÿè¿›è¡Œå­¦ä¹ ã€‚<br>
Raftè¿˜åŒ…å«äº†ä¸€ä¸ªæ”¹å˜é›†ç¾¤æˆå‘˜çš„æ–°æœºåˆ¶ï¼Œå…¶ä½¿ç”¨é‡å çš„å¤§å¤šæ•°(overlapping majorities)æ¥ä¿è¯å®‰å…¨ã€‚<br><br>Consensus algorithms allow a collection of machines to work as a coherent group that can survive the failures of some of its members.<br>
Because of this, they play a key role in building reliable large-scale software systems.<br>
Paxos has dominated the discussion of consensus algorithms over the last decade:<br>
most implementations of consensus are based on Paxos or influenced by it,<br>
and Paxos has become the primary vehicle used to teach students about consensus.<br>ä¸€è‡´æ€§ç®—æ³•å…è®¸ä¸€ä¸ªæœºå™¨çš„é›†ç¾¤ä½œä¸ºä¸€ä¸ªå…·æœ‰ä¸€è‡´æ€§çš„ç»„æ¥è¿›è¡Œå·¥ä½œï¼Œä½¿å¾—åœ¨ä¸€äº›æˆå‘˜å‡ºç°æ•…éšœæ—¶é›†ç¾¤ä¾ç„¶èƒ½æ­£å¸¸å·¥ä½œã€‚<br>
æ­£å› ä¸ºå¦‚æ­¤ï¼Œåœ¨æ„å»ºå¯é çš„å¤§è§„æ¨¡è½¯ä»¶ç³»ç»Ÿæ—¶å…¶èµ·åˆ°äº†å…³é”®çš„ä½œç”¨ã€‚<br>
Paxosä¸»å¯¼äº†è¿‡å»åå¹´ä¸­å…³äºä¸€è‡´æ€§ç®—æ³•çš„è®¨è®ºï¼š<br>
å¤§å¤šæ•°çš„ä¸€è‡´æ€§çš„å®ç°éƒ½ç»™äºˆPaxosæˆ–è€…å—å…¶å½±å“ï¼Œå¹¶ä¸”Paxosæˆä¸ºäº†æ•™å¯¼å­¦ç”Ÿä¸€è‡´æ€§ç›¸å…³çŸ¥è¯†çš„ä¸»è¦å·¥å…·ã€‚<br>Unfortunately, Paxos is quite difficult to understand, in spite of numerous attempts to make it more approachable.<br>
Furthermore, its architecture requires complex changes to support practical systems.<br>
As a result, both system builders and students struggle with Paxos.<br>ä¸å¹¸çš„æ˜¯ï¼ŒPaxosç›¸å½“éš¾ç†è§£ï¼Œå°½ç®¡å¾ˆå¤šäººè¯•å›¾è®©å…¶å˜å¾—æ›´æ˜“ç†è§£ã€‚<br>
æ­¤å¤–ï¼Œä¸ºäº†æ”¯æŒå®é™…çš„ç³»ç»Ÿå…¶æ¶æ„éœ€è¦è¿›è¡Œå¤æ‚çš„æ”¹å˜ã€‚<br>
å› æ­¤ï¼Œæ‰€æœ‰çš„ç³»ç»Ÿæ„å»ºè€…å’Œå­¦ç”Ÿéƒ½åœ¨äºPaxosè¿›è¡Œæ–—äº‰ã€‚<br>After struggling with Paxos ourselves,<br>
we set out to find a new consensus algorithm that could provide a better foundation for system building and education.<br>
Our approach was unusual in that our primary goal was understandability:<br>
could we define a consensus algorithm for practical systems and describe it in a way that is significantly easier to learn than Paxos?<br>
Furthermore, we wanted the algorithm to facilitate the development of intuitions that are essential for system builders.<br>
It was important not just for the algorithm to work, but for it to be obvious why it works.<br>åœ¨ä¸Paxosæ–—äº‰åï¼Œæˆ‘ä»¬å¼€å§‹ç€æ‰‹å»å¯»æ‰¾ä¸€ç§æ–°çš„ä¸€è‡´æ€§ç®—æ³•ï¼Œå…¶èƒ½å¤Ÿä¸ºæ„å»ºç³»ç»Ÿå’Œæ•™è‚²æä¾›æ›´å¥½çš„æ”¯æŒã€‚<br>
æˆ‘ä»¬çš„æ–¹æ³•æ˜¯ä¸åŒå¯»å¸¸çš„ï¼Œå› ä¸ºæˆ‘ä»¬çš„ä¸»è¦ç›®æ ‡æ˜¯(å¢è¿›)å¯ç†è§£æ€§ï¼šæˆ‘ä»¬å¯ä»¥ä¸ºå®é™…çš„ç³»ç»Ÿå®šä¹‰ä¸€ä¸ªä¸€è‡´æ€§ç®—æ³•å¹¶ä»¥æ¯”Paxosæ›´å®¹æ˜“å­¦ä¹ çš„æ–¹å¼å»æè¿°å®ƒå—ï¼Ÿ<br>
æ­¤å¤–ï¼Œæˆ‘ä»¬å¸Œæœ›è¯¥ç®—æ³•èƒ½å¤Ÿä¿ƒè¿›ç›´è§‰çš„å‘å±•ï¼Œè¿™å¯¹ç³»ç»Ÿæ„å»ºè€…æ¥è¯´æ˜¯å¿…è¦çš„ã€‚<br>
é‡è¦çš„ä¸ä»…ä»…æ˜¯ç®—æ³•æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Œç†è§£ç®—æ³•ä¸ºä»€ä¹ˆèƒ½å·¥ä½œä¹Ÿå¾ˆé‡è¦ã€‚<br>The result of this work is a consensus algorithm called Raft.<br>
In designing Raft we applied specific techniques to improve understandability,<br>
including decomposition (Raft separates leader election, log replication, and safety)<br>
and state space reduction (relative to Paxos, Raft reduces the degree of nondeterminism and the ways servers can be inconsistent with each other).<br>
A user study with 43 students at two universities shows that Raft is significantly easier to understand than Paxos:<br>
after learning both algorithms, 33 of these students were able to answer questions about Raft better than questions about Paxos.<br>è¿™é¡¹å·¥ä½œçš„æˆæœæ˜¯ä¸€ä¸ªåä¸ºRaftçš„ä¸€è‡´æ€§ç®—æ³•ã€‚<br>
åœ¨è®¾è®¡Raftæ—¶ï¼Œæˆ‘ä»¬åº”ç”¨äº†ç‰¹åˆ«çš„æŠ€æœ¯æ¥æ”¹å–„å¯ç†è§£æ€§ï¼ŒåŒ…æ‹¬åˆ†è§£(Raftå°†leaderé€‰ä¸¾ï¼Œæ—¥å¿—å¤åˆ¶å’Œå®‰å…¨æ€§è¿›è¡Œäº†åˆ†è§£)<br>
ä»¥åŠçŠ¶æ€ç©ºé—´çš„ç¼©å‡(ç›¸å¯¹äºPaxosï¼ŒRaftç¼©å‡äº†ä¸ç¡®å®šæ€§çš„ç¨‹åº¦ä»¥åŠæœåŠ¡å™¨ä¹‹é—´å½¼æ­¤ä¸ä¸€è‡´çš„æ–¹å¼)ã€‚<br>
ä¸€é¡¹å¯¹ä¸¤æ‰€å¤§å­¦ä¸­çš„43åå­¦ç”Ÿçš„è°ƒæŸ¥æ˜¾ç¤ºRaftæ¯”Paxoså®¹æ˜“ç†è§£çš„å¤šï¼šåœ¨å­¦ä¹ äº†ä¸¤ç§ç®—æ³•åï¼Œç›¸æ¯”å›ç­”Paxosç›¸å…³é—®é¢˜ï¼Œå…¶ä¸­33åå­¦ç”Ÿèƒ½æ›´å¥½çš„å›ç­”å…³äºRaftçš„é—®é¢˜ã€‚<br>Raft is similar in many ways to existing consensus algorithms (most notably, Oki and Liskovâ€™s Viewstamped Replication),<br>
but it has several novel features:<br>
<br>Strong leader: Raft uses a stronger form of leadership than other consensus algorithms.<br>
For example, log entries only flow from the leader to other servers.<br>
This simplifies the management of the replicated log and makes Raft easier to understand.
<br>Leader election: Raft uses randomized timers to elect leaders.<br>
This adds only a small amount of mechanism to the heartbeats already required for any consensus algorithm,<br>
while resolving conflicts simply and rapidly.
<br>Membership changes: Raftâ€™s mechanism for changing the set of servers in the cluster uses a new joint consensus approach<br>
where the majorities of two different configurations overlap during transitions.<br>
This allows the cluster to continue operating normally during configuration changes.
<br>Raftä¸å·²æœ‰çš„ä¸€è‡´æ€§ç®—æ³•åœ¨å¾ˆå¤šæ–¹é¢éƒ½å¾ˆç›¸ä¼¼(å°¤å…¶æ˜¯Okiå’ŒLiskovçš„Viewstamped Replicationç®—æ³•)ï¼Œä½†Raftæœ‰å‡ ä¸ªæ–°é¢–çš„åŠŸèƒ½ï¼š<br>
<br>Strong leader: Raftä½¿ç”¨æ¯”å…¶å®ƒä¸€è‡´æ€§ç®—æ³•æ›´å¼ºåŠ›çš„leaderã€‚<br>
ä¸¾ä¸ªä¾‹å­ï¼Œæ—¥å¿—æ¡ç›®ä»…ä»leaderæµå‘å…¶å®ƒæœåŠ¡å™¨ã€‚è¿™ç®€åŒ–äº†è¢«å¤åˆ¶æ—¥å¿—çš„ç®¡ç†å¹¶ä¸”ä½¿å¾—Raftæ›´åŠ å®¹æ˜“è¢«ç†è§£ã€‚
<br>Leader election: Raftä½¿ç”¨éšæœºè®¡æ—¶å™¨æ¥é€‰ä¸¾leaderã€‚<br>
è¿™åªåœ¨ä»»ä½•ä¸€è‡´æ€§ç®—æ³•éƒ½éœ€è¦çš„å¿ƒè·³æ£€æµ‹ä¸­å¢åŠ äº†å°‘é‡æœºåˆ¶ï¼ŒåŒæ—¶ç®€å•ä¸”å¿«é€Ÿçš„è§£å†³å†²çªã€‚
<br>Membership changes: Raftç”¨äºæ”¹å˜é›†ç¾¤ä¸­æœåŠ¡å™¨é›†åˆçš„æœºåˆ¶ä½¿ç”¨äº†ä¸€ç§æ–°çš„è”åˆçš„ä¸€è‡´æ€§æ–¹æ³•ï¼Œå…¶ä¸­ä¸¤ä¸ªä¸åŒé…ç½®çš„å¤šæ•°åœ¨è¿‡æ¸¡æœŸé—´æ˜¯é‡å çš„ã€‚<br>
è¿™å…è®¸é›†ç¾¤åœ¨é…ç½®æ”¹å˜æ—¶ç»§ç»­æ­£å¸¸å·¥ä½œã€‚
<br>We believe that Raft is superior to Paxos and other consensus algorithms, both for educational purposes and as a foundation for implementation.<br>
It is simpler and more understandable than other algorithms;<br>
it is described completely enough to meet the needs of a practical system;<br>
it has several open-source implementations and is used by several companies;<br>
its safety properties have been formally specified and proven; and its efficiency is comparable to other algorithms.<br>æˆ‘ä»¬è®¤ä¸ºï¼Œæ— è®ºæ˜¯å¤„äºæ•™è‚²çš„ç›®çš„è¿˜æ˜¯ä½œä¸ºå®é™…(ç³»ç»Ÿ)çš„å®ç°ï¼ŒRaftéƒ½æ˜¯èƒœè¿‡Paxoså’Œå…¶å®ƒä¸€è‡´æ€§ç®—æ³•çš„ã€‚<br>
å®ƒæ¯”å…¶å®ƒç®—æ³•æ›´åŠ ç®€å•å’Œå®¹æ˜“ç†è§£ï¼›<br>
å®ƒè¢«è¯¦ç»†çš„æè¿°ä½¿å¾—å…¶è¶³ä»¥æ»¡è¶³å®é™…ç³»ç»Ÿçš„éœ€è¦ï¼›<br>
å®ƒæœ‰ç€å‡ ä¸ªå¼€æºçš„å®ç°å¹¶ä¸”è¢«å‡ å®¶å…¬å¸æ‰€ä½¿ç”¨ï¼›<br>
å®ƒçš„å®‰å…¨æ€§å·²ç»è¢«æ­£å¼çš„è®¤å®šå’Œè¯æ˜ï¼›å¹¶ä¸”å®ƒçš„æ•ˆç‡ä¸å…¶å®ƒç®—æ³•ç›¸å½“ã€‚<br>The remainder of the paper introduces the replicated state machine problem (Section 2),<br>
discusses the strengths and weaknesses of Paxos (Section 3),<br>
describes our general approach to understandability (Section 4),<br>
presents the Raft consensus algorithm (Sections 5â€“8),<br>
evaluates Raft (Section 9), and discusses related work (Section 10).<br>æœ¬æ–‡çš„å‰©ä½™éƒ¨åˆ†ä»‹ç»äº†å¤åˆ¶çŠ¶æ€æœºé—®é¢˜(ç¬¬2èŠ‚)ï¼Œ<br>
è®¨è®ºäº†Paxosçš„ä¼˜ç¼ºç‚¹(ç¬¬3èŠ‚)ï¼Œ<br>
æè¿°äº†æˆ‘ä»¬ä½¿ç®—æ³•æ˜“äºç†è§£çš„ä¸€èˆ¬æ€§æ–¹æ³•(ç¬¬4èŠ‚)ï¼Œ<br>
æå‡ºäº†Raftä¸€è‡´æ€§ç®—æ³•(ç¬¬5-8èŠ‚)ï¼Œ<br>
è¯„ä¼°äº†Raft(ç¬¬9èŠ‚)ï¼Œå¹¶ä¸”è®¨è®ºäº†ç›¸å…³çš„å·¥ä½œ(ç¬¬10èŠ‚)ã€‚<br><br>Consensus algorithms typically arise in the context of replicated state machines.<br>
In this approach, state machines on a collection of servers compute identical copies of the same state<br>
and can continue operating even if some of the servers are down.<br>
Replicated state machines are used to solve a variety of fault tolerance problems in distributed systems.<br>
For example, large-scale systems that have a single cluster leader, such as GFS, HDFS, and RAMCloud,<br>
typically use a separate replicated state machine to manage leader election and store configuration information<br>
that must survive leader crashes.<br>
Examples of replicated state machines include Chubby and ZooKeeper.<br>ä¸€è‡´æ€§ç®—æ³•æ˜¯åœ¨å¤åˆ¶çŠ¶æ€æœºçš„èƒŒæ™¯ä¸‹äº§ç”Ÿçš„ã€‚<br>
åœ¨è¿™ä¸ªæ–¹æ³•ä¸­ï¼ŒæœåŠ¡å™¨é›†åˆä¸­çš„çŠ¶æ€æœºåœ¨å…·æœ‰ç›¸åŒçŠ¶æ€çš„å®Œå…¨ä¸€è‡´çš„å‰¯æœ¬ä¸Šè¿›è¡Œè®¡ç®—ï¼Œå¹¶ä¸”å³ä½¿ä¸€äº›æœåŠ¡å™¨å·²ç»å®•æœºä¹Ÿèƒ½å¤ŸæŒç»­çš„å·¥ä½œã€‚<br>
å¤åˆ¶çŠ¶æ€æœºè¢«ç”¨äºåœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­è§£å†³ä¸€ç³»åˆ—çš„å®¹é”™é—®é¢˜ã€‚<br>
ä¸¾ä¸ªä¾‹å­ï¼Œæœ‰ç€ä¸€ä¸ªå•ç‹¬é›†ç¾¤leaderçš„å¤§è§„æ¨¡ç³»ç»Ÿï¼Œä¾‹å¦‚GFSï¼ŒHDFSä»¥åŠRAMCloudï¼Œé€šå¸¸ä½¿ç”¨ä¸€ä¸ªå•ç‹¬çš„å¤åˆ¶çŠ¶æ€æœºæ¥ç®¡ç†leaderé€‰ä¸¾å’Œå­˜å‚¨åœ¨leaderå´©æºƒåæ‰€å¿…é¡»çš„é…ç½®ä¿¡æ¯ã€‚<br>
å¤åˆ¶çŠ¶æ€æœºçš„ä¾‹å­åŒ…æ‹¬Chubbyå’ŒZooKeeperã€‚<br><img alt="Pasted image 20240725172940.png" src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raft-åŸå§‹è®ºæ–‡ä¸­è‹±/pasted-image-20240725172940.png"><br>Figure 1: Replicated state machine architecture.<br>
The consensus algorithm manages a replicated log containing state machine commands from clients.<br>
The state machines process identical sequences of commands from the logs, so they produce the same outputs.<br>å›¾1ï¼šå¤åˆ¶çŠ¶æ€æœºçš„æ¶æ„ã€‚<br>
ä¸€è‡´æ€§ç®—æ³•ç®¡ç†åŒ…å«äº†æ¥è‡ªå®¢æˆ·ç«¯çš„çŠ¶æ€æœºæŒ‡ä»¤çš„å¤åˆ¶æ—¥å¿—ã€‚<br>
çŠ¶æ€æœºä»¥å®Œå…¨ç›¸åŒçš„é¡ºåºå¤„ç†æ¥è‡ªæ—¥å¿—çš„æŒ‡ä»¤ï¼Œå› æ­¤å®ƒä»¬ä¼šäº§ç”Ÿç›¸åŒçš„è¾“å‡ºã€‚<br>Replicated state machines are typically implemented using a replicated log, as shown in Figure 1.<br>
Each server stores a log containing a series of commands, which its state machine executes in order.<br>
Each log contains the same commands in the same order, so each state machine processes the same sequence of commands.<br>
Since the state machines are deterministic, each computes the same state and the same sequence of outputs.<br>å¤åˆ¶çŠ¶æ€æœºé€šå¸¸ä½¿ç”¨å¤åˆ¶log(replicated log)æ¥å®ç°ï¼Œå¦‚å›¾1æ‰€ç¤ºã€‚<br>
æ¯ä¸ªæœåŠ¡å™¨å­˜å‚¨ç€ä¸€ä¸ªåŒ…å«ä¸€ç³»åˆ—æŒ‡ä»¤çš„æ—¥å¿—ï¼Œè¿™äº›æŒ‡ä»¤åœ¨çŠ¶æ€æœºä¸Šè¢«é¡ºåºæ‰§è¡Œã€‚<br>
æ¯ä¸ªæ—¥å¿—ä¸­åŒ…å«äº†ä»¥ç›¸åŒé¡ºåºæ’å¸ƒçš„ç›¸åŒçš„æŒ‡ä»¤ï¼Œå› æ­¤æ¯ä¸ªçŠ¶æ€æœºéƒ½å¤„ç†ç›¸åŒçš„æŒ‡ä»¤åºåˆ—ã€‚<br>
å› ä¸ºçŠ¶æ€æœºæ˜¯ç¡®å®šæ€§çš„ï¼Œæ¯ä¸€ä¸ªçŠ¶æ€æœºéƒ½è®¡ç®—å‡ºç›¸åŒçš„çŠ¶æ€ä»¥åŠæœ‰ç€ç›¸åŒçš„è¾“å‡ºåºåˆ—ã€‚<br>Keeping the replicated log consistent is the job of the consensus algorithm.<br>
The consensus module on a server receives commands from clients and adds them to its log.<br>
It communicates with the consensus modules on other servers to ensure that every log eventually contains<br>
the same requests in the same order, even if some servers fail.<br>
Once commands are properly replicated, each serverâ€™s state machine processes them in log order,<br>
and the outputs are returned to clients.<br>
As a result, the servers appear to form a single, highly reliable state machine.<br>ä¿æŒå¤åˆ¶æ—¥å¿—çš„ä¸€è‡´æ€§æ˜¯ä¸€è‡´æ€§ç®—æ³•çš„å·¥ä½œã€‚<br>
æœåŠ¡å™¨ä¸­çš„ä¸€è‡´æ€§æ¨¡å—æ¥å—æ¥è‡ªå®¢æˆ·ç«¯çš„æŒ‡ä»¤å¹¶ä¸”å°†å…¶åŠ å…¥æ—¥å¿—ã€‚<br>
å®ƒä¸å…¶å®ƒæœåŠ¡å™¨çš„ä¸€è‡´æ€§æ¨¡å—è¿›è¡Œé€šä¿¡ä»¥ç¡®ä¿æ¯ä¸€ä¸ªæ—¥å¿—æœ€ç»ˆä»¥åŒæ ·çš„é¡ºåºåŒ…å«åŒæ ·çš„è¯·æ±‚ï¼Œå³ä½¿å…¶ä¸­ä¸€äº›æœåŠ¡å™¨æ•…éšœäº†ã€‚<br>
ä¸€æ—¦æŒ‡ä»¤è¢«æ­£ç¡®çš„å¤åˆ¶ï¼Œæ¯ä¸€ä¸ªæœåŠ¡å™¨çš„çŠ¶æ€æœºéƒ½æŒ‰ç…§æ—¥å¿—ä¸­çš„é¡ºåºå¤„ç†è¿™äº›æŒ‡ä»¤ï¼Œå¹¶å°†è¾“å‡ºè¿”å›ç»™å®¢æˆ·ç«¯ã€‚<br>
å› æ­¤ï¼ŒæœåŠ¡å™¨çš„é›†åˆä¼¼ä¹å½¢æˆäº†ä¸€ä¸ªå•ç‹¬çš„ï¼Œé«˜åº¦å¯é çš„çŠ¶æ€æœºã€‚<br>Consensus algorithms for practical systems typically have the following properties:<br>
<br>They ensure safety (never returning an incorrect result) under all non-Byzantine conditions,<br>
including network delays, partitions, and packet loss, duplication, and reordering.
<br>They are fully functional (available) as long as any majority of the servers are operational<br>
and can communicate with each other and with clients.<br>
Thus, a typical cluster of five servers can tolerate the failure of any two servers.<br>
Servers are assumed to fail by stopping; they may later recover from state on stable storage and rejoin the cluster.
<br>They do not depend on timing to ensure the consistency of the logs:<br>
faulty clocks and extreme message delays can, at worst, cause availability problems.
<br>In the common case, a command can complete as soon as a majority of the cluster has responded to a single round of remote procedure calls;<br>
a minority of slow servers need not impact overall system performance.
<br>å®é™…ç³»ç»Ÿä¸­çš„ä¸€è‡´æ€§ç®—æ³•é€šå¸¸å…·æœ‰ä»¥ä¸‹å±æ€§ï¼š<br>
<br>å®ƒä»¬ç¡®ä¿åœ¨æ‰€æœ‰éæ‹œå åº­æ¡ä»¶ä¸‹çš„å®‰å…¨æ€§(æ°¸è¿œä¸è¿”å›é”™è¯¯ç»“æœ)ï¼Œ(éæ‹œå åº­æ¡ä»¶)åŒ…æ‹¬ç½‘ç»œå»¶è¿Ÿï¼Œåˆ†åŒºï¼Œå’Œä¸¢åŒ…ï¼Œé‡å¤ä»¥åŠé‡æ–°æ’åºã€‚
<br>åªè¦å¤§å¤šæ•°æœåŠ¡å™¨èƒ½å¤Ÿæ­£å¸¸å·¥ä½œå¹¶ä¸”èƒ½å¤Ÿä¸å…¶å®ƒæœåŠ¡å™¨ä»¥åŠå®¢æˆ·ç«¯äº’ç›¸é€šä¿¡ï¼Œä¸€è‡´æ€§ç®—æ³•å°±èƒ½å‘æŒ¥å…¶å…¨éƒ¨çš„åŠŸèƒ½(å¯ç”¨æ€§)ã€‚<br>
å› æ­¤ï¼Œä¸€ä¸ªå…¸å‹çš„æœ‰ç€5å°æœåŠ¡å™¨ç»„æˆçš„é›†ç¾¤èƒ½å¤Ÿå®¹å¿ä»»æ„ä¸¤å°æœåŠ¡å™¨å‡ºç°æ•…éšœã€‚<br>
å‡è®¾æœåŠ¡å™¨å› ä¸ºæ•…éšœè€Œåœæœºï¼›ä»–ä»¬å¯ä»¥ç¨åä»ç¨³å®šçš„å­˜å‚¨çŠ¶æ€ä¸­æ¢å¤å¹¶é‡æ–°åŠ å…¥é›†ç¾¤ã€‚
<br>ä»–ä»¬ä¸ä¾èµ–æ—¶é—´æ¥ç¡®ä¿æ—¥å¿—çš„ä¸€è‡´æ€§ï¼šé”™è¯¯çš„æ—¶é’Ÿå’Œæç«¯çš„æ¶ˆæ¯å»¶è¿Ÿåœ¨æœ€åçš„æƒ…å†µä¸‹ä¼šé€ æˆå¯ç”¨æ€§é—®é¢˜ã€‚
<br>é€šå¸¸æƒ…å†µä¸‹ï¼Œåªè¦é›†ç¾¤ä¸­çš„å¤§å¤šæ•°å¯¹å•è½®çš„è¿œè¿‡ç¨‹è°ƒç”¨åšå‡ºäº†å“åº”ï¼Œå‘½ä»¤å°±å¯ä»¥å®Œæˆã€‚å å°‘æ•°çš„æ…¢é€ŸæœåŠ¡å™¨ä¸ä¼šå¯¹ç³»ç»Ÿæ•´ä½“æ€§èƒ½é€ æˆå½±å“ã€‚
<br><br>Over the last ten years, Leslie Lamportâ€™s Paxos protocol has become almost synonymous with consensus:<br>
it is the protocol most commonly taught in courses, and most implementations of consensus use it as a starting point.<br>
Paxos first defines a protocol capable of reaching agreement on a single decision, such as a single replicated log entry.<br>
We refer to this subset as single-decree Paxos.<br>
Paxos then combines multiple instances of this protocol to facilitate a series of decisions such as a log (multi-Paxos).<br>
Paxos ensures both safety and liveness, and it supports changes in cluster membership.<br>
Its correctness has been proven, and it is efficient in the normal case.<br>åœ¨è¿‡å»çš„åå¹´ä¸­ï¼ŒLeslie Lamportçš„Paxosåè®®å‡ ä¹å·²ç»æˆä¸ºäº†ä¸€è‡´æ€§ç®—æ³•çš„ä»£åè¯ï¼š<br>
å®ƒæ˜¯è¯¾å ‚æ•™å­¦ä¸­æœ€å¸¸ç”¨çš„åè®®ï¼Œå¤§å¤šæ•°çš„ä¸€è‡´æ€§ç®—æ³•ä¹Ÿå°†å…¶ä½œä¸ºèµ·ç‚¹ã€‚<br>
Paxosé¦–å…ˆå®šä¹‰äº†ä¸€ä¸ªåè®®ï¼Œå…¶èƒ½å¤Ÿå°±å•ä¸ªå†³å®šè¾¾æˆä¸€è‡´ï¼Œä¾‹å¦‚å•ä¸ªæ—¥å¿—æ¡ç›®çš„å¤åˆ¶ã€‚<br>
æˆ‘ä»¬å°†è¿™ä¸€è‡ªå·±ç§°ä¸ºsingle-decree Paxosã€‚<br>
ç„¶åPaxoså°†è¯¥åè®®çš„å¤šä¸ªå®ä¾‹ç»„åˆèµ·æ¥ä»¥è¾¾æˆä¸€ç³»åˆ—çš„å†³å®šï¼Œä¾‹å¦‚æ—¥å¿—(multi-Paxos)ã€‚<br>
PaxosåŒæ—¶ä¿è¯äº†å®‰å…¨æ€§å’Œæ´»æ€§ï¼Œå¹¶ä¸”æ”¯æŒé›†ç¾¤æˆå‘˜çš„å˜æ›´ã€‚<br>
å…¶æ­£ç¡®æ€§å·²ç»å¾—åˆ°è¯æ˜ï¼Œå¹¶ä¸”åœ¨é€šå¸¸æƒ…å†µä¸‹æ˜¯é«˜æ•ˆçš„ã€‚<br>Unfortunately, Paxos has two significant drawbacks.<br>
The first drawback is that Paxos is exceptionally difficult to understand.<br>
The full explanation is notoriously opaque; few people succeed in understanding it, and only with great effort.<br>
As a result, there have been several attempts to explain Paxos in simpler terms.<br>
These explanations focus on the single-decree subset, yet they are still challenging.<br>
In an informal survey of attendees at NSDI 2012, we found few people who were comfortable with Paxos, even among seasoned researchers.<br>
We struggled with Paxos ourselves;<br>
we were not able to understand the complete protocol until after reading several simplified explanations<br>
and designing our own alternative protocol, a process that took almost a year.<br>ä¸å¹¸çš„æ˜¯ï¼ŒPaxosæœ‰ç€ä¸¤ä¸ªæ˜æ˜¾çš„ç¼ºç‚¹ã€‚<br>
ç¬¬ä¸€ä¸ªç¼ºç‚¹æ˜¯Paxoså¼‚ä¹å¯»å¸¸çš„éš¾ç†è§£ã€‚<br>
Paxoså‡ºäº†åçš„éš¾ç†è§£ï¼Œå³ä½¿åœ¨ä»˜å‡ºäº†å·¨å¤§åŠªåŠ›çš„æƒ…å†µä¸‹ï¼Œä¹Ÿå¾ˆå°‘æœ‰äººèƒ½æˆåŠŸçš„ç†è§£å®ƒã€‚<br>
å› æ­¤ï¼Œæœ‰ä¸€äº›äººå°è¯•ç€ç”¨æ›´ç®€å•çš„æ–¹å¼æ¥ç†è§£Paxosã€‚<br>
è¿™äº›è§£é‡Šèšç„¦äºsingle-decreeè¿™ä¸€å­é›†ï¼Œä½†è¿™ä»å…·æœ‰æŒ‘æˆ˜æ€§ã€‚<br>
åœ¨ä¸€é¡¹é’ˆå¯¹NSDI 2012ä¸ä¼šè€…çš„éæ­£å¼è°ƒæŸ¥ä¸­ï¼Œæˆ‘ä»¬å‘ç°å¾ˆå°‘æœ‰äººå¯¹Paxosæ„Ÿåˆ°æ»¡æ„ï¼Œå³ä½¿å¯¹äºç»éªŒä¸°å¯Œçš„ç ”ç©¶å‘˜æ¥è¯´ä¹Ÿæ˜¯å¦‚æ­¤ã€‚<br>
æˆ‘ä»¬ä¹Ÿä¸Paxosè¿›è¡Œäº†è‰°éš¾çš„æ–—äº‰ï¼›ç›´åˆ°é˜…è¯»äº†å‡ ä¸ªç®€åŒ–çš„è§£é‡Šå¹¶è®¾è®¡äº†æˆ‘ä»¬è‡ªå·±çš„æ›¿ä»£æ–¹æ¡ˆåæˆ‘ä»¬æ‰èƒ½å¤Ÿç†è§£å®Œæ•´çš„åè®®ï¼Œè€Œè¿™ä¸ªè¿‡ç¨‹èŠ±è´¹äº†å°†è¿‘ä¸€å¹´çš„æ—¶é—´ã€‚<br>We hypothesize that Paxosâ€™ opaqueness derives from its choice of the single-decree subset as its foundation.<br>
Single-decree Paxos is dense and subtle:<br>
it is divided into two stages that do not have simple intuitive explanations and cannot be understood independently.<br>
Because of this, it is difficult to develop intuitions about why the single-decree protocol works.<br>
The composition rules for multi-Paxos add significant additional complexity and subtlety.<br>
We believe that the overall problem of reaching consensus on multiple decisions (i.e., a log instead of a single entry)<br>
can be decomposed in other ways that are more direct and obvious.<br>æˆ‘ä»¬çŒœå®šPaxosæ™¦æ¶©éš¾æ‡‚çš„åŸå› åœ¨äºä½œè€…é€‰æ‹©ä»¥single-decreeè¿™ä¸€å­é›†ä½œä¸ºPaxosçš„åŸºç¡€ã€‚<br>
Single-decree Paxosæ˜¯éš¾ç†è§£å’Œç²¾å·§çš„ï¼š<br>
å®ƒè¢«åˆ†ä¸ºäº†ä¸¤ä¸ªé˜¶æ®µï¼Œå¹¶ä¸”æ²¡æœ‰ç®€å•ç›´æ¥çš„è¯´æ˜ï¼Œæ¯ä¸€é˜¶æ®µä¹Ÿæ— æ³•å•ç‹¬çš„ç†è§£ã€‚<br>
æ­£å› å¦‚æ­¤ï¼Œå¾ˆéš¾å‡­å€Ÿç›´è§‰çš„ç†è§£single-decreeåè®®ä¸ºä»€ä¹ˆèƒ½å¤Ÿå·¥ä½œã€‚<br>
multi-Paxosçš„ç»„åˆè§„åˆ™ä¹Ÿæ˜¾è‘—çš„å¢åŠ äº†å¤æ‚æ€§å’Œå¾®å¦™ä¹‹å¤„ã€‚<br>
æˆ‘ä»¬è®¤ä¸ºï¼Œå°±å¤šä¸ªå†³å®šè¾¾æˆä¸€è‡´çš„æ€»ä½“é—®é¢˜(ä¾‹å¦‚ï¼Œä½¿ç”¨æ—¥å¿—è€Œä¸æ˜¯å•ä¸ªçš„entry)èƒ½å¤Ÿè¢«åˆ†è§£ä¸ºå…¶å®ƒæ›´ç›´æ¥å’Œæ›´å®¹æ˜“ç†è§£çš„æ–¹å¼ã€‚<br>The second problem with Paxos is that it does not provide a good foundation for building practical implementations.<br>
One reason is that there is no widely agreed-upon algorithm for multi-Paxos.<br>
Lamportâ€™s descriptions are mostly about single-decree Paxos;<br>
he sketched possible approaches to multi-Paxos, but many details are missing.<br>
There have been several attempts to flesh out and optimize Paxos, such as [26], [39], and [13],<br>
but these differ from each other and from Lamportâ€™s sketches.<br>
Systems such as Chubby [4] have implemented Paxos-like algorithms, but in most cases their details have not been published.<br>Paxosçš„ç¬¬äºŒä¸ªé—®é¢˜æ˜¯å®ƒæ²¡æœ‰ä¸ºæ„å»ºå®é™…å¯è¡Œçš„å®ç°æä¾›ä¸€ä¸ªå¥½çš„åŸºç¡€ã€‚<br>
å…¶ä¸­ä¸€ä¸ªåŸå› æ˜¯å¯¹äºmulti-Paxosæ²¡æœ‰ä¸€ä¸ªè¢«å¹¿æ³›è®¤åŒçš„ç®—æ³•ã€‚<br>
Lamportçš„æè¿°å¤§å¤šæ•°éƒ½æ˜¯å…³äºsingle-decree Paxosçš„ï¼›ä»–ç®€è¦çš„æ¦‚è¿°äº†å®ç°multi-Paxosçš„å¯è¡Œçš„æ–¹æ³•ï¼Œä½†ç¼ºå¤±äº†å¾ˆå¤šçš„ç»†èŠ‚ã€‚<br>
å·²ç»æœ‰å‡ ä¸ª(å›¢é˜Ÿ)è¯•å›¾å»å…·ä½“åŒ–å’Œä¼˜åŒ–Paxosï¼Œä¾‹å¦‚[26],[39]å’Œ[13],ä½†è¿™äº›å°è¯•å½¼æ­¤é—´ä¸åŒä¸”ä¹Ÿä¸åŒäºLamportçš„æ¦‚è¿°ã€‚<br>
åƒChubbyç³»ç»Ÿå·²ç»å®ç°äº†ç±»ä¼¼Paxosçš„ç®—æ³•ï¼Œä½†å¤§å¤šæ•°æƒ…å†µä¸‹çš„ç»†èŠ‚å¹¶æ²¡æœ‰è¢«å…¬å¼€ã€‚<br>Furthermore, the Paxos architecture is a poor one for building practical systems;<br>
this is another consequence of the single-decree decomposition.<br>
For example, there is little benefit to choosing a collection of log entries independently and then melding them into a sequential log;<br>
this just adds complexity.<br>
It is simpler and more efficient to design a system around a log,<br>
where new entries are appended sequentially in a constrained order.<br>
Another problem is that Paxos uses a symmetric peer-to-peer approach at its core<br>
(though it eventually suggests a weak form of leadership as a performance optimization).<br>
This makes sense in a simplified world where only one decision will be made, but few practical systems use this approach.<br>
If a series of decisions must be made, it is simpler and faster to first elect a leader, then have the leader coordinate the decisions.<br>æ­¤å¤–ï¼ŒPaxosçš„æ¶æ„åœ¨æ„å»ºå®é™…çš„ç³»ç»Ÿæ—¶è¡¨ç°ä¸ä½³ï¼›è¿™æ˜¯å¯¹single-decreeè¿›è¡Œåˆ†è§£çš„å¦ä¸€ä¸ªç»“æœã€‚<br>
ä¾‹å¦‚ï¼Œé€‰æ‹©ä¸€ç»„ç‹¬ç«‹çš„æ—¥å¿—é›†åˆå¹¶å°†å…¶åˆå¹¶åˆ°ä¸€ä¸ªé¡ºåºæ—¥å¿—ä¸­å‡ ä¹æ²¡æœ‰å¸¦æ¥ä»€ä¹ˆå¥½å¤„ï¼›è¿™åªä¼šå¢åŠ å¤æ‚æ€§ã€‚<br>
å›´ç»•æ—¥å¿—æ¥è®¾è®¡ç³»ç»Ÿä¼šæ›´ç®€å•å’Œæ›´é«˜æ•ˆï¼Œå…¶ä¸­æ–°çš„æ—¥å¿—æ¡ç›®ä»¥å—çº¦æŸçš„é¡ºåºè¿½åŠ ã€‚<br>
å¦ä¸€ä¸ªé—®é¢˜æ˜¯ï¼ŒPaxosä½¿ç”¨äº†ä¸€ç§å¯¹ç§°çš„ç‚¹å¯¹ç‚¹(P2P)æ–¹æ³•ä½œä¸ºå…¶æ ¸å¿ƒ(å°½ç®¡æœ€åæå‡ºäº†ä¸€ç§æ›´å¼±å½¢å¼çš„leadershipä½œä¸ºæ€§èƒ½ä¼˜åŒ–)ã€‚<br>
åœ¨ä¸€ä¸ªåªéœ€è¦åšä¸€æ¬¡å†³å®šçš„ï¼Œè¢«ç®€åŒ–çš„ä¸–ç•Œä¸­è¿™æ ·æ˜¯è¡Œå¾—é€šçš„ï¼Œä½†å¾ˆå°‘æœ‰å®é™…çš„ç³»ç»Ÿä½¿ç”¨è¿™ä¸ªæ–¹å¼ã€‚<br>
å¦‚æœæœ‰ä¸€ç³»åˆ—çš„å†³å®šå¿…é¡»è¦åšï¼Œé¦–å…ˆé€‰ä¸¾å‡ºä¸€ä¸ªleaderï¼Œç„¶åleaderæ¥åè°ƒå†³ç­–ä¼šæ›´ç®€å•å’Œæ›´å¿«é€Ÿã€‚<br>As a result, practical systems bear little resemblance to Paxos.<br>
Each implementation begins with Paxos, discovers the difficulties in implementing it,<br>
and then develops a significantly different architecture.<br>
This is time-consuming and error-prone, and the difficulties of understanding Paxos exacerbate the problem.<br>
Paxosâ€™ formulation may be a good one for proving theorems about its correctness,<br>
but real implementations are so different from Paxos that the proofs have little value.<br>The following comment from the Chubby implementers is typical:<br>
There are significant gaps between the description of the Paxos algorithm<br>
and the needs of a real-world system. . . . the final system will be based on an unproven protocol [4].<br>å› æ­¤ï¼Œå®é™…çš„ç³»ç»Ÿä¸Paxoså‡ ä¹æ²¡æœ‰ç›¸ä¼¼ä¹‹å¤„ã€‚<br>
æ¯ä¸€ä¸ªå®ç°éƒ½ä»Paxoså‡ºå‘ï¼Œå‘ç°å®ç°Paxosçš„å›°éš¾ä¹‹å¤„ï¼Œç„¶åå¼€å‘å‡ºä¸€ä¸ªä¸ä¹‹æˆªç„¶ä¸åŒçš„æ¶æ„ã€‚<br>
è¿™æ—¢è€—è´¹æ—¶é—´åˆå®¹æ˜“å‡ºé”™ï¼Œå¹¶ä¸”Paxosçš„æ™¦æ¶©éš¾æ‡‚åŠ å‰§äº†è¿™ä¸€é—®é¢˜ã€‚<br>
Paxosçš„å…¬å¼å¯èƒ½å¯ä»¥å¾ˆå¥½çš„è¯æ˜å…¶æ­£ç¡®æ€§ï¼Œä½†æ˜¯å®é™…çš„å®ç°ä¸Paxosæ˜¯å¦‚æ­¤çš„ä¸åŒï¼Œä»¥è‡³äºè¿™äº›è¯æ˜å‡ ä¹æ¯«æ— ä»·å€¼ã€‚<br>ä»¥ä¸‹Chubbyå®ç°è€…çš„è¯„è®ºæ˜¯å…·æœ‰ä»£è¡¨æ€§çš„ï¼š<br>
Paxosç®—æ³•çš„æè¿°ä¸ç°å®ä¸–ç•Œç³»ç»Ÿçš„éœ€æ±‚ä¹‹é—´æœ‰ç€å·¨å¤§çš„é¸¿æ²Ÿ....æœ€ç»ˆçš„ç³»ç»Ÿå°†å»ºç«‹åœ¨ä¸€ä¸ªæœªè¢«è¯æ˜çš„åè®®ä¹‹ä¸Šã€‚<br>Because of these problems, we concluded that Paxos does not provide a good foundation either for system building or for education.<br>
Given the importance of consensus in large-scale software systems,<br>
we decided to see if we could design an alternative consensus algorithm with better properties than Paxos.<br>
Raft is the result of that experiment.<br>ç”±äºè¿™äº›é—®é¢˜ï¼Œæˆ‘ä»¬çš„ç»“è®ºæ˜¯Paxoså¹¶æ²¡æœ‰ä¸ºæ„å»ºç³»ç»Ÿæˆ–æ˜¯è¿›è¡Œæ•™è‚²æä¾›ä¸€ä¸ªå¥½çš„åŸºç¡€ã€‚<br>
è€ƒè™‘åˆ°ä¸€è‡´æ€§åœ¨å¤§è§„æ¨¡è½¯ä»¶ç³»ç»Ÿä¸­çš„é‡è¦æ€§ï¼Œæˆ‘ä»¬å†³å®šçœ‹çœ‹æˆ‘ä»¬æ˜¯å¦å¯ä»¥è®¾è®¡å‡ºä¸€ä¸ªæ¯”èµ·Paxosæœ‰ç€æ›´å¥½ç‰¹æ€§çš„ä¸€è‡´æ€§ç®—æ³•ã€‚<br>
Raftæ­£æ˜¯è¿™ä¸€å®éªŒçš„æˆæœã€‚<br><br>We had several goals in designing Raft: it must provide a complete and practical foundation for system building,<br>
so that it significantly reduces the amount of design work required of developers;<br>
it must be safe under all conditions and available under typical operating conditions; and it must be efficient for common operations.<br>
But our most important goalâ€”and most difficult challengeâ€”was understandability.<br>
It must be possible for a large audience to understand the algorithm comfortably.<br>
In addition, it must be possible to develop intuitions about the algorithm,<br>
so that system builders can make the extensions that are inevitable in real-world implementations.<br>æˆ‘ä»¬åœ¨è®¾è®¡Raftæ—¶æœ‰å‡ ä¸ªç›®æ ‡ï¼šå®ƒå¿…é¡»ä¸ºæ„å»ºç³»ç»Ÿæä¾›ä¸€ä¸ªå®Œæ•´çš„å’Œå®é™…çš„åŸºç¡€ï¼Œä»è€Œæ˜¾è‘—çš„å‡å°‘å¼€å‘è€…è®¾è®¡æ—¶æ‰€éœ€çš„å·¥ä½œï¼›<br>
å®ƒå¿…é¡»åœ¨ä»»ä½•æ¡ä»¶ä¸‹éƒ½æ˜¯å®‰å…¨çš„å¹¶ä¸”åœ¨å…¸å‹çš„å·¥ä½œçŠ¶æ€ä¸‹æ˜¯å¯ç”¨çš„ï¼›åŒæ—¶å®ƒå¿…é¡»åœ¨é€šå¸¸å·¥ä½œçŠ¶æ€ä¸‹æ˜¯é«˜æ•ˆçš„ã€‚<br>
ä½†æˆ‘ä»¬æœ€é‡è¦çš„ç›®æ ‡ä¹Ÿæ˜¯æœ€å›°éš¾çš„æŒ‘æˆ˜æ˜¯ä½¿å¾—Rafté€šä¿—æ˜“æ‡‚ã€‚<br>
å¿…é¡»å°½å¯èƒ½çš„ä½¿å¤§å¤šæ•°äººèƒ½å¤Ÿè½»æ¾çš„ç†è§£è¯¥ç®—æ³•ã€‚<br>
è¿™æ ·ç³»ç»Ÿæ„å»ºè€…æ‰èƒ½å¤Ÿåœ¨ç°å®ä¸–ç•Œçš„å®ç°ä¸­è¿›è¡Œä¸å¯é¿å…çš„æ‹“å±•ã€‚<br>There were numerous points in the design of Raft where we had to choose among alternative approaches.<br>
In these situations we evaluated the alternatives based on understandability:<br>
how hard is it to explain each alternative (for example, how complex is its state space,<br>
and does it have subtle implications?), and how easy will it be for a reader to completely understand the approach and its implications?<br>åœ¨è®¾è®¡Raftæ—¶æœ‰å¾ˆå¤šè¦ç‚¹éƒ½å¿…é¡»åœ¨å¤šä¸ªå¯é€‰æ–¹æ¡ˆä¸­æŠ‰æ‹©ã€‚<br>
åœ¨è¿™äº›æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬åŸºäºæ˜“æ‡‚æ€§æ¥è¯„ä¼°è¿™äº›å¯é€‰æ–¹æ¡ˆï¼š<br>
å¯¹äºæ¯ä¸€ä¸ªå¯é€‰æ–¹æ¡ˆè§£é‡Šèµ·æ¥æœ‰å¤šå›°éš¾(ä¾‹å¦‚ï¼ŒçŠ¶æ€ç©ºé—´æœ‰å¤šå¤æ‚ä»¥åŠæ˜¯å¦æœ‰å¾®å¦™çš„å«ä¹‰ï¼Ÿ)ï¼Œä»¥åŠå¯¹äºä¸€ä¸ªè¯»è€…æ¥è¯´å®Œå…¨ç†è§£è¿™ä¸ªæ–¹æ³•å’Œå…¶å«ä¹‰æœ‰å¤šå®¹æ˜“ï¼Ÿ<br>We recognize that there is a high degree of subjectivity in such analysis; nonetheless, we used two techniques that are generally applicable.<br>
The first technique is the well-known approach of problem decomposition:<br>
wherever possible, we divided problems into separate pieces that could be solved, explained, and understood relatively independently.<br>
For example, in Raft we separated leader election, log replication, safety, and membership changes.<br>æˆ‘ä»¬æ„è¯†åˆ°è¿™ä¸€åˆ†ææ–¹å¼å…·æœ‰é«˜åº¦çš„ä¸»è§‚æ€§ï¼›å°½ç®¡å¦‚æ­¤ï¼Œä½†æˆ‘ä»¬è¿˜æ˜¯ä½¿ç”¨äº†ä¸¤ç§å¯è¡Œçš„é€šç”¨æŠ€æœ¯ã€‚<br>
ç¬¬ä¸€ä¸ªæŠ€æœ¯æ˜¯ä¼—æ‰€å‘¨çŸ¥çš„é—®é¢˜åˆ†è§£æ–¹æ³•ï¼š<br>
åœ¨å¯èƒ½çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å°†é—®é¢˜åˆ†è§£ä¸ºå‡ ä¸ªéƒ¨åˆ†ï¼Œä½¿å¾—æ¯ä¸€éƒ¨åˆ†éƒ½å¯ä»¥è¢«ç›¸å¯¹ç‹¬ç«‹çš„è§£å†³ï¼Œè§£é‡Šå’Œç†è§£ã€‚<br>
ä¾‹å¦‚ï¼Œæˆ‘ä»¬å°†Raftåˆ†è§£ä¸ºleaderé€‰ä¸¾ï¼Œæ—¥å¿—å¤åˆ¶ï¼Œå®‰å…¨æ€§å’Œæˆå‘˜å˜æ›´è¿™å‡ ä¸ªéƒ¨åˆ†ã€‚<br>Our second approach was to simplify the state space by reducing the number of states to consider,<br>
making the system more coherent and eliminating nondeterminism where possible.<br>
Specifically, logs are not allowed to have holes, and Raft limits the ways in which logs can become inconsistent with each other.<br>
Although in most cases we tried to eliminate nondeterminism, there are some situations where nondeterminism actually improves understandability.<br>
In particular, randomized approaches introduce nondeterminism,<br>
but they tend to reduce the state space by handling all possible choices in a similar fashion(â€œchoose any; it doesnâ€™t matterâ€).<br>
We used randomization to simplify the Raft leader election algorithm.<br>æˆ‘ä»¬çš„ç¬¬äºŒç§æ–¹æ³•æ˜¯é€šè¿‡å‡å°‘éœ€è¦è€ƒè™‘çš„çŠ¶æ€æ•°é‡ä»¥ç®€åŒ–çŠ¶æ€ç©ºé—´ï¼Œä½¿ç³»ç»Ÿå˜å¾—æ›´åŠ è¿è´¯å¹¶å°½å¯èƒ½çš„æ¶ˆé™¤ä¸ç¡®å®šæ€§ã€‚<br>
ç‰¹åˆ«çš„ï¼Œæ—¥å¿—æ˜¯ä¸å…è®¸å­˜åœ¨ç©ºæ´çš„ï¼Œå¹¶ä¸”Rafté™åˆ¶äº†ä½¿å¾—æ—¥å¿—é—´å˜å¾—å½¼æ­¤ä¸ä¸€è‡´çš„æ–¹å¼ã€‚<br>
å°½ç®¡åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹æˆ‘ä»¬è¯•å›¾æ¶ˆé™¤ä¸ç¡®å®šæ€§ï¼Œä½†åœ¨ä¸€äº›æ¡ä»¶ä¸‹ä¸ç¡®å®šæ€§å®é™…ä¸Šèƒ½æé«˜å¯ç†è§£æ€§ã€‚<br>
ç‰¹åˆ«çš„ï¼ŒéšæœºåŒ–æ–¹æ³•å¼•å…¥äº†ä¸ç¡®å®šæ€§ï¼Œä½†å®ƒä»¬å€¾å‘äºé€šè¿‡ç”¨ç›¸ä¼¼çš„æ–¹å¼æ¥å¤„ç†æ‰€æœ‰å¯èƒ½çš„é€‰æ‹©ä»¥å‡å°‘çŠ¶æ€ç©ºé—´("é€‰æ‹©ä»»æ„ä¸€ä¸ª;å…·ä½“æ˜¯å“ªä¸€ä¸ªåˆ™æ— å…³ç´§è¦")ã€‚<br>
æˆ‘ä»¬ä½¿ç”¨éšæœºåŒ–æ¥ç®€åŒ–Raftä¸­çš„leaderé€‰ä¸¾ç®—æ³•ã€‚<br><br>Raft is an algorithm for managing a replicated log of the form described in Section 2.<br>
Figure 2 summarizes the algorithm in condensed form for reference, and Figure 3 lists key properties of the algorithm;<br>
the elements of these figures are discussed piecewise over the rest of this section.<br>Raftæ˜¯ä¸€ç§ç®¡ç†å¦‚ç¬¬äºŒèŠ‚æ‰€è¿°çš„å¤åˆ¶æ—¥å¿—çš„ç®—æ³•ã€‚<br>
å›¾2ä»¥ç®€æ˜æ‰¼è¦çš„æ€»ç»“äº†ç®—æ³•ä»¥ä¾›å‚è€ƒï¼Œå›¾3åˆ—ä¸¾å‡ºäº†ç®—æ³•çš„å…³é”®ç‰¹æ€§ï¼›è¿™äº›å›¾ä¸­çš„å…ƒç´ å°†åœ¨æœ¬èŠ‚å‰©ä½™çš„éƒ¨åˆ†ä¸­è¿›è¡Œè®¨è®ºã€‚<br>Raft implements consensus by first electing a distinguished leader,<br>
then giving the leader complete responsibility for managing the replicated log.<br>
The leader accepts log entries from clients,<br>
replicates them on other servers, and tells servers when it is safe to apply log entries to their state machines.<br>
Having a leader simplifies the management of the replicated log.<br>
For example, the leader can decide where to place new entries in the log without consulting other servers,<br>
and data flows in a simple fashion from the leader to other servers.<br>
A leader can fail or become disconnected from the other servers, in which case a new leader is elected.<br>Rafté€šè¿‡å—é™é€‰ä¸¾å‡ºä¸€ä½distinguished leaderï¼Œç„¶åè®©å®ƒå…¨æƒçš„ç®¡ç†å¤åˆ¶æ—¥å¿—ä»¥å®ç°ä¸€è‡´æ€§ã€‚<br>
è¿™ä¸ªleaderæ¥å—æ¥è‡ªå®¢æˆ·ç«¯çš„æ—¥å¿—æ¡ç›®ï¼Œå°†å…¶å¤åˆ¶åˆ°å…¶å®ƒæœåŠ¡å™¨ä¸­ï¼Œå¹¶ä¸”åœ¨æ—¥å¿—æ¡ç›®å¯ä»¥è¢«å®‰å…¨çš„åº”ç”¨åœ¨å®ƒä»¬çš„çŠ¶æ€æœºä¸Šæ—¶é€šçŸ¥è¿™äº›æœåŠ¡å™¨ã€‚<br>
æ‹¥æœ‰ä¸€ä¸ªleaderå¯ä»¥ç®€åŒ–å¯¹å¤åˆ¶æ—¥å¿—çš„ç®¡ç†ã€‚<br>
ä¾‹å¦‚ï¼Œleaderå¯ä»¥å†³å®šæ–°æ—¥å¿—æ¡ç›®çš„ä½ç½®è€Œæ— éœ€å’¨è¯¢å…¶å®ƒæœåŠ¡å™¨ï¼Œå¹¶ä¸”æ•°æ®æµä»¥ä¸€ç§ç®€å•çš„å½¢å¼ç”±leaderæµå‘å…¶å®ƒæœåŠ¡å™¨ã€‚<br>
leaderå¯èƒ½ä¼šæ•…éšœæˆ–è€…ä¸å…¶å®ƒæœåŠ¡å™¨å¤±è”ï¼Œè¿™ç§æƒ…å†µä¸‹ä¸€ä½æ–°çš„leaderå°†ä¼šè¢«é€‰ä¸¾å‡ºæ¥ã€‚<br>Given the leader approach, Raft decomposes the consensus problem into three relatively independent sub-problems,<br>
which are discussed in the subsections that follow:<br>
<br>Leader election: a new leader must be chosen when an existing leader fails (Section 5.2).
<br>Log replication: the leader must accept log entries from clients and replicate them across the cluster,<br>
forcing the other logs to agree with its own (Section 5.3).
<br>Safety: the key safety property for Raft is the State Machine Safety Property in Figure 3:<br>
if any server has applied a particular log entry to its state machine,<br>
then no other server may apply a different command for the same log index.<br>
Section 5.4 describes how Raft ensures this property;<br>
the solution involves an additional restriction on the election mechanism described in Section 5.2.
<br>After presenting the consensus algorithm, this section discusses the issue of availability and the role of timing in the system.<br>é€šè¿‡å¼•å…¥leaderçš„æ–¹æ³•ï¼ŒRaftå°†ä¸€è‡´æ€§é—®é¢˜åˆ†è§£ä¸º3ä¸ªç›¸å¯¹ç‹¬ç«‹çš„å­é—®é¢˜ï¼Œè¿™äº›å­é—®é¢˜å°†åœ¨ä»¥ä¸‹å­ç« èŠ‚ä¸­è¢«è®¨è®ºï¼š<br>
<br>leaderé€‰ä¸¾ï¼š å½“ä¸€ä½ç°å­˜çš„leaderæ•…éšœæ—¶å¿…é¡»é€‰å‡ºä¸€ä½æ–°çš„leader(5.2èŠ‚)ã€‚
<br>æ—¥å¿—å¤åˆ¶ï¼š leaderå¿…é¡»ä»å®¢æˆ·ç«¯æ¥æ”¶æ—¥å¿—æ¡ç›®å¹¶ä¸”åœ¨é›†ç¾¤ä¸­å¤åˆ¶å®ƒä»¬ï¼Œå¹¶ä¸”å¼ºåˆ¶å…¶å®ƒèŠ‚ç‚¹çš„æ—¥å¿—ä¸leaderä¿æŒä¸€è‡´(5.3èŠ‚)ã€‚
<br>å®‰å…¨æ€§ï¼š Raftçš„å…³é”®å®‰å…¨ç‰¹æ€§å°±æ˜¯å›¾3ä¸­çš„çŠ¶æ€æœºçš„å®‰å…¨ç‰¹æ€§ï¼šå¦‚æœä»»ä¸€æœåŠ¡å™¨å·²ç»å°†ä¸€ä¸ªç‰¹å®šçš„æ—¥å¿—æ¡ç›®ä½œç”¨äºå®ƒçš„çŠ¶æ€æœºï¼Œåˆ™æ²¡æœ‰ä»»ä½•æœåŠ¡å™¨å¯ä»¥å¯¹ç›¸åŒçš„æ—¥å¿—ç´¢å¼•åº”ç”¨ä¸åŒçš„æŒ‡ä»¤ã€‚<br>
5.4èŠ‚æè¿°äº†Raftæ˜¯å¦‚ä½•ç¡®ä¿è¿™ä¸€ç‰¹æ€§çš„ï¼›è¿™ä¸€è§£å†³æ–¹æ¡ˆæ¶‰åŠåˆ°å¯¹5.2èŠ‚ä¸­æ‰€æè¿°çš„é€‰ä¸¾æœºåˆ¶çš„é¢å¤–é™åˆ¶ã€‚
<br>åœ¨å±•ç¤ºäº†ä¸€è‡´æ€§ç®—æ³•åï¼Œæœ¬ç« èŠ‚è¿˜å°†è®¨è®ºå¯ç”¨æ€§é—®é¢˜ä»¥åŠæ—¶åºåœ¨ç³»ç»Ÿä¸­èµ·åˆ°çš„ä½œç”¨ã€‚<br><img alt="Pasted image 20240725172955.png" src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raft-åŸå§‹è®ºæ–‡ä¸­è‹±/pasted-image-20240725172955.png"><br>A condensed summary of the Raft consensus algorithm (excluding membership changes and log compaction).<br>
The server behavior in the upper-left box is described as a set of rules that trigger independently and repeatedly.<br>
Section numbers such as Â§5.2 indicate where particular features are discussed.<br>
A formal specification [31] describes the algorithm more precisely.<br>å…³äºRaftä¸€è‡´æ€§ç®—æ³•çš„ç²¾ç®€æ‘˜è¦(ä¸åŒ…æ‹¬æˆå‘˜å˜æ›´å’Œæ—¥å¿—å‹ç¼©)ã€‚<br>
å·¦ä¸Šæ–¹æ¡†å†…æ‰€æè¿°çš„æœåŠ¡å™¨è¡Œä¸ºè¢«æè¿°ä¸ºä¸€ç³»åˆ—ç‹¬ç«‹å’Œé‡å¤è§¦å‘çš„è§„åˆ™ã€‚<br>
ç« èŠ‚ç¼–å·ä¾‹å¦‚Â§5.2æ ‡è¯†äº†å…·ä½“è®¨è®ºè¯¥ç‰¹å®šåŠŸèƒ½çš„ç« èŠ‚ã€‚<br>
å½¢å¼åŒ–è§„çº¦ä»¥æ›´ç²¾ç¡®çš„æ–¹å¼æè¿°è¯¥ç®—æ³•ã€‚<br><img alt="Pasted image 20240725173009.png" src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raft-åŸå§‹è®ºæ–‡ä¸­è‹±/pasted-image-20240725173009.png"><br>Figure 3: Raft guarantees that each of these properties is true at all times.<br>
The section numbers indicate where each property is discussed.<br>å›¾3ï¼šRaftä¿è¯æ¯ä¸€ä¸ªç‰¹æ€§åœ¨ä»»ä½•æ—¶å€™éƒ½æ˜¯æˆç«‹çš„ã€åå‰¯å…¶å®çš„ã€‚<br>
ç« èŠ‚å·æ ‡è¯†ç€æ¯ä¸€ä¸ªç‰¹æ€§è¢«è®¨è®ºçš„å…·ä½“ç« èŠ‚ã€‚<br><br>A Raft cluster contains several servers; five is a typical number, which allows the system to tolerate two failures.<br>
At any given time each server is in one of three states: leader, follower, or candidate.<br>
In normal operation there is exactly one leader and all of the other servers are followers.<br>
Followers are passive: they issue no requests on their own but simply respond to requests from leaders and candidates.<br>
The leader handles all client requests (if a client contacts a follower, the follower redirects it to the leader).<br>
The third state, candidate, is used to elect a new leader as described in Section 5.2.<br>
Figure 4 shows the states and their transitions; the transitions are discussed below.<br>ä¸€ä¸ªRaftçš„é›†ç¾¤åŒ…å«å‡ ä¸ªæœåŠ¡å™¨;é€šå¸¸æ˜¯5ä¸ªèŠ‚ç‚¹ï¼Œè¿™æ ·çš„ç³»ç»Ÿèƒ½å®¹å¿ç³»ç»Ÿä¸­çš„2ä¸ªèŠ‚ç‚¹å‡ºç°æ•…éšœã€‚<br>
åœ¨ä»»ä¸€ç»™å®šçš„æ—¶é—´å†…ï¼Œæ¯ä¸ªæœåŠ¡å™¨åªä¼šå¤„äº3ç§çŠ¶æ€ä¸­çš„ä¸€ç§ï¼šé¢†å¯¼è€…(leader),è¿½éšè€…(follower)ï¼Œæˆ–è€…å€™é€‰è€…(candidate)ã€‚<br>
åœ¨é€šå¸¸æƒ…å†µä¸‹ï¼Œåªä¼šæœ‰1ä¸ªleaderå¹¶ä¸”å…¶å®ƒçš„æœåŠ¡å™¨éƒ½æ˜¯followerã€‚<br>
Followeréƒ½æ˜¯è¢«åŠ¨çš„: å®ƒä»¬è‡ªå·±ä¸ä¼šæå‡ºè¯·æ±‚è€Œåªä¼šç®€å•çš„å“åº”æ¥è‡ªleaderå’Œcandidateçš„è¯·æ±‚ã€‚<br>
leaderå¤„ç†æ‰€æœ‰æ¥è‡ªå®¢æˆ·ç«¯çš„è¯·æ±‚(å¦‚æœä¸€ä¸ªå®¢æˆ·ç«¯ä¸followerè¿›è¡Œè”ç»œï¼Œfollowerä¼šå°†å…¶é‡å®šå‘åˆ°leader)ã€‚<br>
ç¬¬ä¸‰ç§çŠ¶æ€ï¼Œcandidateï¼Œç”¨äºé€‰ä¸¾å‡ºä¸€ä¸ªå¦‚5.2ç« èŠ‚æ‰€æè¿°çš„æ–°leaderã€‚<br>
å›¾4å±•ç¤ºäº†çŠ¶æ€ä»¥åŠçŠ¶æ€é—´çš„è½¬æ¢å…³ç³»ï¼›è½¬æ¢å…³ç³»å°†åœ¨ä¸‹æ–‡è¢«è®¨è®ºã€‚<br>Raft divides time into terms of arbitrary length, as shown in Figure 5.<br>
Terms are numbered with consecutive integers.<br>
Each term begins with an election, in which one or more candidates attempt to become leader as described in Section 5.2.<br>
If a candidate wins the election, then it serves as leader for the rest of the term.<br>
In some situations an election will result in a split vote.<br>
In this case the term will end with no leader; a new term (with a new election) will begin shortly.<br>
Raft ensures that there is at most one leader in a given term.<br>Raftå°†æ—¶é—´åˆ†å‰²ä¸ºä»»æ„é•¿åº¦çš„ä»»æœŸ(term)ï¼Œå¦‚å›¾5æ‰€ç¤ºã€‚<br>
ä»»æœŸç”±è¿ç»­çš„æ•´æ•°è¿›è¡Œç¼–å·ã€‚<br>
æ¯ä¸€ä¸ªä»»æœŸéƒ½ä»¥ä¸€æ¬¡é€‰ä¸¾å¼€å§‹ï¼Œå…¶ä¸­ä¸€ä¸ªæˆ–æ›´å¤šçš„candidateè¯•å›¾æˆä¸ºleader(å¦‚5.2èŠ‚ä¸­æ‰€æè¿°çš„)ã€‚<br>
å¦‚æœä¸€ä¸ªcandidateèµ¢å¾—äº†é€‰ä¸¾ï¼Œç„¶åå®ƒå°†åœ¨ä½™ä¸‹çš„ä»»æœŸä¸­ä½œä¸ºleaderã€‚<br>
åœ¨ä¸€äº›æƒ…å†µä¸‹ä¸€æ¬¡é€‰ä¸¾å¯èƒ½ä¼šå¯¼è‡´åˆ†è£‚çš„æŠ•ç¥¨ç»“æœã€‚<br>
åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä»»æœŸå°†åœ¨æ²¡æœ‰leaderçš„æƒ…å†µä¸‹ç»“æŸ; ä¸€ä¸ªæ–°çš„ä»»æœŸ(ä¼´éšè€…ä¸€ä¸ªæ–°çš„é€‰ä¸¾)å°†å¾ˆå¿«å¼€å§‹ã€‚<br>
Raftä¿è¯äº†åœ¨ä¸€ä¸ªç»™å®šçš„ä»»æœŸå†…æœ€å¤šåªä¼šæœ‰ä¸€ä¸ªleaderã€‚<br><img src="https://img2023.cnblogs.com/blog/1506329/202307/1506329-20230713200905466-706345890.png" referrerpolicy="no-referrer"><br>Figure 4: Server states. Followers only respond to requests from other servers.<br>
If a follower receives no communication, it becomes a candidate and initiates an election.<br>
A candidate that receives votes from a majority of the full cluster becomes the new leader.<br>
Leaders typically operate until they fail.<br>å›¾4ï¼šæœåŠ¡å™¨çŠ¶æ€ã€‚<br>
followeråªèƒ½å“åº”æ¥è‡ªå…¶å®ƒæœåŠ¡å™¨çš„è¯·æ±‚ã€‚<br>
å¦‚æœfolloweræ²¡æœ‰æ”¶åˆ°é€šä¿¡ï¼Œå®ƒå°†æˆä¸ºä¸€åcandidateå¹¶ä¸”åˆå§‹åŒ–ä¸€åœºé€‰ä¸¾ã€‚<br>
ä¸€ä½candidateæ”¶åˆ°äº†æ¥è‡ªæ•´ä¸ªé›†ç¾¤ä¸­çš„å¤§å¤šæ•°æŠ•ç¥¨åˆ™æˆä¸ºæ–°çš„leaderã€‚<br>
leaderé€šå¸¸æŒç»­å·¥ä½œç›´åˆ°å®ƒä»¬å‘ç”Ÿæ•…éšœã€‚<br><img alt="Pasted image 20240725173021.png" src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raft-åŸå§‹è®ºæ–‡ä¸­è‹±/pasted-image-20240725173021.png"><br>Figure 5: Time is divided into terms, and each term begins with an election.<br>
After a successful election, a single leader manages the cluster until the end of the term.<br>
Some elections fail, in which case the term ends without choosing a leader.<br>
The transitions between terms may be observed at different times on different servers.<br>å›¾5ï¼šæ—¶é—´ä»¥ä»»æœŸè¿›è¡Œåˆ’åˆ†ï¼Œæ¯ä¸€ä¸ªä»»æœŸéƒ½ä»¥ä¸€æ¬¡é€‰ä¸¾å¼€å§‹ã€‚<br>
åœ¨æˆåŠŸçš„é€‰ä¸¾ä¹‹åï¼Œä¸€ä¸ªleaderç®¡ç†é›†ç¾¤ç›´åˆ°ä»»æœŸç»“æŸã€‚<br>
æœ‰äº›é€‰ä¸¾å¤±è´¥äº†ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ä»»æœŸç»“æŸæ—¶å¹¶æ²¡æœ‰é€‰å‡ºä¸€ä¸ªleaderã€‚<br>
å¯ä»¥åœ¨ä¸åŒæœåŠ¡å™¨çš„ä¸åŒæ—¶é—´ä¸Šè§‚å¯Ÿåˆ°ä»»æœŸçš„è½¬æ¢ã€‚<br>Different servers may observe the transitions between terms at different times,<br>
and in some situations a server may not observe an election or even entire terms.<br>
Terms act as a logical clock [14] in Raft, and they allow servers to detect obsolete information such as stale leaders.<br>
Each server stores a current term number, which increases monotonically over time.<br>
Current terms are exchanged whenever servers communicate;<br>
if one serverâ€™s current term is smaller than the otherâ€™s, then it updates its current term to the larger value.<br>
If a candidate or leader discovers that its term is out of date, it immediately reverts to follower state.<br>
If a server receives a request with a stale term number, it rejects the request.<br>ä¸åŒæœåŠ¡å™¨å¯èƒ½ä¼šåœ¨ä¸åŒçš„æ—¶é—´ä¸Šè§‚å¯Ÿåˆ°ä»»æœŸä¹‹é—´çš„çŠ¶æ€è½¬æ¢ï¼Œå¹¶ä¸”åœ¨ä¸€äº›æƒ…å†µä¸‹ä¸€ä¸ªæœåŠ¡å™¨å¯èƒ½ä¸ä¼šè§‚å¯Ÿåˆ°ä¸€æ¬¡é€‰ä¸¾ç”šè‡³æ•´ä¸ªä»»æœŸã€‚<br>
ä»»æœŸåœ¨Raftä¸­å……å½“é€»è¾‘æ—¶é’Ÿï¼Œå¹¶ä¸”å®ƒä»¬å…è®¸æœåŠ¡å™¨æ£€æµ‹åˆ°è¿‡æ—¶çš„ä¿¡æ¯æ¯”å¦‚ä¹‹å‰çš„ã€è€leaderã€‚<br>
æ¯ä¸€ä¸ªæœåŠ¡å™¨å­˜å‚¨äº†ä¸€ä¸ªå½“å‰ä»»æœŸçš„ç¼–å·ï¼Œå…¶éšç€æ—¶é—´å•è°ƒå¢åŠ ã€‚<br>
æ¯å½“æœåŠ¡å™¨ä¹‹é—´äº’ç›¸é€šä¿¡æ—¶ï¼Œå®ƒä»¬éƒ½ä¼šäº’ç›¸äº¤æ¢å½“å‰çš„ä»»æœŸ(ç¼–å·);å¦‚æœä¸€ä¸ªæœåŠ¡å™¨çš„å½“å‰ä»»æœŸ(ç¼–å·)å°äºå…¶å®ƒçš„æœåŠ¡å™¨ï¼Œåˆ™å…¶å°†ä¼šå°†å½“å‰çš„ä»»æœŸ(ç¼–å·)æ›´æ–°ä¸ºé‚£ä¸ªæ›´å¤§çš„å€¼ã€‚<br>
å¦‚æœä¸€ä¸ªcandidateæˆ–è€…leaderå‘ç°å®ƒä»¬çš„ä»»æœŸ(ç¼–å·)å·²ç»è¿‡æ—¶ï¼Œå®ƒå°†ç«‹å³å°†è‡ªå·±æ¢å¤ä¸ºfollowerçš„çŠ¶æ€ã€‚<br>
å¦‚æœä¸€ä¸ªæœåŠ¡å™¨æ¥å—åˆ°ä¸€ä¸ªå¸¦æœ‰è¿‡æ—¶ä»»æœŸç¼–å·çš„è¯·æ±‚ï¼Œå®ƒå°†æ‹’ç»è¿™ä¸€è¯·æ±‚ã€‚<br>Raft servers communicate using remote procedure calls(RPCs), and the basic consensus algorithm requires only two types of RPCs.<br>
RequestVote RPCs are initiated by candidates during elections (Section 5.2),<br>
and AppendEntries RPCs are initiated by leaders to replicate log entries and to provide a form of heartbeat (Section 5.3).<br>
Section 7 adds a third RPC for transferring snapshots between servers.<br>
Servers retry RPCs if they do not receive a response in a timely manner, and they issue RPCs in parallel for best performance.<br>RaftæœåŠ¡å™¨ä½¿ç”¨è¿œè¿‡ç¨‹è°ƒç”¨(RPC)è¿›è¡Œé€šä¿¡ï¼Œå¹¶ä¸”åŸºæœ¬çš„ä¸€è‡´æ€§ç®—æ³•åªéœ€è¦ä¸¤ç§ç±»å‹çš„RPCã€‚<br>
è¯·æ±‚æŠ•ç¥¨çš„RPCç”±candidateåœ¨é€‰ä¸¾æœŸé—´å‘èµ·(ç¬¬5.2èŠ‚)ï¼Œæ‹“å±•æ¡ç›®çš„RPCç”±leaderå‘èµ·ï¼Œç”¨äºæ—¥å¿—æ¡ç›®çš„å¤åˆ¶ä»¥åŠæä¾›å¿ƒè·³æœºåˆ¶(ç¬¬5.3èŠ‚)ã€‚<br>
ç¬¬7èŠ‚åŠ å…¥äº†ç¬¬ä¸‰ç§RPCç”¨äºåœ¨æœåŠ¡å™¨é—´ä¼ è¾“å¿«ç…§ã€‚<br>
å¦‚æœæœåŠ¡å™¨åœ¨ç»™å®šçš„æ—¶é—´å†…æ²¡æœ‰æ”¶åˆ°å“åº”ï¼Œåˆ™ä¼šå¯¹RPCè¿›è¡Œé‡è¯•ï¼Œå¹¶ä¸”å®ƒä»¬ä¼šå‘èµ·å¹¶è¡Œçš„rpcä»¥è·å¾—æœ€å¥½çš„æ€§èƒ½ã€‚<br><br>Raft uses a heartbeat mechanism to trigger leader election. When servers start up, they begin as followers.<br>
A server remains in follower state as long as it receives valid RPCs from a leader or candidate.<br>
Leaders send periodic heartbeats (AppendEntries RPCs that carry no log entries) to all followers in order to maintain their authority.<br>
If a follower receives no communication over a period of time called the election timeout,<br>
then it assumes there is no viable leader and begins an election to choose a new leader.<br>Raftä½¿ç”¨å¿ƒè·³æœºåˆ¶æ¥è§¦å‘leaderé€‰ä¸¾ã€‚å½“æœåŠ¡å™¨å¯åŠ¨æ—¶ï¼Œå®ƒä»¬ä¼šæˆä¸ºfollowerã€‚<br>
åªè¦æœåŠ¡å™¨èƒ½ä»leaderæˆ–è€…candidateå¤„æ¥æ”¶åˆ°æœ‰æ•ˆçš„RPCè¯·æ±‚ï¼Œå®ƒä»¬å°±å°†ä¿æŒfollowerçŠ¶æ€ã€‚<br>
leaderå‘æ‰€æœ‰followerå‘é€å‘¨æœŸæ€§çš„å¿ƒè·³(ä¸æºå¸¦æ—¥å¿—æ¡ç›®çš„AppendEntries RPC)æ¥ç»´æŒå®ƒçš„æƒå¨æ€§ã€‚<br>
å¦‚æœä¸€ä¸ªfolloweråœ¨ä¸€æ®µè¢«æˆä¸ºé€‰ä¸¾è¶…æ—¶çš„æ—¶é—´æ®µå†…æœªæ¥æ”¶åˆ°ä»»ä½•é€šä¿¡ï¼Œåˆ™å®ƒå‡è®¾å½“å‰æ²¡æœ‰å¯ç”¨çš„leaderå¹¶ä¸”å‘èµ·é€‰ä¸¾æ¥é€‰æ‹©ä¸€ä¸ªæ–°çš„leaderã€‚<br>To begin an election, a follower increments its current term and transitions to candidate state.<br>
It then votes for itself and issues RequestVote RPCs in parallel to each of the other servers in the cluster.<br>
A candidate continues in this state until one of three things happens:<br>
(a) it wins the election,<br>
(b) another server establishes itself as leader, or<br>
(c) a period of time goes by with no winner.<br>
These outcomes are discussed separately in the paragraphs below.<br>ä¸ºäº†å¼€å§‹ä¸€è½®é€‰ä¸¾ï¼Œfollowerå¢åŠ å®ƒå½“å‰çš„ä»»æœŸå€¼å¹¶ä¸”è½¬æ¢ä¸ºcandidateçŠ¶æ€ã€‚<br>
ç„¶åå®ƒå°†é€‰ç¥¨æŠ•ç»™å®ƒè‡ªå·±å¹¶ä¸”å‘é›†ç¾¤ä¸­çš„å…¶å®ƒæœåŠ¡å™¨å¹¶è¡Œçš„å‘èµ·è¯·æ±‚æŠ•ç¥¨çš„RPC(RequestVote RPCs)ã€‚<br>
ä¸€ä¸ªcandidateä¼šä¸€ç›´ä¿æŒè¿™ç§çŠ¶æ€ç›´åˆ°ä»¥ä¸‹ä¸‰ç§æƒ…å†µä¹‹ä¸€å‘ç”Ÿï¼š<br>
(a) å®ƒèµ¢å¾—æ­¤æ¬¡é€‰ä¸¾ (b) å¦ä¸€ä¸ªæœåŠ¡å™¨å°†è‡ªå·±ç¡®è®¤ä¸ºleaderï¼Œæˆ–è€… (c) ä¸€æ®µæ—¶é—´åæ²¡æœ‰äº§ç”Ÿèƒœåˆ©è€…ã€‚<br>
ä¸‹æ–‡ä¸­çš„å„ä¸ªæ®µè½å°†åˆ†åˆ«è®¨è®ºè¿™äº›ç»“æœã€‚<br>A candidate wins an election if it receives votes from a majority of the servers in the full cluster for the same term.<br>
Each server will vote for at most one candidate in a given term, on a first-come-first-served basis<br>
(note: Section 5.4 adds an additional restriction on votes).<br>
The majority rule ensures that at most one candidate can win the election for a particular term (the Election Safety Property in Figure 3).<br>
Once a candidate wins an election, it becomes leader.<br>
It then sends heartbeat messages to all of the other servers to establish its authority and prevent new elections.<br>å¦‚æœä¸€ä¸ªcandidateåœ¨åŒä¸€ä¸ªä»»æœŸå†…æ¥æ”¶åˆ°äº†æ•´ä¸ªé›†ç¾¤ä¸­å¤§å¤šæ•°æœåŠ¡å™¨çš„æŠ•ç¥¨ï¼Œå…¶å°†èµ¢å¾—è¿™æ¬¡é€‰ä¸¾ã€‚<br>
æ¯ä¸ªæœåŠ¡å™¨åœ¨ç»™å®šçš„æŸä¸€ä»»æœŸå†…å°†ä¼šåŸºäºå…ˆæ¥å…ˆæœåŠ¡çš„åŸåˆ™(first-come-first-served)æŠ•ç¥¨ç»™è‡³å¤šä¸€ä½candidate(ç¬¬5.4èŠ‚å¯¹æŠ•ç¥¨å¢åŠ äº†é¢å¤–çš„é™åˆ¶)ã€‚<br>
å¤šæ•°è§„åˆ™ç¡®ä¿äº†å¯¹äºä¸€ä¸ªç‰¹å®šçš„ä»»æœŸï¼Œæœ€å¤šåªä¼šæœ‰ä¸€åcandidateèƒ½å¤Ÿèµ¢å¾—é€‰ä¸¾(å›¾3ä¸­é€‰ä¸¾çš„å®‰å…¨ç‰¹æ€§)ã€‚<br>
ä¸€æ—¦ä¸€ä¸ªcandidateèµ¢å¾—äº†ä¸€æ¬¡é€‰ä¸¾ï¼Œå®ƒå°†æˆä¸ºleaderã€‚<br>
ç„¶åå®ƒå‘å…¶å®ƒæœåŠ¡å™¨å‘é€å¿ƒè·³ä¿¡æ¯ä»¥å»ºç«‹æƒå¨å¹¶ä¸”é˜»æ­¢æ–°çš„é€‰ä¸¾ã€‚<br>While waiting for votes, a candidate may receive an AppendEntries RPC from another server claiming to be leader.<br>
If the leaderâ€™s term (included in its RPC) is at least as large as the candidateâ€™s current term,<br>
then the candidate recognizes the leader as legitimate and returns to follower state.<br>
If the term in the RPC is smaller than the candidateâ€™s current term, then the candidate rejects the RPC and continues in candidate state.<br>åœ¨ç­‰å¾…æŠ•ç¥¨æ—¶ï¼Œä¸€ä¸ªcandidateå¯èƒ½ä¼šæ¥å—åˆ°æ¥è‡ªè‡ªç§°æ˜¯leaderçš„å…¶å®ƒæœåŠ¡å™¨çš„AppendEntries RPCã€‚<br>
å¦‚æœleaderçš„ä»»æœŸ(åŒ…å«åœ¨å®ƒçš„RPCä¸­)å¤§äºæˆ–ç­‰äºcandidateçš„å½“å‰ä»»æœŸï¼Œé‚£ä¹ˆcandidateæ‰¿è®¤è¯¥leaderæ˜¯åˆæ³•çš„å¹¶ä¸”è¿”å›åˆ°followerçŠ¶æ€ã€‚<br>
å¦‚æœRPCä¸­çš„ä»»æœŸå°äºcandidateçš„å½“å‰ä»»æœŸï¼Œcandidateå°†ä¼šæ‹’ç»è¿™ä¸€RPCå¹¶ä¸”ç»§ç»­ä¿æŒcandidateçš„çŠ¶æ€ã€‚<br>The third possible outcome is that a candidate neither wins nor loses the election:<br>
if many followers become candidates at the same time, votes could be split so that no candidate obtains a majority.<br>
When this happens, each candidate will time out and start a new election by incrementing its term<br>
and initiating another round of RequestVote RPCs.<br>
However, without extra measures split votes could repeat indefinitely.<br>ç¬¬ä¸‰ç§å¯èƒ½çš„ç»“æœæ˜¯ä¸€ä¸ªcandidateæ—¢æ²¡æœ‰èµ¢å¾—é€‰ä¸¾ä¹Ÿæ²¡æœ‰è¾“æ‰é€‰ä¸¾ï¼š<br>
å¦‚æœè®¸å¤šfolloweréƒ½åœ¨åŒä¸€æ—¶é—´æˆä¸ºäº†candidateï¼ŒæŠ•ç¥¨å¯èƒ½ä¼šè¢«ç“œåˆ†å¯¼è‡´æ²¡æœ‰candidateè·å¾—å¤§å¤šæ•°çš„é€‰ç¥¨ã€‚<br>
å½“è¿™ç§æƒ…å†µå‘ç”Ÿæ—¶ï¼Œæ¯ä¸€ä¸ªcandidateéƒ½å°†ä¼šè¶…æ—¶å¹¶ä¸”é€šè¿‡å¢åŠ å®ƒçš„ä»»æœŸå€¼å¹¶ä¸”åˆå§‹åŒ–å¦ä¸€è½®çš„RequestVote RPCsä»¥å¼€å§‹ä¸€è½®æ–°çš„é€‰ä¸¾ã€‚<br>
ç„¶è€Œï¼Œå¦‚æœä¸é‡‡å–é¢å¤–çš„æªæ–½ï¼Œåˆ†è£‚çš„æŠ•ç¥¨å¯èƒ½ä¼šæ— é™çš„é‡å¤ã€‚<br>Raft uses randomized election timeouts to ensure that split votes are rare and that they are resolved quickly.<br>
To prevent split votes in the first place, election timeouts are chosen randomly from a fixed interval (e.g., 150â€“300ms).<br>
This spreads out the servers so that in most cases only a single server will time out;<br>
it wins the election and sends heartbeats before any other servers time out.<br>
The same mechanism is used to handle split votes.<br>
Each candidate restarts its randomized election timeout at the start of an election, and it waits for that timeout to elapse before<br>
starting the next election; this reduces the likelihood of another split vote in the new election.<br>
Section 9.3 shows that this approach elects a leader rapidly.<br>Raftä½¿ç”¨éšæœºåŒ–çš„é€‰ä¸¾è¶…æ—¶æ—¶é—´æ¥ç¡®ä¿åˆ†è£‚çš„æŠ•ç¥¨å¾ˆå°‘ä¼šå‘ç”Ÿå¹¶ä½¿å¾—å®ƒä»¬èƒ½å¤Ÿè¢«è¿…é€Ÿçš„è§£å†³ã€‚<br>
ä¸ºäº†é˜²æ­¢ä¸€å¼€å§‹å°±å‡ºç°åˆ†è£‚çš„æŠ•ç¥¨ï¼Œé€‰ä¸¾çš„è¶…æ—¶æ—¶é—´æ˜¯ä»ä¸€ä¸ªå›ºå®šçš„é—´éš”ä¸­è¢«éšæœºé€‰å–çš„(ä¾‹å¦‚150-300ms)ã€‚<br>
è¿™æ‰“æ•£äº†æœåŠ¡å™¨ä½¿å¾—åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹åªæœ‰å•ç‹¬ä¸€ä¸ªæœåŠ¡å™¨å°†ä¼šè¶…æ—¶ï¼›å®ƒèµ¢å¾—é€‰ä¸¾å¹¶ä¸”åœ¨å…¶å®ƒæœåŠ¡å™¨è¶…æ—¶ä¹‹å‰å‘é€å¿ƒè·³(è¯‘è€…æ³¨ï¼šè¶…æ—¶åè‡ªå·±å°±ä¼šåœ¨åˆ«çš„æœåŠ¡å™¨æ²¡ååº”è¿‡æ¥å‰å‘èµ·æ–°ä¸€è½®ä»»æœŸæ›´å¤§çš„æŠ•ç¥¨ï¼Œè®©åˆ«äººéƒ½æŠ•ç»™å®ƒæ¥èµ¢å¾—é€‰ä¸¾)ã€‚<br>
åŒæ ·çš„æœºåˆ¶ä¹Ÿè¢«ç”¨äºè§£å†³åˆ†è£‚çš„æŠ•ç¥¨ã€‚<br>
æ¯ä¸ªcandidateåœ¨ä¸€è½®é€‰ä¸¾å¼€å§‹æ—¶ä¼šé‡æ–°éšæœºçš„è®¾ç½®å…¶é€‰ä¸¾è¶…æ—¶æ—¶é—´ï¼Œå¹¶ä¸”åœ¨ä¸‹ä¸€è½®é€‰ä¸¾å‰ç­‰å¾…ç›´åˆ°è¶…æ—¶ï¼›è¿™å‡å°‘äº†åœ¨æ–°çš„é€‰ä¸¾ä¸­å†ä¸€æ¬¡å‡ºç°åˆ†è£‚æŠ•ç¥¨çš„å¯èƒ½æ€§ã€‚<br>
ç¬¬9.3èŠ‚å±•ç¤ºäº†è¯¥æ–¹æ³•èƒ½è¿…é€Ÿçš„é€‰ä¸¾å‡ºä¸€ä¸ªleaderã€‚<br>Elections are an example of how understandability guided our choice between design alternatives.<br>
Initially we planned to use a ranking system: each candidate was assigned a unique rank, which was used to select between competing candidates.<br>
If a candidate discovered another candidate with higher rank,<br>
it would return to follower state so that the higher ranking candidate could more easily win the next election.<br>
We found that this approach created subtle issues around availability<br>
(a lower-ranked server might need to time out and become a candidate again if a higher-ranked server fails,<br>
but if it does so too soon, it can reset progress towards electing a leader).<br>
We made adjustments to the algorithm several times, but after each adjustment new corner cases appeared.<br>
Eventually we concluded that the randomized retry approach is more obvious and understandable.<br>é€‰ä¸¾æ˜¯ä¸€ä¸ªå¯ç†è§£æ€§å¦‚ä½•æŒ‡å¯¼æˆ‘ä»¬åœ¨å¯é€‰è®¾è®¡é—´è¿›è¡Œé€‰æ‹©çš„ä¾‹å­ã€‚<br>
æœ€åˆï¼Œæˆ‘ä»¬è®¡åˆ’ä½¿ç”¨ç­‰çº§ç³»ç»Ÿ(ranking system)ï¼šæ¯ä¸€ä¸ªcandidateéƒ½è¢«åˆ†é…ä¸€ä¸ªå”¯ä¸€çš„ç­‰çº§ï¼Œå…¶ç”¨äºåœ¨å½¼æ­¤ç«äº‰çš„candidateåšé€‰æ‹©ã€‚<br>
å¦‚æœä¸€ä¸ªcandidateå‘ç°äº†ä¸€ä¸ªå…·æœ‰æ›´é«˜ç­‰çº§çš„candidateï¼Œå®ƒå°†è¿”å›åˆ°followerçŠ¶æ€å› æ­¤æ›´å¥½ç­‰çº§çš„candidateå°†æ›´å®¹æ˜“èµ¢å¾—ä¸‹ä¸€æ¬¡é€‰ä¸¾ã€‚<br>
ä½†æˆ‘ä»¬å‘ç°è¿™ä¸ªæ–¹æ³•åœ¨å¯ç”¨æ€§æ–¹é¢å­˜åœ¨å¾®å¦™çš„é—®é¢˜(å¦‚æœä¸€ä¸ªé«˜ç­‰çº§çš„æœåŠ¡å™¨æ•…éšœäº†ï¼Œåˆ™ä¸€ä¸ªä½ç­‰çº§çš„æœåŠ¡å™¨å¯èƒ½éœ€è¦è¶…æ—¶å¹¶å†æ¬¡æˆä¸ºcandidateï¼Œä½†å¦‚æœè¿™æ ·åšçš„å¤ªæ—©ï¼Œå®ƒå°†ä¼šé‡ç½®é€‰ä¸¾leaderçš„è¿›åº¦)ã€‚<br>
æˆ‘ä»¬å¯¹ç®—æ³•è¿›è¡Œäº†æ•°æ¬¡è°ƒæ•´ï¼Œä½†æ¯æ¬¡è°ƒæ•´åéƒ½å‡ºç°äº†æ–°çš„å›°å¢ƒã€‚<br>
æœ€ç»ˆæˆ‘ä»¬å¾—å‡ºç»“è®ºï¼ŒéšæœºåŒ–é‡è¯•çš„æ–¹æ³•æ›´ç›´è§‚ä¸”æ›´å®¹æ˜“è¢«ç†è§£ã€‚<br><br>Once a leader has been elected, it begins servicing client requests.<br>
Each client request contains a command to be executed by the replicated state machines.<br>
The leader appends the command to its log as a new entry,<br>
then issues AppendEntries RPCs in parallel to each of the other servers to replicate the entry.<br>
When the entry has been safely replicated (as described below),<br>
the leader applies the entry to its state machine and returns the result of that execution to the client.<br>
If followers crash or run slowly, or if network packets are lost,<br>
the leader retries AppendEntries RPCs indefinitely (even after it has responded to the client)<br>
until all followers eventually store all log entries.<br>ä¸€æ—¦ä¸€ä¸ªleaderè¢«é€‰ä¸¾å‡ºæ¥ï¼Œå®ƒå°†å¼€å§‹æœåŠ¡äºå®¢æˆ·ç«¯çš„è¯·æ±‚ã€‚<br>
æ¯ä¸€ä¸ªå®¢æˆ·ç«¯çš„è¯·æ±‚éƒ½åŒ…å«äº†ä¸€ä¸ªè¢«ç”¨äºåœ¨å¤åˆ¶çŠ¶æ€æœºä¸Šæ‰§è¡Œçš„æŒ‡ä»¤ã€‚<br>
leaderå°†æŒ‡ä»¤ä½œä¸ºä¸€ä¸ªæ–°çš„æ¡ç›®è¿½åŠ åˆ°å…¶æ—¥å¿—ä¸­ï¼Œç„¶åå‘å…¶å®ƒçš„æ¯ä¸ªæœåŠ¡å™¨å‘èµ·å¹¶è¡Œçš„AppendEntries RPCä»¤å®ƒä»¬å¤åˆ¶è¿™ä¸€æ¡ç›®ã€‚<br>
å½“æ¡ç›®å·²è¢«å®‰å…¨çš„è¢«å¤åˆ¶(å¦‚ä¸‹æ‰€è¿°)ï¼Œleaderåœ¨å®ƒçš„çŠ¶æ€æœºä¸Šåº”ç”¨è¿™ä¸€æ¡ç›®å¹¶ä¸”å°†æ‰§è¡Œçš„ç»“æœè¿”å›ç»™å®¢æˆ·ç«¯ã€‚<br>
å¦‚æœfollowerå´©æºƒäº†æˆ–è€…è¿è¡Œçš„å¾ˆæ…¢ï¼Œæˆ–è€…ç½‘ç»œä¸¢åŒ…ï¼Œleaderä¼šæ— é™çš„é‡è¯•AppendEntries RPC(å³ä½¿åœ¨å“åº”äº†å®¢æˆ·ç«¯çš„è¯·æ±‚ä¹‹å)ï¼Œ<br>
ç›´åˆ°æ‰€æœ‰çš„followeræœ€ç»ˆéƒ½å­˜å‚¨äº†æ‰€æœ‰çš„æ—¥å¿—æ¡ç›®ã€‚<br><img alt="Pasted image 20240725173038.png" src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raft-åŸå§‹è®ºæ–‡ä¸­è‹±/pasted-image-20240725173038.png"><br>Figure 6: Logs are composed of entries, which are numbered sequentially.<br>
Each entry contains the term in which it was created (the number in each box) and a command for the state machine.<br>
An entry is considered committed if it is safe for that entry to be applied to state machines.<br>å›¾6ï¼šæ—¥å¿—ç”±æŒ‰ç…§é¡ºåºç¼–å·çš„æ¡ç›®ç»„æˆã€‚<br>
æ¯ä¸€ä¸ªæ¡ç›®éƒ½åŒ…å«å®ƒè¢«åˆ›å»ºæ—¶çš„ä»»æœŸ(æ¡†ä¸­çš„æ•°å­—)ä»¥åŠç”¨äºçŠ¶æ€æœºçš„æŒ‡ä»¤ã€‚<br>
å¦‚æœæ¡ç›®å·²ç»å®‰å…¨çš„è¢«ä½œç”¨äºçŠ¶æ€æœºï¼Œåˆ™è¯¥æ¡ç›®è¢«è§†ä¸ºå·²æäº¤ã€‚<br>Logs are organized as shown in Figure 6.<br>
Each log entry stores a state machine command along with the term number when the entry was received by the leader.<br>
The term numbers in log entries are used to detect inconsistencies between logs and to ensure some of the properties in Figure 3.<br>
Each log entry also has an integer index identifying its position in the log.<br>æ—¥å¿—å¦‚å›¾6æ‰€ç¤ºçš„æ–¹å¼è¢«ç»„ç»‡ã€‚<br>
æ¯ä¸€ä¸ªæ—¥å¿—æ¡ç›®å­˜å‚¨äº†ä¸€ä¸ªçŠ¶æ€æœºçš„æŒ‡ä»¤ï¼Œä»¥åŠä»leaderå¤„æ¥å—æ¡ç›®æ—¶çš„ä»»æœŸç¼–å·ã€‚<br>
æ—¥å¿—æ¡ç›®ä¸­çš„ä»»æœŸç¼–å·è¢«ç”¨äºæ£€æµ‹æ—¥å¿—é—´çš„ä¸ä¸€è‡´ï¼Œå¹¶ä¸”ç”¨äºä¿è¯å›¾3ä¸­çš„ä¸€äº›ç‰¹æ€§ã€‚<br>
æ¯ä¸ªæ—¥å¿—æ¡ç›®ä¹Ÿæœ‰ä¸€ä¸ªæ•´æ•°çš„ç´¢å¼•æ ‡è¯†å…¶åœ¨æ—¥å¿—ä¸­çš„ä½ç½®ã€‚<br>The leader decides when it is safe to apply a log entry to the state machines; such an entry is called committed.<br>
Raft guarantees that committed entries are durable and will eventually be executed by all of the available state machines.<br>
A log entry is committed once the leader that created the entry has replicated it on a majority of the servers (e.g., entry 7 in Figure 6).<br>
This also commits all preceding entries in the leaderâ€™s log, including entries created by previous leaders.<br>
Section 5.4 discusses some subtleties when applying this rule after leader changes,<br>
and it also shows that this definition of commitment is safe.<br>
The leader keeps track of the highest index it knows to be committed,<br>
and it includes that index in future AppendEntries RPCs (including heartbeats) so that the other servers eventually find out.<br>
Once a follower learns that a log entry is committed, it applies the entry to its local state machine (in log order).<br>leaderå†³å®šä½•æ—¶èƒ½å®‰å…¨çš„åœ¨çŠ¶æ€æœºä¸Šåº”ç”¨æ—¥å¿—æ¡ç›®ï¼›è¿™æ ·çš„æ¡ç›®è¢«ç§°ä½œå·²æäº¤çš„æ—¥å¿—ã€‚<br>
Raftä¿è¯å·²æäº¤çš„æ¡ç›®éƒ½ä¼šè¢«æŒä¹…åŒ–å¹¶ä¸”æœ€ç»ˆå°†ä¼šåœ¨æ‰€æœ‰å¯ç”¨çš„çŠ¶æ€æœºä¸Šè¢«æ‰§è¡Œã€‚<br>
ä¸€æ—¦è¢«åˆ›å»ºçš„æ¡ç›®è¢«å¤§å¤šæ•°æœåŠ¡å™¨æ‰€å¤åˆ¶ï¼Œleaderå°±ä¼šå°†å…¶æäº¤(ä¾‹å¦‚ï¼Œå›¾6ä¸­çš„æ¡ç›®7)ã€‚<br>
åŒæ—¶ä¹Ÿä¼šæäº¤leaderæ—¥å¿—ä¸­æ›´æ—©ä¹‹å‰çš„æ‰€æœ‰æ¡ç›®ï¼Œå…¶ä¸­åŒ…æ‹¬è¢«å‰ä»»leaderä»¬æ‰€åˆ›å»ºçš„æ¡ç›®ã€‚<br>
ç¬¬5.4èŠ‚è®¨è®ºäº†åœ¨leaderå˜æ›´æ—¶åº”ç”¨è¿™ä¸€è§„åˆ™çš„å¾®å¦™ä¹‹å¤„ï¼ŒåŒæ—¶å®ƒä¹Ÿè¯æ˜äº†æ‰€æ‰¿è¯ºçš„å®šä¹‰æ˜¯å®‰å…¨çš„ã€‚<br>
leaderæŒç»­çš„è·Ÿè¸ªå®ƒå·²çŸ¥çš„è¢«æäº¤æ—¥å¿—çš„æœ€å¤§ç´¢å¼•å€¼ï¼Œå¹¶ä¸”å°†ç´¢å¼•å€¼åŒ…å«åœ¨æœªæ¥çš„AppendEntries RPCä¸­(åŒ…æ‹¬å¿ƒè·³)ï¼Œä»¥ä¾¿å…¶å®ƒçš„æœåŠ¡å™¨æœ€ç»ˆèƒ½çŸ¥é“(æœ€å¤§ç¼–å·çš„å·²æäº¤ç´¢å¼•)ã€‚<br>
ä¸€æ—¦ä¸€ä¸ªfollowerçŸ¥é“ä¸€ä¸ªæ—¥å¿—æ¡ç›®å·²è¢«æäº¤ï¼Œå®ƒä¾¿å°†è¿™ä¸€æ¡ç›®åº”ç”¨äºæœ¬åœ°çš„çŠ¶æ€æœº(åŸºäºæ—¥å¿—çš„é¡ºåº)ã€‚<br>We designed the Raft log mechanism to maintain a high level of coherency between the logs on different servers.<br>
Not only does this simplify the systemâ€™s behavior and make it more predictable, but it is an important component of ensuring safety.<br>
Raft maintains the following properties, which together constitute the Log Matching Property in Figure 3:<br>
<br>If two entries in different logs have the same index and term, then they store the same command.
<br>If two entries in different logs have the same index and term, then the logs are identical in all preceding entries.
<br>æˆ‘ä»¬è®¾è®¡äº†Raftæ—¥å¿—æœºåˆ¶ï¼Œå…¶ç”¨äºç»´æŒä¸åŒæœåŠ¡å™¨ä¹‹é—´æ—¥å¿—çš„é«˜åº¦ä¸€è‡´ã€‚<br>
å…¶ä¸ä»…ä»…ç®€åŒ–äº†ç³»ç»Ÿçš„è¡Œä¸ºï¼Œè¿˜ä½¿å¾—å®ƒæ›´åŠ çš„å¯é¢„æµ‹ï¼ŒåŒæ—¶è¿™ä¹Ÿæ˜¯ç¡®ä¿å®‰å…¨æ€§çš„é‡è¦éƒ¨åˆ†ã€‚<br>
Raftç»´æŠ¤ç€ä»¥ä¸‹ç‰¹æ€§ï¼Œè¿™äº›ç‰¹æ€§ä¸€å¹¶ç»„æˆäº†å›¾3ä¸­çš„æ—¥å¿—åŒ¹é…ç‰¹æ€§(Log Matching Property)ï¼š<br>
<br>å¦‚æœä¸åŒæ—¥å¿—ä¸­çš„ä¸¤ä¸ªæ¡ç›®æœ‰ç€ç›¸åŒçš„ç´¢å¼•å€¼å’Œä»»æœŸï¼Œåˆ™å®ƒä»¬å­˜å‚¨ç€ç›¸åŒçš„æŒ‡ä»¤ã€‚
<br>å¦‚æœä¸åŒæ—¥å¿—ä¸­çš„ä¸¤ä¸ªæ¡ç›®æœ‰ç€ç›¸åŒçš„ç´¢å¼•å€¼å’Œä»»æœŸï¼Œåˆ™è¯¥æ—¥å¿—ä¹‹å‰çš„æ‰€æœ‰æ¡ç›®ä¹Ÿéƒ½æ˜¯å®Œå…¨ç›¸åŒçš„ã€‚
<br>The first property follows from the fact that a leader creates at most one entry with a given log index in a given term,<br>
and log entries never change their position in the log.<br>
The second property is guaranteed by a simple consistency check performed by AppendEntries.<br>
When sending an AppendEntries RPC, the leader includes the index and term of the entry in its log that immediately precedes the new entries.<br>
If the follower does not find an entry in its log with the same index and term, then it refuses the new entries.<br>
The consistency check acts as an induction step: the initial empty state of the logs satisfies the Log Matching Property,<br>
and the consistency check preserves the Log Matching Property whenever logs are extended.<br>
As a result, whenever AppendEntries returns successfully,<br>
the leader knows that the followerâ€™s log is identical to its own log up through the new entries.<br>ç¬¬ä¸€ä¸ªç‰¹æ€§æºè‡ªè¿™æ ·ä¸€ä¸ªäº‹å®ï¼Œå³ä¸€ä¸ªleaderåªä¼šåœ¨ç‰¹å®šä»»æœŸå†…çš„æŸä¸€ç´¢å¼•å€¼ä¸‹æœ€å¤šåªä¼šåˆ›å»ºä¸€ä¸ªæ¡ç›®ï¼Œå¹¶ä¸”æ—¥å¿—æ¡ç›®åœ¨æ—¥å¿—ä¸­çš„ä½ç½®æ˜¯æ°¸è¿œä¸ä¼šæ”¹å˜çš„ã€‚<br>
ç¬¬äºŒä¸ªç‰¹æ€§åˆ™ç”±AppendEntriesæ‰§è¡Œä¸€ä¸ªç®€å•çš„ä¸€è‡´æ€§æ£€æŸ¥æ¥ä¿è¯ã€‚<br>
å½“å‘é€AppendEntries RPCæ—¶ï¼Œleaderå°†å‰ä¸€ä¸ªæ¡ç›®çš„ç´¢å¼•å’Œä»»æœŸåŒ…å«åœ¨æ–°æ¡ç›®ä¸­ã€‚<br>
å¦‚æœfolloweræ²¡æœ‰æ‰¾åˆ°ä¸€ä¸ªå…·æœ‰ç›¸åŒç´¢å¼•å€¼å’Œä»»æœŸçš„æ—¥å¿—æ¡ç›®ï¼Œåˆ™å®ƒå°†æ‹’ç»è¿™ä¸€æ–°æ¡ç›®ã€‚<br>
ä¸€è‡´æ€§æ£€æŸ¥å°±åƒä¸€ä¸ªå½’çº³çš„æ­¥éª¤:åˆå§‹åŒ–æ—¶çš„ç©ºçŠ¶æ€æ»¡è¶³æ—¥å¿—åŒ¹é…çš„ç‰¹æ€§(Log Matching Property)ï¼Œå¹¶ä¸”æ¯å½“æ‰©å±•æ—¥å¿—æ—¶ï¼Œä¸€è‡´æ€§æ£€æŸ¥éƒ½ä¼šç»´æŒæ—¥å¿—åŒ¹é…çš„ç‰¹æ€§ã€‚<br>
å› æ­¤ï¼Œæ¯å½“AppendEntriesè¿”å›æˆåŠŸæ—¶ï¼Œé€šè¿‡æ–°çš„æ¡ç›®leaderå°±çŸ¥é“followerçš„æ—¥å¿—ä¸leaderè‡ªå·±çš„æ˜¯å®Œå…¨ä¸€è‡´çš„ï¼Œ<br>During normal operation, the logs of the leader and followers stay consistent,<br>
so the AppendEntries consistency check never fails.<br>
However, leader crashes can leave the logs inconsistent (the old leader may not have fully replicated all of the entries in its log).<br>
These inconsistencies can compound over a series of leader and follower crashes.<br>
Figure 7 illustrates the ways in which followersâ€™ logs may differ from that of a new leader.<br>
A follower may be missing entries that are present on the leader, it may have extra entries that are not present on the leader, or both.<br>
Missing and extraneous entries in a log may span multiple terms.<br>åœ¨æ­£å¸¸æ“ä½œæœŸé—´ï¼Œleaderå’Œfollowerçš„æ—¥å¿—å§‹ç»ˆä¿æŒä¸€è‡´ï¼Œå› æ­¤AppendEntriesçš„ä¸€è‡´æ€§æ£€æŸ¥ä»æ¥ä¸ä¼šå¤±è´¥ã€‚<br>
ç„¶è€Œï¼Œleaderå¥”æºƒä¼šå¯¼è‡´æ—¥å¿—çš„ä¸ä¸€è‡´(è€çš„leaderå¯èƒ½æ²¡æœ‰å°†å®ƒæ‰€æœ‰çš„æ—¥å¿—æ¡ç›®å®Œå…¨å¤åˆ¶å®Œæˆ)ã€‚<br>
è¿™äº›ä¸ä¸€è‡´å¯èƒ½ä¼šéšç€ä¸€ç³»åˆ—çš„leaderå’Œfollowerçš„å´©æºƒè€ŒåŠ å‰§ã€‚<br>
å›¾7è¯´æ˜äº†followeræ—¥å¿—å¯èƒ½ä¸æ–°leaderä¸åŒçš„æ–¹å¼ã€‚<br>
ä¸€ä¸ªFollowerå¯èƒ½ç¼ºå°‘äº†ä¹‹å‰leaderä¸­æ‰æœ‰çš„æ¡ç›®ï¼Œä¹Ÿå¯èƒ½æ‹¥æœ‰ä¸€äº›åœ¨æ–°leaderä¸­ä¸å­˜åœ¨çš„é¢å¤–çš„æ¡ç›®ï¼Œæˆ–è€…è¿™ä¸¤ç§æ–¹å¼çš†æœ‰ã€‚<br>
ç¼ºå¤±çš„æˆ–è€…é¢å¤–å¤šå‡ºçš„æ¡ç›®å¯èƒ½æ¶‰åŠåˆ°å¤šä¸ªä»»æœŸã€‚<br><img alt="Pasted image 20240725173049.png" src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raft-åŸå§‹è®ºæ–‡ä¸­è‹±/pasted-image-20240725173049.png"><br>Figure 7: When the leader at the top comes to power, it is possible that any of scenarios (aâ€“f) could occur in follower logs.<br>
Each box represents one log entry; the number in the box is its term.<br>
A follower may be missing entries (aâ€“b), may have extra uncommitted entries (câ€“d), or both (eâ€“f).<br>
For example, scenario (f) could occur if that server was the leader for term 2, added several entries to its log,<br>
then crashed before committing any of them; it restarted quickly, became leader for term 3, and added a few more entries to its log;<br>
before any of the entries in either term 2 or term 3 were committed, the server crashed again and remained down for several terms.<br>å›¾7ï¼šå½“leaderè·å¾—æœ€é«˜æƒåŠ›ä¸Šå°æ—¶ï¼Œä»¥ä¸‹ä»»ä½•ä¸€ç§æƒ…å†µ(a-f)éƒ½å¯èƒ½å‡ºç°åœ¨followerçš„æ—¥å¿—ä¸­ã€‚<br>
æ¯ä¸€ä¸ªæ¡†è¡¨ç¤ºä¸€ä¸ªæ—¥å¿—æ¡ç›®ï¼›æ¡†ä¸­çš„æ•°å­—æ˜¯å®ƒçš„ä»»æœŸã€‚<br>
followerå¯èƒ½ä¼šç¼ºå°‘ä¸€äº›æ¡ç›®(a-b)ï¼Œå¯èƒ½æœ‰ä¸€äº›é¢å¤–çš„æœªæäº¤çš„æ¡ç›®(c-d),æˆ–è€…ä¸¤ç§æƒ…å†µçš†æœ‰(e-f)ã€‚<br>
ä¾‹å¦‚ï¼Œå¦‚æœä¸€ä¸ªæœåŠ¡å™¨æ˜¯ä»»æœŸ2çš„leaderï¼Œå…¶å¢åŠ äº†ä¸€äº›æ¡ç›®åˆ°å®ƒä»¬çš„æ—¥å¿—ä¸­ï¼Œç„¶ååœ¨æäº¤è¿™äº›æ—¥å¿—æ¡ç›®ä¹‹å‰å´©æºƒäº†;<br>
å®ƒå¾ˆå¿«é‡æ–°å¯åŠ¨ï¼Œæˆä¸ºäº†ä»»æœŸ3çš„leaderï¼Œå¹¶ä¸”å¢åŠ äº†å‡ ä¸ªæ¡ç›®åˆ°å®ƒçš„æ—¥å¿—ä¸­ï¼Œåœ¨æäº¤ä»»æœŸ2æˆ–è€…ä»»æœŸ3ä¸­çš„ä»»ä½•ä¸€ä¸ªæ¡ç›®ä¹‹å‰ï¼Œè¿™ä¸ªæœåŠ¡å™¨å†æ¬¡å´©æºƒå¹¶ä¸”åœ¨åå‡ ä¸ªä»»æœŸå†…ä¸€ç›´å¤„äºåœæœºçŠ¶æ€ï¼Œ<br>
åˆ™ä¼šå‘ç”Ÿæƒ…å†µ(f);<br>In Raft, the leader handles inconsistencies by forcing the followersâ€™ logs to duplicate its own.<br>
This means that conflicting entries in follower logs will be overwritten with entries from the leaderâ€™s log.<br>
Section 5.4 will show that this is safe when coupled with one more restriction.<br>åœ¨Raftä¸­ï¼Œleaderé€šè¿‡å¼ºåˆ¶followerå¤åˆ¶å®ƒçš„æ—¥å¿—æ¥å¤„ç†ä¸ä¸€è‡´é—®é¢˜ã€‚<br>
è¿™æ„å‘³ç€followerä¸­å­˜åœ¨å†²çªçš„æ—¥å¿—æ¡ç›®å°†ä¼šè¢«æ¥è‡ªleaderçš„æ—¥å¿—ç»™è¦†ç›–ã€‚<br>
ç¬¬5.4èŠ‚å°†å±•ç¤ºåœ¨åŠ ä¸Šä¸€ä¸ªé™åˆ¶æ—¶ï¼Œè¿™å°†ä¼šæ˜¯å®‰å…¨çš„ã€‚<br>To bring a followerâ€™s log into consistency with its own, the leader must find the latest log entry where the two logs agree,<br>
delete any entries in the followerâ€™s log after that point, and send the follower all of the leaderâ€™s entries after that point.<br>
All of these actions happen in response to the consistency check performed by AppendEntries RPCs.<br>
The leader maintains a nextIndex for each follower, which is the index of the next log entry the leader will send to that follower.<br>
When a leader first comes to power, it initializes all nextIndex values to the index just after the last one in its log (11 in Figure 7).<br>
If a followerâ€™s log is inconsistent with the leaderâ€™s,<br>
the AppendEntries consistency check will fail in the next AppendEntries RPC.<br>
After a rejection, the leader decrements nextIndex and retries the AppendEntries RPC.<br>
Eventually nextIndex will reach a point where the leader and follower logs match.<br>
When this happens, AppendEntries will succeed,<br>
which removes any conflicting entries in the followerâ€™s log and appends entries from the leaderâ€™s log (if any).<br>
Once AppendEntries succeeds, the followerâ€™s log is consistent with the leaderâ€™s, and it will remain that way for the rest of the term.<br>ä¸ºäº†ä½¿å¾—followerçš„æ—¥å¿—ä¸è‡ªå·±çš„ä¿æŒä¸€è‡´ï¼Œleaderå¿…é¡»æ‰¾åˆ°ä¸¤ä¸ªæ—¥å¿—ä¸­ä¸€è‡´çš„æ¡ç›®ä¸­æœ€æ–°çš„é‚£ä¸ªï¼Œ<br>
åˆ é™¤followeræ—¥å¿—ä¸­ä½äºè¯¥ç‚¹ä½ä¹‹åçš„æ‰€æœ‰æ¡ç›®ï¼Œå¹¶ä¸”å°†leaderåœ¨è¯¥ç‚¹ä½åçš„æ‰€æœ‰æ¡ç›®å‘é€ç»™followerã€‚<br>
æ‰€æœ‰çš„è¿™äº›åŠ¨ä½œéƒ½å‘ç”Ÿåœ¨å¯¹AppendEntries RPCçš„ä¸€è‡´æ€§æ£€æŸ¥å·¥ä½œçš„å“åº”ä¸­ã€‚<br>
leaderä¸ºæ¯ä¸€ä¸ªfollowerç»´æŠ¤äº†ä¸€ä¸ªnextIndex,è¿™æ˜¯leaderå°†å‘é€ç»™followerçš„ä¸‹ä¸€ä¸ªæ—¥å¿—æ¡ç›®çš„ç´¢å¼•ç¼–å·ã€‚<br>
å½“leaderç¬¬ä¸€æ¬¡æŒæƒæ—¶ï¼Œå…¶å°†æ‰€æœ‰çš„nextIndexçš„å€¼åˆå§‹åŒ–ä¸ºå…¶æœ€åä¸€ä¸ªæ—¥å¿—ç´¢å¼•å€¼å†åŠ 1(å›¾7ä¸­çš„11)ã€‚<br>
å¦‚æœfollowerçš„æ—¥å¿—ä¸leaderçš„ä¸ä¸€è‡´ï¼ŒAppendEntriesçš„ä¸€è‡´æ€§æ£€æŸ¥å°†ä¼šåœ¨ä¸‹ä¸€æ¬¡AppendEntries RPCä¸­å¤±è´¥ã€‚<br>
åœ¨ä¸€æ¬¡æ‹’ç»åï¼Œleaderå°†ä¼šé€’å‡nextIndexå¹¶ä¸”é‡è¯•AppendEntries RPCã€‚<br>
æœ€ç»ˆnextIndexå°†ä¼šåˆ°è¾¾ä¸€ä¸ªleaderä¸followerçš„æ—¥å¿—æƒ³åŒ¹é…çš„ç‚¹ä½ã€‚<br>
å½“è¿™ä¸€æƒ…å†µå‘ç”Ÿæ—¶ï¼ŒAppendEntrieså°†ä¼šæˆåŠŸï¼Œå…¶å°†åˆ é™¤followeræ—¥å¿—ä¸­çš„æ‰€æœ‰å†²çªçš„æ¡ç›®å¹¶ä¸”è¿½åŠ æ¥è‡ªleaderæ—¥å¿—ä¸­çš„æ¡ç›®(å¦‚æœéœ€è¦çš„è¯)ã€‚<br>
ä¸€æ—¦AppendEntriesæˆåŠŸï¼Œfollowerçš„æ—¥å¿—å°†ä¼šä¸leaderä¸€è‡´ï¼Œå¹¶ä¸”åœ¨æœ¬ä»»æœŸå†…æ¥ä¸‹æ¥çš„æ—¶é—´å†…ä¿æŒä¸€è‡´ã€‚<br>If desired, the protocol can be optimized to reduce the number of rejected AppendEntries RPCs.<br>
For example, when rejecting an AppendEntries request,<br>
the follower can include the term of the conflicting entry and the first index it stores for that term.<br>
With this information, the leader can decrement nextIndex to bypass all of the conflicting entries in that term;<br>
one AppendEntries RPC will be required for each term with conflicting entries, rather than one RPC per entry.<br>
In practice, we doubt this optimization is necessary,<br>
since failures happen infrequently and it is unlikely that there will be many inconsistent entries.<br>å¦‚æœæœ‰éœ€è¦çš„è¯ï¼Œåè®®å¯ä»¥é€šè¿‡å‡å°‘è¢«æ‹’ç»çš„AppendEntries RPCsæ•°é‡æ¥è¿›è¡Œä¼˜åŒ–ã€‚<br>
ä¾‹å¦‚ï¼Œå½“ä¸€æ¬¡AppendEntriesè¯·æ±‚è¢«æ‹’ç»æ—¶ï¼Œfollowerå¯ä»¥å°†åŒ…å«å¯¹åº”ä»»æœŸçš„å†²çªæ¡ç›®å’Œå­˜å‚¨äº†å¯¹åº”ä»»æœŸçš„ç¬¬ä¸€ä¸ªç´¢å¼•å€¼è¿”å›ç»™leaderã€‚<br>
æœ‰äº†è¿™äº›ä¿¡æ¯ï¼Œleaderé€’å‡nextIndexæ¥é¿å¼€å¯¹åº”ä»»æœŸå†…çš„æ‰€æœ‰å†²çªçš„æ¡ç›®;å¯¹äºæ¯ä¸€ä¸ªä»»æœŸçš„å†²çªæ¡ç›®ï¼Œå°†åªéœ€è¦ä¸€æ¬¡AppendEntries RPCï¼Œè€Œä¸æ˜¯ä¸€æ¬¡RPC(å¤„ç†)ä¸€ä¸ªæ¡ç›®ã€‚<br>
åœ¨å®è·µä¸­ï¼Œæˆ‘ä»¬æ€€ç–‘è¿™ä¸€ä¼˜åŒ–æ˜¯å¦æ˜¯å¿…è¦çš„ï¼Œå› ä¸ºå¾ˆå°‘å‘ç”Ÿæ•…éšœå¹¶ä¸”ä¸å¤ªå¯èƒ½æœ‰å¾ˆå¤šä¸ä¸€è‡´çš„æ¡ç›®ã€‚<br>With this mechanism, a leader does not need to take any special actions to restore log consistency when it comes to power.<br>
It just begins normal operation, and the logs automatically converge in response to failures of the AppendEntries consistency check.<br>
A leader never overwrites or deletes entries in its own log (the Leader Append-Only Property in Figure 3).<br>æœ‰äº†è¿™ä¸€æœºåˆ¶ï¼Œleaderå°†ä¸éœ€è¦åœ¨æŒæƒæ—¶ä½¿ç”¨ä»»ä½•ç‰¹åˆ«çš„æ–¹æ³•æ¥æ¢å¤æ—¥å¿—çš„ä¸€è‡´æ€§ã€‚<br>
å®ƒåªæ˜¯å¼€å§‹è¿›è¡Œæ­£å¸¸çš„æ“ä½œï¼Œæ—¥å¿—ä¾¿ä¼šåœ¨å“åº”AppendEntriesçš„ä¸€è‡´æ€§æ£€æŸ¥æ—¶è‡ªåŠ¨çš„è¶‹äºä¸€è‡´ã€‚<br>
leaderä»æ¥ä¸ä¼šè¦†ç›–æˆ–è€…åˆ é™¤å®ƒè‡ªå·±çš„æ—¥å¿—(å›¾3ä¸­leaderçš„Append-Onlyç‰¹æ€§)ã€‚<br>This log replication mechanism exhibits the desirable consensus properties described in Section 2:<br>
Raft can accept, replicate, and apply new log entries as long as a majority of the servers are up;<br>
in the normal case a new entry can be replicated with a single round of RPCs to a majority of the cluster;<br>
and a single slow follower will not impact performance.<br>è¿™ä¸€æ—¥å¿—å¤åˆ¶æœºåˆ¶å±•ç¤ºäº†ç¬¬2èŠ‚ä¸­æ‰€æè¿°çš„ç†æƒ³çš„ä¸€è‡´æ€§ç‰¹æ€§ã€‚<br>
åªè¦å¤§å¤šæ•°æœåŠ¡å™¨æ˜¯åœ¨çº¿çš„ï¼ŒRaftä¾¿èƒ½æ¥æ”¶ï¼Œå¤åˆ¶å¹¶ä¸”åº”ç”¨æ–°çš„æ—¥å¿—æ¡ç›®ï¼›<br>
åœ¨æ­£å¸¸æƒ…å†µä¸‹ä¸€ä¸ªæ–°çš„æ¡ç›®å¯ä»¥é€šè¿‡å•è½®çš„RPCå¤åˆ¶åˆ°é›†ç¾¤ä¸­çš„å¤§å¤šæ•°æœåŠ¡å™¨ä¸Š;å¹¶ä¸”å•ç‹¬çš„æ…¢é€Ÿçš„followerå°†ä¸ä¼šå½±å“æ€§èƒ½ã€‚<br><br>The previous sections described how Raft elects leaders and replicates log entries.<br>
However, the mechanisms described so far are not quite sufficient to ensure<br>
that each state machine executes exactly the same commands in the same order.<br>
For example, a follower might be unavailable while the leader commits several log entries,<br>
then it could be elected leader and overwrite these entries with new ones;<br>
as a result, different state machines might execute different command sequences.<br>å‰é¢çš„ç« èŠ‚æè¿°äº†Raftæ˜¯å¦‚ä½•é€‰ä¸¾leaderå’Œå¤åˆ¶æ—¥å¿—æ¡ç›®çš„ã€‚<br>
ç„¶è€Œï¼Œç›®å‰ä¸ºæ­¢å·²æè¿°çš„æœºåˆ¶è¿˜ä¸è¶³ä»¥ç¡®ä¿æ¯ä¸€ä¸ªçŠ¶æ€æœºä»¥ç›¸åŒçš„é¡ºåºå‡†ç¡®åœ°æ‰§è¡Œç›¸åŒçš„æŒ‡ä»¤ã€‚<br>
ä¾‹å¦‚ï¼Œå½“leaderæäº¤äº†å‡ ä¸ªæ—¥å¿—æ¡ç›®åä¸€ä¸ªfollowerå¯èƒ½ä¼šå˜å¾—ä¸å¯ç”¨ï¼Œéšåfollowerå¯ä»¥è¢«é€‰ä¸¾ä¸ºleaderå¹¶ä¸”ç”¨æ–°çš„æ¡ç›®è¦†ç›–è¿™äº›æ¡ç›®ï¼›<br>
å› æ­¤ï¼Œä¸åŒçš„çŠ¶æ€æœºå¯èƒ½ä¼šæ‰§è¡Œä¸åŒçš„æŒ‡ä»¤åºåˆ—ã€‚<br>This section completes the Raft algorithm by adding a restriction on which servers may be elected leader.<br>
The restriction ensures that the leader for any given term contains all of the entries committed in previous terms<br>
(the Leader Completeness Property from Figure 3).<br>
Given the election restriction, we then make the rules for commitment more precise.<br>
Finally, we present a proof sketch for the Leader Completeness Property<br>
and show how it leads to correct behavior of the replicated state machine.<br>è¿™ä¸€èŠ‚é€šè¿‡å¢åŠ ä¸€ä¸ªå¯¹å“ªäº›æœåŠ¡å™¨å¯ä»¥è¢«é€‰ä¸¾ä¸ºleaderçš„é™åˆ¶æ¥å®Œå–„Raftç®—æ³•ã€‚<br>
è¯¥é™åˆ¶ç¡®ä¿leaderå¯¹äºç»™å®šçš„ä»»æœŸï¼Œå…¶åŒ…å«äº†æ‰€æœ‰ä¹‹å‰ä»»æœŸçš„å·²æäº¤æ¡ç›®ï¼ˆå›¾3ä¸­çš„leader Completenessç‰¹æ€§ï¼‰ã€‚<br>
æœ‰äº†é€‰ä¸¾çš„é™åˆ¶ï¼Œæˆ‘ä»¬ä¹Ÿä½¿å¾—å…³äºæäº¤çš„è§„åˆ™å˜å¾—æ›´åŠ æ¸…æ™°ã€‚<br>
æœ€åï¼Œæˆ‘ä»¬ç»™å‡ºäº†å…³äºLeader Completenessçš„ç®€è¦è¯æ˜ï¼Œå¹¶ä¸”å±•ç¤ºäº†å®ƒæ˜¯å¦‚ä½•è®©å¤åˆ¶çŠ¶æ€æœºæ‰§è¡Œæ­£ç¡®è¡Œä¸ºçš„ã€‚<br><br>In any leader-based consensus algorithm, the leader must eventually store all of the committed log entries.<br>
In some consensus algorithms, such as Viewstamped Replication [22],<br>
a leader can be elected even if it doesnâ€™t initially contain all of the committed entries.<br>
These algorithms contain additional mechanisms to identify the missing entries and transmit them to the new leader,<br>
either during the election process or shortly afterwards.<br>
Unfortunately, this results in considerable additional mechanism and complexity.<br>
Raft uses a simpler approach where it guarantees<br>
that all the committed entries from previous terms are present on each new leader from the moment of its election,<br>
without the need to transfer those entries to the leader.<br>
This means that log entries only flow in one direction, from leaders to followers,<br>
and leaders never overwrite existing entries in their logs.<br>åœ¨ä»»ä½•åŸºäºleaderçš„ä¸€è‡´æ€§ç®—æ³•ä¸­ï¼Œleaderå¿…é¡»æœ€ç»ˆå­˜å‚¨æ‰€æœ‰å·²æäº¤çš„æ—¥å¿—æ¡ç›®ã€‚<br>
åœ¨ä¸€äº›ä¸€è‡´æ€§ç®—æ³•ä¸­ï¼Œä¾‹å¦‚Viewstamped Replicationï¼Œä¸€ä¸ªleaderå³ä½¿æœ€åˆä¸åŒ…å«æ‰€æœ‰å·²æäº¤çš„æ¡ç›®ä¹Ÿèƒ½è¢«é€‰ä¸¾ä¸ºleaderã€‚<br>
è¿™äº›ç®—æ³•åŒ…å«äº†é¢å¤–çš„æœºåˆ¶æ¥è¯†åˆ«ç¼ºå¤±çš„æ¡ç›®å¹¶åœ¨é€‰ä¸¾è¿‡ç¨‹ä¸­æˆ–é€‰ä¸¾åä¸ä¹…å°†å…¶ä¼ è¾“ç»™æ–°çš„leaderã€‚<br>
ä¸å¹¸çš„æ˜¯ï¼Œè¿™å¸¦æ¥äº†éå¸¸å¤šçš„é¢å¤–æœºåˆ¶å’Œå¤æ‚æ€§ã€‚<br>
Raftä½¿ç”¨äº†ä¸€ç§æ›´ç®€å•çš„æ–¹æ³•æ¥ç¡®ä¿æ¯ä¸€ä¸ªæ–°çš„leaderå½“é€‰æ—¶éƒ½æ‹¥æœ‰ä¹‹å‰ä»»æœŸçš„æ‰€æœ‰å·²æäº¤çš„æ¡ç›®ï¼Œè€Œæ— éœ€ä¼ è¾“è¿™äº›æ¡ç›®ç»™leaderã€‚<br>
è¿™æ„å‘³ç€æ—¥å¿—æ¡ç›®åªä¼šå•æ–¹å‘çš„ä»leaderå‘followeræµåŠ¨ï¼Œå¹¶ä¸”leaderä»ä¸è¦†ç›–å®ƒä»¬å·²å­˜åœ¨çš„æ¡ç›®ã€‚<br>Raft uses the voting process to prevent a candidate from winning an election unless its log contains all committed entries.<br>
A candidate must contact a majority of the cluster in order to be elected,<br>
which means that every committed entry must be present in at least one of those servers.<br>
If the candidateâ€™s log is at least as up-to-date as any other log in that majority<br>
(where â€œup-to-dateâ€ is defined precisely below), then it will hold all the committed entries.<br>
The RequestVote RPC implements this restriction: the RPC includes information about the candidateâ€™s log,<br>
and the voter denies its vote if its own log is more up-to-date than that of the candidate.<br>Raftä½¿ç”¨æŠ•ç¥¨æœºåˆ¶æ¥é˜²æ­¢ä¸åŒ…å«æ‰€æœ‰å·²æäº¤æ¡ç›®çš„candidateèµ¢å¾—é€‰ä¸¾ã€‚<br>
ä¸€ä¸ªcandidateå¿…é¡»ä¸é›†ç¾¤ä¸­çš„å¤§å¤šæ•°æˆå‘˜è”ç³»åæ‰èƒ½å½“é€‰ï¼Œè¿™æ„å‘³ç€æ¯ä¸ªæäº¤çš„æ¡ç›®å¿…é¡»è‡³å°‘å­˜åœ¨äºå…¶ä¸­çš„è‡³å°‘ä¸€ä¸ªæœåŠ¡å™¨ä¸­ã€‚<br>
å¦‚æœcandidateçš„æ—¥å¿—è‡³å°‘å’Œå…¶å®ƒå¤§å¤šæ•°çš„æ—¥å¿—ä¸€æ ·æ–°(ä½•ä¸º"æœ€æ–°"(up-to-date)å°†åœ¨ä¸‹é¢è¢«å®šä¹‰)ï¼Œåˆ™å®ƒå°†æŒæœ‰æ‰€æœ‰å·²æäº¤çš„æ¡ç›®ã€‚<br>
RequestVote RPCä¸­å®ç°äº†ä¹‹ä¸€é™åˆ¶ï¼šRPCåŒ…æ‹¬äº†candidateçš„æ—¥å¿—ä¿¡æ¯ï¼Œå¹¶ä¸”å¦‚æœcandidateçš„æ—¥å¿—ä¸å¦‚æŠ•ç¥¨äºº(voter)çš„æ—¥å¿—æ–°ï¼Œåˆ™voterå°†æ‹’ç»æŠ•ç¥¨ç»™è¯¥candidateã€‚<br>Raft determines which of two logs is more up-to-date by comparing the index and term of the last entries in the logs.<br>
If the logs have last entries with different terms, then the log with the later term is more up-to-date.<br>
If the logs end with the same term, then whichever log is longer is more up-to-date.<br>Rafté€šè¿‡æ¯”è¾ƒä¸¤ä¸ªæ—¥å¿—ä¸­æœ€åä¸€ä¸ªæ¡ç›®çš„ç´¢å¼•å’Œä»»æœŸæ¥å†³å®šè°æ˜¯æœ€æ–°çš„ã€‚<br>
å¦‚æœä¸¤ä¸ªæ—¥å¿—ä¸­æœ€åçš„æ¡ç›®æœ‰ç€ä¸åŒçš„ä»»æœŸï¼Œåˆ™ä»»æœŸè¾ƒåçš„æ—¥å¿—æ˜¯æ›´æ–°çš„ã€‚<br>
å¦‚æœä¸¤ä¸ªæ—¥å¿—ä¸­æœ€åçš„æ¡ç›®æœ‰ç€ç›¸åŒçš„ä»»æœŸï¼Œåˆ™è¾ƒé•¿çš„(æ³¨ï¼šç´¢å¼•å€¼æ›´å¤§çš„)é‚£ä¸ªæ—¥å¿—æ˜¯æ›´æ–°çš„ã€‚<br><br>As described in Section 5.3, a leader knows that an entry from its current term is committed once<br>
that entry is stored on a majority of the servers.<br>
If a leader crashes before committing an entry, future leaders will attempt to finish replicating the entry.<br>
However, a leader cannot immediately conclude that an entry from a previous term is committed once it is stored on a majority of servers.<br>
Figure 8 illustrates a situation where an old log entry is stored on a majority of servers,<br>
yet can still be overwritten by a future leader.<br>å¦‚5.3èŠ‚æ‰€æè¿°çš„é‚£æ ·ï¼Œleaderä¸€æ—¦çŸ¥é“å½“å‰ä»»æœŸå†…çš„ä¸€ä¸ªæ¡ç›®è¢«å­˜å‚¨åœ¨äº†å¤§å¤šæ•°çš„æœåŠ¡å™¨ä¸­ï¼Œå°±ä¼šå°†å…¶æäº¤ã€‚<br>
å¦‚æœleaderåœ¨æäº¤ä¸€ä¸ªæ¡ç›®å‰å´©æºƒäº†ï¼Œæœªæ¥çš„leaderå°†è¯•å›¾å»å®Œæˆè¯¥æ¡ç›®çš„å¤åˆ¶ã€‚<br>
ç„¶è€Œï¼Œleaderæ— æ³•ç«‹å³å¾—å‡ºç»“è®ºï¼Œå³ä¸€ä¸ªæ¥è‡ªä¹‹å‰ä»»æœŸçš„æ¡ç›®ä¸€æ—¦è¢«å¤§å¤šæ•°æœåŠ¡å™¨æ‰€å­˜å‚¨å°±æ˜¯å·²è¢«æäº¤çš„ã€‚<br>
å›¾8å±•ç¤ºäº†è¿™æ ·ä¸€ç§æƒ…å†µï¼Œä¸€ä¸ªè€çš„æ—¥å¿—æ¡ç›®è¢«å­˜å‚¨åœ¨äº†å¤§å¤šæ•°çš„æœåŠ¡å™¨ä¸Šï¼Œä½†ä»»ç„¶è¢«æœªæ¥çš„leaderè¦†ç›–æ‰äº†ã€‚<br><img alt="Pasted image 20240725173101.png" src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raft-åŸå§‹è®ºæ–‡ä¸­è‹±/pasted-image-20240725173101.png"><br>A time sequence showing why a leader cannot determine commitment using log entries from older terms.<br>
In(a) S1 is leader and partially replicates the log entry at index2.<br>
In (b) S1 crashes; S5 is elected leader for term 3 with votes from S3, S4, and itself, and accepts a different entry at log index 2.<br>
In (c) S5 crashes; S1 restarts, is elected leader, and continues replication.<br>
At this point, the log entry from term 2 has been replicated on a majority of the servers, but it is not committed.<br>
If S1 crashes as in (d), S5 could be elected leader (with votes from S2, S3, and S4) and overwrite the entry with its own entry from term 3.<br>
However, if S1 replicates an entry from its current term on a majority of the servers before crashing, as in (e),<br>
then this entry is committed (S5 cannot win an election).<br>
At this point all preceding entries in the log are committed as well.<br>ä¸€ä¸ªæ—¶é—´åºåˆ—ï¼Œå±•ç¤ºäº†ä¸ºä»€ä¹ˆleaderä¸èƒ½ä½¿ç”¨æ¥è‡ªæ—§ä»»æœŸçš„æ—¥å¿—æ¡ç›®æ¥å†³å®šæ˜¯å¦å·²æäº¤ã€‚(æ³¨ï¼šS1-S5æ˜¯é›†ç¾¤ä¸­çš„5å°æœåŠ¡å™¨ï¼Œa-eæ˜¯æ—¶é—´åºåˆ—)<br>
åœ¨(a)ä¸­S1æ˜¯leaderå¹¶ä¸”éƒ¨åˆ†çš„å¤åˆ¶äº†ä½äºindex2çš„æ—¥å¿—æ¡ç›®ã€‚<br>
åœ¨(b)ä¸­S1å´©æºƒäº†;S5é€šè¿‡ä»»æœŸ3ä¸­æ¥è‡ªS3ï¼ŒS4å’Œå®ƒè‡ªå·±çš„æŠ•ç¥¨è€Œè¢«é€‰ä¸¾ä¸ºleaderï¼Œå¹¶ä¸”æ¥å—äº†ä¸€ä¸ªä¸åŒçš„æ¡ç›®åœ¨æ—¥å¿—index2ã€‚<br>
åœ¨(c)ä¸­S5å´©æºƒäº†;S1é‡æ–°å¯åŠ¨ï¼Œè¢«é€‰ä¸¾ä¸ºäº†leaderï¼Œå¹¶ä¸”ç»§ç»­å¤åˆ¶ã€‚<br>
åœ¨è¿™ä¸ªæ—¶é—´ç‚¹ï¼Œæ¥è‡ªä»»æœŸ2çš„æ—¥å¿—æ¡ç›®å·²ç»è¢«å¤åˆ¶åˆ°äº†å¤§å¤šæ•°æœåŠ¡å™¨ä¸­ï¼Œä½†è¿˜æ²¡æœ‰è¢«æäº¤ã€‚<br>
å¦‚æœS1åƒ(d)ä¸­é‚£æ ·å´©æºƒäº†ï¼ŒS5å¯ä»¥è¢«é€‰ä¸¾ä¸ºleader(é€šè¿‡æ¥è‡ªS2ï¼ŒS3,å’ŒS4çš„æŠ•ç¥¨)å¹¶ä¸”ç”¨å®ƒè‡ªå·±çš„æ¥è‡ªä»»æœŸ3çš„æ¡ç›®è¿›è¡Œè¦†ç›–ã€‚<br>
ç„¶è€Œï¼Œå¦‚æœS1åœ¨å´©æºƒå‰å¤åˆ¶äº†æ¥è‡ªå®ƒå½“å‰ä»»æœŸçš„æ¡ç›®åœ¨å¤§å¤šæ•°æœåŠ¡å™¨ä¸­ï¼Œå°±åƒ(e),åˆ™è¿™ä¸€æ¡ç›®æ˜¯å·²æäº¤çš„(S5ä¸èƒ½èµ¢å¾—é€‰ä¸¾)ã€‚<br>
æ­¤æ—¶æ—¥å¿—ä¸­æ‰€æœ‰ä¹‹å‰çš„æ¡ç›®éƒ½å·²ç»è¢«æäº¤ã€‚<br><img alt="Pasted image 20240725173109.png" src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raft-åŸå§‹è®ºæ–‡ä¸­è‹±/pasted-image-20240725173109.png"><br>Figure 9: If S1 (leader for term T) commits a new log entry from its term, and S5 is elected leader for a later term U,<br>
then there must be at least one server (S3) that accepted the log entry and also voted for S5.<br>å›¾9ï¼šå¦‚æœS1(ä»»æœŸTçš„leader)æäº¤äº†å·²ç»™æ¥è‡ªå®ƒä»»æœŸçš„æ–°æ—¥å¿—æ¡ç›®ï¼Œå¹¶ä¸”S5åœ¨åé¢çš„ä»»æœŸUè¢«é€‰ä¸¾ä¸ºleader,<br>
åˆ™è‡³å°‘æœ‰ä¸€ä¸ªæœåŠ¡å™¨(S3)èƒ½å¤Ÿæ¥æ”¶è¯¥æ—¥å¿—æ¡ç›®å¹¶ä¸”ä¹ŸæŠ•ç¥¨ç»™S5ã€‚<br>To eliminate problems like the one in Figure 8, Raft never commits log entries from previous terms by counting replicas.<br>
Only log entries from the leaderâ€™s current term are committed by counting replicas;<br>
once an entry from the current term has been committed in this way,<br>
then all prior entries are committed indirectly because of the Log Matching Property.<br>
There are some situations where a leader could safely conclude that an older log entry is committed<br>
(for example, if that entry is stored on every server), but Raft takes a more conservative approach for simplicity.<br>ä¸ºäº†æ¶ˆé™¤åƒå›¾8ä¸­é‚£æ ·çš„é—®é¢˜ï¼ŒRaftä»æ¥ä¸åŸºäºå‰¯æœ¬æ•°é‡æ¥æäº¤æ¥è‡ªä¹‹å‰ä»»æœŸçš„æ—¥å¿—æ¡ç›®ã€‚<br>
åªæœ‰æ¥è‡ªleaderå½“å‰ä»»æœŸçš„æ—¥å¿—æ¡ç›®æ‰åŸºäºå‰¯æœ¬æ•°é‡è¢«æäº¤ï¼Œä¸€æ—¦ä¸€ä¸ªæ¥è‡ªå½“å‰ä»»æœŸçš„æ¡ç›®ä»¥è¿™ç§æ–¹å¼è¢«æäº¤ï¼Œåˆ™æ‰€æœ‰ä¹‹å‰çš„æ¡ç›®éƒ½å°†ç”±äºLog Matchingç‰¹æ€§è€Œé—´æ¥çš„è¢«æäº¤ã€‚<br>
åœ¨ä¸€äº›æƒ…å†µä¸‹ï¼Œleaderå¯ä»¥å®‰å…¨çš„æ–­å®šä¸€ä¸ªä¹‹å‰çš„logå·²ç»è¢«æäº¤(æ¯”å¦‚ï¼Œå¦‚æœä¸€ä¸ªentryå·²ç»è¢«å­˜å‚¨åœ¨æ¯ä¸€ä¸ªæœåŠ¡å™¨ä¸Šäº†)ï¼Œä½†ä¸ºäº†ç®€å•èµ·è§ï¼ŒRafté‡‡å–äº†ä¸€ç§æ›´ä¿å®ˆçš„æ–¹æ³•ã€‚<br>Raft incurs this extra complexity in the commitment rules because log entries retain their original term numbers<br>
when a leader replicates entries from previous terms.<br>
In other consensus algorithms, if a new leader re-replicates entries from prior â€œterms,â€ it must do so with its new â€œterm number.â€<br>
Raftâ€™s approach makes it easier to reason about log entries, since they maintain the same term number over time and across logs.<br>
In addition, new leaders in Raft send fewer log entries from previous terms<br>
than in other algorithms (other algorithms must send redundant log entries to renumber them before they can be committed).<br>Raftå‘æäº¤è§„åˆ™ä¸­å¼•å…¥äº†é¢å¤–çš„å¤æ‚æ€§ï¼Œå› ä¸ºå½“leaderå¤åˆ¶æ¥è‡ªä¹‹å‰ä»»æœŸçš„æ¡ç›®æ—¶ï¼Œè¿™äº›æ—¥å¿—æ¡ç›®ä¼šä¿ç•™å®ƒåŸå§‹çš„ä»»æœŸç¼–å·ã€‚<br>
åœ¨å…¶å®ƒä¸€è‡´æ€§ç®—æ³•ä¸­ï¼Œå¦‚æœä¸€ä¸ªæ–°çš„leaderè¦é‡æ–°å¤åˆ¶æ¥è‡ªä¹‹å‰ä»»æœŸçš„æ¡ç›®ï¼Œå®ƒå¿…é¡»ä½¿ç”¨æ–°çš„ä»»æœŸç¼–å·ã€‚<br>
Raftçš„æ–¹æ³•ä½¿å¾—æ›´å®¹æ˜“ç†è§£æ—¥å¿—æ¡ç›®ï¼Œå› ä¸ºå®ƒä»¬åœ¨ä¸åŒæœåŠ¡å™¨çš„æ—¥å¿—ä¸­è‡ªå§‹è‡³ç»ˆä¿ç•™äº†ç›¸åŒçš„ä»»æœŸç¼–å·ã€‚<br>
é¢å¤–çš„ï¼Œç›¸æ¯”å…¶å®ƒç®—æ³•ï¼Œraftä¸­çš„æ–°leaderä¼šå‘é€æ›´å°‘çš„æ¥è‡ªä¹‹å‰ä»»æœŸçš„æ—¥å¿—æ¡ç›®(å…¶å®ƒç®—æ³•å¿…é¡»å‘é€å†—ä½™çš„æ—¥å¿—æ¡ç›®ä»¥å¯¹è®©å¯¹åº”çš„æ—¥å¿—æ¡ç›®åœ¨æäº¤å‰é‡æ–°è¿›è¡Œç¼–å·)ã€‚<br><br>Given the complete Raft algorithm,<br>
we can now argue more precisely that the Leader Completeness Property holds (this argument is based on the safety proof; see Section 9.2).<br>
We assume that the Leader Completeness Property does not hold, then we prove a contradiction.<br>
Suppose the leader for term T (leaderT) commits a log entry from its term, but that log entry is not stored by the leader of some future term.<br>
Consider the smallest term U &gt; T whose leader (leaderU) does not store the entry.<br>åœ¨ç»™å‡ºäº†å®Œæ•´çš„Raftç®—æ³•åï¼Œæˆ‘ä»¬å¯ä»¥æ›´åŠ å‡†ç¡®çš„è®¨è®ºleaderçš„å®Œæ•´æ€§(Completeness)ç‰¹æ€§æ˜¯å¦æˆç«‹äº†(è¿™ä¸€è®¨è®ºåŸºäº9.2èŠ‚çš„å®‰å…¨æ€§è¯æ˜)ã€‚<br>
æˆ‘ä»¬å‡è®¾leaderçš„Completenessç‰¹æ€§ä¸æˆç«‹ï¼Œåˆ™æˆ‘ä»¬å¯ä»¥æ¨åˆ°å‡ºçŸ›ç›¾æ¥ã€‚<br>
å‡è®¾ä»»æœŸTçš„leader(leaderT)æäº¤äº†ä¸€ä¸ªæ¥è‡ªå½“å‰ä»»æœŸçš„æ—¥å¿—æ¡ç›®ï¼Œä½†è¯¥æ—¥å¿—æ¡ç›®æ²¡æœ‰è¢«æœªæ¥æŸäº›ä»»æœŸçš„leaderæ‰€å­˜å‚¨ã€‚<br>
è€ƒè™‘ä¸€ä¸ªå¤§äºTçš„æœ€å°ä»»æœŸUï¼Œå…¶leader(leaderU)æ²¡æœ‰å­˜å‚¨è¿™ä¸ªæ¡ç›®ã€‚<br>
<br>
The committed entry must have been absent from leaderUâ€™s log at the time of its election (leaders never delete or overwrite entries).

<br>
leaderT replicated the entry on a majority of the cluster, and leaderU received votes from a majority of the cluster.<br>
Thus, at least one server (â€œthe voterâ€) both accepted the entry from leaderT and voted for leaderU, as shown in Figure 9.<br>
The voter is key to reaching a contradiction.

<br>
The voter must have accepted the committed entry from leaderT before voting for leaderU;<br>
otherwise it would have rejected the AppendEntries request from leaderT (its current term would have been higher than T).

<br>
The voter still stored the entry when it voted for leaderU, since every intervening leader contained the entry (by assumption),<br>
leaders never remove entries, and followers only remove entries if they conflict with the leader.

<br>
The voter granted its vote to leaderU, so leaderUâ€™s log must have been as up-to-date as the voterâ€™s.<br>
This leads to one of two contradictions.

<br>
First, if the voter and leaderU shared the same last log term,<br>
then leaderUâ€™s log must have been at least as long as the voterâ€™s, so its log contained every entry in the voterâ€™s log.<br>
This is a contradiction, since the voter contained the committed entry and leaderU was assumed not to.

<br>
Otherwise, leaderUâ€™s last log term must have been larger than the voterâ€™s.<br>
Moreover, it was larger than T, since the voterâ€™s last log term was at least T (it contains the committed entry from term T).<br>
The earlier leader that created leaderUâ€™s last log entry must have contained the committed entry in its log (by assumption).<br>
Then, by the Log Matching Property, leaderUâ€™s log must also contain the committed entry, which is a contradiction.

<br>
This completes the contradiction. Thus, the leaders of all terms greater than T must contain all entries from term T<br>
that are committed in term T.

<br>
The Log Matching Property guarantees that future leaders will also contain entries that are committed indirectly,<br>
such as index 2 in Figure 8(d).

<br>
å·²æäº¤çš„æ¡ç›®åœ¨leaderUå½“é€‰æ—¶ï¼Œå¿…é¡»ä¸åœ¨leaderUçš„æ—¥å¿—ä¸­(leaderä»æ¥ä¸ä¼šåˆ é™¤æˆ–è€…è¦†ç›–æ¡ç›®)ã€‚

<br>
leaderTå°†å¯¹åº”æ¡ç›®å¤åˆ¶åˆ°äº†é›†ç¾¤ä¸­çš„å¤§å¤šæ•°(æœåŠ¡å™¨)ä¸­,å¹¶ä¸”leaderUè·å¾—äº†æ¥è‡ªé›†ç¾¤ä¸­çš„å¤§å¤šçš„é€‰ç¥¨ã€‚<br>
å› æ­¤ï¼Œè‡³å°‘æœ‰ä¸€ä¸ªæœåŠ¡å™¨(ä½œä¸ºvoter)åŒæ—¶æ¥æ”¶åˆ°äº†æ¥è‡ªleaderTçš„æ¡ç›®å¹¶ä¸”æŠ•ç¥¨ç»™äº†leaderU.å¦‚å›¾9æ‰€ç¤ºã€‚è¯¥voteræ˜¯è¾¾æˆçŸ›ç›¾çš„å…³é”®æ‰€åœ¨ã€‚

<br>
voterå¿…é¡»åœ¨æŠ•ç¥¨ç»™leaderUä¹‹å‰æ¥å—æ¥è‡ªleaderTçš„å·²æäº¤çš„æ¡ç›®;<br>
å¦åˆ™å…¶å°†æ‹’ç»æ¥è‡ªleaderTçš„AppendEntries request(å®ƒå½“å‰çš„ä»»æœŸå°†å·²ç»é«˜äºT)ã€‚

<br>
voteråœ¨æŠ•ç¥¨ç»™leaderUæ—¶ä¾ç„¶å­˜å‚¨äº†è¯¥æ¡ç›®ï¼Œå› ä¸ºæ¯ä¸€ä¸ªä»‹äºå…¶ä¸­çš„leader(ä»»æœŸä½äºTå’ŒUä¹‹é—´)éƒ½åŒ…å«äº†è¯¥æ¡ç›®ï¼Œ<br>
leaderä»ä¸ç§»é™¤æ¡ç›®ï¼Œå¹¶ä¸”followeråªç§»é™¤ä¸leaderç›¸å†²çªçš„æ¡ç›®ã€‚

<br>
voteråŒæ„æŠ•ç¥¨ç»™leaderU,å› æ­¤leaderUçš„æ—¥å¿—å¿…é¡»è‡³å°‘ä¸voteræ˜¯ä¸€æ ·æ–°çš„ã€‚è¿™å¸¦æ¥äº†ä»¥ä¸‹ä¸¤ä¸ªçŸ›ç›¾ä¸­çš„ä¸€ä¸ªã€‚

<br>
é¦–å…ˆï¼Œå¦‚æœvoterå’ŒleaderUçš„æœ€åä¸€ä¸ªæ—¥å¿—æœ‰ç€ç›¸åŒçš„ä»»æœŸï¼Œåˆ™leaderUçš„æ—¥å¿—å¿…é¡»è‡³å°‘ä¸voterä¸€æ ·é•¿ï¼Œ<br>
å› æ­¤leaderUçš„æ—¥å¿—åŒ…å«äº†voteræ—¥å¿—ä¸­çš„æ¯ä¸€ä¸ªæ¡ç›®ã€‚<br>
è¿™æ˜¯çŸ›ç›¾çš„ï¼Œå› ä¸ºvoteråŒ…å«äº†å·²æäº¤çš„æ¡ç›®è€ŒleaderUè¢«å‡è®¾ä¸ºæ²¡æœ‰åŒ…å«ã€‚

<br>
å¦åˆ™leaderUçš„æœ€åä¸€ä¸ªæ—¥å¿—çš„ä»»æœŸå°±å¿…é¡»æ¯”voterè¦å¤§äº†ã€‚<br>
æ­¤å¤–ï¼Œä»»æœŸçš„å€¼ä¹Ÿå¤§äºTï¼Œå› ä¸ºvoterçš„æœ€åä¸€ä¸ªæ—¥å¿—çš„ä»»æœŸè‡³å°‘æ˜¯T(å…¶åŒ…å«äº†æ¥è‡ªä»»æœŸTçš„æ‰€æœ‰å·²æäº¤æ¡ç›®)ã€‚<br>
åˆ›å»ºleaderUæœ€åä¸€ä¸ªæ—¥å¿—æ¡ç›®çš„æ›´æ—©çš„leaderä¹Ÿå¿…é¡»åŒ…å«è¿™ä¸ªæ—¥å¿—(å‡è®¾)ã€‚<br>
ç„¶åï¼ŒåŸºäºLog Matchingç‰¹æ€§ï¼ŒleaderUçš„æ—¥å¿—å¿…é¡»ä¹ŸåŒ…å«å·²æäº¤çš„æ¡ç›®ï¼Œè¿™æ˜¯ä¸€ä¸ªçŸ›ç›¾ã€‚

<br>
è¿™å°±ç»ˆç»“äº†çŸ›ç›¾ã€‚å› æ­¤ï¼Œæ‰€æœ‰ä»»æœŸå¤§äºTçš„leaderå¿…é¡»åŒ…å«æ‰€æœ‰çš„ä»»æœŸTå†…çš„å·²æäº¤æ¡ç›®ã€‚

<br>
Log Matchingç‰¹æ€§ä¿è¯äº†æœªæ¥çš„leaderä¹ŸåŒ…å«é—´æ¥æäº¤çš„æ—¥å¿—ï¼Œå°±åƒå›¾8ä¸­çš„ç´¢å¼•2ã€‚

<br>Given the Leader Completeness Property, we can prove the State Machine Safety Property from Figure 3,<br>
which states that if a server has applied a log entry at a given index to its state machine,<br>
no other server will ever apply a different log entry for the same index.<br>
At the time a server applies a log entry to its state machine,<br>
its log must be identical to the leaderâ€™s log up through that entry and the entry must be committed.<br>
Now consider the lowest term in which any server applies a given log index;<br>
the Log Completeness Property guarantees that the leaders for all higher terms will store that same log entry,<br>
so servers that apply the index in later terms will apply the same value.<br>
Thus, the State Machine Safety Property holds.<br>é€šè¿‡Leader Completenessç‰¹æ€§ï¼Œæˆ‘ä»¬å¯ä»¥è¯æ˜æ¥è‡ªå›¾3çš„State Machine Safety(å®‰å…¨çŠ¶æ€æœº)ç‰¹æ€§ï¼Œ<br>
å¦‚æœæœåŠ¡å™¨å°†ç»™å®šç´¢å¼•æ—¥å¿—æ¡ç›®ä½œç”¨äºçŠ¶æ€æœºï¼Œå…¶å®ƒçš„æœåŠ¡å™¨å°†ä¸èƒ½åœ¨ç›¸åŒçš„ç´¢å¼•å¤„åº”ç”¨ä¸åŒçš„æ—¥å¿—æ¡ç›®ã€‚<br>
ä¸€æ—¦æœåŠ¡å™¨åº”ç”¨äº†ä¸€ä¸ªæ—¥å¿—æ¡ç›®åˆ°å…¶çŠ¶æ€æœºä¸Šï¼Œå…¶æ—¥å¿—å¿…é¡»ä¸ä¼ é€’è¯¥æ¡ç›®çš„leaderçš„æ—¥å¿—å®Œå…¨ä¸€æ ·ï¼Œå¹¶ä¸”è¿™ä¸ªæ¡ç›®å¿…é¡»è¢«æäº¤ã€‚<br>
ç°åœ¨è€ƒè™‘ä»»ä¸€æœåŠ¡å™¨åº”ç”¨ç»™å®šæ—¥å¿—ç´¢å¼•çš„æœ€å°ä»»æœŸï¼ŒLog Completenessç‰¹æ€§ä¿è¯äº†æ‰€æœ‰æ›´é«˜ä»»æœŸçš„leaderå°†å­˜å‚¨ç›¸åŒçš„æ—¥å¿—æ¡ç›®ï¼Œæ‰€ä»¥æœåŠ¡å™¨åœ¨æœ€æ™šä»»æœŸæ‰€åº”ç”¨çš„ç´¢å¼•å°†ä½œç”¨äºç›¸åŒçš„å€¼ã€‚<br>
å› æ­¤ï¼ŒState Machine Safetyç‰¹æ€§æ˜¯æˆç«‹çš„ã€‚<br>Finally, Raft requires servers to apply entries in log index order.<br>
Combined with the State Machine Safety Property,<br>
this means that all servers will apply exactly the same set of log entries to their state machines, in the same order.<br>æœ€åï¼ŒRaftè¦æ±‚æœåŠ¡å™¨æŒ‰ç…§æ—¥å¿—ç´¢å¼•çš„é¡ºåºåº”ç”¨æ—¥å¿—æ¡ç›®ã€‚<br>
ç»“åˆState Machine Safetyç‰¹æ€§ï¼Œè¿™æ„å‘³ç€æ‰€æœ‰çš„æœåŠ¡å™¨å°†ç²¾ç¡®çš„ä»¥ç›¸åŒçš„é¡ºåºä¸ºå®ƒä»¬çš„çŠ¶æ€æœºåº”ç”¨ä¸€ä¸ªç›¸åŒçš„æ—¥å¿—æ¡ç›®é›†åˆã€‚<br><br>Until this point we have focused on leader failures.<br>
Follower and candidate crashes are much simpler to handle than leader crashes, and they are both handled in the same way.<br>
If a follower or candidate crashes, then future RequestVote and AppendEntries RPCs sent to it will fail.<br>
Raft handles these failures by retrying indefinitely; if the crashed server restarts, then the RPC will complete successfully.<br>
If a server crashes after completing an RPC but before responding, then it will receive the same RPC again after it restarts.<br>
Raft RPCs are idempotent, so this causes no harm.<br>
For example, if a follower receives an AppendEntries request that includes log entries already present in its log,<br>
it ignores those entries in the new request.<br>åœ¨æ­¤ä¹‹å‰æˆ‘ä»¬ä¸€ç›´èšç„¦äºleaderå‡ºæ•…éšœçš„æƒ…å†µã€‚<br>
followerå’Œcandidateçš„å´©æºƒæ¯”èµ·leaderçš„å´©æºƒä¼šæ›´åŠ å®¹æ˜“å¤„ç†ï¼Œå¹¶ä¸”å®ƒä»¬éƒ½ä»¥ç›¸åŒçš„æ–¹å¼è¢«å¤„ç†ã€‚<br>
å¦‚æœä¸€ä¸ªfolloweræˆ–è€…candidateå´©æºƒäº†ï¼Œåˆ™æœªæ¥å‘é€ç»™å®ƒçš„æŠ•ç¥¨è¯·æ±‚(RequestVote)å’ŒAppendEntries RPCçš„å‘é€å°†ä¼šå¤±è´¥ã€‚<br>
Rafté€šè¿‡æ— é™çš„é‡è¯•æ¥å¤„ç†è¿™äº›å¤±è´¥ï¼Œå¦‚æœå·²å´©æºƒçš„æœåŠ¡å™¨é‡å¯äº†ï¼Œåˆ™RPCå°†ä¼šæˆåŠŸçš„å®Œæˆã€‚<br>
å¦‚æœæœåŠ¡å™¨åœ¨å®Œæˆäº†ä¸€ä¸ªRPCä½†æ˜¯åœ¨è¿›è¡Œå“åº”ä¹‹å‰å´©æºƒäº†ï¼Œåˆ™å®ƒå°†ä¼šåœ¨é‡å¯åå†ä¸€æ¬¡æ¥å—åˆ°ç›¸åŒçš„RPCã€‚<br>
Raftçš„RPCæ˜¯å¹‚ç­‰çš„ï¼Œæ‰€ä»¥è¿™ä¸ä¼šæœ‰é—®é¢˜ã€‚<br>
ä¾‹å¦‚ï¼Œå¦‚æœä¸€ä¸ªfolloweræ¥å—åˆ°çš„ä¸€ä¸ªAppendEntriesè¯·æ±‚ä¸­åŒ…å«çš„æ—¥å¿—æ¡ç›®å·²ç»åœ¨å®ƒè‡ªå·±çš„æ—¥å¿—ä¸­äº†ï¼Œè¯¥followerå°±ä¼šåœ¨è¿™æ¬¡æ–°çš„è¯·æ±‚ä¸­å¿½ç•¥æ‰è¿™äº›æ¡ç›®ã€‚<br><br>One of our requirements for Raft is that safety must not depend on timing:<br>
the system must not produce incorrect results just because some event happens more quickly or slowly than expected.<br>
However, availability (the ability of the system to respond to clients in a timely manner) must inevitably depend on timing.<br>
For example, if message exchanges take longer than the typical time between server crashes,<br>
candidates will not stay up long enough to win an election; without a steady leader, Raft cannot make progress.<br>æˆ‘ä»¬å¯¹Raftçš„è¦æ±‚ä¹‹ä¸€æ˜¯å®‰å…¨æ€§ä¸å¾—ä¾èµ–æ—¶é—´ï¼šç³»ç»Ÿä¸èƒ½å› ä¸ºä¸€äº›äº‹ä»¶æ¯”æ‰€æœŸæœ›çš„æ›´å¿«æˆ–æ›´æ…¢å‘ç”Ÿè€Œäº§ç”Ÿä¸æ­£ç¡®çš„ç»“æœã€‚<br>
ç„¶è€Œï¼Œå¯ç”¨æ€§(ç³»ç»ŸåŠæ—¶å“åº”å®¢æˆ·ç«¯çš„èƒ½åŠ›)ä¸€å®šä¸å¯é¿å…çš„ä¾èµ–äºæ—¶é—´ã€‚<br>
ä¾‹å¦‚ï¼Œå¦‚æœæ¶ˆæ¯äº¤æ¢æ‰€èŠ±è´¹çš„æ—¶é—´æ¯”æœåŠ¡å™¨å´©æºƒæ—¶æ‰€èŠ±è´¹çš„æ—¶é—´è¿˜é•¿ï¼Œcandidateså°†æ— æ³•ä¸€ç›´ç­‰å¾…ä»¥èµ¢å¾—ä¸€åœºé€‰ä¸¾ï¼›æ²¡æœ‰ä¸€ä¸ªç¨³å®šçš„leaderï¼ŒRaftå°±æ— æ³•å·¥ä½œã€‚<br>Leader election is the aspect of Raft where timing is most critical.<br>
Raft will be able to elect and maintain a steady leader as long as the system satisfies the following timing requirement:<br>
broadcastTime â‰ª electionTimeout â‰ª MTBF<br>leaderé€‰ä¸¾æ˜¯Raftå…³äºæ—¶é—´çš„æœ€å…³é”®çš„æ–¹é¢ã€‚<br>
åªè¦ç³»ç»Ÿèƒ½æ»¡è¶³ä»¥ä¸‹æ—¶é—´çš„éœ€æ±‚ï¼ŒRaftå°†èƒ½å¤Ÿé€‰å‡ºå¹¶ä¸”ç»´æŒä¸€ä¸ªç¨³å®šçš„leaderï¼š<br>
å¹¿æ’­æ—¶é—´(broadcastTime) â‰ª é€‰ä¸¾è¶…æ—¶æ—¶é—´(electionTimeout) â‰ª å¹³å‡æ•…éšœé—´éš”æ—¶é—´(MTBF: Mean Time between Failures)<br>In this inequality broadcastTime is the average time it takes a server to send RPCs in parallel to every server<br>
in the cluster and receive their responses;<br>
electionTimeout is the election timeout described in Section 5.2;<br>
and MTBF is the average time between failures for a single server.<br>
The broadcast time should be an order of magnitude less than the election timeout so<br>
that leaders can reliably send the heartbeat messages required to keep followers from starting elections;<br>
given the randomized approach used for election timeouts, this inequality also makes split votes unlikely.<br>
The election timeout should be a few orders of magnitude less than MTBF so that the system makes steady progress.<br>
When the leader crashes, the system will be unavailable for roughly the election timeout;<br>
we would like this to represent only a small fraction of overall time.<br>åœ¨è¿™ä¸ªä¸ç­‰å¼ä¸­ï¼Œå¹¿æ’­æ—¶é—´æ˜¯æœåŠ¡å™¨å¹¶è¡Œå‘é€RPCç»™é›†ç¾¤ä¸­çš„æ¯ä¸€ä¸ªæœåŠ¡å™¨å¹¶ä¸”æ¥å—åˆ°å®ƒä»¬çš„å“åº”æ‰€èŠ±è´¹çš„æ—¶é—´ï¼›<br>
é€‰ä¸¾è¶…æ—¶æ—¶é—´æ˜¯åœ¨5.2èŠ‚ä¸­æ‰€æè¿°çš„é€‰ä¸¾è¶…æ—¶æ—¶é—´ï¼›åŒæ—¶MTBFæ˜¯å¯¹äºå•ä¸€æœåŠ¡å™¨åœ¨ä¸¤æ¬¡æ•…éšœé—´éš”çš„å¹³å‡æ—¶é—´ã€‚<br>
å¹¿æ’­æ—¶é—´åº”è¯¥æ¯”é€‰ä¸¾è¶…æ—¶æ—¶é—´å°ä¸€ä¸ªæ•°é‡çº§å› æ­¤leaderå¯ä»¥å¯é çš„å‘é€æ‰€éœ€çš„å¿ƒè·³ä¿¡æ¯æ¥é˜»æ­¢followerå¼€å§‹é€‰ä¸¾ï¼›<br>
è€ƒè™‘åˆ°ç”¨äºé€‰ä¸¾è¶…æ—¶çš„éšæœºåŒ–æ–¹æ³•ï¼Œè¿™ä¸ªä¸ç­‰å¼ä¹Ÿä½¿å¾—ä¸å¤ªå¯èƒ½å‡ºç°æŠ•ç¥¨åˆ†è£‚ã€‚<br>
é€‰ä¸¾è¶…æ—¶æ—¶é—´å¿…é¡»æ¯”MTBFä½å‡ ä¸ªæ•°é‡çº§æ‰èƒ½ä½¿å¾—ç³»ç»Ÿèƒ½ç¨³å®šçš„è¿è¡Œã€‚<br>
å½“leaderå´©æºƒæ—¶ï¼Œç³»ç»Ÿå°†æœ‰å¤§è‡´ç­‰äºé€‰ä¸¾è¶…æ—¶æ—¶é—´å·¦å³çš„ä¸å¯ç”¨æ—¶é—´ï¼Œæˆ‘ä»¬å¸Œæœ›è¿™åªå ç”¨æ•´ä¸ª(å·¥ä½œ)æ—¶é—´çš„ä¸€å°éƒ¨åˆ†ã€‚<br>The broadcast time and MTBF are properties of the underlying system, while the election timeout is something we must choose.<br>
Raftâ€™s RPCs typically require the recipient to persist information to stable storage,<br>
so the broadcast time may range from 0.5ms to 20ms, depending on storage technology.<br>
As a result, the election timeout is likely to be somewhere between 10ms and 500ms.<br>
Typical server MTBFs are several months or more, which easily satisfies the timing requirement.<br>å¹¿æ’­æ—¶é—´å’Œå¹³å‡æ•…éšœé—´éš”æ—¶é—´æ˜¯åº•å±‚ç³»ç»Ÿçš„ç‰¹æ€§ï¼Œåªæœ‰é€‰ä¸¾è¶…æ—¶æ—¶é—´æ˜¯æˆ‘ä»¬å¿…é¡»é€‰æ‹©çš„ã€‚<br>
Raftçš„RPCé€šå¸¸éœ€è¦æ¥æ”¶æ–¹å°†ä¿¡æ¯æŒä¹…åŒ–åˆ°ç¨³å®šçš„å­˜å‚¨ä»‹è´¨ä¸­ï¼Œæ‰€ä»¥å¹¿æ’­æ—¶é—´å¯èƒ½åœ¨0.5msåˆ°20msä¹‹é—´ï¼Œè¿™å–å†³äºå­˜å‚¨æŠ€æœ¯ã€‚<br>
å› æ­¤ï¼Œé€‰ä¸¾æ—¶é—´å¯èƒ½åœ¨10msåˆ°500msä¹‹é—´ã€‚<br>
å…¸å‹çš„æœåŠ¡å™¨å¹³å‡æ•…éšœé—´éš”æ—¶é—´æ˜¯å‡ ä¸ªæœˆæˆ–è€…æ›´å¤šï¼Œå› æ­¤å¯¹è¿™ä¸€æ—¶é—´(çš„è¦æ±‚)å¾ˆå®¹æ˜“æ»¡è¶³ã€‚<br><img alt="Pasted image 20240725173120.png" src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raft-åŸå§‹è®ºæ–‡ä¸­è‹±/pasted-image-20240725173120.png"><br>Figure 10: Switching directly from one configuration to another is unsafe because different servers will switch at different times.<br>
In this example, the cluster grows from three servers to five.<br>
Unfortunately, there is a point in time where two different leaders can be elected for the same term,<br>
one with a majority of the old configuration (Cold) and another with a majority of the new configuration (Cnew).<br>å›¾10ï¼šç›´æ¥å°†ä¸€ç§é…ç½®åˆ‡æ¢åˆ°å¦ä¸€ç§é…ç½®æ˜¯ä¸å®‰å…¨çš„å› ä¸ºä¸åŒçš„æœåŠ¡å™¨å°†ä¼šåœ¨ä¸åŒçš„æ—¶é—´ç‚¹è¿›è¡Œåˆ‡æ¢ã€‚<br>
åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œé›†ç¾¤ä»3å°æœåŠ¡å™¨å¢é•¿åˆ°5å°ã€‚<br>
ä¸å¹¸çš„æ˜¯ï¼Œè¿™ä¸ªæ—¶é—´ç‚¹å°†ä¼šåœ¨ç›¸åŒçš„ä»»æœŸå†…é€‰ä¸¾å‡ºä¸¤ä¸ªä¸åŒçš„leaderï¼Œå…¶ä¸­ä¹‹ä¸€è·å¾—äº†æ—§é…ç½®ä¸­çš„å¤§å¤šæ•°(Cold)åŒæ—¶å¦ä¸€ä¸ªè·å¾—äº†æ–°é…ç½®ä¸­çš„å¤§å¤šæ•°(Cnew)ã€‚<br><br>Up until now we have assumed that the cluster configuration (the set of servers participating in the consensus algorithm) is fixed.<br>
In practice, it will occasionally be necessary to change the configuration,<br>
for example to replace servers when they fail or to change the degree of replication.<br>
Although this can be done by taking the entire cluster off-line, updating configuration files,<br>
and then restarting the cluster, this would leave the cluster unavailable during the changeover.<br>
In addition, if there are any manual steps, they risk operator error.<br>
In order to avoid these issues, we decided to automate configuration changes and incorporate them into the Raft consensus algorithm.<br>åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»å‡è®¾é›†ç¾¤çš„é…ç½®(å‚ä¸ä¸€è‡´æ€§ç®—æ³•çš„æœåŠ¡å™¨é›†åˆ)æ˜¯å›ºå®šçš„ã€‚<br>
åœ¨å®è·µä¸­ï¼Œå¶å°”çš„æ”¹å˜é…ç½®æ˜¯å¿…é¡»çš„ï¼Œä¾‹å¦‚åœ¨æœåŠ¡å™¨å‘ç”Ÿæ•…éšœæ—¶è¿›è¡Œæ›¿æ¢æˆ–è€…æ”¹å˜å¤åˆ¶çš„ç¨‹åº¦ã€‚<br>
å°½ç®¡è¿™å¯ä»¥é€šè¿‡ä½¿æ•´ä¸ªé›†ç¾¤ç¦»çº¿ï¼Œæ›´æ–°é…ç½®æ–‡ä»¶å¹¶ä¸”éšåé‡å¯é›†ç¾¤æ¥å®ç°ï¼Œä½†è¿™ä¹Ÿä½¿å¾—é›†ç¾¤åœ¨è½¬æ¢è¿‡ç¨‹ä¸­å˜å¾—ä¸å¯ç”¨ã€‚<br>
å¦å¤–ï¼Œå¦‚æœæœ‰ä»»ä½•çš„æ‰‹å·¥æ­¥éª¤ï¼Œåˆ™æœ‰ç®¡ç†å‘˜æ“ä½œå¤±è¯¯çš„é£é™©ã€‚<br>
ä¸ºäº†é¿å…è¿™äº›é—®é¢˜ï¼Œæˆ‘ä»¬å†³å®šå°†é…ç½®çš„å˜æ›´è‡ªåŠ¨åŒ–å¹¶ä¸”å°†å…¶çº³å…¥åˆ°Raftä¸€è‡´æ€§ç®—æ³•ä¸­ã€‚<br>For the configuration change mechanism to be safe,<br>
there must be no point during the transition where it is possible for two leaders to be elected for the same term.<br>
Unfortunately, any approach where servers switch directly from the old configuration to the new configuration is unsafe.<br>
It isnâ€™t possible to atomically switch all of the servers at once,<br>
so the cluster can potentially split into two independent majorities during the transition (see Figure 10).<br>ä¸ºäº†ä½¿å¾—é…ç½®å˜æ›´çš„è¿‡ç¨‹æ˜¯å®‰å…¨çš„ï¼Œåœ¨è½¬æ¢çš„è¿‡ç¨‹ä¸­å¿…é¡»ä¿è¯ä¸èƒ½åœ¨åŒä¸€ä¸ªä»»æœŸå†…é€‰ä¸¾å‡ºä¸¤ä¸ªleaderã€‚<br>
ä¸å¹¸çš„æ˜¯ï¼Œä»»ä½•å°†æ—§é…ç½®ç›´æ¥åˆ‡æ¢åˆ°æ–°é…ç½®çš„æ–¹æ³•éƒ½æ˜¯ä¸å®‰å…¨çš„ã€‚<br>
ä¸å¯èƒ½åŸå­æ€§çš„ä¸€æ¬¡æ€§åˆ‡æ¢æ‰€æœ‰çš„æœåŠ¡å™¨ï¼Œå› æ­¤æœåŠ¡å™¨å¯èƒ½åœ¨è½¬æ¢æœŸé—´è¢«åˆ‡åˆ†ä¸ºä¸¤ä¸ªç‹¬ç«‹çš„å¤šæ•°(å¦‚å›¾10æ‰€ç¤º)ã€‚<br>In order to ensure safety, configuration changes must use a two-phase approach.<br>
There are a variety of ways to implement the two phases.<br>
For example, some systems(e.g., [22]) use the first phase to disable the old configuration so it cannot process client requests;<br>
then the second phase enables the new configuration.<br>
In Raft the cluster first switches to a transitional configuration we call joint consensus;<br>
once the joint consensus has been committed, the system then transitions to the new configuration.<br>
The joint consensus combines both the old and new configurations:<br>
<br>Log entries are replicated to all servers in both configurations.
<br>Any server from either configuration may serve as leader
<br>Agreement (for elections and entry commitment) requires separate majorities from both the old and new configurations.
<br><img alt="Pasted image 20240725173130.png" src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raft-åŸå§‹è®ºæ–‡ä¸­è‹±/pasted-image-20240725173130.png"><br>Figure 11: Timeline for a configuration change.<br>
Dashed lines show configuration entries that have been created but not committed, and solid lines show the latest committed configuration entry.<br>
The leader first creates the Cold,new configuration entry in its log and commits it to Cold,new<br>
(a majority of Cold and a majority of Cnew).<br>
Then it creates the Cnew entry and commits it to a majority of Cnew.<br>
There is no point in time in which Cold and Cnew can both make decisions independently.<br>å›¾11ï¼šé…ç½®å˜æ›´çš„æ—¶é—´çº¿ã€‚<br>
è™šçº¿æ ‡è¯†é…ç½®æ¡ç›®å·²ç»è¢«åˆ›å»ºä½†è¿˜æœªè¢«æäº¤ï¼Œè€Œå®ç°æ ‡è¯†æœ€æ–°çš„å·²æäº¤çš„é…ç½®æ¡ç›®ã€‚<br>
leaderé¦–å…ˆåœ¨å®ƒçš„æ—¥å¿—ä¸­åˆ›å»ºCold,newçš„é…ç½®æ¡ç›®å¹¶ä¸”å‘Cold,new(Coldä¸­çš„å¤§å¤šæ•°ä»¥åŠCnewä¸­çš„å¤§å¤šæ•°)æäº¤è¿™ä¸€æ—¥å¿—ã€‚<br>
ç„¶åå®ƒåˆ›å»ºCnewæ¡ç›®å¹¶ä¸”å‘Cnewä¸­çš„å¤§å¤šæ•°æäº¤è¿™ä¸€æ¡ç›®ã€‚<br>
æ²¡æœ‰ä»»ä½•ä¸€ä¸ªæ—¶é—´ç‚¹å¯ä»¥è®©Coldå’ŒCnewéƒ½èƒ½åŒæ—¶ç‹¬ç«‹çš„åšå‡ºå†³å®šã€‚<br>ä¸ºäº†ç¡®ä¿å®‰å…¨ï¼Œé…ç½®çš„å˜æ›´å¿…é¡»ä½¿ç”¨ä¸€ç§ä¸¤é˜¶æ®µçš„æ–¹æ³•ã€‚<br>
æœ‰å¾ˆå¤šæ–¹æ³•å¯ä»¥å®ç°ä¸¤é˜¶æ®µã€‚<br>
ä¾‹å¦‚ï¼Œä¸€äº›ç³»ç»Ÿé€šè¿‡åœ¨ä¸€é˜¶æ®µç¦ç”¨æ—§çš„é…ç½®å› æ­¤å…¶æ— æ³•å¤„ç†å®¢æˆ·ç«¯è¯·æ±‚ï¼Œç„¶åäºŒé˜¶æ®µåˆ™å¯ç”¨æ–°çš„é…ç½®ã€‚<br>
åœ¨Raftçš„é›†ç¾¤é¦–å…ˆåˆ‡æ¢åˆ°æˆ‘ä»¬æˆä¸ºè”åˆä¸€è‡´(joint consensus)çš„è¿‡æ¸¡é…ç½®;ä¸€æ—¦è”åˆä¸€è‡´å·²è¢«æäº¤ï¼Œç³»ç»Ÿä¾¿è¿‡åº¦åˆ°æ–°çš„é…ç½®ã€‚<br>
è”åˆä¸€è‡´ç»“åˆäº†æ—§çš„å’Œæ–°çš„é…ç½®ï¼š<br>
<br>æ—¥å¿—æ¡ç›®éƒ½ä¼šè¢«å¤åˆ¶åˆ°åœ¨è¿™ä¸¤ç§é…ç½®ä¸­æ‰€æœ‰çš„æœåŠ¡å™¨ä¸Šã€‚
<br>æ–°ã€æ—§é…ç½®ä¸­çš„ä»»ä¸€æœåŠ¡å™¨éƒ½å¯ä»¥ä½œä¸ºleaderã€‚
<br>(å¯¹äºé€‰ä¸¾å’Œæ¡ç›®æäº¤)è¾¾æˆä¸€è‡´éœ€è¦åœ¨æ–°çš„å’Œæ—§çš„é…ç½®ä¸­åˆ†åˆ«è·å¾—å¤§å¤šæ•°æœåŠ¡å™¨çš„åŒæ„ã€‚
<br>The joint consensus allows individual servers to transition between configurations at different times without compromising safety.<br>
Furthermore, joint consensus allows the cluster to continue servicing client requests throughout the configuration change.<br>è”åˆä¸€è‡´å…è®¸å•ç‹¬çš„æœåŠ¡å™¨åœ¨ä¸åŒçš„æ—¶é—´å†…è½¬æ¢é…åˆè€Œä¸ä¼šåœ¨å®‰å…¨æ€§ä¸Šæœ‰æ‰€å¦¥åã€‚<br>
æ­¤å¤–ï¼Œè”åˆä¸€è‡´å…è®¸é›†ç¾¤åœ¨é…ç½®å˜æ›´çš„è¿‡ç¨‹ä¸­æŒç»­çš„ä¸ºå®¢æˆ·ç«¯çš„è¯·æ±‚æä¾›æœåŠ¡ã€‚<br>Cluster configurations are stored and communicated using special entries in the replicated log;<br>
Figure 11 illustrates the configuration change process.<br>
When the leader receives a request to change the configuration from Cold to Cnew,<br>
it stores the configuration for joint consensus(Cold,new in the figure) as a log entry and replicates that<br>
entry using the mechanisms described previously.<br>
Once a given server adds the new configuration entry to its log, it uses that configuration for all future decisions<br>
(a server always uses the latest configuration in its log, regardless of whether the entry is committed).<br>
This means that the leader will use the rules of Cold,new to determine when the log entry for Cold,new is committed.<br>
If the leader crashes, a new leader may be chosen under either Cold or Cold,new,<br>
depending on whether the winning candidate has received Cold,new.<br>
In any case, Cnew cannot make unilateral decisions during this period.<br>é›†ç¾¤é…ç½®é€šè¿‡å¤åˆ¶æ—¥å¿—ä¸­ç‰¹æ®Šçš„æ¡ç›®è¿›è¡Œå­˜å‚¨å’Œé€šä¿¡ï¼›å›¾11å±•ç¤ºäº†é…ç½®å˜æ›´çš„è¿‡ç¨‹ã€‚<br>
å½“leaderæ¥å—åˆ°ä»¤é…ç½®ä»Cold(æ—§é…ç½®)åˆ°Cnew(æ–°é…ç½®)çš„è¯·æ±‚æ—¶ï¼Œ<br>
å®ƒä¸ºäº†è”åˆä¸€è‡´ä»¥ä¸€ä¸ªæ—¥å¿—æ¡ç›®çš„å½¢å¼å­˜å‚¨è¿™ä¸ªé…ç½®(å›¾ä¸­çš„Cold,new)å¹¶ä¸”ä½¿ç”¨ä¹‹å‰æ‰€æè¿°çš„æœºåˆ¶å¤åˆ¶è¿™ä¸ªæ¡ç›®ã€‚<br>
ä¸€æ—¦ç»™å®šçš„æœåŠ¡å™¨å°†æ–°çš„é…ç½®æ¡ç›®åŠ å…¥äº†å®ƒçš„æ—¥å¿—ï¼Œå®ƒå°†ä½¿ç”¨è¿™äº›é…ç½®æ¥æŒ‡å®šæœªæ¥æ‰€æœ‰çš„å†³å®š(ä¸€ä¸ªæœåŠ¡å™¨æ€»æ˜¯ä½¿ç”¨å®ƒæ—¥å¿—ä¸­æœ€åçš„é…ç½®ï¼Œæ— è®ºè¯¥æ¡ç›®æ˜¯å¦æ˜¯å·²æäº¤çš„)ã€‚<br>
è¿™æ„å‘³ç€leaderå°†ä½¿ç”¨è§„åˆ™Cold,newæ¥å†³å®šä½•æ—¶æäº¤å…³äºCold,newçš„æ—¥å¿—æ¡ç›®ã€‚<br>
å¦‚æœleaderå´©æºƒäº†ï¼Œæ–°çš„leaderå¯èƒ½æ˜¯åœ¨Coldæˆ–è€…æ˜¯Cold,newä¸‹é€‰æ‹©å‡ºæ¥çš„ï¼Œè¿™å–å†³äºè·èƒœçš„candidateæ˜¯å¦å·²ç»æ”¶åˆ°äº†Cold,newã€‚<br>
æ— è®ºå¦‚ä½•ï¼ŒCnewéƒ½ä¸èƒ½åœ¨è¿™ä¸ªé˜¶æ®µå•ç‹¬çš„åšå‡ºå†³å®šã€‚<br>Once Cold,new has been committed, neither Cold nor Cnew can make decisions without approval of the other,<br>
and the Leader Completeness Property ensures that only servers with the Cold,new log entry can be elected as leader.<br>
It is now safe for the leader to create a log entry describing Cnew and replicate it to the cluster.<br>
Again, this configuration will take effect on each server as soon as it is seen.<br>
When the new configuration has been committed under the rules of Cnew,<br>
the old configuration is irrelevant and servers not in the new configuration can be shut down.<br>
As shown in Figure 11, there is no time when Cold and Cnew can both make unilateral decisions; this guarantees safety.<br>ä¸€æ—¦Cold,newå·²ç»æäº¤ï¼ŒColdæˆ–è€…Cnewéƒ½ä¸èƒ½åœ¨æ²¡æœ‰å¦ä¸€æ–¹åŒæ„çš„æƒ…å†µä¸‹åšå‡ºå†³å®šï¼Œ<br>
å¹¶ä¸”Leader Completenessç‰¹æ€§ç¡®ä¿åªæœ‰æ‹¥æœ‰Cold,newæ—¥å¿—æ¡ç›®çš„æœåŠ¡å™¨æ‰èƒ½è¢«é€‰ä¸¾ä¸ºleaderã€‚<br>
ç°åœ¨leaderå¯ä»¥å®‰å…¨çš„åˆ›å»ºä¸€ä¸ªæè¿°äº†Cnewçš„æ—¥å¿—æ¡ç›®å¹¶å°†å…¶åœ¨é›†ç¾¤ä¸­è¿›è¡Œå¤åˆ¶ã€‚<br>
åŒæ ·çš„ï¼Œè¯¥é…ç½®å°†åœ¨æ¯ä¸€ä¸ªæœåŠ¡å™¨çœ‹åˆ°å…¶åç«‹å³ç”Ÿæ•ˆã€‚<br>
å½“æ–°çš„é…ç½®åœ¨Cnewçš„è§„åˆ™ä¸‹è¢«æäº¤ï¼Œæ—§çš„é…ç½®å°†å˜å¾—æ— å…³ç´§è¦å¹¶ä¸”æ²¡æœ‰åœ¨æ–°é…ç½®ä¸­çš„æœåŠ¡å™¨å°†å¯ä»¥è¢«å…³é—­ã€‚<br>
å¦‚å›¾11æ‰€ç¤ºï¼ŒColdå’ŒCnewä¸èƒ½åŒæ—¶åšå‡ºå•ç‹¬çš„å†³å®šï¼›è¿™ä¿è¯äº†å®‰å…¨æ€§ã€‚<br>There are three more issues to address for reconfiguration.<br>
The first issue is that new servers may not initially store any log entries.<br>
If they are added to the cluster in this state, it could take quite a while for them to catch up,<br>
during which time it might not be possible to commit new log entries.<br>
In order to avoid availability gaps, Raft introduces an additional phase before the configuration change,<br>
in which the new servers join the cluster as non-voting members<br>
(the leader replicates log entries to them, but they are not considered for majorities).<br>
Once the new servers have caught up with the rest of the cluster, the reconfiguration can proceed as described above.<br>å…³äºé…ç½®å˜æ›´è¿˜å­˜åœ¨ä¸‰ä¸ªé—®é¢˜éœ€è¦è§£å†³ã€‚<br>
ç¬¬ä¸€ä¸ªé—®é¢˜æ˜¯ï¼Œæ–°çš„æœåŠ¡å™¨å¯èƒ½åœ¨åˆå§‹åŒ–æ—¶æ²¡æœ‰å­˜å‚¨ä»»ä½•çš„æ—¥å¿—æ¡ç›®ã€‚<br>
å¦‚æœåœ¨è¿™ç§çŠ¶æ€ä¸‹è¢«åŠ å…¥åˆ°é›†ç¾¤ï¼Œå®ƒå¯èƒ½éœ€è¦èŠ±è´¹å¾ˆé•¿ä¸€æ®µæ—¶é—´æ‰èƒ½èµ¶ä¸Šï¼Œåœ¨è¿™æ®µæ—¶é—´å†…éƒ½æ— æ³•æäº¤æ–°çš„æ—¥å¿—æ¡ç›®ã€‚<br>
ä¸ºäº†é¿å…å¯ç”¨æ€§çš„å·®è·ï¼ŒRaftåœ¨é…ç½®å˜æ›´å‰å¼•å…¥äº†ä¸€ä¸ªé¢å¤–çš„é˜¶æ®µï¼Œæ–°çš„æœåŠ¡å™¨ä»¥æ— æŠ•ç¥¨æƒæˆå‘˜(non-voting members)çš„èº«ä»½åŠ å…¥é›†ç¾¤<br>
(leaderå¤åˆ¶æ—¥å¿—æ¡ç›®ç»™å®ƒä»¬ï¼Œä½†å®ƒä»¬ä¸è¢«è®¤ä¸ºæ˜¯å¤§å¤šæ•°çš„ä¸€ä»½å­)ã€‚<br>
ä¸€æ—¦æ–°çš„æœåŠ¡å™¨èƒ½å¤Ÿè¿½ä¸Šé›†ç¾¤ä¸­çš„å…¶å®ƒæœºå™¨ï¼Œå°±å¯ä»¥å‘ä¸Šè¿°é‚£èˆ¬æ‰§è¡Œé…ç½®å˜æ›´ã€‚<br>The second issue is that the cluster leader may not be part of the new configuration.<br>
In this case, the leader steps down (returns to follower state) once it has committed the Cnew log entry.<br>
This means that there will be a period of time (while it is committing Cnew)<br>
when the leader is managing a cluster that does not include itself; it replicates log entries but does not count itself in majorities.<br>
The leader transition occurs when Cnew is committed<br>
because this is the first point when the new configuration can operate independently (it will always be possible to choose a leader from Cnew).<br>
Before this point, it may be the case that only a server from Cold can be elected leader.<br>ç¬¬äºŒä¸ªé—®é¢˜æ˜¯ï¼Œé›†ç¾¤çš„leaderå¯èƒ½ä¸æ˜¯æ–°é…ç½®ä¸­çš„ä¸€å‘˜ã€‚<br>
åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä¸€æ—¦Cnewæ—¥å¿—æ¡ç›®è¢«æäº¤ï¼Œleaderå°†ä¼šé€€ä¸‹(è¿”å›åˆ°followerçŠ¶æ€)ã€‚<br>
è¿™æ„å‘³ç€å­˜åœ¨ä¸€æ®µæ—¶é—´(åœ¨æäº¤Cnewæ—¶)ï¼Œå…¶ä¸­leaderç®¡ç†è€…ä¸€ä¸ªä¸åŒ…å«è‡ªå·±çš„é›†ç¾¤ï¼›å®ƒå¤åˆ¶ç€æ—¥å¿—æ¡ç›®ä½†ä¸æŠŠå®ƒè‡ªå·±ç®—ä½œå¤§å¤šæ•°ä¸­çš„ä¸€å‘˜ã€‚<br>
å½“Cnewè¢«æäº¤æ—¶å°†ä¼šå‘ç”Ÿleaderçš„åˆ‡æ¢ï¼Œå› ä¸ºè¿™æ˜¯æ–°é…ç½®å¯ä»¥è¿›è¡Œç‹¬ç«‹æ“ä½œçš„ç¬¬ä¸€ä¸ªç‚¹ä½(æ€»æ˜¯å¯ä»¥åœ¨Cnewä¸­é€‰æ‹©å‡ºä¸€ä¸ªleader)ã€‚<br>
åœ¨æ­¤ä¹‹å‰ï¼Œåªæœ‰æ¥è‡ªColdçš„æœåŠ¡å™¨æ‰æœ‰å¯èƒ½è¢«é€‰ä¸¾ä¸ºleaderã€‚<br>The third issue is that removed servers (those not in Cnew) can disrupt the cluster.<br>
These servers will not receive heartbeats, so they will time out and start new elections.<br>
They will then send RequestVote RPCs with new term numbers, and this will cause the current leader to revert to follower state.<br>
A new leader will eventually be elected, but the removed servers will time out again and the process will repeat,<br>
resulting in poor availability.<br>ç¬¬ä¸‰ä¸ªé—®é¢˜æ˜¯è¢«ç§»é™¤çš„æœåŠ¡å™¨(ä¸åœ¨Cnewä¸­)å¯èƒ½ä¼šä¸­æ–­é›†ç¾¤ã€‚<br>
è¿™äº›æœåŠ¡å™¨å°†ä¸å†æ¥æ”¶åˆ°å¿ƒè·³ï¼Œæ‰€ä»¥å®ƒä»¬å°†ä¼šè¶…æ—¶è€Œå¯åŠ¨æ–°çš„é€‰ä¸¾ã€‚<br>
ç„¶åå®ƒä»¬å°†å‘é€æœ‰ç€æ–°ä»»æœŸç¼–å·çš„RequestVote RPCï¼Œå¹¶ä¸”è¿™å°†å¯¼è‡´å½“å‰çš„leaderæ¢å¤ä¸ºfollowerçŠ¶æ€ã€‚<br>
æœ€ç»ˆå°†ä¼šæœ‰ä¸€åæ–°çš„leaderè¢«é€‰ä¸¾å‡ºæ¥ï¼Œä½†æ˜¯è¢«ç§»é™¤çš„æœåŠ¡å™¨å°†ä¼šå†æ¬¡è¶…æ—¶å¹¶ä¸”é‡å¤è¿™ä¸€è¿‡ç¨‹ï¼Œè¿™å°†å¯¼è‡´ç³»ç»Ÿæœ‰ç€è¾ƒå·®çš„å¯ç”¨æ€§ã€‚<br>To prevent this problem, servers disregard RequestVote RPCs when they believe a current leader exists.<br>
Specifically, if a server receives a RequestVote RPC within the minimum election timeout of hearing from a current leader,<br>
it does not update its term or grant its vote.<br>
This does not affect normal elections, where each server waits at least a minimum election timeout before starting an election.<br>
However, it helps avoid disruptions from removed servers:<br>
if a leader is able to get heartbeats to its cluster, then it will not be deposed by larger term numbers.<br>ä¸ºäº†é¿å…è¿™ä¸€é—®é¢˜ï¼ŒæœåŠ¡å™¨å°†ä¼šåœ¨å®ƒä»¬è®¤ä¸ºå½“å‰leaderå­˜åœ¨æ—¶å¿½ç•¥æ‰RequestVote RPCã€‚<br>
ç‰¹åˆ«çš„ï¼Œå¦‚æœä¸€ä¸ªæœåŠ¡å™¨åœ¨å½“å‰leaderæœ€å°çš„é€‰ä¸¾è¶…æ—¶æ—¶é—´å†…æ¥æ”¶åˆ°ä¸€ä¸ªRequestVote RPCï¼Œå®ƒå°†ä¸ä¼šæ›´æ–°å®ƒçš„ä»»æœŸæˆ–è€…å‘èµ·æŠ•ç¥¨ã€‚<br>
è¿™ä¸ä¼šå½±å“æ­£å¸¸çš„é€‰ä¸¾ï¼Œå³æ¯ä¸€ä¸ªæœåŠ¡å™¨åœ¨å¼€å§‹ä¸€è½®é€‰ä¸¾ä¹‹å‰è‡³å°‘ç­‰å¾…ä¸€ä¸ªæœ€å°çš„é€‰ä¸¾è¶…æ—¶æ—¶é—´ã€‚<br>
ç„¶è€Œï¼Œå®ƒæœ‰åŠ©äºé¿å…ç§»é™¤æœåŠ¡å™¨æ—¶çš„æ··ä¹±ï¼šå¦‚æœä¸€ä¸ªleaderèƒ½å¤Ÿæä¾›é›†ç¾¤ä¸­çš„å¿ƒè·³ï¼Œåˆ™å®ƒå°†ä¸ä¼šè¢«ä¸€ä¸ªæ›´å¤§çš„ä»»æœŸç¼–å·ç»™å–ä»£ã€‚<br><br>Raftâ€™s log grows during normal operation to incorporate more client requests, but in a practical system, it cannot grow without bound.<br>
As the log grows longer, it occupies more space and takes more time to replay.<br>
This will eventually cause availability problems without some mechanism to discard obsolete information that has accumulated in the log.<br>Raftçš„æ—¥å¿—åœ¨æ­£å¸¸æ“ä½œæœŸé—´ä¸æ–­å¢é•¿ä»¥æ»¡è¶³æ›´å¤šçš„å®¢æˆ·ç«¯è¯·æ±‚ï¼Œä½†æ˜¯åœ¨å®é™…çš„ç³»ç»Ÿä¸­ï¼Œæ—¥å¿—ä¸èƒ½ä¸åŠ é™åˆ¶çš„å¢é•¿ã€‚<br>
éšç€æ—¥å¿—ä¸æ–­å˜é•¿ï¼Œå®ƒå°†å ç”¨æ›´å¤šçš„ç©ºé—´å¹¶ä¸”èŠ±è´¹æ›´é•¿çš„äº‹ä»¶æ¥è¿›è¡Œå›æ”¾ã€‚<br>
å¦‚æœæ²¡æœ‰ä¸€äº›æœºåˆ¶æ¥å‰”é™¤æ—¥å¿—ä¸­æ‰€ç´¯ç§¯çš„è¿‡æ—¶çš„ä¿¡æ¯ï¼Œè¿™ç»ˆå°†é€ æˆå¯ç”¨æ€§é—®é¢˜ã€‚<br>Snapshotting is the simplest approach to compaction.<br>
In snapshotting, the entire current system state is written to a snapshot on stable storage,<br>
then the entire log up to that point is discarded.<br>
Snapshotting is used in Chubby and ZooKeeper, and the remainder of this section describes snapshotting in Raft.<br>å¿«ç…§æ˜¯æœ€ç®€å•çš„å‹ç¼©æ–¹æ³•ã€‚<br>
åœ¨å¿«ç…§ä¸­ï¼Œå®Œæ•´çš„å½“å‰ç³»ç»ŸçŠ¶æ€ä»¥å¿«ç…§çš„å½¢å¼å†™å…¥ç¨³å®šçš„å­˜å‚¨ä¸­ï¼Œç„¶ååœ¨è¿™ä¸ªç‚¹ä½ä¹‹å‰çš„æ•´ä¸ªæ—¥å¿—ä¼šè¢«ä¸¢å¼ƒã€‚<br>
å¿«ç…§è¢«ç”¨äºChubbyå’ŒZooKeeperä¸­ï¼Œæœ¬å±Šçš„å‰©ä½™éƒ¨åˆ†å°†ç”¨äºæè¿°Raftä¸­çš„å¿«ç…§ã€‚<br><img alt="Pasted image 20240725173140.png" src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raft-åŸå§‹è®ºæ–‡ä¸­è‹±/pasted-image-20240725173140.png"><br>Figure 12: A server replaces the committed entries in its log(indexes 1 through 5) with a new snapshot,<br>
which stores just the current state (variables x and y in this example).<br>
The snapshotâ€™s last included index and term serve to position the snapshot in the log preceding entry 6.<br>å›¾12ï¼šæœåŠ¡å™¨ç”¨æ–°çš„å¿«ç…§ä»£æ›¿å…¶æ—¥å¿—ä¸­å·²æäº¤çš„æ¡ç›®(ç´¢å¼•1åˆ°5)ï¼Œè¯¥å¿«ç…§åªå­˜å‚¨äº†å½“å‰çš„çŠ¶æ€(æœ¬ä¾‹ä¸­çš„å˜é‡xå’Œy)ã€‚<br>
å¿«ç…§ä¸­çš„last included indexå’Œtermç”¨äºå®šä½å¿«ç…§ä¸­çš„æ¡ç›®6ä¹‹å‰çš„æ—¥å¿—ã€‚<br>Incremental approaches to compaction, such as log cleaning [36] and log-structured merge trees [30, 5], are also possible.<br>
These operate on a fraction of the data at once, so they spread the load of compaction more evenly over time.<br>
They first select a region of data that has accumulated many deleted and overwritten objects,<br>
then they rewrite the live objects from that region more compactly and free the region.<br>
This requires significant additional mechanism and complexity compared to snapshotting,<br>
which simplifies the problem by always operating on the entire data set.<br>
While log cleaning would require modifications to Raft, state machines can implement LSM trees using the same interface as snapshotting.<br>åŸºäºå¢é‡çš„å‹ç¼©æ–¹æ³•ï¼Œä¾‹å¦‚æ—¥å¿—æ¸…ç†å’Œæ—¥å¿—ç»“æ„åˆå¹¶æ ‘(LSM tree)ä¹Ÿæ˜¯å¯è¡Œçš„ã€‚<br>
è¿™äº›æ“ä½œä¸€æ¬¡åªæ“ä½œå°‘é‡çš„æ•°æ®ï¼Œå› æ­¤å®ƒä»¬èƒ½éšç€æ—¶é—´çš„é€€å½¹å‡æ‘Šè´Ÿè½½ã€‚<br>
å®ƒä»¬é¦–å…ˆé€‰æ‹©ä¸€ç‰‡æ•°æ®åŒºåŸŸï¼Œå…¶å·²ç»ç§¯ç´¯äº†å¾ˆå¤šçš„è¢«åˆ é™¤å’Œè¦†ç›–çš„å¯¹è±¡ï¼Œç„¶åå®ƒä»¬ä»¥æ›´åŠ ç´§å‡‘çš„æ–¹å¼é‡å†™æ¥è‡ªè¿™ä¸€ç‰‡åŒºåŸŸçš„å­˜æ´»å¯¹è±¡(live objects)å¹¶é‡Šæ”¾è¿™ä¸€åŒºåŸŸã€‚<br>
ä¸å¿«ç…§å‹ç¼©ç›¸æ¯”è¿™æ˜¾è‘—çš„å¼•å…¥äº†é¢å¤–çš„æœºåˆ¶å’Œå¤æ‚åº¦ï¼Œå¿«ç…§é€šè¿‡å§‹ç»ˆæ“ä½œæ•´ä¸ªæ•°æ®é›†åˆæ¥ç®€åŒ–è¿™ä¸€é—®é¢˜ã€‚<br>
è™½ç„¶æ—¥å¿—æ¸…ç†éœ€è¦å¯¹Raftè¿›è¡Œä¿®æ”¹ï¼Œä½†çŠ¶æ€æœºå¯ä»¥ä½¿ç”¨ä¸å¿«ç…§ç›¸åŒçš„æ¥å£æ¥å®ç°LSMæ ‘ã€‚<br>Figure 12 shows the basic idea of snapshotting in Raft.<br>
Each server takes snapshots independently, covering just the committed entries in its log.<br>
Most of the work consists of the state machine writing its current state to the snapshot.<br>
Raft also includes a small amount of metadata in the snapshot:<br>
the last included index is the index of the last entry in the log that the snapshot replaces<br>
(the last entry the state machine had applied), and the last included term is the term of this entry.<br>
These are preserved to support the AppendEntries consistency check for the first log entry following the snapshot,<br>
since that entry needs a previous log index and term.<br>
To enable cluster membership changes (Section 6), the snapshot also includes the latest configuration in the log as of last included index.<br>
Once a server completes writing a snapshot, it may delete all log entries up through the last included index, as well as any prior snapshot.<br>å›¾12å±•ç¤ºäº†Raftä¸­å…³äºå¿«ç…§çš„åŸºç¡€æ€æƒ³ã€‚<br>
æ¯ä¸€ä¸ªæœåŠ¡å™¨éƒ½ç‹¬ç«‹çš„è·å¾—å¿«ç…§ï¼Œåªè¦†ç›–å®ƒå·²æäº¤çš„æ—¥å¿—æ¡ç›®ã€‚<br>
å¤§éƒ¨åˆ†çš„å·¥ä½œä¸»è¦ç”±çŠ¶æ€æœºä»¥å¿«ç…§å½¢å¼å†™å…¥å®ƒçš„å½“å‰çŠ¶æ€ç»„æˆã€‚<br>
Raftè¿˜å°†å°‘é‡çš„å…ƒæ•°æ®åŒ…æ‹¬åœ¨äº†å¿«ç…§ä¸­ï¼š<br>
last included indexæ˜¯å¿«ç…§ä»£æ›¿çš„æ—¥å¿—ä¸­çš„æœ€åä¸€ä¸ªæ¡ç›®çš„ç´¢å¼•å€¼(çŠ¶æ€æœºå·²åº”ç”¨çš„æœ€åä¸€ä¸ªæ¡ç›®)ï¼Œå¹¶ä¸”last included termæ˜¯è¿™ä¸ªæ¡ç›®çš„ä»»æœŸå€¼ã€‚<br>
ä¿ç•™è¿™äº›æ¡ç›®æ˜¯ä¸ºäº†æ”¯æŒå¿«ç…§åé¢ç¬¬ä¸€ä¸ªæ¡ç›®çš„AppendEntriesä¸€è‡´æ€§æ£€æŸ¥ï¼Œå› ä¸ºè¿™ä¸ªæ¡ç›®éœ€è¦å‰ä¸€ä¸ªæ—¥å¿—çš„ç´¢å¼•å€¼å’Œä»»æœŸå€¼ã€‚<br>
è¦å¯ç”¨é›†ç¾¤å˜æ›´(ç¬¬6èŠ‚)ï¼Œå¿«ç…§è¿˜è¦åŒ…æ‹¬å«æœ‰last included indexæ—¥å¿—çš„æœ€åé…ç½®ã€‚<br>
ä¸€æ—¦ä¸€ä¸ªæœåŠ¡å™¨å®Œæˆäº†ä¸€ä¸ªå¿«ç…§çš„å†™å…¥ï¼Œå®ƒå¯èƒ½ä¼šåˆ é™¤åŒ…å«last included indexä¹‹å‰çš„æ‰€æœ‰æ—¥å¿—æ¡ç›®ï¼Œä»¥åŠä¹‹å‰çš„ä»»ä½•å¿«ç…§ã€‚<br>Although servers normally take snapshots independently, the leader must occasionally send snapshots to followers that lag behind.<br>
This happens when the leader has already discarded the next log entry that it needs to send to a follower.<br>
Fortunately, this situation is unlikely in normal operation: a follower that has kept up with the leader would already have this entry.<br>
However, an exceptionally slow follower or a new server joining the cluster(Section 6) would not.<br>
The way to bring such a follower up-to-date is for the leader to send it a snapshot over the network.<br><img alt="Pasted image 20240725173149.png" src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raft-åŸå§‹è®ºæ–‡ä¸­è‹±/pasted-image-20240725173149.png"><br>Figure 13: A summary of the InstallSnapshot RPC.<br>
Snapshots are split into chunks for transmission; this gives the follower a sign of life with each chunk, so it can reset its election timer.<br>å›¾13ï¼šInstallSnapshot RPCçš„å¿«ç…§ã€‚<br>
å¿«ç…§è¢«åˆ†å‰²ä¸ºå—è¿›è¡Œä¼ è¾“ï¼›æ¯ä¸€å—éƒ½å¸¦ç»™äº†followerå…¶å­˜æ´»çš„æ ‡è¯†ï¼Œå› æ­¤followerå¯ä»¥é‡ç½®å…¶é€‰ä¸¾è®¡æ—¶å™¨ã€‚<br>å°½ç®¡æœåŠ¡å™¨é€šå¸¸ç‹¬ç«‹çš„ç”Ÿæˆå¿«ç…§ï¼Œä½†leaderå¿…é¡»å¶å°”çš„å‘è½åçš„followerå‘é€å¿«ç…§ã€‚<br>
å½“leaderå·²ç»ä¸¢å¼ƒäº†éœ€è¦å‘é€ç»™followerçš„ä¸‹ä¸€ä¸ªæ—¥å¿—æ¡ç›®æ—¶å°±ä¼šå‘ç”Ÿè¿™ç§æƒ…å†µã€‚<br>
å¹¸è¿çš„æ˜¯ï¼Œè¿™ç§æƒ…å†µä¸å¤ªå¯èƒ½åœ¨æ­£å¸¸æ“ä½œä¸­å‡ºç°ï¼šä¸€ä¸ªè·Ÿä¸Šäº†leaderçš„followerå·²ç»æœ‰äº†è¿™ä¸ªæ¡ç›®äº†ã€‚<br>
ç„¶è€Œï¼Œä¸€ä¸ªå¼‚å¸¸æ…¢çš„followeræˆ–è€…ä¸€ä¸ªæ–°åŠ å…¥é›†ç¾¤çš„æœåŠ¡å™¨(ç¬¬6èŠ‚)å°†æ²¡æœ‰è¿™ä¸ªæ¡ç›®ã€‚<br>
è®©è¿™æ ·çš„ä¸€ä¸ªfollowerçš„æ—¥å¿—å’Œleaderä¸€æ ·æ–°çš„æ–¹æ³•å°±æ˜¯é€šè¿‡ç½‘ç»œå‘å®ƒå‘é€ä¸€ä¸ªå¿«ç…§ã€‚<br>The leader uses a new RPC called InstallSnapshot to send snapshots to followers that are too far behind; see Figure 13.<br>
When a follower receives a snapshot with this RPC, it must decide what to do with its existing log entries.<br>
Usually the snapshot will contain new information not already in the recipientâ€™s log.<br>
In this case, the follower discards its entire log; it is all superseded by the snapshot<br>
and may possibly have uncommitted entries that conflict with the snapshot.<br>
If instead the follower receives a snapshot that describes a prefix of its log (due to retransmission or by mistake),<br>
then log entries covered by the snapshot are deleted but entries following the snapshot are still valid and must be retained.<br>leaderä½¿ç”¨ä¸€ç§æ–°çš„è¢«æˆä¸ºInstallSnapshotçš„RPCå‘è½åå¤ªå¤šçš„followerå‘é€å¿«ç…§;å¦‚å›¾13æ‰€ç¤ºã€‚<br>
å½“ä¸€ä¸ªfollowerä½¿ç”¨è¿™ä¸ªRPCæ¥å—åˆ°ä¸€ä¸ªå¿«ç…§æ—¶ï¼Œå®ƒå¿…é¡»å†³å®šå¦‚ä½•å¤„ç†å®ƒç›®å‰å·²å­˜åœ¨çš„æ—¥å¿—æ¡ç›®ã€‚<br>
é€šå¸¸ï¼Œè¿™ä¸ªå¿«ç…§å°†åŒ…å«ç›®å‰è¿˜ä¸åœ¨æ¥å—è€…æ—¥å¿—ä¸­çš„æ–°ä¿¡æ¯ã€‚<br>
è¿™ç§æƒ…å†µä¸‹ï¼Œfollowerå°†ä¸¢å¼ƒå®ƒå…¨éƒ¨çš„æ—¥å¿—;å…¶å…¨éƒ¨è¢«å¿«ç…§æ‰€å–ä»£ï¼Œå¹¶ä¸”è¢«ä¸¢å¼ƒçš„æ—¥å¿—ä¸­å¯èƒ½æœ‰ç€ä¸å¿«ç…§ç›¸å†²çªçš„ä½†è¿˜æœªæäº¤çš„æ¡ç›®ã€‚<br>
ç›¸åï¼Œå¦‚æœfolloweræ¥å—åˆ°çš„å¿«ç…§æ˜¯å®ƒå½“å‰æ—¥å¿—çš„å‰é¢ä¸€éƒ¨åˆ†(ç”±äºé‡ä¼ æˆ–è€…å‡ºé”™äº†)ï¼Œåˆ™è¢«å¿«ç…§æ‰€è¦†ç›–çš„æ—¥å¿—æ¡ç›®å°†ä¼šè¢«åˆ é™¤ä½†æ˜¯å¿«ç…§åé¢çš„æ¡ç›®ä¾ç„¶æ˜¯æœ‰æ•ˆçš„å¹¶ä¸”å¿…é¡»è¢«ä¿ç•™ã€‚<br>This snapshotting approach departs from Raftâ€™s strong leader principle, since followers can take snapshots without the knowledge of the leader.<br>
However, we think this departure is justified.<br>
While having a leader helps avoid conflicting decisions in reaching consensus,<br>
consensus has already been reached when snapshotting, so no decisions conflict.<br>
Data still only flows from leaders to followers, just followers can now reorganize their data.<br>è¿™ç§å¿«ç…§çš„æ–¹å¼èƒŒç¦»äº†Raftçš„å¼ºleaderåŸåˆ™ï¼Œå› ä¸ºfollowerå¯ä»¥åœ¨leaderä¸çŸ¥æƒ…çš„æƒ…å†µä¸‹ç”Ÿæˆå¿«ç…§ã€‚<br>
ç„¶è€Œï¼Œæˆ‘ä»¬è®¤ä¸ºè¿™ç§èƒŒç¦»æ˜¯å€¼å¾—çš„ã€‚<br>
è™½ç„¶ç”±ä¸€ä¸ªleaderæœ‰åŠ©äºé¿å…åœ¨è¾¾æˆä¸€è‡´æ—¶äº§ç”Ÿå†³ç­–å†²çªï¼Œä½†ç”Ÿæˆå¿«ç…§æ—¶æ˜¯å·²ç»è¾¾æˆäº†ä¸€è‡´çš„ï¼Œæ‰€ä»¥ä¸ä¼šæœ‰å†³ç­–å†²çªã€‚<br>
æ•°æ®ä¾ç„¶æ˜¯ä»…ç”±leaderæµå‘followerï¼Œä½†followerç°åœ¨å¯ä»¥é‡æ–°ç»„ç»‡å®ƒä»¬çš„æ•°æ®ã€‚<br>We considered an alternative leader-based approach in which only the leader would create a snapshot,<br>
then it would send this snapshot to each of its followers.<br>
However, this has two disadvantages.<br>
First, sending the snapshot to each follower would waste network bandwidth and slow the snapshotting process.<br>
Each follower already has the information needed to produce its own snapshots,<br>
and it is typically much cheaper for a server to produce a snapshot from its local state than it is to send and receive one over the network.<br>
Second, the leaderâ€™s implementation would be more complex.<br>
For example, the leader would need to send snapshots to followers in parallel with replicating new log entries to them,<br>
so as not to block new client requests.<br>æˆ‘ä»¬è€ƒè™‘è¿‡å¦ä¸€ç§åŸºäºleaderçš„æ–¹æ³•ï¼Œå…¶åªæœ‰leaderå¯ä»¥åˆ›å»ºå¿«ç…§ï¼Œç„¶åleaderå°†å‘é€å¿«ç…§ç»™æ¯ä¸€ä¸ªfollowerã€‚<br>
ç„¶è€Œï¼Œè¿™æ ·åšæœ‰ä¸¤ä¸ªç¼ºç‚¹ã€‚<br>
é¦–å…ˆï¼Œå‘é€å¿«ç…§ç»™æ¯ä¸€ä¸ªfollowerå°†æµªè´¹ç½‘ç»œå¸¦å®½å¹¶ä¸”å‡æ…¢å¿«ç…§çš„å¤„ç†ã€‚<br>
æ¯ä¸€ä¸ªfollowerå·²ç»æœ‰äº†ç”Ÿæˆå®ƒä»¬è‡ªå·±å¿«ç…§æ‰€éœ€è¦çš„ä¿¡æ¯ï¼Œå¹¶ä¸”é€šå¸¸åŸºäºæœåŠ¡å™¨æœ¬åœ°çŠ¶æ€æ¥ç”Ÿæˆå¿«ç…§è¦æ¯”å®ƒä»¬é€šè¿‡ä»ç½‘ç»œå‘é€å’Œæ¥æ”¶å¿«ç…§çš„å¼€é”€è¦æ›´ä½ã€‚<br>
å…¶æ¬¡ï¼Œleaderä¹Ÿä¼šè¢«å®ç°çš„æ›´åŠ å¤æ‚ã€‚<br>
æ¯”å¦‚ï¼Œleaderå°†éœ€è¦å¹¶è¡Œçš„å‘é€å¿«ç…§ç»™followerçš„åŒæ—¶è¿˜è¦ä»¤å®ƒä»¬å¤åˆ¶æ–°çš„æ—¥å¿—æ¡ç›®ï¼Œä»¥é¿å…é˜»å¡æ–°çš„å®¢æˆ·ç«¯è¯·æ±‚ã€‚<br>There are two more issues that impact snapshotting performance.<br>
First, servers must decide when to snapshot.<br>
If a server snapshots too often, it wastes disk bandwidth and energy; if it snapshots too infrequently,<br>
it risks exhausting its storage capacity, and it increases the time required to replay the log during restarts.<br>
One simple strategy is to take a snapshot when the log reaches a fixed size in bytes.<br>
If this size is set to be significantly larger than the expected size of a snapshot,<br>
then the disk bandwidth overhead for snapshotting will be small.<br>è¿˜æœ‰ä¸¤ä¸ªé—®é¢˜ä¼šå½±å“å¿«ç…§çš„æ€§èƒ½ã€‚<br>
é¦–å…ˆï¼ŒæœåŠ¡å™¨å¿…é¡»å†³å®šä½•æ—¶ç”Ÿæˆå¿«ç…§ã€‚<br>
å¦‚æœæœåŠ¡å™¨ç”Ÿæˆå¿«ç…§å¤ªé¢‘ç¹ï¼Œåˆ™å°†æµªè´¹ç£ç›˜å¸¦å®½å’Œèƒ½æºï¼›å¦‚æœç”Ÿæˆå¿«ç…§å¤ªä¸é¢‘ç¹ï¼Œåˆ™å­˜åœ¨è€—å°½ç£ç›˜ç©ºé—´çš„é£é™©ï¼Œå¹¶ä¸”å¢åŠ é‡å¯æ—¶å›æ”¾æ—¥å¿—æ‰€éœ€çš„æ—¶é—´ã€‚<br>
ä¸€ç§ç®€å•çš„ç­–ç•¥æ—¶å½“æ—¥å¿—åˆ°è¾¾ä¸€ä¸ªå›ºå®šçš„å­—èŠ‚æ•°æ—¶ç”Ÿæˆä¸€ä¸ªå¿«ç…§ã€‚<br>
å¦‚æœè¿™ä¸ªå¤§å°è®¾ç½®ä¸ºä¸€ä¸ªæ˜æ˜¾å¤§äºå¿«ç…§é¢„æœŸå¤§å°çš„å€¼ï¼Œåˆ™ç”¨äºå¿«ç…§ç”Ÿæˆçš„ç£ç›˜å¸¦å®½å¼€é”€å°†ä¼šå¾ˆå°ã€‚<br>The second performance issue is that writing a snapshot can take a significant amount of time,<br>
and we do not want this to delay normal operations.<br>
The solution is to use copy-on-write techniques so that new updates can be accepted without impacting the snapshot being written.<br>
For example, state machines built with functional data structures naturally support this.<br>
Alternatively, the operating systemâ€™s copy-on-write support (e.g., fork on Linux)<br>
can be used to create an in-memory snapshot of the entire state machine (our implementation uses this approach).<br>ç¬¬äºŒä¸ªé—®é¢˜æ˜¯å†™å…¥ä¸€ä¸ªå¿«ç…§ä¼šèŠ±è´¹éå¸¸å¤šçš„æ—¶é—´ï¼Œå¹¶ä¸”æˆ‘ä»¬ä¸å¸Œæœ›è¿™ä¼šå»¶è¿Ÿæ­£å¸¸æ“ä½œã€‚<br>
è§£å†³çš„æ–¹æ¡ˆæ˜¯ä½¿ç”¨å†™æ—¶å¤åˆ¶(copy-on-write)æŠ€æœ¯,ä»¥ä¾¿å¯ä»¥åœ¨ä¸å½±å“å¿«ç…§çš„å†™å…¥çš„åŒæ—¶æ¥å—æ–°çš„æ›´æ–°ã€‚<br>
ä¾‹å¦‚ï¼Œä½¿ç”¨å‡½æ•°å¼æ•°æ®ç»“æ„(functional data structures)æ„å»ºçš„çŠ¶æ€æœºèƒ½è‡ªç„¶çš„æ”¯æŒè¿™ä¸€ç‚¹ã€‚<br>
æˆ–è€…ï¼Œæ“ä½œç³»ç»Ÿçš„å†™æ—¶å¤åˆ¶æ”¯æŒ(ä¾‹å¦‚ï¼Œlinuxä¸­çš„fork)å¯ä»¥è¢«ç”¨äºåˆ›å»ºæ•´ä¸ªçŠ¶æ€æœºçš„å†…å­˜å¿«ç…§(æˆ‘ä»¬çš„å®ç°ä½¿ç”¨äº†è¿™ä¸ªæ–¹æ³•)ã€‚<br><br>This section describes how clients interact with Raft,<br>
including how clients find the cluster leader and how Raft supports linearizable semantics [10].<br>
These issues apply to all consensus-based systems, and Raftâ€™s solutions are similar to other systems.<br>æœ¬èŠ‚æè¿°äº†å®¢æˆ·ç«¯å¦‚ä½•ä¸Raftäº¤äº’ï¼ŒåŒ…æ‹¬å®¢æˆ·ç«¯å¦‚ä½•æ‰¾åˆ°é›†ç¾¤leaderä»¥åŠRaftæ˜¯å¦‚ä½•æ”¯æŒçº¿æ€§åŒ–è¯­ä¹‰çš„ã€‚<br>
è¿™äº›é—®é¢˜é€‚ç”¨äºæ‰€æœ‰çš„åŸºäºä¸€è‡´æ€§çš„ç³»ç»Ÿï¼ŒåŒæ—¶Raftçš„è§£å†³æ–¹æ¡ˆä¹Ÿä¸å…¶å®ƒç³»ç»Ÿæ˜¯ç±»ä¼¼çš„ã€‚<br>Clients of Raft send all of their requests to the leader.<br>
When a client first starts up, it connects to a randomly-chosen server.<br>
If the clientâ€™s first choice is not the leader,<br>
that server will reject the clientâ€™s request and supply information about the most recent leader it has heard from<br>
(AppendEntries requests include the network address of the leader).<br>
If the leader crashes, client requests will time out; clients then try again with randomly-chosen servers.<br>Raftçš„å®¢æˆ·ç«¯å°†å®ƒä»¬çš„æ‰€æœ‰è¯·æ±‚å‘é€ç»™leaderã€‚<br>
å½“å®¢æˆ·ç«¯ç¬¬ä¸€æ¬¡å¯åŠ¨æ—¶ï¼Œå®ƒä¼šéšæœºé€‰æ‹©ä¸€å°æœåŠ¡å™¨å¹¶è¿›è¡Œè¿æ¥ã€‚<br>
å¦‚æœå®¢æˆ·ç«¯ç¬¬ä¸€æ¬¡é€‰æ‹©çš„ä¸æ˜¯leaderï¼Œåˆ™æœåŠ¡å™¨å°†ä¼šæ‹’ç»å®¢æˆ·ç«¯çš„è¯·æ±‚å¹¶ä¸”æä¾›å…³äºå®ƒå¬åˆ°çš„æœ€è¿‘çš„leaderçš„ä¿¡æ¯(AppendEntriesçš„è¯·æ±‚ä¸­åŒ…æ‹¬äº†leaderçš„ç½‘ç»œåœ°å€)ã€‚<br>
å¦‚æœleaderå´©æºƒäº†ï¼Œå®¢æˆ·ç«¯çš„è¯·æ±‚å°†ä¼šè¶…æ—¶;å®¢æˆ·ç«¯åˆ™ä¼šå†ä¸€æ¬¡éšæœºé€‰æ‹©ä¸€å°æœåŠ¡å™¨ã€‚<br>Our goal for Raft is to implement linearizable semantics (each operation appears to execute instantaneously,<br>
exactly once, at some point between its invocation and its response).<br>
However, as described so far Raft can execute a command multiple times:<br>
for example, if the leader crashes after committing the log entry but before responding to the client,<br>
the client will retry the command with a new leader, causing it to be executed a second time.<br>
The solution is for clients to assign unique serial numbers to every command.<br>
Then, the state machine tracks the latest serial number processed for each client, along with the associated response.<br>
If it receives a command whose serial number has already been executed, it responds immediately without re-executing the request.<br>æˆ‘ä»¬å¯¹äºRaftçš„ç›®æ ‡æ˜¯å®ç°å¯çº¿æ€§åŒ–çš„è¯­ä¹‰(æ¯ä¸€ä¸ªæ“ä½œä¼šç«‹å³æ‰§è¡Œï¼Œæ‰§è¡Œä¸”åªæ‰§è¡Œä¸€æ¬¡ï¼Œæ‰§è¡Œçš„æ—¶æœºä½äºè¯·æ±‚å’Œå“åº”ä¹‹é—´)ã€‚<br>
ç„¶è€Œï¼Œå¦‚ä¸Šæ‰€è¿°Raftå¯ä»¥æ‰§è¡Œæ‰§è¡Œä¸€æ¡æŒ‡ä»¤å¤šæ¬¡ï¼šä¾‹å¦‚ï¼Œå¦‚æœleaderåœ¨æäº¤æ—¥å¿—æ¡ç›®åä½†å“åº”å®¢æˆ·ç«¯ä¹‹å‰å´©æºƒäº†ï¼Œå®¢æˆ·ç«¯å°†ä¼šä¸æ–°çš„leaderé‡è¯•è¿™æ¡æŒ‡ä»¤ï¼Œä½¿å¾—è¯¥æŒ‡ä»¤è¢«æ‰§è¡Œäº†ä¸¤æ¬¡ã€‚<br>
è§£å†³æ–¹æ¡ˆæ˜¯è®©å®¢æˆ·ç«¯ä¸ºæ¯ä¸€ä¸ªæŒ‡ä»¤åˆ†é…ä¸€ä¸ªå”¯ä¸€çš„åºåˆ—å·ã€‚<br>
ç„¶åï¼ŒçŠ¶æ€æœºè¿½è¸ªä¸ºæ¯ä¸€ä¸ªå®¢æˆ·ç«¯å¤„ç†çš„æœ€åçš„åºåˆ—å·ï¼Œä»¥åŠç›¸å…³çš„å“åº”ã€‚<br>
å¦‚æœå®ƒæ¥å—åˆ°äº†ä¸€ä¸ªæŒ‡ä»¤å…¶åºåˆ—å·æ˜¯å·²ç»è¢«æ‰§è¡Œäº†çš„ï¼Œå®ƒå°†ç«‹å³è¿”å›è€Œä¸ä¼šé‡æ–°æ‰§è¡Œè¯¥è¯·æ±‚ã€‚<br>Read-only operations can be handled without writing anything into the log.<br>
However, with no additional measures, this would run the risk of returning stale data,<br>
since the leader responding to the request might have been superseded by a newer leader of which it is unaware.<br>
Linearizable reads must not return stale data, and Raft needs two extra precautions to guarantee this without using the log.<br>
First, a leader must have the latest information on which entries are committed.<br>
The Leader Completeness Property guarantees that a leader has all committed entries,<br>
but at the start of its term, it may not know which those are.<br>
To find out, it needs to commit an entry from its term.<br>
Raft handles this by having each leader commit a blank no-op entry into the log at the start of its term.<br>
Second, a leader must check whether it has been deposed before processing a read-only request<br>
(its information may be stale if a more recent leader has been elected).<br>
Raft handles this by having the leader exchange heartbeat messages with a majority of the cluster before responding to read-only requests.<br>
Alternatively, the leader could rely on the heartbeat mechanism to provide a form of lease [9],<br>
but this would rely on timing for safety (it assumes bounded clock skew).<br>åªè¯»æ“ä½œå¯ä»¥ç›´æ¥è¢«å¤„ç†è€Œä¸éœ€è¦å‘æ—¥å¿—å†™å…¥ä»»ä½•ä¸œè¥¿ã€‚<br>
ç„¶è€Œï¼Œå¦‚æœæ²¡æœ‰é¢å¤–çš„æœºåˆ¶ï¼Œå°†ä¼šæœ‰è¿”å›è¿‡æ—¶æ•°æ®çš„é£é™©ï¼Œå› ä¸ºå“åº”è¯·æ±‚çš„leaderå¯èƒ½å·²ç»è¢«ä¸€ä¸ªæ–°çš„leaderå–ä»£äº†ä½†å®ƒè‡ªå·±å´æ²¡æ„ŸçŸ¥åˆ°ã€‚<br>
çº¿æ€§åŒ–çš„è¯»å¿…é¡»ä¸è¿”å›è¿‡æ—¶æ•°æ®ï¼Œå¹¶ä¸”Raftéœ€è¦ä¸¤ä¸ªé¢å¤–çš„é¢„é˜²æªæ–½åœ¨ä¸ä½¿ç”¨æ—¥å¿—çš„å‰æä¸‹ä¿è¯è¿™ä¸€ç‚¹ã€‚<br>
é¦–å…ˆï¼Œleaderå¿…é¡»æŒæ¡å·²æäº¤æ—¥å¿—æ¡ç›®çš„æœ€æ–°ä¿¡æ¯ã€‚<br>
leaderå®Œæ•´æ€§å±æ€§ä¿è¯äº†leaderæœ‰ç€æ‰€æœ‰å·²æäº¤çš„æ¡ç›®ï¼Œä½†åœ¨å®ƒä»»æœŸçš„å¼€å§‹æ—¶ï¼Œå®ƒä¸çŸ¥é“å“ªäº›æ˜¯å·²æäº¤çš„æ¡ç›®ã€‚<br>
ä¸ºäº†æ‰¾åˆ°å“ªäº›æ˜¯å·²æäº¤çš„æ¡ç›®ï¼Œå®ƒéœ€è¦æäº¤ä¸€ä¸ªæ¥è‡ªå®ƒè‡ªå·±ä»»æœŸçš„æ¡ç›®ã€‚<br>
Rafté€šè¿‡åœ¨leaderå¼€å§‹å…¶ä»»æœŸæ—¶ï¼Œè®©æ¯ä¸€ä¸ªleaderæäº¤ä¸€ä¸ªç©ºç™½çš„no-opæ¡ç›®æ¥å¤„ç†è¿™ä¸€é—®é¢˜ã€‚<br>
å…¶æ¬¡ï¼Œleaderåœ¨å¤„ç†åªè¯»è¯·æ±‚æ—¶å¿…é¡»æ£€æŸ¥å®ƒæ˜¯å¦å·²ç»è¢«ç½¢é»œé€€ä½äº†(å¦‚æœæœ€æ–°çš„leaderå·²ç»è¢«é€‰å‡ºï¼Œåˆ™å®ƒçš„ä¿¡æ¯å¯èƒ½å·²ç»è¿‡æ—¶äº†)ã€‚<br>
Rafté€šè¿‡è®©leaderåœ¨å“åº”åªè¯»è¯·æ±‚ä¹‹å‰ä¸é›†ç¾¤ä¸­çš„å¤§å¤šæ•°äº¤æ¢å¿ƒè·³ä¿¡æ¯æ¥è§£å†³è¿™ä¸€é—®é¢˜ã€‚<br>
æˆ–è€…ï¼Œleaderå¯ä»¥ä¾èµ–å¿ƒè·³æœºåˆ¶æ¥æä¾›ä¸€ç§ç§Ÿçº¦çš„å½¢å¼ï¼Œä½†è¿™å°†ä¼šä¾èµ–äºæ—¶é’Ÿçš„å®‰å…¨æ€§(å‡è®¾æ—¶é—´è¯¯å·®æ˜¯æœ‰é™çš„)ã€‚<br><br>We have implemented Raft as part of a replicated state machine that stores configuration information for RAMCloud [33]<br>
and assists in failover of the RAMCloud coordinator.<br>
The Raft implementation contains roughly 2000 lines of C++ code, not including tests, comments, or blank lines.<br>
The source code is freely available [23].<br>
There are also about 25 independent third-party open source implementations [34] of Raft in various stages of development,<br>
based on drafts of this paper.<br>
Also, various companies are deploying Raft-based systems [34].<br>æˆ‘ä»¬å·²ç»å°†Raftå®ç°ä¸ºå¤åˆ¶çŠ¶æ€æœºçš„ä¸€éƒ¨åˆ†ï¼Œå…¶å­˜å‚¨RAMCloudçš„é…ç½®ä¿¡æ¯å¹¶ä¸”ååŠ©RAMCloudåè°ƒè€…è¿›è¡Œæ•…éšœæ¢å¤ã€‚<br>
Raftçš„å®ç°åŒ…å«äº†å¤§æ¦‚2000è¡Œçš„C++ä»£ç ï¼Œä¸åŒ…æ‹¬æµ‹è¯•ï¼Œå¤‡æ³¨æˆ–è€…ç©ºè¡Œã€‚<br>
æºä»£ç æ˜¯å…è´¹æä¾›çš„ã€‚<br>
åŸºäºæœ¬è®ºæ–‡çš„è‰ç¨¿ï¼Œæœ‰å¤§çº¦25ä¸ªç‹¬ç«‹çš„ã€å¤„äºä¸åŒå¼€å‘é˜¶æ®µçš„Raftä¸‰æ–¹å¼€æºå®ç°ã€‚<br>
æ­¤å¤–ï¼Œå¾ˆå¤šå…¬å¸ä¹Ÿéƒ¨ç½²äº†åŸºäºRaftçš„ç³»ç»Ÿã€‚<br>The remainder of this section evaluates Raft using three criteria: understandability, correctness, and performance.<br>æœ¬èŠ‚çš„å‰©ä½™éƒ¨åˆ†ç”¨äºåœ¨ä¸‰ä¸ªæ–¹é¢è¯„ä¼°Raft: å¯ç†è§£æ€§ï¼Œæ­£ç¡®æ€§å’Œæ€§èƒ½ã€‚<br><br>To measure Raftâ€™s understandability relative to Paxos,<br>
we conducted an experimental study using upper-level undergraduate and graduate students in<br>
an Advanced Operating Systems course at Stanford University and a Distributed Computing course at U.C. Berkeley.<br>
We recorded a video lecture of Raft and another of Paxos, and created corresponding quizzes.<br>
The Raft lecture covered the content of this paper except for log compaction;<br>
the Paxos lecture covered enough material to create an equivalent replicated state machine, including single-decree Paxos,<br>
multi-decree Paxos, reconfiguration, and a few optimizations needed in practice (such as leader election).<br>
The quizzes tested basic understanding of the algorithms and also required students to reason about corner cases.<br>
Each student watched one video, took the corresponding quiz, watched the second video, and took the second quiz.<br>
About half of the participants did the Paxos portion first<br>
and the other half did the Raft portion first in order to account for both individual differences in performance<br>
and experience gained from the first portion of the study.<br>
We compared participantsâ€™ scores on each quiz to determine whether participants showed a better understanding of Raft.<br><img alt="Pasted image 20240725173202.png" src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raft-åŸå§‹è®ºæ–‡ä¸­è‹±/pasted-image-20240725173202.png"><br>Figure 14: A scatter plot comparing 43 participantsâ€™ performance on the Raft and Paxos quizzes.<br>
Points above the diagonal (33) represent participants who scored higher for Raft.<br>å›¾14ï¼šæ¯”è¾ƒ43åå‚ä¸è€…åœ¨Raftå’ŒPaxosæµ‹éªŒä¸­è¡¨ç°çš„æ•£ç‚¹å›¾ã€‚<br>
ä½äºå¯¹è§’çº¿ä¹‹ä¸Šçš„(33ä¸ª)å‚ä¸è€…æ˜¯Raftåˆ†æ•°æ›´é«˜çš„ã€‚<br>ä¸ºäº†æµ‹é‡Raftç›¸å¯¹äºPaxosçš„å¯ç†è§£æ€§ï¼Œæˆ‘ä»¬å¯¹æ¥è‡ªæ–¯å¦ç¦å¤§å­¦çš„é«˜çº§æ“ä½œç³»ç»Ÿè¯¾ç¨‹å’ŒåŠ å·å¤§å­¦ä¼¯å…‹åˆ©åˆ†æ ¡çš„åˆ†å¸ƒå¼ç³»ç»Ÿè¯¾ç¨‹çš„é«˜æ°´å¹³æœ¬ç§‘ç”Ÿå’Œç ”ç©¶ç”Ÿç»„ç»‡äº†ä¸€åœºå­¦ä¹ å®éªŒã€‚<br>
æˆ‘ä»¬å½•åˆ¶äº†Raftå’ŒPaxosçš„è§†é¢‘è®²åº§ï¼Œå¹¶ä¸”åˆ¶ä½œäº†ç›¸å¯¹åº”çš„æµ‹éªŒã€‚<br>
Raftçš„è®²åº§è¦†ç›–äº†æœ¬æ–‡é™¤æ—¥å¿—å‹ç¼©ä»¥å¤–çš„å†…å®¹ï¼ŒPaxosçš„è®²åº§è¦†ç›–äº†ç›¸å½“äºåˆ›å»ºä¸€ä¸ªç­‰æ•ˆçš„å¤åˆ¶çŠ¶æ€æœºçš„è¶³å¤Ÿå¤šçš„ææ–™ï¼ŒåŒ…æ‹¬single-decree Paxosï¼Œmulti-decree Paxosï¼Œ<br>
åˆ·æ–°é…ç½®ï¼Œä»¥åŠå®è·µä¸­æ‰€éœ€è¦çš„ä¸€å°éƒ¨åˆ†ä¼˜åŒ–(ä¾‹å¦‚leaderé€‰ä¸¾)ã€‚<br>
æµ‹éªŒæµ‹è¯•äº†å­¦ç”Ÿå¯¹ç®—æ³•çš„åŸºç¡€ç†è§£åŒæ—¶ä¹Ÿéœ€è¦å­¦ç”Ÿèƒ½æ¨ç†å‡ºæç«¯çš„caseã€‚<br>
æ¯ä¸ªå­¦ç”Ÿè§‚çœ‹ç¬¬ä¸€ä¸ªè§†é¢‘ï¼Œç„¶ååšç›¸åº”çš„æµ‹éªŒï¼Œå†çœ‹ç¬¬äºŒä¸ªè§†é¢‘ï¼Œç„¶åå†åšç¬¬äºŒä¸ªè§†é¢‘å¯¹åº”çš„æµ‹éªŒã€‚<br>
ä¸ºè§£é‡Šæœ¬å®éªŒç¬¬ä¸€æ¬¡å­¦ä¹ æ—¶è·å¾—çš„ç»éªŒå’Œè¡¨ç°ä¸Šçš„å·®å¼‚ï¼Œå¤§çº¦ä¸€èˆ¬çš„å®éªŒè€…å…ˆåšPaxosé‚£éƒ¨åˆ†çš„è€Œå¦ä¸€åŠå®éªŒè€…åˆ™å…ˆåšRaftçš„é‚£éƒ¨åˆ†ã€‚<br>
æˆ‘ä»¬æ¯”è¾ƒäº†å®éªŒè€…åœ¨æ¯ä¸€æ¬¡æµ‹éªŒä¸­çš„åˆ†æ•°æ¥ç¡®å®šå®ç°è€…æ˜¯å¦å±•ç°å‡ºäº†å¯¹Raftæœ‰ç€æ›´å¥½çš„è£‚è§£ã€‚<br>We tried to make the comparison between Paxos and Raft as fair as possible.<br>
The experiment favored Paxos in two ways: 15 of the 43 participants reported having some prior experience with Paxos,<br>
and the Paxos video is 14% longer than the Raft video.<br>
As summarized in Table 1, we have taken steps to mitigate potential sources of bias.<br>
All of our materials are available for review [28, 31].<br>æˆ‘ä»¬å°è¯•ç€ä½¿å¾—Paxoså’ŒRaftä¹‹é—´çš„æ¯”è¾ƒå°½å¯èƒ½çš„å…¬å¹³ã€‚<br>
è¯¥å®éªŒåœ¨ä¸¤æ–¹é¢æœ‰åˆ©äºPaxosï¼š43åå®éªŒè€…ä¸­çš„15åæŠ¥å‘Šè¯´æ›¾ç»æœ‰ç€ä¸€äº›å…³äºPaxosçš„ç»éªŒï¼ŒåŒæ—¶Paxosçš„è§†é¢‘æ¯”Raftçš„è§†é¢‘è¦é•¿14%ã€‚<br>
å¦‚è¡¨1æ‰€ç¤ºï¼Œæˆ‘ä»¬å·²ç»é‡‡å–æªæ–½æ¥å‡å°‘æ½œåœ¨çš„æ¥æºåå·®ã€‚<br>
æˆ‘ä»¬æ‰€æœ‰çš„ææ–™éƒ½æ˜¯å¯ä»¥å®¡æŸ¥çš„ã€‚<br>On average, participants scored 4.9 points higher on the Raft quiz than on the Paxos quiz<br>
(out of a possible 60 points, the mean Raft score was 25.7 and the mean Paxos score was 20.8);<br>
Figure 14 shows their individual scores.<br>
A paired t-test states that, with 95% confidence,<br>
the true distribution of Raft scores has a mean at least 2.5 points larger than the true distribution of Paxos scores.<br>å¹³å‡è€Œè¨€ï¼Œå‚ä¸è€…åœ¨Raftæµ‹éªŒä¸­çš„å¾—åˆ†è¦æ¯”Paxosçš„æµ‹éªŒä¸­çš„å¾—åˆ†è¦é«˜4.9åˆ†(æ¢ç®—æˆ60åˆ†åˆ¶ï¼Œæ„å‘³ç€Raftçš„æµ‹éªŒåˆ†æ•°ä¸º25.7åŒæ—¶Paxosçš„æµ‹éªŒåˆ†æ•°ä¸º20.8)<br>
å›¾14å±•ç¤ºäº†å®ƒä»¬å„è‡ªçš„åˆ†æ•°ã€‚<br>
é…é˜Ÿt-testè¡¨åï¼Œæœ‰95%çš„ç½®ä¿¡åº¦ä¸‹ï¼ŒRaftçš„çœŸå®åˆ†æ•°åˆ†å¸ƒæ¯”Paxosçš„çœŸå®åˆ†æ•°åˆ†å¸ƒè‡³å°‘è¦é«˜2.5åˆ†ã€‚<br>We also created a linear regression model that predicts a new studentâ€™s quiz scores based on three factors:<br>
which quiz they took, their degree of prior Paxos experience, and the order in which they learned the algorithms.<br>
The model predicts that the choice of quiz produces a 12.5-point difference in favor of Raft.<br>
This is significantly higher than the observed difference of 4.9 points, because many of the actual students had prior Paxos experience,<br>
which helped Paxos considerably, whereas it helped Raft slightly less.<br>
Curiously, the model also predicts scores 6.3 points lower on Raft for people that have already taken the Paxos quiz;<br>
although we donâ€™t know why, this does appear to be statistically significant.<br><img alt="Pasted image 20240725173212.png" src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raft-åŸå§‹è®ºæ–‡ä¸­è‹±/pasted-image-20240725173212.png"><br>Figure 15: Using a 5-point scale, participants were asked(left) which algorithm they felt<br>
would be easier to implement in a functioning, correct, and efficient system,<br>
and (right) which would be easier to explain to a CS graduate student.<br>å›¾15ï¼šä½¿ç”¨5åˆ†æ”¯ï¼Œå‚ä¸è€…è¢«é—®åˆ°(å·¦ä¾§)ä»–ä»¬æ„Ÿè§‰ä½¿ç”¨å“ªç§ç®—æ³•æ›´å®¹æ˜“å»å®ç°ä¸€ä¸ªæ­£å¸¸å·¥ä½œçš„ï¼Œæ­£ç¡®çš„ï¼Œå’Œæœ‰æ•ˆçš„ç³»ç»Ÿï¼Œ<br>
åŒæ—¶(å³ä¾§)æ˜¯å“ªç§ç®—æ³•å¯¹äºè®¡ç®—æœºç§‘å­¦(CS)çš„ç ”ç©¶ç”Ÿæ¥è¯´ä¼šæ›´å®¹æ˜“è§£é‡Šã€‚<br>æˆ‘ä»¬è¿˜åˆ›å»ºäº†ä¸€ä¸ªçº¿æ€§å›å½’æ¨¡å‹ï¼Œå…¶ç”¨äºé¢„æµ‹æ–°ç”ŸåŸºäºä¸‰ä¸ªè¦ç´ çš„æµ‹éªŒæˆç»©ï¼šåˆ†åˆ«æ˜¯å®ƒä»¬å‚åŠ çš„æµ‹éªŒï¼Œå®ƒä»¬ä¹‹å‰å…³äºPaxosçš„ç»éªŒï¼Œä»¥åŠå®ƒä»¬å­¦ä¹ ç®—æ³•çš„é¡ºåºã€‚<br>
è¿™ä¸ªæ¨¡å‹é¢„æµ‹é€‰æ‹©çš„æµ‹éªŒä¸­Raftè¦æ¯”Paxosé«˜12.5åˆ†ã€‚<br>
è¿™æ˜æ˜¾é«˜äºè§‚å¯Ÿåˆ°çš„4.9åˆ†çš„å·®å¼‚ï¼Œå› ä¸ºå®é™…ä¸Šå¾ˆå¤šå­¦ç”Ÿä¹‹å‰æœ‰è¿‡Paxosçš„ç»éªŒï¼Œè¿™æœ‰åŠ©äºå¯¹Paxosçš„ç†è§£ï¼Œè€Œå¯¹äºRaftçš„å¸®åŠ©åˆ™å°‘å¾ˆå¤šã€‚<br>
å¥‡æ€ªçš„æ˜¯ï¼Œæ¨¡å‹è¿˜é¢„æµ‹å·²ç»å‚åŠ è¿‡Paxosæµ‹éªŒçš„äººåœ¨Raftçš„å®éªŒä¸Šå°†ä¼šä½6.3åˆ†ï¼›å³ä½¿æˆ‘ä»¬ä¸çŸ¥é“ä¸ºä»€ä¹ˆï¼Œä½†è¿™ä¼¼ä¹å…·æœ‰ç»Ÿè®¡å­¦çš„æ„ä¹‰ã€‚<br>We also surveyed participants after their quizzes to see which algorithm they felt would be easier to implement or explain;<br>
these results are shown in Figure 15.<br>
An overwhelming majority of participants reported Raft would be easier to implement and explain (33 of 41 for each question).<br>
However, these self-reported feelings may be less reliable than participantsâ€™ quiz scores,<br>
and participants may have been biased by knowledge of our hypothesis that Raft is easier to understand.<br>æˆ‘ä»¬è¿˜åœ¨å‚ä¸è€…æµ‹éªŒåå¯¹å…¶è¿›è¡Œäº†è°ƒæŸ¥ï¼Œè¯¢é—®å®ƒä»¬æ„Ÿè§‰å“ªç§ç®—æ³•æ›´åŠ å®¹æ˜“å®ç°æˆ–è§£é‡Šï¼›ç»“æœå¦‚å›¾15æ‰€ç¤ºã€‚<br>
ç»å¤§å¤šæ•°å‚ä¸è€…è¡¨ç¤ºRaftè¦æ›´åŠ å®¹æ˜“å®ç°å’Œè§£é‡Š(41ä¸ªè¢«æé—®è€…ä¸­çš„33ä¸ª)<br>
ç„¶è€Œï¼Œè¿™äº›è‡ªæˆ‘æŠ¥å‘Šçš„æ„Ÿå—å¯èƒ½ä¸å¦‚å‚ä¸è€…çš„æµ‹éªŒåˆ†æ•°æ›´åŠ å¯é ï¼Œå¹¶ä¸”å‚ä¸è€…å¯èƒ½ç”±äºæˆ‘ä»¬å‡è®¾äº†Raftæ›´åŠ å®¹æ˜“ç†è§£è€Œäº§ç”Ÿåè§ã€‚<br>A detailed discussion of the Raft user study is available at [31].<br>æœ‰å…³Raftç”¨æˆ·ç ”ç©¶çš„è¯¦ç»†è®¨è®ºï¼Œè¯·å‚è§[31]ã€‚<br><img alt="Pasted image 20240725173219.png" src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raft-åŸå§‹è®ºæ–‡ä¸­è‹±/pasted-image-20240725173219.png"><br><br>We have developed a formal specification and a proof of safety for the consensus mechanism described in Section 5.<br>
The formal specification [31] makes the information summarized in Figure 2 completely precise using the TLA+ specification language [17].<br>
It is about 400 lines long and serves as the subject of the proof.<br>
It is also useful on its own for anyone implementing Raft.<br>
We have mechanically proven the Log Completeness Property using the TLA proof system [7].<br>
However, this proof relies on invariants that have not been mechanically checked<br>
(for example, we have not proven the type safety of the specification).<br>
Furthermore, we have written an informal proof [31] of the State Machine Safety property which is complete<br>
(it relies on the specification alone) and rela tively precise (it is about 3500 words long).<br><img alt="Pasted image 20240725173227.png" src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raft-åŸå§‹è®ºæ–‡ä¸­è‹±/pasted-image-20240725173227.png"><br>Figure 16: The time to detect and replace a crashed leader.<br>
The top graph varies the amount of randomness in election timeouts, and the bottom graph scales the minimum election timeout.<br>
Each line represents 1000 trials (except for 100 trials for â€œ150â€“150msâ€) and corresponds to a particular choice of election timeouts;<br>
for example, â€œ150â€“155msâ€ means that election timeouts were chosen randomly and uniformly between 150ms and 155ms.<br>
The measurements were taken on a cluster of five servers with a broadcast time of roughly 15ms.<br>
Results for a cluster of nine servers are similar.<br>å›¾16ï¼šæ£€æµ‹å’Œæ›¿ä»£ä¸€ä¸ªå·²å´©æºƒleaderçš„æ—¶é—´ã€‚<br>
ä¸Šå›¾æ˜¯ä¸€ç³»åˆ—éšæœºåŒ–çš„é€‰ä¸¾è¶…æ—¶æ—¶é—´ï¼Œä¸‹å›¾æ˜¯ç¼©æ”¾åçš„æœ€å°é€‰ä¸¾è¶…æ—¶æ—¶é—´ã€‚<br>
æ¯ä¸€è¡Œä»£è¡¨äº†å¯¹åº”äºä¸€ä¸ªç‰¹å®šé€‰ä¸¾è¶…æ—¶æ—¶é—´çš„1000æ¬¡å®éªŒ(é™¤äº†â€œ150-150msâ€çš„100æ¬¡å®éªŒ)ï¼›<br>
ä¾‹å¦‚ï¼Œâ€œ150-155msâ€æ„å‘³ç€é€‰ä¸¾è¶…æ—¶æ—¶é—´æ˜¯åœ¨150msåˆ°155msé—´éšæœºä¸”å‡åŒ€é€‰æ‹©çš„ã€‚<br>
æµ‹é‡æ˜¯åœ¨ä¸€ä¸ªæœ‰ç€5å°æœºå™¨çš„é›†ç¾¤ä¸Šè¿›è¡Œçš„ï¼Œå…¶å¹¿æ’­æ—¶é—´å¤§çº¦ä¸º15msã€‚<br>
ç”±9å°æœåŠ¡å™¨ç»„æˆçš„é›†ç¾¤çš„ç»“æœæ˜¯ç±»ä¼¼çš„ã€‚<br>æˆ‘ä»¬å·²ç»ä¸ºç¬¬5èŠ‚æ‰€æè¿°çš„ä¸€è‡´æ€§æœºåˆ¶æä¾›äº†å½¢å¼åŒ–è§„çº¦å’Œå®‰å…¨æ€§è¯æ˜ã€‚<br>
å½¢å¼åŒ–è§„çº¦ä½¿ç”¨TLA+è§„çº¦è¯­è¨€ç²¾ç¡®çš„ä½¿ç”¨äº†å¦‚å›¾2æ‘˜è¦ä¸­çš„ä¿¡æ¯ã€‚<br>
å¤§çº¦ç”±400è¡Œé•¿å¹¶ä¸”å¯ä»¥ä½œä¸ºè¯æ˜çš„ä¸»ä½“æ¥ä½¿ç”¨ã€‚<br>
å¯¹äºä»»ä½•ä¸€ä¸ªæƒ³å®ç°Raftçš„äººæ¥è¯´ä¹Ÿæ˜¯æœ‰ç”¨çš„ã€‚<br>
æˆ‘ä»¬å·²ç»ä½¿ç”¨TLAè¯æ˜ç³»ç»Ÿæœºæ¢°åœ°è¯æ˜äº†Log Completenessç‰¹æ€§ã€‚<br>
ç„¶è€Œï¼Œè¿™ä¸€è¯æ˜ä¾èµ–äºå°šæœªè¢«æœºæ¢°åœ°æ£€æŸ¥åœ°ä¸å˜é‡(ä¾‹å¦‚ï¼Œæˆ‘ä»¬è¿˜æ²¡æœ‰è¯æ˜è§„çº¦çš„ç±»å‹å®‰å…¨æ€§)ã€‚<br>
æ­¤å¤–ï¼Œæˆ‘ä»¬ä¹Ÿç¼–å†™äº†å…³äºçŠ¶æ€æœºå®‰å…¨ç‰¹æ€§(State Machine Safety property)çš„éæ­£å¼è¯æ˜ï¼Œè¯¥è¯æ˜æ˜¯å®Œæ•´çš„(ä»…ä¾èµ–äºè§„çº¦)å¹¶ä¸”æ˜¯ç›¸å¯¹ç²¾ç¡®çš„(å¤§çº¦é•¿3500å­—)ã€‚<br><br>Raftâ€™s performance is similar to other consensus algorithms such as Paxos.<br>
The most important case for performance is when an established leader is replicating new log entries.<br>
Raft achieves this using the minimal number of messages (a single round-trip from the leader to half the cluster).<br>
It is also possible to further improve Raftâ€™s performance.<br>
For example, it easily supports batching and pipelining requests for higher throughput and lower latency.<br>
Various optimizations have been proposed in the literature for other algorithms; many of these could be applied to Raft,<br>
but we leave this to future work.<br>Raftçš„æ€§èƒ½ä¸Paxosç­‰å…¶å®ƒä¸€è‡´æ€§ç®—æ³•çš„æ€§èƒ½ç›¸å·®æ— å‡ ã€‚<br>
å¯¹äºæ€§èƒ½è€Œè¨€æœ€é‡è¦çš„æ–¹é¢æ˜¯ä¸€ä¸ªå·²è¢«é€‰å‡ºçš„leaderå¤åˆ¶æ–°çš„æ—¥å¿—æ¡ç›®ã€‚<br>
Rafté€šè¿‡ä½¿ç”¨æœ€å°‘æ•°é‡çš„æ¶ˆæ¯æ¥å®ç°è¿™ä¸€ç‚¹(ä»leaderåˆ°é›†ç¾¤ä¸­åŠæ•°æœºå™¨çš„å•è½®å¾€è¿”)ã€‚<br>
è¿™ä¹Ÿå¯èƒ½è¿›ä¸€æ­¥çš„æå‡Raftçš„æ€§èƒ½ã€‚<br>
ä¾‹å¦‚ï¼Œå®ƒå¯ä»¥è½»æ¾çš„æ”¯æŒæ‰¹å¤„ç†å’Œæµæ°´çº¿(pipelining)è¯·æ±‚æ¥è·å¾—æ›´é«˜çš„ååé‡å’Œæ›´ä½çš„å»¶è¿Ÿã€‚<br>
åœ¨èµ„æ–™ä¸­å·²ç»é’ˆå¯¹å…¶å®ƒç®—æ³•æå‡ºäº†ä¸€ç³»åˆ—çš„ä¼˜åŒ–;å…¶ä¸­æœ‰å¾ˆå¤šä¼˜åŒ–ä¹Ÿèƒ½åº”ç”¨åœ¨Raftä¸­ï¼Œä½†æˆ‘ä»¬å°†æ­¤ç•™ç»™æœªæ¥çš„å·¥ä½œã€‚<br>We used our Raft implementation to measure the performance of Raftâ€™s leader election algorithm and answer two questions.<br>
First, does the election process converge quickly?<br>
Second, what is the minimum downtime that can be achieved after leader crashes?<br>æˆ‘ä»¬ä½¿ç”¨æˆ‘ä»¬è‡ªå·±çš„Raftå®ç°æ¥è¡¡é‡Raftçš„leaderé€‰ä¸¾ç®—æ³•æ€§èƒ½ï¼Œå¹¶ä¸”å›ç­”ä¸¤ä¸ªé—®é¢˜ã€‚<br>
ç¬¬ä¸€ï¼Œé€‰ä¸¾è¿‡ç¨‹æ˜¯å¦è¿…é€Ÿçš„æ”¶æ•›ï¼Ÿ<br>
ç¬¬äºŒï¼Œåœ¨leaderå´©æºƒåå¯ä»¥å®ç°çš„åœæœºå®•æœºæ—¶é—´æ˜¯å¤šå°‘ï¼Ÿ<br>To measure leader election, we repeatedly crashed the leader of a cluster of five servers<br>
and timed how long it took to detect the crash and elect a new leader (see Figure 16).<br>
To generate a worst-case scenario, the servers in each trial had different log lengths, so some candidates were not eligible to become leader.<br>
Furthermore, to encourage split votes, our test script triggered<br>
a synchronized broadcast of heartbeat RPCs from the leader before terminating its process<br>
(this approximates the behavior of the leader replicating a new log entry prior to crashing).<br>
The leader was crashed uniformly randomly within its heartbeat interval, which was half of the minimum election timeout for all tests.<br>
Thus, the smallest possible downtime was about half of the minimum election timeout.<br>ä¸ºäº†æµ‹é‡leaderé€‰ä¸¾çš„æ€§èƒ½ï¼Œæˆ‘ä»¬åå¤çš„ä»¤ä¸€ä¸ªäº”èŠ‚ç‚¹é›†ç¾¤ä¸­çš„leaderå´©æºƒï¼Œå¹¶ä¸”æµ‹é‡é›†ç¾¤å¤šä¹…èƒ½æ£€æµ‹åˆ°å´©æºƒå¹¶é€‰ä¸¾å‡ºä¸€ä¸ªæ–°çš„leader(è§å›¾16)ã€‚<br>
ä¸ºäº†ç”Ÿæˆæœ€åçš„æƒ…å†µï¼Œåœ¨æ¯æ¬¡å®éªŒä¸­æœåŠ¡å™¨éƒ½æœ‰ç€ä¸åŒçš„æ—¥å¿—é•¿åº¦ï¼Œå› æ­¤ä¸€äº›candidateå°†æ²¡æœ‰èµ„æ ¼æˆä¸ºleaderã€‚<br>
æ­¤å¤–ï¼Œä¸ºäº†ä¿ƒè¿›åˆ†è£‚æŠ•ç¥¨çš„äº§ç”Ÿï¼Œæˆ‘ä»¬çš„æµ‹è¯•è„šæœ¬åœ¨ç»ˆæ­¢leaderè¿›ç¨‹å‰è§¦å‘äº†ä¸€æ¬¡leaderçš„åŒæ­¥RPCå¿ƒè·³å¹¿æ’­(è¿™ç±»ä¼¼äºleaderåœ¨å´©æºƒå‰å¤åˆ¶æ–°çš„æ—¥å¿—æ¡ç›®çš„è¡Œä¸º)ã€‚<br>The top graph in Figure 16 shows that a small amount of randomization in the election timeout is enough to avoid split votes in elections.<br>
In the absence of randomness, leader election consistently took longer than 10 seconds in our tests due to many split votes.<br>
Adding just 5ms of randomness helps significantly, resulting in a median downtime of 287ms.<br>
Using more randomness improves worst-case behavior: with 50ms of randomness the worstcase completion time (over 1000 trials) was 513ms.<br>å›¾16ä¸­çš„ä¸Šå›¾æ˜¾ç¤ºäº†ï¼Œåªè¦å°‘é‡çš„éšæœºåŒ–é€‰ä¸¾è¶…æ—¶æ—¶é—´å°±è¶³å¤Ÿé¿å…é€‰ä¸¾æ—¶çš„æŠ•ç¥¨åˆ†è£‚ã€‚<br>
åœ¨ç¼ºä¹éšæœºæ€§çš„æƒ…å†µä¸‹ï¼Œç”±äºè®¸å¤šåˆ†è£‚çš„æŠ•ç¥¨ï¼Œåœ¨æˆ‘ä»¬çš„æµ‹è¯•ä¸­leaderé€‰ä¸¾ä¸€ç›´æŒç»­äº†è¶…è¿‡10ç§’é’Ÿã€‚<br>
åªè¦å¢åŠ 5msçš„éšæœºæ€§å°±èƒ½æœ‰æ˜¾è‘—çš„å¸®åŠ©ï¼Œå¹³å‡çš„åœæœºæ—¶é—´ä¸­ä½æ•°ä¸º287msã€‚<br>
ä½¿ç”¨æ›´å¤šçš„éšæœºæ€§å¯ä»¥æ”¹å–„æœ€åæƒ…å†µä¸‹çš„è¡Œä¸ºï¼šæœ‰ç€50msçš„éšæœºæ€§æ—¶æœ€åæƒ…å†µä¸‹(è¶…è¿‡1000æ¬¡å®éªŒ)çš„é€‰ä¸¾å®Œæˆæ—¶é—´ä¸º513msã€‚<br>The bottom graph in Figure 16 shows that downtime can be reduced by reducing the election timeout.<br>
With an election timeout of 12â€“24ms, it takes only 35ms on average to elect a leader (the longest trial took 152ms).<br>
However, lowering the timeouts beyond this point violates Raftâ€™s timing requirement:<br>
leaders have difficulty broadcasting heartbeats before other servers start new elections.<br>
This can cause unnecessary leader changes and lower overall system availability.<br>
We recommend using a conservative election timeout such as 150â€“300ms;<br>
such timeouts are unlikely to cause unnecessary leader changes and will still provide good availability.<br>å›¾16ä¸­çš„ä¸‹å›¾æ˜¾ç¤ºï¼Œå¯ä»¥é€šè¿‡å‡å°‘é€‰ä¸¾è¶…æ—¶æ—¶é—´æ¥å‡å°‘åœæœºæ—¶é—´ã€‚<br>
ç”±äºé€‰ä¸¾è¶…æ—¶æ—¶é—´ä¸º12-24msï¼Œé€‰ä¸¾å‡ºä¸€ä¸ªleaderçš„å¹³å‡è€—æ—¶åªéœ€è¦35ms(æœ€é•¿çš„ä¸€æ¬¡å®éªŒèŠ±è´¹äº†152ms)ã€‚<br>
ç„¶è€Œï¼Œè¶…æ—¶æ—¶é—´ä½äºè¿™ä¸€ä½ç‚¹ä»¥ä¸‹ä¼šè¿åRaftçš„æ—¶é—´éœ€æ±‚ï¼šleaderå¾ˆéš¾åœ¨å…¶å®ƒleaderå‘èµ·æ–°ä¸€è½®é€‰ä¸¾å‰è¿›è¡Œå¿ƒè·³å¹¿æ’­ã€‚<br>
è¿™å¯èƒ½ä¼šå¯¼è‡´ä¸å¿…è¦çš„leaderå˜æ›´ä»¥åŠæ›´ä½çš„æ•´ä½“ç³»ç»Ÿå¯ç”¨æ€§ã€‚<br>
æˆ‘ä»¬æ¨èä½¿ç”¨ä¸€ä¸ªä¿å®ˆçš„é€‰ä¸¾è¶…æ—¶æ—¶é—´æ¯”å¦‚150-300msï¼›è¿™ä¸€è¶…æ—¶æ—¶é—´ä¸å¤ªå¯èƒ½é€ æˆä¸å¿…è¦çš„leaderå˜æ›´å¹¶ä¸”å°†ä»ç„¶æä¾›è‰¯å¥½çš„å¯ç”¨æ€§ã€‚<br><br>There have been numerous publications related to consensus algorithms, many of which fall into one of the following categories:<br>
<br>Lamportâ€™s original description of Paxos [15], and attempts to explain it more clearly [16, 20, 21].
<br>Elaborations of Paxos, which fill in missing details and modify the algorithm to provide a better foundation for implementation [26, 39, 13].
<br>Systems that implement consensus algorithms, such as Chubby [2, 4], ZooKeeper [11, 12], and Spanner [6].<br>
The algorithms for Chubby and Spanner have not been published in detail, though both claim to be based on Paxos.<br>
ZooKeeperâ€™s algorithm has been published in more detail, but it is quite different from Paxos.
<br>Performance optimizations that can be applied to Paxos [18, 19, 3, 25, 1, 27].
<br>Oki and Liskovâ€™s View-stamped Replication (VR), an alternative approach to consensus developed around the same time as Paxos.<br>
The original description [29] was intertwined with a protocol for distributed transactions,<br>
but the core consensus protocol has been separated in a recent update [22].<br>
VR uses a leader-based approach with many similarities to Raft.
<br>å·²ç»æœ‰è®¸å¤šä¸ä¸€è‡´æ€§ç®—æ³•æœ‰å…³çš„å‡ºç‰ˆç‰©äº†ï¼Œå…¶ä¸­å¾ˆå¤šéƒ½å±äºä»¥ä¸‹ç±»ç›®ä¸­çš„ä¸€ä¸ªï¼š<br>
<br>Lamportå¯¹äºPaxosçš„åŸå§‹æè¿°ï¼Œå¹¶ä¸”è¯•å›¾æ›´åŠ æ¸…æ™°çš„è¿›è¡Œè§£é‡Šã€‚
<br>å¯¹Paxosçš„ç»†åŒ–ï¼Œå…¶å¡«å……äº†ç¡®å®çš„ç»†èŠ‚å¹¶ä¸”ä¿®æ”¹äº†ç®—æ³•ä»¥ä¸ºå®ç°Paxosæä¾›äº†ä¸€ä¸ªæ›´å¥½çš„åŸºç¡€ã€‚
<br>å®ç°äº†å…±è¯†ç®—æ³•çš„ç³»ç»Ÿï¼Œä¾‹å¦‚Chubbyï¼ŒZooKeeperå’ŒSpannerã€‚<br>
Chubbyå’ŒSpannerçš„ç®—æ³•å¹¶æ²¡æœ‰å…¬å¸ƒç»†èŠ‚ï¼Œå³ä½¿å®ƒä»¬éƒ½å£°ç§°å…¶åŸºäºPaxosã€‚<br>
ZooKeeperçš„ç®—æ³•å…¬å¸ƒäº†æ›´å¤šçš„ç»†èŠ‚ï¼Œä½†å…¶ä¸Paxosæˆªç„¶ä¸åŒã€‚
<br>å¯ç”¨äºPaxosçš„æ€§èƒ½ä¼˜åŒ–ã€‚
<br>Okiå’ŒLiskovçš„Viewstamped Replication (VR)ç®—æ³•ï¼Œå¦ä¸€ç§å…±è¯†ç®—æ³•å…¶è¢«å¼€å‘çš„æ—¶é—´ç‚¹ä¸Paxosç›¸åŒã€‚<br>
æœ€åˆçš„æè¿°ä¸åˆ†å¸ƒå¼äº‹åŠ¡çš„åè®®æ··åœ¨äº†ä¸€èµ·ï¼Œä½†æœ€è¿‘çš„æ›´æ–°ä¸­å…¶æ ¸å¿ƒçš„å…±è¯†åè®®å·²ç»è¢«åˆ†ç¦»å‡ºæ¥äº†ã€‚<br>
VRé‡‡ç”¨äº†ä¸€ç§åŸºäºleaderçš„æ–¹æ³•,å…¶ä¸Raftå­˜åœ¨å¾ˆå¤šç›¸ä¼¼ä¹‹å¤„ã€‚
<br>The greatest difference between Raft and Paxos is Raftâ€™s strong leadership:<br>
Raft uses leader election as an essential part of the consensus protocol, and it concentrates as much functionality as possible in the leader.<br>
This approach results in a simpler algorithm that is easier to understand.<br>
For example, in Paxos, leader election is orthogonal to the basic consensus protocol:<br>
it serves only as a performance optimization and is not required for achieving consensus.<br>
However, this results in additional mechanism:<br>
Paxos includes both a two-phase protocol for basic consensus and a separate mechanism for leader election.<br>
In contrast, Raft incorporates leader election directly into the consensus algorithm and uses it as the first of the two phases of consensus.<br>
This results in less mechanism than in Paxos.<br>Raftå’ŒPaxosæœ€å¤§çš„åŒºåˆ«åœ¨äºRaftçš„å¼ºé¢†å¯¼æ€§ï¼š<br>
Raftå°†leaderé€‰ä¸¾ä½œä¸ºå…±è¯†åè®®ä¸­å¿…è¦çš„ç»„æˆéƒ¨åˆ†ï¼Œå¹¶å°½å¯èƒ½çš„å°†å¾ˆå¤šåŠŸèƒ½é›†ä¸­åœ¨leaderèº«ä¸Šã€‚<br>
è¿™ä¸€ç­–ç•¥ä½¿å¾—Raftæˆä¸ºäº†ä¸€ä¸ªæ›´ç®€å•çš„ç®—æ³•ï¼Œå…¶æ›´å®¹æ˜“è¢«ç†è§£ã€‚<br>
ä¾‹å¦‚ï¼Œåœ¨Paxosä¸­ï¼Œleaderé€‰ä¸¾åŸºæœ¬ä¸Šä¸åŸºç¡€çš„ä¸€è‡´æ€§åè®®æ— å…³ï¼š<br>
å…¶ä»…ä»…ç”¨äºæ€§èƒ½ä¼˜åŒ–å¹¶ä¸”ä¸æ˜¯å®ç°å…±è¯†æ‰€å¿…é¡»çš„ã€‚<br>
ç„¶è€Œï¼Œè¿™äº§ç”Ÿäº†é¢å¤–çš„æœºåˆ¶ï¼š<br>
PaxosåŒ…æ‹¬äº†ä¸€ä¸ªç”¨äºåŸºç¡€ä¸€è‡´æ€§çš„ä¸¤é˜¶æ®µåè®®ä»¥åŠä¸€ä¸ªå•ç‹¬çš„ç”¨äºleaderé€‰ä¸¾çš„æœºåˆ¶ã€‚<br>
ç›¸æ¯”ä¹‹ä¸‹ï¼ŒRaftå°†leaderé€‰ä¸¾ç›´æ¥çº³å…¥å…±è¯†ç®—æ³•ä¸­å¹¶ä¸”å°†leaderé€‰ä¸¾ä½œä¸ºå…±è¯†çš„ä¸¤é˜¶æ®µä¸­çš„ç¬¬ä¸€ä¸ªé˜¶æ®µã€‚<br>
è¿™ä½¿å¾—Raftæ¯”èµ·Paxosæœ‰ç€æ›´å°‘çš„æœºåˆ¶ã€‚<br>Like Raft, VR and ZooKeeper are leader-based and therefore share many of Raftâ€™s advantages over Paxos.<br>
However, Raft has less mechanism that VR or ZooKeeper because it minimizes the functionality in non-leaders.<br>
For example, log entries in Raft flow in only one direction: outward from the leader in AppendEntries RPCs.<br>
In VR log entries flow in both directions (leaders can receive log entries during the election process);<br>
this results in additional mechanism and complexity.<br>
The published description of ZooKeeper also transfers log entries both to and from the leader,<br>
but the implementation is apparently more like Raft [35].<br>ä¸Raftä¸€æ ·ï¼ŒVRå’ŒZooKeeperéƒ½æ˜¯åŸºäºleaderçš„å¹¶ä¸”ä¹Ÿå…±äº«ç€å¾ˆå¤šRaftç›¸å¯¹äºPaxosçš„ä¼˜ç‚¹ã€‚<br>
ç„¶è€Œï¼ŒRaftæ¯”èµ·VRæˆ–è€…Zookeeperæœ‰ç€æ›´å°‘çš„æœºåˆ¶ï¼Œå› ä¸ºå®ƒæœ€å°åŒ–äº†éleader(non-leaders)çš„åŠŸèƒ½ã€‚<br>
ä¾‹å¦‚ï¼ŒRaftä¸­çš„æ—¥å¿—æ¡ç›®æµå‘åªæœ‰ä¸€ä¸ªæ–¹å‘ï¼šä»leaderå‘å¤–æµå‡ºçš„AppendEntries RPCã€‚<br>
åœ¨VRä¸­æ—¥å¿—æ¡ç›®æ˜¯åŒå‘æµåŠ¨çš„(leaderä¹Ÿå¯ä»¥åœ¨é€‰ä¸¾æœŸé—´æ¥å—æ—¥å¿—æ¡ç›®);è¿™å¼•å…¥äº†é¢å¤–çš„æœºåˆ¶å’Œå¤æ‚åº¦ã€‚<br>
ZooKeeperçš„å·²å…¬å¸ƒçš„æè¿°ä¸­ä¹Ÿå…è®¸æ—¥å¿—æ¡ç›®åœ¨leaderä¸­åŒå‘çš„ä¼ è¾“ï¼Œä½†å…¶å®ç°æ˜æ˜¾ä¸Raftæ›´åŠ ç›¸ä¼¼ã€‚<br>Raft has fewer message types than any other algorithm for consensus-based log replication that we are aware of.<br>
For example, we counted the message types VR and ZooKeeper use for basic consensus and membership<br>
changes (excluding log compaction and client interaction, as these are nearly independent of the algorithms).<br>
VR and ZooKeeper each define 10 different message types, while Raft has only 4 message types (two RPC requests and their responses).<br>
Raftâ€™s messages are a bit more dense than the other algorithmsâ€™, but they are simpler collectively.<br>
In addition, VR and ZooKeeper are described in terms of transmitting entire logs during leader changes;<br>
additional message types will be required to optimize these mechanisms so that they are practical.<br>Raftçš„æ¶ˆæ¯ç±»å‹æ¯”ä»»ä½•å…¶å®ƒå·²çŸ¥çš„ã€åŸºäºæ—¥å¿—å¤åˆ¶çš„å…±è¯†ç®—æ³•éƒ½è¦å°‘ã€‚<br>
ä¾‹å¦‚ï¼Œæˆ‘ä»¬ç»Ÿè®¡äº†VRå’ŒZooKeeperç”¨äºåŸºç¡€å…±è¯†å’Œæˆå‘˜å˜æ›´çš„æ¶ˆæ¯ç±»å‹æ•°(ä¸åŒ…æ‹¬æ—¥å¿—å‹ç¼©å’Œå®¢æˆ·ç«¯äº¤äº’ï¼Œå› ä¸ºè¿™äº›ä¸ç®—æ³•å‡ ä¹æ˜¯ç‹¬ç«‹çš„)ã€‚<br>
VRå’ŒZooKeeperéƒ½å®šä¹‰äº†10ç§ä¸åŒçš„æ¶ˆæ¯ç±»å‹ï¼Œè€ŒRaftåªæœ‰4ç§(2ç§RPCçš„è¯·æ±‚ä»¥åŠå®ƒä»¬çš„å“åº”)ã€‚<br>
Raftçš„æ¶ˆæ¯æ¯”å…¶å®ƒç®—æ³•çš„è¦ç¨å¾®ç´§å¯†ä¸€äº›ï¼Œä½†æ€»ä½“ä¸Šæ›´åŠ ç®€å•ã€‚<br>
æ­¤å¤–ï¼ŒVRå’ŒZooKeeperæ‰€æè¿°çš„åœ¨ä»»æœŸè½¬æ¢æ—¶éœ€è¦ä¼ è¾“å®Œæ•´çš„æ—¥å¿—;æ‰€ä»¥åœ¨å®è·µä¸­éœ€è¦é¢å¤–çš„æ¶ˆæ¯ç±»å‹æ¥ä¼˜åŒ–è¿™äº›æœºåˆ¶ã€‚<br>Raftâ€™s strong leadership approach simplifies the algorithm, but it precludes some performance optimizations.<br>
For example, Egalitarian Paxos (EPaxos) can achieve higher performance under some conditions with a leaderless approach [27].<br>
EPaxos exploits commutativity in state machine commands.<br>
Any server can commit a command with just one round of communication as long as other commands that are proposed concurrently commute with it.<br>
However, if commands that are proposed concurrently do not commute with each other, EPaxos requires an additional round of communication.<br>
Because any server may commit commands, EPaxos balances load well between servers and is able to achieve lower latency than Raft in WAN settings.<br>
However, it adds significant complexity to Paxos.<br>Raftçš„å¼ºé¢†å¯¼åŠ›æ–¹æ³•ç®€åŒ–äº†ç®—æ³•ï¼Œä½†æ˜¯ä¹Ÿæ’é™¤äº†ä¸€äº›æ€§èƒ½ä¼˜åŒ–ã€‚<br>
ä¾‹å¦‚ï¼ŒEgalitarian Paxos(EPaxos)å¯ä»¥é€šè¿‡æ— leaderçš„æ–¹æ³•åœ¨æŸäº›æ¡ä»¶ä¸‹å¯ä»¥è·å¾—æ›´é«˜çš„æ€§èƒ½ã€‚<br>
EPaxosåˆ©ç”¨äº†çŠ¶æ€æœºæŒ‡ä»¤çš„äº¤æ¢æ€§ã€‚<br>
åªè¦åŒæ—¶æå‡ºçš„å…¶å®ƒæŒ‡ä»¤èƒ½å¤Ÿä¸ä¹‹äº¤æ¢ï¼Œä»»ä½•æœåŠ¡å™¨éƒ½å¯ä»¥ä»…åœ¨ä¸€è½®é€šä¿¡ä¸­æäº¤æŒ‡ä»¤ã€‚<br>
ç„¶è€Œï¼Œå¦‚æœåŒæ—¶å‘å‡ºçš„æŒ‡ä»¤ä¸èƒ½ç›¸äº’äº¤æ¢ï¼Œåˆ™EPaxoséœ€è¦é¢å¤–çš„ä¸€è½®é€šä¿¡ã€‚<br>
å› ä¸ºä»»ä½•æœåŠ¡å™¨éƒ½èƒ½å¤Ÿæäº¤æŒ‡ä»¤ï¼ŒEPaxosèƒ½å¤Ÿæ›´å¥½çš„å¹³è¡¡æœåŠ¡å™¨é—´çš„è´Ÿè½½å¹¶ä¸”èƒ½å¤Ÿè¾¾åˆ°æ¯”Raftçš„WANè®¾ç½®æ›´ä½çš„å»¶è¿Ÿã€‚<br>
ç„¶è€Œï¼Œè¿™æ˜¾è‘—çš„å¢åŠ äº†Paxosçš„å¤æ‚æ€§ã€‚<br>Several different approaches for cluster membership changes have been proposed or implemented in other work,<br>
including Lamportâ€™s original proposal [15], VR [22], and SMART [24].<br>
We chose the joint consensus approach for Raft because it leverages the rest of the consensus protocol,<br>
so that very little additional mechanism is required for membership changes.<br>
Lamportâ€™s Î±-based approach was not an option for Raft because it assumes consensus can be reached without a leader.<br>
In comparison to VR and SMART, Raftâ€™s reconfiguration algorithm has the advantage<br>
that membership changes can occur without limiting the processing of normal requests;<br>
in contrast, VR stops all normal processing during configuration changes,<br>
and SMART imposes an Î±-like limit on the number of outstanding requests.<br>
Raftâ€™s approach also adds less mechanism than either VR or SMART.<br>åœ¨å…¶å®ƒå·¥ä½œä¸­ï¼Œå‡ ç§ä¸åŒçš„ç”¨äºé›†ç¾¤æˆå‘˜å˜æ›´çš„æ–¹æ³•å·²ç»è¢«æå‡ºæˆ–è¢«å®ç°ï¼ŒåŒ…æ‹¬Lamportçš„åŸå§‹ææ¡ˆï¼ŒVRä»¥åŠSMARTã€‚<br>
æˆ‘ä»¬ä¸ºRafté€‰æ‹©äº†è”åˆä¸€è‡´çš„æ–¹æ³•ï¼Œå› ä¸ºå®ƒåˆ©ç”¨äº†ä¸€è‡´æ€§åè®®çš„å…¶ä½™éƒ¨åˆ†ï¼Œå› æ­¤æˆå‘˜å˜æ›´åªéœ€è¦å¢åŠ éå¸¸å°‘çš„é¢å¤–æœºåˆ¶ã€‚<br>
Lamportçš„Î±-basedæ–¹æ³•æ²¡æœ‰è¢«Rafté€‰ä¸­ï¼Œå› ä¸ºå®ƒå‡è®¾å¯ä»¥åœ¨æ²¡æœ‰leaderçš„æƒ…å†µä¸‹è¾¾æˆå…±è¯†ã€‚<br>
ä¸VRå’ŒSMARTç›¸æ¯”ï¼ŒRaftçš„åˆ·æ–°é…ç½®çš„ç®—æ³•æœ‰ä¸€ä¸ªä¼˜ç‚¹æ˜¯å¯ä»¥å†ä¸é™åˆ¶æ­£å¸¸è¯·æ±‚çš„æƒ…å†µä¸‹è¿›è¡Œæˆå‘˜å˜æ›´ï¼›<br>
ç›¸æ¯”ä¹‹ä¸‹ï¼ŒVRåœ¨é…ç½®å˜æ›´æœŸé—´åœæ­¢æ‰€æœ‰æ­£å¸¸çš„è¯·æ±‚å¤„ç†å¹¶ä¸”SMARTå¯¹æœªå®Œæˆçš„è¯·æ±‚æ–½åŠ äº†Î±-likeé™åˆ¶ã€‚<br>
Raftçš„æ–¹æ³•ç›¸æ¯”VRæˆ–è€…SMARTä¹Ÿå¢åŠ äº†æœ€å°‘çš„æœºåˆ¶ã€‚<br><br>Algorithms are often designed with correctness, efficiency, and/or conciseness as the primary goals.<br>
Although these are all worthy goals, we believe that understandability is just as important.<br>
None of the other goals can be achieved until developers render the algorithm into a practical implementation,<br>
which will inevitably deviate from and expand upon the published form.<br>
Unless developers have a deep understanding of the algorithm and can create intuitions about it,<br>
it will be difficult for them to retain its desirable properties in their implementation.<br>ç®—æ³•çš„è®¾è®¡é€šå¸¸ä»¥æ­£ç¡®æ€§ï¼Œæ•ˆç‡å’Œ/æˆ–é—´æ¥æ€§ä¸ºä¸»è¦ç›®æ ‡ã€‚<br>
å°½ç®¡è¿™äº›éƒ½æ˜¯æœ‰ä»·å€¼çš„ç›®æ ‡ï¼Œæˆ‘ä»¬è®¤ä¸ºå¯ç†è§£æ€§åŒæ ·é‡è¦ã€‚<br>
åœ¨å¼€å‘äººå‘˜å°†ç®—æ³•è½¬åŒ–ä¸ºä¸€ä¸ªå¯è¡Œçš„å®ç°å‰æ— æ³•è¾¾æˆä»»ä½•å…¶å®ƒçš„ç›®æ ‡ï¼Œè€Œå®é™…å®ç°å°†ä¸å¯é¿å…çš„åç¦»å’Œæ‹“å±•å·²å‘å¸ƒçš„å½¢å¼ã€‚<br>
é™¤éå¼€å‘äººå‘˜å¯¹ç®—æ³•æœ‰ç€å¾ˆæ·±çš„ç†è§£å¹¶ä¸”å¯¹å…¶äº§ç”Ÿç›´è§‰ï¼Œå¦åˆ™å…¶å°†å¾ˆéš¾åœ¨ä»–ä»¬çš„å®ç°ä¸­ä¿ç•™ç†æƒ³çš„ç‰¹æ€§ã€‚<br>In this paper we addressed the issue of distributed consensus, where a widely accepted but impenetrable algorithm,<br>
Paxos, has challenged students and developers for many years.<br>
We developed a new algorithm, Raft, which we have shown to be more understandable than Paxos.<br>
We also believe that Raft provides a better foundation for system building.<br>
Using understandability as the primary design goal changed the way we approached the design of Raft;<br>
as the design progressed we found ourselves reusing a few techniques repeatedly,<br>
such as decomposing the problem and simplifying the state space.<br>
These techniques not only improved the understandability of Raft but also made it easier to convince ourselves of its correctness.<br>åœ¨æœ¬æ–‡ä¸­æˆ‘ä»¬è®¨è®ºäº†åˆ†å¸ƒå¼ä¸€è‡´æ€§çš„é—®é¢˜ï¼Œä¸€ç§è¢«å¹¿æ³›æ¥å—ä½†éš¾äºå®ç°çš„ç®—æ³•Paxosï¼Œåœ¨å¤šå¹´æ¥ä¸€ç›´åœ¨æŒ‘æˆ˜ç€å­¦ç”Ÿå’Œå¼€å‘è€…ã€‚<br>
æˆ‘ä»¬å¼€å‘äº†ä¸€ç§æ–°çš„ç®—æ³•ï¼ŒRaftï¼Œæˆ‘ä»¬å·²ç»å±•ç¤ºäº†å…¶æ¯”Paxosæ›´åŠ å®¹æ˜“ç†è§£ã€‚<br>
æˆ‘ä»¬ä¹Ÿè®¤ä¸ºRaftä¸ºæ„å»ºç³»ç»Ÿæä¾›äº†ä¸€ä¸ªæ›´å¥½çš„åŸºç¡€ã€‚<br>
ä»¥å¯ç†è§£æ€§ä½œä¸ºä¸»è¦å®ç°ç›®æ ‡æ”¹å˜äº†æˆ‘ä»¬è®¾è®¡Raftæ—¶çš„æ–¹æ³•ï¼›éšç€è®¾è®¡çš„è¿‘æˆ˜æˆ‘ä»¬å‘ç°æˆ‘ä»¬é‡å¤çš„å¤ç”¨äº†å°‘é‡æŠ€æœ¯ï¼Œä¾‹å¦‚åˆ†è§£é—®é¢˜å’Œç®€åŒ–çŠ¶æ€ç©ºé—´ã€‚<br>
è¿™äº›æŠ€æœ¯ä¸ä»…æé«˜äº†Raftçš„å¯ç†è§£æ€§ä¹Ÿä½¿å¾—æˆ‘ä»¬æ›´å®¹æ˜“ç›¸ä¿¡å®ƒçš„æ­£ç¡®æ€§ã€‚<br><br>The user study would not have been possible without the support of Ali Ghodsi, David Mazieres,<br>
and the students of CS 294-91 at Berkeley and CS 240 at Stanford.<br>
Scott Klemmer helped us design the user study, and Nelson Ray advised us on statistical analysis.<br>
The Paxos slides for the user study borrowed heavily from a slide deck originally created by Lorenzo Alvisi.<br>
Special thanks go to David Mazi`eres and Ezra Hoch for finding subtle bugs in Raft.<br>
Many people provided helpful feedback on the paper and user study materials,<br>
including Ed Bugnion, Michael Chan, Hugues Evrard,Daniel Giffin, Arjun Gopalan, Jon Howell, Vimalkumar Jeyakumar, Ankita Kejriwal,<br>
Aleksandar Kracun, Amit Levy, Joel Martin, Satoshi Matsushita, Oleg Pesok, David Ramos,<br>
Robbert van Renesse, Mendel Rosenblum, Nicolas Schiper, Deian Stefan, Andrew Stone, Ryan Stutsman,<br>
David Terei, Stephen Yang, Matei Zaharia, 24 anonymous conference reviewers (with duplicates), and especially our shepherd Eddie Kohler.<br>
Werner Vogels tweeted a link to an earlier draft, which gave Raft significant exposure.<br>
This work was supported by the Gigascale Systems Research Center and the Multiscale Systems Center,<br>
two of six research centers funded under the Focus Center Research Program, a Semiconductor Research Corporation program,<br>
by STAR net, a Semiconductor Research Corporation program sponsored by MARCO and DARPA,<br>
by the National Science Foundation under Grant No. 0963859, and by grants from Facebook, Google, Mellanox, NEC, NetApp, SAP,<br>
and Samsung. Diego Ongaro is supported by The Junglee Corporation Stanford Graduate Fellowship.]]></description><link>https://muqiuhan.github.io/wiki/computer-science/distributed-system/raft-åŸå§‹è®ºæ–‡ä¸­è‹±/in-search-of-an-understandable-consensus-algorithm(extended-version).html</link><guid isPermaLink="false">Computer Science/Distributed System/Raft åŸå§‹è®ºæ–‡ä¸­è‹±/In Search of an Understandable Consensus Algorithm(Extended Version).md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Thu, 25 Jul 2024 09:32:41 GMT</pubDate><enclosure url="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raft-åŸå§‹è®ºæ–‡ä¸­è‹±/pasted-image-20240725172940.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raft-åŸå§‹è®ºæ–‡ä¸­è‹±/pasted-image-20240725172940.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Raftå®ç° - ä¸€è‡´æ€§ç®—æ³•ä»‹ç»]]></title><description><![CDATA[ 
 <br><br><br>
<br>å¯¹å¯é æ€§æœ‰å¾ˆé«˜è¦æ±‚çš„ç³»ç»Ÿï¼Œé€šå¸¸éƒ½ä¼šé¢å¤–éƒ¨ç½²1è‡³å¤šä¸ªæœºå™¨ä¸ºå¤‡ç”¨å‰¯æœ¬ç»„æˆä¸»å¤‡é›†ç¾¤ï¼Œé¿å…å‡ºç°å•ç‚¹æ•…éšœã€‚<br>
æœ‰çŠ¶æ€çš„ç³»ç»Ÿéœ€è¦ä¸»èŠ‚ç‚¹ä¸å¤‡ç”¨å‰¯æœ¬é—´ä»¥æŸç§æ–¹å¼è¿›è¡Œæ•°æ®å¤åˆ¶ï¼Œè¿™æ ·ä¸»èŠ‚ç‚¹å‡ºç°æ•…éšœæ—¶å°±èƒ½å¿«é€Ÿçš„ä»¤å¤‡ç”¨æœºå™¨æ¥ç®¡ç³»ç»Ÿä»¥è¾¾åˆ°é«˜å¯ç”¨çš„ç›®çš„ã€‚
<br>å¸¸è§çš„ä¸»å¤‡å¤åˆ¶æ–¹å¼æ˜¯å¼‚æ­¥ã€å¼±ä¸€è‡´æ€§çš„ï¼Œä¾‹å¦‚DNSç³»ç»Ÿï¼Œmysqlã€redis(7.0ä¹‹å‰)ç­‰æ•°æ®åº“çš„ä¸»å¤‡å¤åˆ¶ï¼Œæˆ–è€…é€šè¿‡æŸç§æ¶ˆæ¯ä¸­é—´ä»¶æ¥è¿›è¡Œè§£è€¦ï¼Œå³åœ¨CAPä¸­é€‰æ‹©äº†AP(é«˜å¯ç”¨ã€åˆ†åŒºå®¹é”™)è€Œèˆå¼ƒäº†C(å¼ºä¸€è‡´æ€§)ã€‚<br>
å¼±ä¸€è‡´æ€§çš„APç›¸æ¯”å¼ºä¸€è‡´CPçš„å¤åˆ¶æœ‰ç€è®¸å¤šä¼˜ç‚¹ï¼šæ•ˆç‡é«˜(å¤šä¸ªå•æ¬¡æ“ä½œå¯ä»¥æ‰¹é‡å¤„ç†)ï¼Œè€¦åˆæ€§ä½(å¤‡ä»½èŠ‚ç‚¹æŒ‚äº†ä¹Ÿä¸å½±å“ä¸»èŠ‚ç‚¹å·¥ä½œ)ï¼Œå®ç°ç›¸å¯¹ç®€å•ç­‰ç­‰ã€‚<br>
ä½†APå¤åˆ¶æœ€å¤§çš„ç¼ºç‚¹å°±æ˜¯ä¸§å¤±äº†å¼ºä¸€è‡´æ€§ï¼Œä¸»èŠ‚ç‚¹åœ¨æ“ä½œå®Œæˆå“åº”å®¢æˆ·ç«¯åï¼Œä½†è¿˜æœªæˆåŠŸåŒæ­¥åˆ°å¤‡ä»½èŠ‚ç‚¹å‰å®•æœºï¼Œå¯¹åº”çš„å˜æ›´å­˜åœ¨ç€ä¸¢å¤±çš„é£é™©ï¼Œå› æ­¤APçš„æ–¹æ¡ˆä¸é€‚ç”¨äºå¯¹ä¸€è‡´æ€§æœ‰è‹›åˆ»è¦æ±‚çš„åœºåˆã€‚
<br>æœ€åŸå§‹çš„å¼ºä¸€è‡´æ€§ä¸»å¤‡åŒæ­¥ï¼Œå³ä¸»èŠ‚ç‚¹åœ¨æ¯ä¸€ä¸ªå¤‡ä»½èŠ‚ç‚¹åŒæ­¥å®Œæˆåæ‰èƒ½å“åº”å®¢æˆ·ç«¯æˆåŠŸçš„æ–¹æ¡ˆæ•ˆç‡å¤ªä½ï¼Œå¯ç”¨æ€§å¤ªå·®(ä»»æ„ä¸€ä¸ªå¤‡ä»½èŠ‚ç‚¹æ•…éšœå°±ä¼šä½¿å¾—é›†ç¾¤ä¸å¯ç”¨)ã€‚<br>
å› æ­¤åŸºäºå¤šæ•°æ´¾çš„åˆ†å¸ƒå¼å¼ºä¸€è‡´ç®—æ³•è¢«å‘æ˜äº†å‡ºæ¥ï¼Œå…¶ä¸­æœ€æ—©è¢«æå‡ºçš„ä¾¿æ˜¯Paxosç®—æ³•ã€‚ä½†Paxosç®—æ³•è¿‡äºå¤æ‚ï¼Œåœ¨åˆ†å¸ƒå¼ç¯å¢ƒä¸‹æœ‰å¤§é‡çš„caseéœ€è¦å¾—åˆ°æ­£ç¡®çš„å®ç°ï¼Œå› æ­¤æ—¶è‡³ä»Šæ—¥ä¹Ÿæ²¡æœ‰å¤šå°‘ç³»ç»ŸçœŸæ­£çš„å°†Paxosè½åœ°ã€‚
<br><br>
<br>ç”±äºPaxosè¿‡äºå¤æ‚çš„åŸå› ï¼ŒRaftç®—æ³•è¢«å‘æ˜äº†å‡ºæ¥ã€‚Raftç®—æ³•åœ¨è®¾è®¡æ—¶å¤§é‡å‚è€ƒäº†Paxosï¼Œä¹Ÿæ˜¯ä¸€ä¸ªåŸºäºæ—¥å¿—å’Œå¤šæ•°æ´¾çš„ä¸€è‡´æ€§ç®—æ³•ï¼Œä½†åœ¨å¾ˆå¤šç»†èŠ‚ä¸Šç›¸æ¯”Paxosåšäº†è®¸å¤šç®€åŒ–ã€‚
<br>å› ä¸ºRaftæ¯”Paxosè¦ç®€å•å¾ˆå¤šï¼Œæ›´å®¹æ˜“è¢«å¼€å‘äººå‘˜ç†è§£å¹¶æœ€ç»ˆç”¨äºæ„å»ºå®é™…çš„ç³»ç»Ÿã€‚å› æ­¤å³ä½¿raftç®—æ³•çš„æ€§èƒ½ç›¸æ¯”Paxosè¦å·®ä¸€ç‚¹ï¼Œä½†ç›®å‰æµè¡Œçš„å¼ºä¸€è‡´åˆ†å¸ƒå¼ç³»ç»ŸåŸºæœ¬éƒ½æ˜¯åŸºäºRaftç®—æ³•çš„ã€‚
<br><a data-tooltip-position="top" aria-label="https://raft.github.io/raft.pdf" rel="noopener" class="external-link" href="https://raft.github.io/raft.pdf" target="_blank">raftçš„è®ºæ–‡</a> ä¸­å°†raftç®—æ³•çš„åŠŸèƒ½åˆ†è§£ä¸º4ä¸ªæ¨¡å—ï¼š<br>
<br>leaderé€‰ä¸¾
<br>æ—¥å¿—å¤åˆ¶
<br>æ—¥å¿—å‹ç¼©
<br>é›†ç¾¤æˆå‘˜åŠ¨æ€å˜æ›´
<br>å…¶ä¸­å‰ä¸¤é¡¹â€œleaderé€‰ä¸¾â€å’Œâ€œæ—¥å¿—å¤åˆ¶â€æ˜¯raftç®—æ³•çš„åŸºç¡€ï¼Œè€Œåä¸¤é¡¹â€œæ—¥å¿—å‹ç¼©â€å’Œâ€œé›†ç¾¤æˆå‘˜åŠ¨æ€å˜æ›´â€å±äºraftç®—æ³•åœ¨åŠŸèƒ½ä¸Šçš„é‡è¦ä¼˜åŒ–ã€‚<br><a data-tooltip-position="top" aria-label="https://www.cnblogs.com/xiaoxiongcanguan/p/17552027.html" rel="noopener" class="external-link" href="https://www.cnblogs.com/xiaoxiongcanguan/p/17552027.html" target="_blank">raftè®ºæ–‡ä¸­è‹±ç¿»è¯‘</a><br><br>é€šè¿‡raftçš„è®ºæ–‡æˆ–è€…å…¶å®ƒç›¸å…³èµ„æ–™ï¼Œè¯»è€…åŸºæœ¬èƒ½å¤§è‡´ç†è§£raftçš„å·¥ä½œåŸç†ã€‚<br>
ä½†çº¸ä¸Šå¾—æ¥ç»ˆè§‰æµ…ï¼Œç»çŸ¥æ­¤äº‹è¦èº¬è¡Œï¼Œäº²æ‰‹å®è·µæ‰èƒ½æ›´å¥½çš„æŠŠæ¡raftä¸­çš„ç²¾å·§ç»†èŠ‚ï¼ŒåŠ æ·±å¯¹raftç®—æ³•çš„ç†è§£ï¼Œæ›´æœ‰æ•ˆçš„é˜…è¯»åŸºäºraftæˆ–å…¶å®ƒä¸€è‡´æ€§åè®®çš„å¼€æºé¡¹ç›®æºç ã€‚<br><br>åœ¨è¿™ä¸ªç³»åˆ—åšå®¢ä¸­ä¼šå¸¦é¢†è¯»è€…ä¸€æ­¥æ­¥å®ç°ä¸€ä¸ªåŸºäºraftç®—æ³•çš„ç®€æ˜“KVæ•°æ®åº“,å³MyRaftã€‚MyRaftçš„å®ç°åŸºäºåŸå§‹çš„raftç®—æ³•ï¼Œæ²¡æœ‰é¢å¤–çš„ä¼˜åŒ–ï¼Œç›®çš„æ˜¯ä¸ºäº†ä¿è¯å®ç°çš„ç®€å•æ€§ã€‚<br>
MyRaftå®ç°äº†raftè®ºæ–‡ä¸­æåˆ°çš„ä¸‰ä¸ªåŠŸèƒ½ï¼Œå³â€leaderé€‰ä¸¾â€œã€â€æ—¥å¿—å¤åˆ¶â€œå’Œâ€æ—¥å¿—å‹ç¼©â€œï¼ˆåœ¨å®è·µä¸­å‘ç°â€œé›†ç¾¤æˆå‘˜åŠ¨æ€å˜æ›´â€å¯¹åŸæœ‰é€»è¾‘æœ‰è¾ƒå¤§æ”¹åŠ¨è€Œå¤§å¹…å¢åŠ äº†å¤æ‚åº¦ï¼Œé™äºä¸ªäººæ°´å¹³æš‚ä¸å®ç°ï¼‰ã€‚<br>
ä¸‰ä¸ªåŠŸèƒ½ä¼šé€šè¿‡ä¸‰æ¬¡è¿­ä»£å®éªŒé€æ­¥å®Œæˆï¼Œå…¶ä¸­æ¯ä¸ªè¿­ä»£éƒ½ä¼šä»¥åšå®¢çš„å½¢å¼åˆ†äº«å‡ºæ¥ã€‚<br><br>![[Pasted image 20240725171642.png]]
Copy<br><br>
<br>ç”±äºæ˜¯MyRaftçš„ç¬¬ä¸€ä¸ªè¿­ä»£ï¼Œåœ¨è¿™ä¸ªè¿­ä»£ä¸­éœ€è¦å…ˆæ­å¥½MyRaftçš„åŸºç¡€éª¨æ¶ã€‚<br>
raftä¸­çš„æ¯ä¸ªèŠ‚ç‚¹æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªrpcæœåŠ¡å™¨ï¼ŒåŒæ—¶ä¹Ÿæ˜¯ä¸€ä¸ªrpcçš„æ¶ˆè´¹è€…ï¼ŒèŠ‚ç‚¹ä¹‹é—´é€šè¿‡rpcçš„æ–¹å¼äº’ç›¸é€šä¿¡ã€‚
<br>MyRaftä½¿ç”¨çš„rpcæ¡†æ¶æ˜¯ä¸Šä¸€ä¸ªå®éªŒä¸­è‡ªå·±å®ç°çš„MyRpcæ¡†æ¶ï¼š<br>
åšå®¢åœ°å€: <a rel="noopener" class="external-link" href="https://www.cnblogs.com/xiaoxiongcanguan/p/17506728.html" target="_blank">https://www.cnblogs.com/xiaoxiongcanguan/p/17506728.html</a><br>
githubåœ°å€ï¼š<a rel="noopener" class="external-link" href="https://github.com/1399852153/MyRpc" target="_blank">https://github.com/1399852153/MyRpc</a> (mainåˆ†æ”¯)
<br><br>
<br>å› ä¸ºlab1ä¸­åªå®ç°leaderé€‰ä¸¾ï¼Œç®€å•èµ·è§åªå®šä¹‰å½“å‰æ‰€éœ€çš„apiæ¥å£ï¼Œæ¥å£å‚æ•°ç›¸æ¯”æœ€ç»ˆçš„å®ç°ä¹Ÿçœå»äº†å¤§é‡å½“å‰ç”¨ä¸ä¸Šçš„å­—æ®µï¼Œåç»­æœ‰éœ€è¦å†è¿›è¡Œæ‹“å±•ã€‚
<br>public interface RaftService {

    /**
     * è¯·æ±‚æŠ•ç¥¨ requestVote
     *
     * Receiver implementation:
     * 1. Reply false if term &lt; currentTerm (Â§5.1)
     * 2. If votedFor is null or candidateId, and candidateâ€™s log is at
     * least as up-to-date as receiverâ€™s log, grant vote (Â§5.2, Â§5.4)
     *
     * æ¥å—è€…éœ€è¦å®ç°ä»¥ä¸‹åŠŸèƒ½ï¼š
     * 1. å¦‚æœå‚æ•°ä¸­çš„ä»»æœŸå€¼termå°äºå½“å‰è‡ªå·±çš„ä»»æœŸå€¼currentTermï¼Œåˆ™è¿”å›falseä¸åŒæ„æŠ•ç¥¨ç»™è°ƒç”¨è€…
     * 2. å¦‚æœè‡ªå·±è¿˜æ²¡æœ‰æŠ•ç¥¨(FIFO)æˆ–è€…å·²ç»æŠ•ç¥¨ç»™äº†candidateIdå¯¹åº”çš„èŠ‚ç‚¹(å¹‚ç­‰)ï¼Œ
     *    å¹¶ä¸”å€™é€‰äººçš„æ—¥å¿—è‡³å°‘ä¸è¢«è°ƒç”¨è€…çš„æ—¥å¿—ä¸€æ ·æ–°(æ¯”è¾ƒæ—¥å¿—çš„ä»»æœŸå€¼å’Œç´¢å¼•å€¼)ï¼Œåˆ™æŠ•ç¥¨ç»™è°ƒç”¨è€…(è¿”å›å€¼é‡ŒvoteGrantedä¸ºtrue)
     * */
    RequestVoteRpcResult requestVote(RequestVoteRpcParam requestVoteRpcParam);

    /**
     * è¿½åŠ æ—¥å¿—æ¡ç›® AppendEntries
     * */
    AppendEntriesRpcResult appendEntries(AppendEntriesRpcParam appendEntriesRpcParam);
}
Copy<br>/**
 * è¯·æ±‚æŠ•ç¥¨çš„RPCæ¥å£å‚æ•°å¯¹è±¡
 */
public class RequestVoteRpcParam implements Serializable {

    /**
     * å€™é€‰äººçš„ä»»æœŸç¼–å·
     * */
    private int term;

    /**
     * å€™é€‰äººçš„Id
     * */
    private String candidateId;

    /**
     * å€™é€‰äººæœ€æ–°æ—¥å¿—çš„ç´¢å¼•ç¼–å·
     * */
    private long lastLogIndex;

    /**
     * å€™é€‰äººæœ€æ–°æ—¥å¿—å¯¹åº”çš„ä»»æœŸç¼–å·
     * */
    private int lastLogTerm;
}
Copy<br>/**
 * è¯·æ±‚æŠ•ç¥¨çš„RPCæ¥å£å“åº”å¯¹è±¡
 * */
public class RequestVoteRpcResult implements Serializable {

    /**
     * è¢«è°ƒç”¨è€…å½“å‰çš„ä»»æœŸå€¼
     * */
    private int term;

    /**
     * æ˜¯å¦åŒæ„æŠ•ç¥¨ç»™è°ƒç”¨è€…
     * */
    private boolean voteGranted;
}
Copy<br>/**
 * è¿½åŠ æ—¥å¿—æ¡ç›®çš„RPCæ¥å£å‚æ•°å¯¹è±¡
 * */
public class AppendEntriesRpcParam implements Serializable {

    /**
     * å½“å‰leaderçš„ä»»æœŸå€¼
     * */
    private int term;

    /**
     * leaderçš„id
     * */
    private String leaderId;
}
Copy<br>/**
 * è¿½åŠ æ—¥å¿—æ¡ç›®çš„RPCæ¥å£å“åº”å¯¹è±¡
 * */
public class AppendEntriesRpcResult implements Serializable {

    /**
     * è¢«è°ƒç”¨è€…å½“å‰çš„ä»»æœŸå€¼
     * */
    private int term;

    /**
     * æ˜¯å¦å¤„ç†æˆåŠŸ
     * */
    private boolean success;
}
Copy<br><br>/**
 * raftçš„rpcæœåŠ¡
 * */
public class RaftRpcServer extends RaftServer {

    private final Registry registry;
    private final RaftNodeConfig currentNodeConfig;

    public RaftRpcServer(RaftConfig raftConfig, Registry registry){
        super(raftConfig);

        this.currentNodeConfig = raftConfig.getCurrentNodeConfig();
        this.registry = registry;
    }

    @Override
    public void init(List&lt;RaftService&gt; otherNodeInCluster) {
        // å…ˆåˆå§‹åŒ–å†…éƒ¨æ¨¡å—
        super.init(otherNodeInCluster);

        // åˆå§‹åŒ–å†…éƒ¨çš„æ¨¡å—åï¼Œå¯åŠ¨rpc
        initRpcServer();
    }

    public List&lt;RaftService&gt; getRpcProxyList(List&lt;RaftNodeConfig&gt; otherNodeInCluster){
        return initRpcConsumer(otherNodeInCluster);
    }

    private List&lt;RaftService&gt; initRpcConsumer(List&lt;RaftNodeConfig&gt; otherNodeInCluster){
        ConsumerBootstrap consumerBootstrap = new ConsumerBootstrap()
            .registry(registry)
            .loadBalance(new SimpleRoundRobinBalance());

        // æ³¨å†Œæ¶ˆè´¹è€…
        Consumer&lt;RaftService&gt; consumer = consumerBootstrap.registerConsumer(RaftService.class,new FastFailInvoker());
        RaftService raftServiceProxy = consumer.getProxy();

        List&lt;RaftService&gt; raftRpcConsumerList = new ArrayList&lt;&gt;();
        for(RaftNodeConfig raftNodeConfig : otherNodeInCluster){
            // ä½¿ç”¨rpcä»£ç†çš„å®¢æˆ·ç«¯
            raftRpcConsumerList.add(new RaftRpcConsumer(raftNodeConfig,raftServiceProxy));
        }

        return raftRpcConsumerList;
    }

    private void initRpcServer(){
        URLAddress providerURLAddress = new URLAddress(currentNodeConfig.getIp(),currentNodeConfig.getPort());
        Provider&lt;RaftService&gt; provider = new Provider&lt;&gt;();
        provider.setInterfaceClass(RaftService.class);
        provider.setRef(this);
        provider.setUrlAddress(providerURLAddress);
        provider.setRegistry(registry);
        provider.export();

        NettyServer nettyServer = new NettyServer(providerURLAddress);
        nettyServer.init();
    }
}
Copy<br>public class RaftRpcConsumer implements RaftService {

    private static final Logger logger = LoggerFactory.getLogger(RaftRpcConsumer.class);

    private final RaftNodeConfig targetNodeConfig;
    private final RaftService raftServiceProxy;

    public RaftRpcConsumer(RaftNodeConfig targetNodeConfig, RaftService proxyRaftService) {
        this.targetNodeConfig = targetNodeConfig;
        this.raftServiceProxy = proxyRaftService;
    }

    @Override
    public RequestVoteRpcResult requestVote(RequestVoteRpcParam requestVoteRpcParam) {
        // å¼ºåˆ¶æŒ‡å®šrpcç›®æ ‡çš„ip/port
        setTargetProviderUrl();
        RequestVoteRpcResult result = raftServiceProxy.requestVote(requestVoteRpcParam);
        return result;
    }

    @Override
    public AppendEntriesRpcResult appendEntries(AppendEntriesRpcParam appendEntriesRpcParam) {
        // å¼ºåˆ¶æŒ‡å®šrpcç›®æ ‡çš„ip/port
        setTargetProviderUrl();
        AppendEntriesRpcResult result = raftServiceProxy.appendEntries(appendEntriesRpcParam);
        return result;
    }

    private void setTargetProviderUrl(){
        ConsumerRpcContext consumerRpcContext = ConsumerRpcContextHolder.getConsumerRpcContext();
        consumerRpcContext.setTargetProviderAddress(
            new URLAddress(targetNodeConfig.getIp(),targetNodeConfig.getPort()));
    }
}
Copy<br><br>
<br>raftçš„è®ºæ–‡ä¸­æåˆ°raftæœåŠ¡ä¸­éœ€è¦æŒä¹…åŒ–çš„ä¸‰ä¸ªè¦ç´ ï¼šcurrentTermï¼ˆå½“å‰æœåŠ¡å™¨çš„ä»»æœŸå€¼ï¼‰ã€votedFor(å½“å‰æœåŠ¡å™¨åœ¨æ­¤ä¹‹å‰æŠ•ç¥¨ç»™äº†è°)å’Œlogs(raftçš„æ“ä½œæ—¥å¿—ï¼Œä¸æœ¬ç¯‡åšå®¢æ— å…³åœ¨lab2ä¸­æ‰ä¼šå¼•å…¥)ã€‚
<br>currentTermå’ŒvotedForéœ€è¦æŒä¹…åŒ–çš„åŸå› æ˜¯ä¸ºäº†é¿å…raftèŠ‚ç‚¹åœ¨å®Œæˆleaderé€‰ä¸¾çš„æŠ•ç¥¨åå®•æœºï¼Œé‡å¯æ¢å¤åå¦‚æœè¿™ä¸¤ä¸ªæ•°æ®ä¸¢å¤±äº†å°±å¾ˆå®¹æ˜“åœ¨åŒä¸€ä»»æœŸå†…æŠ•ç¥¨ç»™å¤šä¸ªå€™é€‰äººè€Œå‡ºç°é›†ç¾¤è„‘è£‚(å³å¤šä¸ªåˆæ³•leader)ã€‚
<br>MyRaftç”¨ç£ç›˜æ–‡ä»¶è¿›è¡ŒæŒä¹…åŒ–ï¼Œç®€å•èµ·è§åœ¨currentTermæˆ–votedForæ›´æ–°æ—¶åŠ å†™é”ï¼Œé€šè¿‡åŸå­æ€§çš„æ•´ä½“åˆ·ç›˜æ¥å®ŒæˆæŒä¹…åŒ–ã€‚
<br>public class RaftServerMetaData {

    /**
     * å½“å‰æœåŠ¡å™¨çš„ä»»æœŸå€¼
     * */
    private int currentTerm;

    /**
     * å½“å‰æœåŠ¡å™¨åœ¨æ­¤ä¹‹å‰æŠ•ç¥¨ç»™äº†è°ï¼Ÿ
     * (å€™é€‰è€…çš„serverIdï¼Œå¦‚æœè¿˜æ²¡æœ‰æŠ•é€’å°±æ˜¯null)
     * */
    private String votedFor;
}
Copy<br>public class RaftServerMetaDataPersistentModule {

    /**
     * å½“å‰æœåŠ¡å™¨çš„ä»»æœŸå€¼
     * */
    private volatile int currentTerm;

    /**
     * å½“å‰æœåŠ¡å™¨åœ¨æ­¤ä¹‹å‰æŠ•ç¥¨ç»™äº†è°ï¼Ÿ
     * (å€™é€‰è€…çš„serverIdï¼Œå¦‚æœè¿˜æ²¡æœ‰æŠ•é€’å°±æ˜¯null)
     * */
    private volatile String votedFor;

    private final File persistenceFile;

    private final ReentrantReadWriteLock reentrantLock = new ReentrantReadWriteLock();
    private final ReentrantReadWriteLock.WriteLock writeLock = reentrantLock.writeLock();
    private final ReentrantReadWriteLock.ReadLock readLock = reentrantLock.readLock();

    public RaftServerMetaDataPersistentModule(String serverId) {
        String userPath = System.getProperty("user.dir") + File.separator + serverId;

        this.persistenceFile = new File(userPath + File.separator + "raftServerMetaData-" + serverId + ".txt");
        MyRaftFileUtil.createFile(persistenceFile);

        // è¯»å–æŒä¹…åŒ–åœ¨ç£ç›˜ä¸­çš„æ•°æ®
        RaftServerMetaData raftServerMetaData = readRaftServerMetaData(persistenceFile);
        this.currentTerm = raftServerMetaData.getCurrentTerm();
        this.votedFor = raftServerMetaData.getVotedFor();
    }

    public int getCurrentTerm() {
        readLock.lock();
        try {
            return currentTerm;
        }finally {
            readLock.unlock();
        }
    }

    public void setCurrentTerm(int currentTerm) {
        writeLock.lock();
        try {
            this.currentTerm = currentTerm;

            // æ›´æ–°åæ•°æ®è½ç›˜
            persistentRaftServerMetaData(new RaftServerMetaData(this.currentTerm,this.votedFor),persistenceFile);
        }finally {
            writeLock.unlock();
        }
    }

    public String getVotedFor() {
        readLock.lock();
        try {
            return votedFor;
        }finally {
            readLock.unlock();
        }
    }

    public void setVotedFor(String votedFor) {
        writeLock.lock();
        try {
            if(Objects.equals(this.votedFor,votedFor)){
                // ç›¸ç­‰çš„è¯å°±ä¸åˆ·æ–°äº†
                return;
            }
            
            this.votedFor = votedFor;

            // æ›´æ–°åæ•°æ®è½ç›˜
            persistentRaftServerMetaData(new RaftServerMetaData(this.currentTerm,this.votedFor),persistenceFile);
        }finally {
            writeLock.unlock();
        }
    }

    private static RaftServerMetaData readRaftServerMetaData(File persistenceFile){
        String content = MyRaftFileUtil.getFileContent(persistenceFile);
        if(StringUtils.hasText(content)){
            return JsonUtil.json2Obj(content,RaftServerMetaData.class);
        }else{
            return RaftServerMetaData.getDefault();
        }
    }

    private static void persistentRaftServerMetaData(RaftServerMetaData raftServerMetaData, File persistenceFile){
        String content = JsonUtil.obj2Str(raftServerMetaData);

        MyRaftFileUtil.writeInFile(persistenceFile,content);
    }
}
Copy<br><br><br>raftçš„leaderé€‰ä¸¾åœ¨è®ºæ–‡ä¸­æœ‰è¾ƒè¯¦ç»†çš„æè¿°ï¼Œè¿™é‡Œè¯´ä¸€ä¸‹æˆ‘è®¤ä¸ºçš„å…³é”®ç»†èŠ‚ã€‚<br>
<br>Raftç®—æ³•ä¸­leaderæ‰®æ¼”ç€ç»å¯¹æ ¸å¿ƒçš„è§’è‰²ï¼Œleaderè´Ÿè´£å¤„ç†å®¢æˆ·ç«¯çš„è¯·æ±‚ã€å°†æ“ä½œæ—¥å¿—åŒæ­¥ç»™å…¶å®ƒçš„followerèŠ‚ç‚¹ä»¥åŠé€šçŸ¥followeræäº¤æ—¥å¿—ç­‰ç­‰ã€‚<br>
å› æ­¤Rafté›†ç¾¤å¿…é¡»åŸºäºå¤šæ•°åŸåˆ™é€‰ä¸¾å‡ºä¸€ä¸ªå­˜æ´»çš„leaderæ‰èƒ½å¯¹å¤–æä¾›æœåŠ¡ï¼Œå¹¶ä¸”ä¸€ä¸ªä»»æœŸå†…åªèƒ½æœ‰ä¸€ä¸ªåŸºäºå¤šæ•°ç¥¨é€‰å‡ºçš„leaderã€‚
<br>raftæ˜¯éæ‹œå åº­å®¹é”™å…±è¯†ç®—æ³•ï¼Œrpcé€šä¿¡æ—¶äº¤äº’çš„åŒæ–¹çš„è¯·æ±‚å’Œå“åº”éƒ½æ˜¯å¯ä¿¡çš„ï¼Œä¸ä¼šä½œå‡ï¼ŒèŠ‚ç‚¹è¿è¡Œçš„è¡Œä¸ºä¹Ÿç¬¦åˆraftç®—æ³•çš„è§„å®šã€‚
<br>raftä¸­å­˜åœ¨ä»»æœŸtermçš„æ¦‚å¿µï¼Œä»»æœŸå€¼åªä¼šå•å‘é€’å¢ï¼Œå¯ä»¥ç†è§£ä¸ºä¸€ä¸ªè™šæ‹Ÿçš„æ—¶é—´ï¼Œæ˜¯raftå®ç°çº¿æ€§ä¸€è‡´æ€§å…³é”®çš„ä¸€ç¯ã€‚è¿‡å»çš„leader(termå€¼æ›´å°çš„)éœ€è¦æœä»ã€è¿½éšç°ä»»çš„leader(termå€¼æ›´å¤§çš„)ã€‚
<br>åœ¨raftèŠ‚ç‚¹åˆšå¯åŠ¨æ—¶å¤„äºfollowerè¿½éšè€…çŠ¶æ€ã€‚å¦‚æœä¸€æ®µæ—¶é—´å†…raftèŠ‚ç‚¹æ²¡æœ‰æ¥å—åˆ°æ¥è‡ªleaderçš„å®šæ—¶å¿ƒè·³rpc(logEntryä¸ºç©ºçš„appendEntries)é€šçŸ¥æ—¶å°±ä¼šå‘èµ·ä¸€è½®æ–°çš„é€‰ä¸¾ã€‚<br>
äº§ç”Ÿè¿™ä¸ªç°è±¡çš„åŸå› æœ‰å¾ˆå¤šï¼Œæ¯”å¦‚é›†ç¾¤åˆšåˆšå¯åŠ¨è¿˜æ²¡æœ‰leaderï¼›æˆ–è€…ä¹‹å‰çš„leaderå› ä¸ºæŸç§åŸå› å®•æœºæˆ–ä¸followerçš„ç½‘ç»œé€šä¿¡å‡ºç°æ•…éšœç­‰ã€‚
<br>å‘èµ·è¯·æ±‚çš„followerä¼šè½¬å˜ä¸ºcandidateå€™é€‰äººçŠ¶æ€ï¼Œå¹¶é¦–å…ˆæŠ•ç¥¨ç»™è‡ªå·±ã€‚åŒæ—¶å¹¶è¡Œçš„å‘é›†ç¾¤ä¸­çš„å…¶å®ƒèŠ‚ç‚¹å‘èµ·è¯·æ±‚æŠ•ç¥¨çš„rpcè¯·æ±‚(requestVote),å¯ä»¥ç†è§£ä¸ºç»™è‡ªå·±æ‹‰ç¥¨ã€‚<br>
æ¥æ”¶åˆ°requestVoteè¯·æ±‚çš„èŠ‚ç‚¹ä¼šæ ¹æ®è‡ªèº«çš„çŠ¶æ€ç­‰ä¿¡æ¯å†³å®šæ˜¯å¦æŠ•ç¥¨ç»™å‘èµ·æŠ•ç¥¨çš„èŠ‚ç‚¹ã€‚<br>
å½“candidateè·å¾—äº†é›†ç¾¤ä¸­è¶…è¿‡åŠæ•°çš„æŠ•ç¥¨(å³åŒ…æ‹¬è‡ªå·±åœ¨å†…çš„1ç¥¨åŠ ä¸ŠrequestVoteè¿”å›æŠ•ç¥¨æˆåŠŸçš„æ•°é‡è¶…è¿‡åŠæ•°(æ¯”å¦‚5èŠ‚ç‚¹å¾—åˆ°3ç¥¨ï¼Œ6èŠ‚ç‚¹å¾—åˆ°4ç¥¨))ï¼Œåˆ™candidateæˆä¸ºå½“å‰ä»»æœŸçš„leaderã€‚<br>
å¦‚æœæ²¡æœ‰ä»»ä½•ä¸€ä¸ªcandidateè·å¾—å¤šæ•°é€‰ç¥¨(æ²¡é€‰å‡ºleaderï¼Œå¯èƒ½æ˜¯åˆ†ç¥¨äº†ï¼Œä¹Ÿå¯èƒ½æ˜¯ç½‘ç»œæ³¢åŠ¨ç­‰ç­‰)ï¼Œåˆ™candidateä¼šå°†å½“å‰ä»»æœŸè‡ªå¢1ï¼Œåˆ™ä¸‹ä¸€æ¬¡é€‰ä¸¾è¶…æ—¶æ—¶ä¼šå†è§¦å‘ä¸€è½®æ–°çš„é€‰ä¸¾ï¼Œå¾ªç¯å¾€å¤ç›´è‡³é€‰å‡ºleaderã€‚<br>
<img alt="Pasted image 20240725172248.png" src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raftå®ç°/pasted-image-20240725172248.png">
<br>leaderå½“é€‰åéœ€è¦ç«‹å³å‘å…¶å®ƒçš„èŠ‚ç‚¹å‘é€å¿ƒè·³rpc(logEntryä¸ºç©ºçš„appendEntries)ï¼Œæ˜­å‘Šæ–°leaderçš„äº§ç”Ÿä»¥æŠ‘åˆ¶å…¶å®ƒèŠ‚ç‚¹å‘èµ·æ–°çš„é€‰ä¸¾ã€‚<br>
å¿ƒè·³rpcå¿…é¡»ä»¥ä¸€å®šé¢‘ç‡çš„å®šæ—¶å‘æ‰€æœ‰followerå‘é€ï¼Œå‘é€çš„æ—¶é—´é—´éš”éœ€è¦å°äºè®¾ç½®çš„é€‰ä¸¾è¶…æ—¶æ—¶é—´ã€‚
<br>ç”±äºå¤„ç†requestVoteæ˜¯å…ˆåˆ°å…ˆå¾—çš„ï¼ŒåŒä¸€ä»»æœŸå†…å…ˆå‘èµ·æŠ•ç¥¨è¯·æ±‚çš„candidateä¼šæ”¶åˆ°ç¥¨ï¼Œåå‘é€çš„ä¼šè¢«æ‹’ç»ã€‚<br>
å‡å¦‚leaderå®•æœºäº†ï¼Œåˆ™æ¯ä¸ªfolloweréƒ½ä¼šåœ¨ä¸€æ®µæ—¶é—´åè§¦å‘æ–°ä¸€è½®é€‰ä¸¾ï¼Œå¦‚æœæ²¡æœ‰é¢å¤–çš„é™åˆ¶ï¼Œåˆ™æ¯ä¸ªèŠ‚ç‚¹å¹¶å‘çš„å‘èµ·é€‰ä¸¾å¾ˆå®¹æ˜“å¯¼è‡´åˆ†ç¥¨ï¼Œå³è‡ªå·±æŠ•ç»™è‡ªå·±ï¼Œåˆ™éš¾ä»¥è¾¾æˆå…±è¯†(å–å¾—å¤šæ•°ç¥¨)ã€‚<br>
Raftçš„è®ºæ–‡ä¸­æå‡ºäº†éšæœºåŒ–é€‰ä¸¾è¶…æ—¶æ—¶é—´çš„æ–¹æ¡ˆï¼Œå³æ¯ä¸ªfollowerèŠ‚ç‚¹çš„é€‰ä¸¾è¶…æ—¶æ—¶é—´æ˜¯ä¸€ä¸ªå›ºå®šå€¼å†åŠ ä¸Šä¸€ä¸ªéšæœºåŒ–çš„å€¼å¾—åˆ°çš„ï¼Œè¿™æ ·å¾ˆéš¾åœ¨åŒä¸€ç¬é—´éƒ½è§¦å‘é€‰ä¸¾ã€‚<br>
éšæœºè¶…æ—¶æ—¶é—´æ›´çŸ­çš„followerèƒ½å¤Ÿæœ€å…ˆå‘èµ·é€‰ä¸¾ï¼Œæ›´å¿«çš„å¾—åˆ°å…¶å®ƒèŠ‚ç‚¹çš„æŠ•ç¥¨ä»è€Œé¿å…åˆ†ç¥¨çš„æƒ…å†µã€‚<br>
è™½ç„¶æ— æ³•å®Œå…¨é¿å…åˆ†ç¥¨ï¼Œä½†å®è·µä¸­å‘ç°æ•ˆæœå¾ˆå¥½ï¼Œéšæœºè¶…æ—¶æ—¶é—´ä¸‹é€šå¸¸å°‘æ•°çš„å‡ æ¬¡åˆ†ç¥¨åå°±èƒ½æ”¶æ•›è€Œé€‰å‡ºleaderæ¥ã€‚
<br>æ³¨æ„ï¼šraftè®ºæ–‡åœ¨5.4å®‰å…¨æ€§ä¸€èŠ‚ä¸­æåˆ°ï¼Œleaderé€‰ä¸¾å¯¹äºcandidateçš„æ—¥å¿—çŠ¶æ€æœ‰ä¸€å®šçš„è¦æ±‚(å› ä¸ºåªæœ‰æ‹¥æœ‰å®Œæ•´æ—¥å¿—çš„èŠ‚ç‚¹æ‰æœ‰èµ„æ ¼æˆä¸ºleaderï¼Œç¡®ä¿leaderæ›´æ›¿æ—¶æ—¥å¿—ä¸ä¼šä¸¢å¤±)ï¼Œ<br>
ä½†lab1ä¸­ä¸æ”¯æŒæ—¥å¿—å¤åˆ¶ï¼Œæ‰€ä»¥MyRaftåœ¨lab1çš„requestVoteå®ç°ä¸­çœç•¥äº†ç›¸å…³é€»è¾‘ã€‚
<br><br>ä¸‹é¢åŸºäºæºç å±•å¼€ä»‹ç»MyRaftæ˜¯å¦‚ä½•å®ç°rafté¢†å¯¼è€…é€‰ä¸¾çš„ã€‚<br>å¤§è‡´åˆ†ä¸ºä»¥ä¸‹å‡ éƒ¨åˆ†ï¼š<br>
<br>raftèŠ‚ç‚¹é…ç½®
<br>raftèŠ‚ç‚¹å®šæ—¶é€‰ä¸¾è¶…æ—¶æ£€æŸ¥
<br>candidateå‘èµ·é€‰ä¸¾
<br>leaderå®šæ—¶å‘èµ·å¿ƒè·³å¹¿æ’­
<br>raftèŠ‚ç‚¹å¤„ç†requestVoteè¯·æ±‚
<br><br>
<br>raftæœåŠ¡ä¸­æœ‰å¾ˆå¤šå‚æ•°éœ€è¦é…ç½®ï¼Œæ¯”å¦‚æœåŠ¡çš„ip/portï¼Œæˆ–è€…raftç›¸å…³çš„é€‰ä¸¾è¶…æ—¶æ—¶é—´ã€å¿ƒè·³é—´éš”æ—¶é—´ç­‰ç­‰ã€‚
<br>MyRaftä¸­ç»Ÿä¸€æ”¾åˆ°ä¸€ä¸ªå«RaftConfigçš„ç±»é‡Œç»´æŠ¤ï¼Œåç»­çš„åŠŸèƒ½å®ç°æ—¶ä¹Ÿä¼šåœ¨è¿™ä¸ªç±»ä¸­è¿›è¡Œæ‹“å±•ã€‚
<br>public class RaftConfig {
    
    /**
     * å½“å‰æœåŠ¡èŠ‚ç‚¹çš„id(é›†ç¾¤å†…å…¨å±€å”¯ä¸€)
     * */
    private final String serverId;

    /**
     * è‡ªå·±èŠ‚ç‚¹çš„é…ç½®
     * */
    private final RaftNodeConfig currentNodeConfig;

    /**
     * æ•´ä¸ªé›†ç¾¤æ‰€æœ‰çš„æœåŠ¡èŠ‚ç‚¹çš„idé›†åˆ
     * */
    private final List&lt;RaftNodeConfig&gt; raftNodeConfigList;

    /**
     * é›†ç¾¤ä¸­å¤šæ•°çš„å€¼(ä¾‹å¦‚ï¼š5èŠ‚ç‚¹majorityNum=3,6èŠ‚ç‚¹majorityNum=4)
     * */
    private final int majorityNum;

    /**
     * é€‰ä¸¾è¶…æ—¶æ—¶é—´ å•ä½:ç§’
     * */
    private int electionTimeout;
    
    /**
     * é€‰ä¸¾è¶…æ—¶æ—¶é—´çš„éšæœºåŒ–åŒºé—´ å•ä½ï¼šæ¯«ç§’
     * */
    private Range&lt;Integer&gt; electionTimeoutRandomRange;

    /**
     * å¿ƒè·³é—´éš”æ—¶é—´ å•ä½ï¼šç§’
     * */
    private int HeartbeatInternal;
}
Copy<br>public class RaftNodeConfig {

    private String serverId;
    private String ip;
    private int port;
}
Copy<br><br>
<br>MyRaftä¸­å°†leaderé€‰ä¸¾ç›¸å…³çš„ä¸»è¦é€»è¾‘éƒ½é›†ä¸­ç»´æŠ¤åœ¨RaftLeaderElectionModuleç±»ä¸­ã€‚<br>
lastHeartbeatTimeå±æ€§ç”¨äºå­˜å‚¨æœ€åä¸€æ¬¡æ”¶åˆ°leaderå¿ƒè·³çš„ç»å¯¹æ—¶é—´ï¼Œå¦‚æœå½“å‰èŠ‚ç‚¹çŠ¶æ€ä¸æ˜¯leaderï¼Œå¹¶ä¸”å‘ç°lastHeartbeatTimeè·ç¦»å½“å‰æ—¶é—´å·²ç»è¶…è¿‡äº†æŒ‡å®šçš„é€‰ä¸¾è¶…æ—¶æ—¶é—´åˆ™è§¦å‘é€‰ä¸¾ã€‚
<br>å¿ƒè·³æ£€æŸ¥çš„è¶…æ—¶é€»è¾‘é›†ä¸­åœ¨HeartbeatTimeoutCheckTaskä¸­ã€‚<br>
ç”±äºéœ€è¦å¼•å…¥éšæœºåŒ–çš„å¿ƒè·³è¶…æ—¶æ—¶é—´ï¼Œå› æ­¤æ— æ³•ä½¿ç”¨ScheduledExecutorServiceçš„scheduleAtFixedRateæ–¹æ³•ï¼Œæ”¹ä¸ºåœ¨æ¯ä¸ªä»»åŠ¡æ‰§è¡Œå®Œæˆæ—¶å†æ·»åŠ ä¸€ä¸ªæ–°ä»»åŠ¡å›å»çš„æ–¹å¼æ¥å®ç°ã€‚
<br>/**
 * RaftæœåŠ¡å™¨çš„leaderé€‰ä¸¾æ¨¡å—
 * */
public class RaftLeaderElectionModule {

    private static final Logger logger = LoggerFactory.getLogger(RaftLeaderElectionModule.class);

    private final RaftServer currentServer;

    /**
     * æœ€è¿‘ä¸€æ¬¡æ¥å—åˆ°å¿ƒè·³çš„æ—¶é—´
     * */
    private volatile Date lastHeartbeatTime;

    private final ScheduledExecutorService scheduledExecutorService;

    private final ExecutorService rpcThreadPool;

    public RaftLeaderElectionModule(RaftServer currentServer) {
        this.currentServer = currentServer;
        this.lastHeartbeatTime = new Date();
        this.scheduledExecutorService = Executors.newScheduledThreadPool(3);
        this.rpcThreadPool = Executors.newFixedThreadPool(
                Math.max(currentServer.getOtherNodeInCluster().size() * 2, 1));

        registerHeartbeatTimeoutCheckTaskWithRandomTimeout();
    }

    /**
     * æäº¤æ–°çš„å»¶è¿Ÿä»»åŠ¡(å¸¦æœ‰éšæœºåŒ–çš„è¶…æ—¶æ—¶é—´)
     * */
    public void registerHeartbeatTimeoutCheckTaskWithRandomTimeout(){
        int electionTimeout = currentServer.getRaftConfig().getElectionTimeout();
        if(currentServer.getCurrentTerm() &gt; 0 &amp;&amp; currentServer.getRaftConfig().getDebugElectionTimeout() != null){
            // debugçš„æ—¶å€™å¤šç­‰å¾…ä¸€äº›æ—¶é—´
            electionTimeout = currentServer.getRaftConfig().getDebugElectionTimeout();
        }

        long randomElectionTimeout = getRandomElectionTimeout();
        // é€‰ä¸¾è¶…æ—¶æ—¶é—´çš„åŸºç¡€ä¸Šï¼ŒåŠ ä¸Šä¸€ä¸ªéšæœºåŒ–çš„æ—¶é—´
        long delayTime = randomElectionTimeout + electionTimeout * 1000L;
        logger.debug("registerHeartbeatTimeoutCheckTaskWithRandomTimeout delayTime={}",delayTime);
        scheduledExecutorService.schedule(
            new HeartbeatTimeoutCheckTask(currentServer,this),delayTime,TimeUnit.MILLISECONDS);
    }

    /**
     * å¤„ç†æŠ•ç¥¨è¯·æ±‚
     * æ³¨æ„ï¼šsynchronizedä¿®é¥°é˜²æ­¢ä¸åŒcandidateå¹¶å‘çš„æŠ•ç¥¨ç”³è¯·å¤„ç†ï¼Œä»¥FIFOçš„æ–¹å¼å¤„ç†
     * */
    public synchronized RequestVoteRpcResult requestVoteProcess(RequestVoteRpcParam requestVoteRpcParam){
        if(this.currentServer.getCurrentTerm() &gt; requestVoteRpcParam.getTerm()){
            // Reply false if term &lt; currentTerm (Â§5.1)
            // å‘èµ·æŠ•ç¥¨çš„candidateä»»æœŸå°äºå½“å‰æœåŠ¡å™¨ä»»æœŸï¼Œæ‹’ç»æŠ•ç¥¨ç»™å®ƒ
            logger.info("reject requestVoteProcess! term &lt; currentTerm, currentServerId={}",currentServer.getServerId());
            return new RequestVoteRpcResult(this.currentServer.getCurrentTerm(),false);
        }

        // å‘èµ·æŠ•ç¥¨çš„èŠ‚ç‚¹ä»»æœŸé«˜äºå½“å‰èŠ‚ç‚¹ï¼Œæ— æ¡ä»¶æŠ•ç¥¨ç»™å®ƒ(ä»»æœŸé«˜çš„è¯´äº†ç®—)
        if(this.currentServer.getCurrentTerm() &lt; requestVoteRpcParam.getTerm()){
            // åˆ·æ–°å…ƒæ•°æ®
            this.currentServer.refreshRaftServerMetaData(
                new RaftServerMetaData(requestVoteRpcParam.getTerm(),requestVoteRpcParam.getCandidateId()));
            // ä»»æœŸæ²¡å®ƒé«˜ï¼Œè‡ªå·±è½¬ä¸ºfollower
            this.currentServer.setServerStatusEnum(ServerStatusEnum.FOLLOWER);
            return new RequestVoteRpcResult(this.currentServer.getCurrentTerm(),true);
        }

        // termä»»æœŸå€¼ç›¸åŒï¼Œéœ€è¦é¿å…åŒä¸€ä»»æœŸå†…æŠ•ç¥¨ç»™ä¸åŒçš„èŠ‚ç‚¹è€Œè„‘è£‚
        if(this.currentServer.getVotedFor() != null &amp;&amp; !this.currentServer.getVotedFor().equals(requestVoteRpcParam.getCandidateId())){
            // If votedFor is null or candidateIdï¼ˆå–åçš„å«è¯­å¥ï¼‰
            // å½“å‰æœåŠ¡å™¨å·²ç»æŠŠç¥¨æŠ•ç»™äº†åˆ«äºº,æ‹’ç»æŠ•ç¥¨ç»™å‘èµ·æŠ•ç¥¨çš„candidate
            logger.info("reject requestVoteProcess! votedFor={},currentServerId={}",
                currentServer.getVotedFor(),currentServer.getServerId());
            return new RequestVoteRpcResult(this.currentServer.getCurrentTerm(),false);
        }

        // æŠ•ç¥¨æ ¡éªŒé€šè¿‡,åˆ·æ–°å…ƒæ•°æ®
        this.currentServer.refreshRaftServerMetaData(
            new RaftServerMetaData(requestVoteRpcParam.getTerm(),requestVoteRpcParam.getCandidateId()));
        this.currentServer.processCommunicationHigherTerm(requestVoteRpcParam.getTerm());
        return new RequestVoteRpcResult(this.currentServer.getCurrentTerm(),true);
    }

    public void refreshLastHeartbeatTime(){
        // åˆ·æ–°æœ€æ–°çš„æ¥å—åˆ°å¿ƒè·³çš„æ—¶é—´
        this.lastHeartbeatTime = new Date();
        // æ¥å—æ–°çš„å¿ƒè·³,è¯´æ˜ç°åœ¨leaderæ˜¯å­˜æ´»çš„ï¼Œæ¸…ç†æ‰ä¹‹å‰çš„æŠ•ç¥¨ä¿¡æ¯
        this.currentServer.cleanVotedFor();
    }
    
    private long getRandomElectionTimeout(){
        long min = currentServer.getRaftConfig().getElectionTimeoutRandomRange().getLeft();
        long max = currentServer.getRaftConfig().getElectionTimeoutRandomRange().getRight();

        // ç”Ÿæˆ[min,max]èŒƒå›´å†…éšæœºæ•´æ•°çš„é€šç”¨å…¬å¼ä¸ºï¼šn=rand.nextInt(max-min+1)+minã€‚
        return ThreadLocalRandom.current().nextLong(max-min+1) + min;
    }
}
Copy<br>/**
 * å¿ƒè·³è¶…æ—¶æ£€æŸ¥ä»»åŠ¡
 * */
public class HeartbeatTimeoutCheckTask implements Runnable{

    private static final Logger logger = LoggerFactory.getLogger(HeartbeatTimeoutCheckTask.class);

    private final RaftServer currentServer;
    private final RaftLeaderElectionModule raftLeaderElectionModule;

    public HeartbeatTimeoutCheckTask(RaftServer currentServer, RaftLeaderElectionModule raftLeaderElectionModule) {
        this.currentServer = currentServer;
        this.raftLeaderElectionModule = raftLeaderElectionModule;
    }

    @Override
    public void run() {
        if(currentServer.getServerStatusEnum() == ServerStatusEnum.LEADER){
            // leaderæ˜¯ä¸éœ€è¦å¤„ç†å¿ƒè·³è¶…æ—¶çš„
            // æ³¨å†Œä¸‹ä¸€ä¸ªå¿ƒè·³æ£€æŸ¥ä»»åŠ¡
            raftLeaderElectionModule.registerHeartbeatTimeoutCheckTaskWithRandomTimeout();
        }else{
            try {
                doTask();
            }catch (Exception e){
                logger.info("do HeartbeatTimeoutCheckTask error! ignore",e);
            }

            // æ³¨å†Œä¸‹ä¸€ä¸ªå¿ƒè·³æ£€æŸ¥ä»»åŠ¡
            raftLeaderElectionModule.registerHeartbeatTimeoutCheckTaskWithRandomTimeout();
        }
    }

    private void doTask(){
        logger.debug("do HeartbeatTimeoutCheck start {}",currentServer.getServerId());

        int electionTimeout = currentServer.getRaftConfig().getElectionTimeout();

        // å½“å‰æ—¶é—´
        Date currentDate = new Date();
        Date lastHeartbeatTime = raftLeaderElectionModule.getLastHeartbeatTime();
        long diffTime = currentDate.getTime() - lastHeartbeatTime.getTime();

        logger.debug("currentDate={}, lastHeartbeatTime={}, diffTime={}, serverId={}",
            currentDate,lastHeartbeatTime,diffTime,currentServer.getServerId());
        // å¿ƒè·³è¶…æ—¶åˆ¤æ–­
        if(diffTime &gt; (electionTimeout * 1000L)){
            logger.info("HeartbeatTimeoutCheck check fail, trigger new election! serverId={}",currentServer.getServerId());

            // è§¦å‘æ–°çš„ä¸€è½®é€‰ä¸¾
            triggerNewElection();
        }else{
            // è®¤å®šä¸ºå¿ƒè·³æ­£å¸¸ï¼Œæ— äº‹å‘ç”Ÿ
            logger.debug("HeartbeatTimeoutCheck check success {}",currentServer.getServerId());
        }

        logger.debug("do HeartbeatTimeoutCheck end {}",currentServer.getServerId());
    }

    private void triggerNewElection(){
        logger.info("HeartbeatTimeoutCheck check fail, trigger new election! serverId={}",currentServer.getServerId());

        // è·ç¦»æœ€è¿‘ä¸€æ¬¡æ¥åˆ°å¿ƒè·³å·²ç»è¶…è¿‡äº†é€‰ä¸¾è¶…æ—¶æ—¶é—´ï¼Œè§¦å‘æ–°ä¸€è½®é€‰ä¸¾

        // å½“å‰æœåŠ¡å™¨èŠ‚ç‚¹å½“å‰ä»»æœŸè‡ªå¢1
        currentServer.setCurrentTerm(currentServer.getCurrentTerm()+1);
        // è‡ªå·±å‘èµ·é€‰ä¸¾ï¼Œå…ˆæŠ•ç¥¨ç»™è‡ªå·±
        currentServer.setVotedFor(currentServer.getServerId());
        // è§’è‰²è½¬å˜ä¸ºCANDIDATEå€™é€‰è€…
        currentServer.setServerStatusEnum(ServerStatusEnum.CANDIDATE);

        // å¹¶è¡Œçš„å‘é€è¯·æ±‚æŠ•ç¥¨çš„rpcç»™é›†ç¾¤ä¸­çš„å…¶å®ƒèŠ‚ç‚¹
        List&lt;RaftService&gt; otherNodeInCluster = currentServer.getOtherNodeInCluster();
        List&lt;Future&lt;RequestVoteRpcResult&gt;&gt; futureList = new ArrayList&lt;&gt;(otherNodeInCluster.size());

        // æ„é€ è¯·æ±‚å‚æ•°
        RequestVoteRpcParam requestVoteRpcParam = new RequestVoteRpcParam();
        requestVoteRpcParam.setTerm(currentServer.getCurrentTerm());
        requestVoteRpcParam.setCandidateId(currentServer.getServerId());

        for(RaftService node : otherNodeInCluster){
            Future&lt;RequestVoteRpcResult&gt; future = raftLeaderElectionModule.getRpcThreadPool().submit(
                ()-&gt; {
                    RequestVoteRpcResult rpcResult = node.requestVote(requestVoteRpcParam);
                    // æ”¶åˆ°æ›´é«˜ä»»æœŸçš„å¤„ç†
                    currentServer.processCommunicationHigherTerm(rpcResult.getTerm());
                    return rpcResult;
                }
            );

            futureList.add(future);
        }

        List&lt;RequestVoteRpcResult&gt; requestVoteRpcResultList = CommonUtil.concurrentGetRpcFutureResult(
            "requestVote", futureList,
            raftLeaderElectionModule.getRpcThreadPool(),1,TimeUnit.SECONDS);

        // è·å¾—rpcå“åº”ä¸­å†³å®šæŠ•ç¥¨ç»™è‡ªå·±çš„æ€»ç¥¨æ•°ï¼ˆç®—ä¸Šè‡ªå·±çš„1ç¥¨ï¼‰
        int getRpcVoted = (int) requestVoteRpcResultList.stream().filter(RequestVoteRpcResult::isVoteGranted).count()+1;
        logger.info("HeartbeatTimeoutCheck election, getRpcVoted={}, currentServerId={}",getRpcVoted,currentServer.getServerId());

        // æ˜¯å¦è·å¾—å¤§å¤šæ•°çš„æŠ•ç¥¨
        boolean majorVoted = getRpcVoted &gt;= this.currentServer.getRaftConfig().getMajorityNum();
        if(majorVoted){
            logger.info("HeartbeatTimeoutCheck election result: become a leader! {}, currentTerm={}",currentServer.getServerId(),currentServer.getCurrentTerm());

            // ç¥¨æ•°è¿‡åŠæˆåŠŸå½“é€‰ä¸ºleader
            currentServer.setServerStatusEnum(ServerStatusEnum.LEADER);
            currentServer.setCurrentLeader(currentServer.getServerId());

            // æˆä¸ºleaderåç«‹é©¬å‘é€ä¸€æ¬¡å¿ƒè·³,æŠ‘åˆ¶å…¶å®ƒèŠ‚ç‚¹å‘èµ·æ–°çš„ä¸€è½®é€‰ä¸¾
            // Upon election: send initial empty AppendEntries RPCs (heartbeat) to each server;
            // repeat during idle periods to prevent election timeouts (Â§5.2)
            HeartbeatBroadcastTask.doHeartbeatBroadcast(currentServer);
        }else{
            // ç¥¨æ•°ä¸è¿‡åŠï¼Œæ— æ³•æˆä¸ºleader
            logger.info("HeartbeatTimeoutCheck election result: not become a leader! {}",currentServer.getServerId());
        }

        this.currentServer.cleanVotedFor();
    }
}
Copy<br><br>
<br>åœ¨ä¸Šä¸€èŠ‚ä»‹ç»çš„HeartbeatTimeoutCheckTaskä¸­ï¼Œå¦‚æœå‘ç°æœ‰ä¸€æ®µæ—¶é—´æ²¡æœ‰æ”¶åˆ°å¿ƒè·³åå½“å‰èŠ‚ç‚¹ä¾¿ä¼šè§¦å‘æ–°ä¸€è½®çš„é€‰ä¸¾ï¼Œä¸»è¦é€»è¾‘åœ¨triggerNewElectionæ–¹æ³•ä¸­ã€‚<br>
triggerNewElectionä¸­é€šè¿‡é¦–å…ˆä»¤å½“å‰termå€¼è‡ªå¢1å¹¶æŠ•ç¥¨ç»™è‡ªå·±ï¼Œç„¶åå¹¶è¡Œçš„å‘é›†ç¾¤ä¸­çš„å…¶å®ƒèŠ‚ç‚¹å‘é€requestVoteçš„rpcè¯·æ±‚ã€‚
<br>å¹¶è¡Œå¤„ç†é€»è¾‘é€šè¿‡CommonUtilä¸­çš„concurrentGetRpcFutureResultæ–¹æ³•æ”¶é›†æ‰€æœ‰çš„å“åº”ç»“æœã€‚<br>
é€šè¿‡future.getè®¾ç½®è¶…æ—¶æ—¶é—´ï¼Œè¶…æ—¶åˆ™è®¤ä¸ºæ˜¯æŠ•ç¥¨å¤±è´¥ã€‚
<br>åœ¨è¶…æ—¶æ—¶é—´å†…è·å¾—æ‰€æœ‰å“åº”ç»“æœåï¼Œè®¡ç®—æ‰€å¾—åˆ°çš„çš„ç¥¨æ•°æ˜¯å¦å¤§äºåŠæ•°(&gt;majorityNum)ã€‚<br>
å¦‚æœè¶…è¿‡åŠæ•°åˆ™è®¤ä¸ºé€‰ä¸¾æˆåŠŸï¼Œè‡ªå·±æˆä¸ºåˆæ³•çš„leaderã€‚å½“å‰èŠ‚ç‚¹åˆ·æ–°ç›¸å…³çš„çŠ¶æ€æ•°æ®ï¼ŒåŒæ—¶ç«‹å³å‘èµ·ä¸€æ¬¡å¿ƒè·³å¹¿æ’­ä»¥æŠ‘åˆ¶å…¶å®ƒèŠ‚ç‚¹å‘èµ·æ–°çš„é€‰ä¸¾ã€‚
<br>public class CommonUtil {

    private static final Logger logger = LoggerFactory.getLogger(CommonUtil.class);

    /**
     * å¹¶å‘çš„è·å¾—futureåˆ—è¡¨çš„ç»“æœ
     * */
    public static &lt;T&gt; List&lt;T&gt; concurrentGetRpcFutureResult(
            String info, List&lt;Future&lt;T&gt;&gt; futureList, ExecutorService threadPool, long timeout, TimeUnit timeUnit){
        CountDownLatch countDownLatch = new CountDownLatch(futureList.size());

        List&lt;T&gt; resultList = new ArrayList&lt;&gt;(futureList.size());

        for(Future&lt;T&gt; futureItem : futureList){
            threadPool.execute(()-&gt;{
                try {
                    logger.debug(info + " concurrentGetRpcFutureResult start!");
                    T result = futureItem.get(timeout,timeUnit);
                    logger.debug(info + " concurrentGetRpcFutureResult end!");

                    resultList.add(result);
                } catch (Exception e) {
                    // rpcå¼‚å¸¸ä¸è€ƒè™‘
                    logger.error( "{} getFutureResult error!",info,e);
                } finally {
                    countDownLatch.countDown();
                }
            });
        }

        try {
            countDownLatch.await();
        } catch (InterruptedException e) {
            throw new MyRaftException("getFutureResult error!",e);
        }

        return resultList;
    }
}
Copy<br><br>
<br>MyRaftä¸­å°†leaderå¿ƒè·³å¹¿æ’­ç›¸å…³çš„é€»è¾‘éƒ½é›†ä¸­åœ¨äº†RaftHeartbeatBroadcastModuleç±»ä¸­ï¼Œå¿ƒè·³å¹¿æ’­ä»»åŠ¡ä»¥RaftConfigä¸­è®¾ç½®çš„é¢‘ç‡å®šæœŸæ‰§è¡Œã€‚<br>
éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¿ƒè·³çš„æ—¶é—´é—´éš”å¿…é¡»é…ç½®ä¸ºæ˜æ˜¾å°äºé…ç½®çš„é€‰ä¸¾è¶…æ—¶æ—¶é—´çš„å€¼(è€ƒè™‘åˆ°rpcç½‘ç»œè¯·æ±‚å»¶è¿Ÿä»¥åŠfollowerå®é™…å¤„ç†å¿ƒè·³çš„è€—æ—¶)ï¼Œå¦åˆ™leaderå¿ƒè·³å°†æ— æ³•æŠ‘åˆ¶followerè§¦å‘é€‰ä¸¾ã€‚
<br>leaderå¿ƒè·³å¹¿æ’­çš„é€»è¾‘é›†ä¸­åœ¨HeartbeatBroadcastTaskä¸­ã€‚å’Œå‘èµ·æŠ•ç¥¨ç±»ä¼¼ï¼Œå½“å‰èŠ‚ç‚¹é€šè¿‡futureå¹¶å‘çš„å‘é›†ç¾¤ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹å‘é€logEntryä¸ºç©ºçš„appendEntries(å› ä¸ºlab1ä¸­ä¸æ¶‰åŠæ—¥å¿—å¤åˆ¶ï¼Œæ‰€ä»¥ç›´æ¥å»æ‰äº†logEntryè¿™ä¸ªå‚æ•°å­—æ®µ)ã€‚<br>
leaderåŸåˆ™ä¸Šå¯ä»¥ä¸å…³å¿ƒfollowerå¯¹äºå¿ƒè·³çš„å“åº”ç»“æœï¼Œä½†è¿˜æ˜¯éœ€è¦æ£€æŸ¥æˆåŠŸå“åº”ä¸­è¿”å›çš„termå€¼ã€‚å¦‚æœå‘ç°æœ‰å…¶å®ƒèŠ‚ç‚¹è¿”å›äº†æ›´å¤§çš„termå€¼ï¼Œè¯´æ˜é›†ç¾¤ä¸­å¯èƒ½å·²ç»é€‰å‡ºäº†æ–°çš„leaderæˆ–è€…æ­£åœ¨è¿›è¡Œé€‰ä¸¾ï¼Œåˆ™å½“å‰èŠ‚ç‚¹éœ€è¦é€€å›åˆ°followerçŠ¶æ€ã€‚
<br>/**
 * RaftæœåŠ¡å™¨çš„å¿ƒè·³å¹¿æ’­æ¨¡å—
 * */
public class RaftHeartbeatBroadcastModule {

    private final RaftServer currentServer;

    private final ScheduledExecutorService scheduledExecutorService;

    private final ExecutorService rpcThreadPool;

    public RaftHeartbeatBroadcastModule(RaftServer currentServer) {
        this.currentServer = currentServer;

        this.scheduledExecutorService = Executors.newScheduledThreadPool(1);
        this.rpcThreadPool = Executors.newFixedThreadPool(
            Math.max(currentServer.getOtherNodeInCluster().size() * 2, 1));

        int HeartbeatInternal = currentServer.getRaftConfig().getHeartbeatInternal();

        // å¿ƒè·³å¹¿æ’­ä»»åŠ¡éœ€è¦ä»¥å›ºå®šé¢‘ç‡æ‰§è¡Œ(scheduleAtFixedRate)
        scheduledExecutorService.scheduleAtFixedRate(
            new HeartbeatBroadcastTask(currentServer,this), 0, HeartbeatInternal, TimeUnit.SECONDS);
    }
}
Copy<br>/**
 * leaderå¿ƒè·³å¹¿æ’­ä»»åŠ¡
 * */
public class HeartbeatBroadcastTask implements Runnable{

    private static final Logger logger = LoggerFactory.getLogger(HeartbeatBroadcastTask.class);

    private final RaftServer currentServer;
    private final RaftHeartbeatBroadcastModule raftHeartbeatBroadcastModule;

    private int HeartbeatCount = 0;

    public HeartbeatBroadcastTask(RaftServer currentServer, RaftHeartbeatBroadcastModule raftHeartbeatBroadcastModule) {
        this.currentServer = currentServer;
        this.raftHeartbeatBroadcastModule = raftHeartbeatBroadcastModule;
    }

    @Override
    public void run() {
        if(currentServer.getServerStatusEnum() != ServerStatusEnum.LEADER){
            // åªæœ‰leaderæ‰éœ€è¦å¹¿æ’­å¿ƒè·³
            return;
        }

        // å¿ƒè·³å¹¿æ’­
        doHeartbeatBroadcast(currentServer);
    }

    /**
     * åšå¿ƒè·³å¹¿æ’­
     * @return æ˜¯å¦å¤§å¤šæ•°èŠ‚ç‚¹ä¾ç„¶è®¤ä¸ºè‡ªå·±æ˜¯leader
     * */
    public static boolean doHeartbeatBroadcast(RaftServer currentServer){
        logger.info("do HeartbeatBroadcast start {}",currentServer.getServerId());

        // å…ˆåˆ·æ–°è‡ªå·±çš„å¿ƒè·³æ—¶é—´
        currentServer.getRaftLeaderElectionModule().refreshLastHeartbeatTime();

        // å¹¶è¡Œçš„å‘é€å¿ƒè·³rpcç»™é›†ç¾¤ä¸­çš„å…¶å®ƒèŠ‚ç‚¹
        List&lt;RaftService&gt; otherNodeInCluster = currentServer.getOtherNodeInCluster();
        List&lt;Future&lt;AppendEntriesRpcResult&gt;&gt; futureList = new ArrayList&lt;&gt;(otherNodeInCluster.size());

        // æ„é€ è¯·æ±‚å‚æ•°(å¿ƒè·³rpcï¼Œentriesä¸ºç©º)
        AppendEntriesRpcParam appendEntriesRpcParam = new AppendEntriesRpcParam();
        appendEntriesRpcParam.setTerm(currentServer.getCurrentTerm());
        appendEntriesRpcParam.setLeaderId(currentServer.getServerId());

        for(RaftService node : otherNodeInCluster){
            Future&lt;AppendEntriesRpcResult&gt; future = currentServer.getRaftHeartbeatBroadcastModule().getRpcThreadPool().submit(
                ()-&gt; {
                    AppendEntriesRpcResult rpcResult = node.appendEntries(appendEntriesRpcParam);
                    // rpcäº¤äº’æ—¶ä»»æœŸé«˜äºå½“å‰èŠ‚ç‚¹ä»»æœŸçš„å¤„ç†
                    currentServer.processCommunicationHigherTerm(rpcResult.getTerm());
                    return rpcResult;
                }
            );

            futureList.add(future);
        }

        List&lt;AppendEntriesRpcResult&gt; appendEntriesRpcResultList = CommonUtil.concurrentGetRpcFutureResult("doHeartbeatBroadcast",futureList,
            currentServer.getRaftHeartbeatBroadcastModule().getRpcThreadPool(),1, TimeUnit.SECONDS);

        // é€šçŸ¥æˆåŠŸçš„æ•°é‡(+1åŒ…æ‹¬è‡ªå·±)
        int successResponseCount = (int) (appendEntriesRpcResultList.stream().filter(AppendEntriesRpcResult::isSuccess).count() + 1);
        if(successResponseCount &gt;= currentServer.getRaftConfig().getMajorityNum()
            &amp;&amp; currentServer.getServerStatusEnum() == ServerStatusEnum.LEADER){
            // å¤§å¤šæ•°èŠ‚ç‚¹ä¾ç„¶è®¤ä¸ºè‡ªå·±æ˜¯leader,å¹¶ä¸”å¹¿æ’­çš„èŠ‚ç‚¹ä¸­æ²¡æœ‰äººä»»æœŸé«˜äºå½“å‰èŠ‚ç‚¹ï¼Œè®©å½“å‰èŠ‚ç‚¹ä¸»åŠ¨è®©ä½
            return true;
        }else{
            // å¤§å¤šæ•°èŠ‚ç‚¹ä¸è®¤ä¸ºè‡ªå·±æ˜¯leaderï¼ˆåŒ…æ‹¬å¹¿æ’­è¶…æ—¶ç­‰æœªæ¥åˆ°å“åº”çš„åœºæ™¯ï¼Œä¹Ÿè®¤ä¸ºæ˜¯å¹¿æ’­å¤±è´¥ï¼‰
            return false;
        }
    }
}
Copy<br><br>å¤„ç†requestVoteè¯·æ±‚<br>
<br>MyRaftå¤„ç†requestVoteçš„é€»è¾‘åœ¨ä¸Šé¢æåˆ°çš„RaftLeaderElectionModuleçš„requestVoteProcessæ–¹æ³•ä¸­ã€‚<br>
raftéœ€è¦ä¿è¯æ¯ä¸ªä»»æœŸéƒ½åªèƒ½é€‰å‡ºä¸€ä¸ªleaderï¼Œæ‰€ä»¥å¯¹äºç‰¹å®šçš„termä»»æœŸéœ€è¦åšåˆ°åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹èƒ½è·å¾—è¶…è¿‡åŠæ•°é€‰ç¥¨ã€‚
<br>å› æ­¤ï¼ŒrequestVoteProcessä¸­ä¼šå¯¹å‘èµ·æŠ•ç¥¨çš„candidateå’Œè‡ªå·±æœ¬åœ°çš„termå€¼è¿›è¡Œæ¯”å¯¹ï¼Œå¦‚æœtermå€¼æ¯”è‡ªå·±ä½å°±ç›´æ¥æ‹’ç»(è¿‡å»çš„leaderä¸æ˜¯leaderï¼Œåªæœ‰ç°åœ¨çš„leaderæ‰æ˜¯leader)ã€‚<br>
æ¯ä¸ªèŠ‚ç‚¹åªæœ‰ä¸€ç¥¨ï¼Œå¦‚æœtermå€¼ç›¸åŒåˆ™éœ€è¦ç¡®ä¿è‡ªå·±åœ¨æ­¤ä¹‹å‰æ²¡æœ‰æŠ•ç¥¨ç»™å…¶å®ƒcandidateã€‚
<br>å¤„ç†å¿ƒè·³è¯·æ±‚<br>
<br>MyRaftçš„å¤„ç†å¿ƒè·³è¯·æ±‚çš„é€»è¾‘åœ¨RaftServerç±»çš„appendEntriesä¸­ã€‚ç”±äºlab1æ²¡æœ‰æ—¥å¿—å¤åˆ¶çš„åŠŸèƒ½ï¼Œæ‰€ä»¥è®¤ä¸ºæ”¶åˆ°çš„è¯·æ±‚éƒ½æ˜¯å¿ƒè·³è¯·æ±‚ã€‚
<br>appendEntriesä¸­ï¼ŒåŒæ ·éœ€è¦æ¯”å¯¹å‚æ•°ä¸­termå’Œæœ¬åœ°termçš„å€¼ï¼Œå°½å¯èƒ½çš„ç¡®ä¿æ˜¯çœŸæ­£çš„leaderå‘æ¥çš„å¿ƒè·³ã€‚<br>
å¦‚æœæ ¡éªŒé€šè¿‡äº†ï¼Œåˆ™å°†æœ¬åœ°çš„æœ€åæ¥å—åˆ°çš„å¿ƒè·³æ—¶é—´åˆ·æ–°ä¸ºå½“å‰æ—¶é—´ï¼Œæ¥æŠ‘åˆ¶é€‰ä¸¾è¶…æ—¶æ£€æŸ¥ä»»åŠ¡ä¸­è§¦å‘æ–°ä¸€è½®é€‰ä¸¾ã€‚
<br>public class RaftServer implements RaftService {

    private static final Logger logger = LoggerFactory.getLogger(RaftServer.class);

    /**
     * å½“å‰æœåŠ¡èŠ‚ç‚¹çš„id(é›†ç¾¤å†…å…¨å±€å”¯ä¸€)
     * */
    private final String serverId;

    /**
     * RaftæœåŠ¡ç«¯é…ç½®
     * */
    private final RaftConfig raftConfig;

    /**
     * å½“å‰æœåŠ¡å™¨çš„çŠ¶æ€
     * */
    private volatile ServerStatusEnum serverStatusEnum;

    /**
     * raftæœåŠ¡å™¨å…ƒæ•°æ®(å½“å‰ä»»æœŸå€¼currentTermã€å½“å‰æŠ•ç¥¨ç»™äº†è°votedFor)
     * */
    private final RaftServerMetaDataPersistentModule raftServerMetaDataPersistentModule;

    /**
     * å½“å‰æœåŠ¡è®¤ä¸ºçš„leaderèŠ‚ç‚¹çš„Id
     * */
    private volatile String currentLeader;

    /**
     * é›†ç¾¤ä¸­çš„å…¶å®ƒraftèŠ‚ç‚¹æœåŠ¡
     * */
    protected List&lt;RaftService&gt; otherNodeInCluster;

    private RaftLeaderElectionModule raftLeaderElectionModule;
    private RaftHeartbeatBroadcastModule raftHeartbeatBroadcastModule;

    public RaftServer(RaftConfig raftConfig) {
        this.serverId = raftConfig.getServerId();
        this.raftConfig = raftConfig;
        // åˆå§‹åŒ–æ—¶éƒ½æ˜¯follower
        this.serverStatusEnum = ServerStatusEnum.FOLLOWER;

        // æœåŠ¡å™¨å…ƒæ•°æ®æ¨¡å—
        this.raftServerMetaDataPersistentModule = new RaftServerMetaDataPersistentModule(raftConfig.getServerId());
    }

    public void init(List&lt;RaftService&gt; otherNodeInCluster){
        // é›†ç¾¤ä¸­çš„å…¶å®ƒèŠ‚ç‚¹æœåŠ¡
        this.otherNodeInCluster = otherNodeInCluster;

        raftLeaderElectionModule = new RaftLeaderElectionModule(this);
        raftHeartbeatBroadcastModule = new RaftHeartbeatBroadcastModule(this);

        logger.info("raft server init end! otherNodeInCluster={}, currentServerId={}",otherNodeInCluster,serverId);
    }

    @Override
    public RequestVoteRpcResult requestVote(RequestVoteRpcParam requestVoteRpcParam) {
        RequestVoteRpcResult requestVoteRpcResult = raftLeaderElectionModule.requestVoteProcess(requestVoteRpcParam);

        processCommunicationHigherTerm(requestVoteRpcParam.getTerm());

        logger.info("do requestVote requestVoteRpcParam={},requestVoteRpcResult={}, currentServerId={}",
            requestVoteRpcParam,requestVoteRpcResult,this.serverId);

        return requestVoteRpcResult;
    }

    @Override
    public AppendEntriesRpcResult appendEntries(AppendEntriesRpcParam appendEntriesRpcParam) {
        if(appendEntriesRpcParam.getTerm() &lt; this.raftServerMetaDataPersistentModule.getCurrentTerm()){
            // Reply false if term &lt; currentTerm (Â§5.1)
            // æ‹’ç»å¤„ç†ä»»æœŸä½äºè‡ªå·±çš„è€leaderçš„è¯·æ±‚

            logger.info("doAppendEntries term &lt; currentTerm");
            return new AppendEntriesRpcResult(this.raftServerMetaDataPersistentModule.getCurrentTerm(),false);
        }

        if(appendEntriesRpcParam.getTerm() &gt;= this.raftServerMetaDataPersistentModule.getCurrentTerm()){
            // appendEntriesè¯·æ±‚ä¸­ä»»æœŸå€¼å¦‚æœå¤§äºè‡ªå·±ï¼Œè¯´æ˜å·²ç»æœ‰ä¸€ä¸ªæ›´æ–°çš„leaderäº†ï¼Œè‡ªå·±è½¬ä¸ºfollowerï¼Œå¹¶ä¸”ä»¥å¯¹æ–¹æ›´å¤§çš„ä»»æœŸä¸ºå‡†
            this.serverStatusEnum = ServerStatusEnum.FOLLOWER;
            this.currentLeader = appendEntriesRpcParam.getLeaderId();
            this.raftServerMetaDataPersistentModule.setCurrentTerm(appendEntriesRpcParam.getTerm());
        }

        // æ¥è‡ªleaderçš„å¿ƒè·³å¤„ç†ï¼Œæ¸…ç†æ‰ä¹‹å‰é€‰ä¸¾çš„votedFor
        this.cleanVotedFor();
        // entriesä¸ºç©ºï¼Œè¯´æ˜æ˜¯å¿ƒè·³è¯·æ±‚ï¼Œåˆ·æ–°ä¸€ä¸‹æœ€è¿‘æ”¶åˆ°å¿ƒè·³çš„æ—¶é—´
        raftLeaderElectionModule.refreshLastHeartbeatTime();

        // å¿ƒè·³è¯·æ±‚ï¼Œç›´æ¥è¿”å›
        return new AppendEntriesRpcResult(this.raftServerMetaDataPersistentModule.getCurrentTerm(),true);
    }
}
Copy<br><br>åœ¨å·¥ç¨‹çš„testç›®å½•ä¸‹ï¼Œå¯ä»¥å¯åŠ¨ä¸€ä¸ª5èŠ‚ç‚¹çš„MyRaftçš„æœåŠ¡é›†ç¾¤(ç”¨mainæ–¹æ³•å¯åŠ¨å³å¯)ï¼Œé€šè¿‡ä¿®æ”¹å…¶ä¸­çš„RaftClusterGlobalConfigç±»å¯ä»¥ä¿®æ”¹ç›¸å…³çš„é…ç½®ã€‚<br>
<img alt="Pasted image 20240725172328.png" src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raftå®ç°/pasted-image-20240725172328.png"><br>public class RaftClusterGlobalConfig {
    
    public static Registry registry = RegistryFactory.getRegistry(
        new RegistryConfig(RegistryCenterTypeEnum.FAKE_REGISTRY.getCode(), "127.0.0.1:2181"));

    /**
     * raftçš„é›†ç¾¤é…ç½®
     * */
    public static final List&lt;RaftNodeConfig&gt; raftNodeConfigList = Arrays.asList(
        new RaftNodeConfig("raft-1","127.0.0.1",8001)
        ,new RaftNodeConfig("raft-2","127.0.0.1",8002)
        ,new RaftNodeConfig("raft-3","127.0.0.1",8003)
        ,new RaftNodeConfig("raft-4","127.0.0.1",8004)
        ,new RaftNodeConfig("raft-5","127.0.0.1",8005)
    );

    public static final int electionTimeout = 3;

    public static final Integer debugElectionTimeout = null;

    public static final int HeartbeatInterval = 1;

    /**
     * Næ¬¡å¿ƒè·³åï¼Œleaderä¼šè‡ªåŠ¨æ¨¡æ‹Ÿå‡ºç°æ•…éšœ(é€€å›followï¼Œåœæ­¢å¿ƒè·³å¹¿æ’­)
     * N&lt;=0ä»£è¡¨ä¸è§¦å‘è‡ªåŠ¨æ¨¡æ‹Ÿæ•…éšœ
     */
    public static final int leaderAutoFailCount = 0;

    /**
     * éšæœºåŒ–çš„é€‰ä¸¾è¶…æ—¶æ—¶é—´(æ¯«ç§’)
     * */
    public static final Range&lt;Integer&gt; electionTimeoutRandomRange = new Range&lt;&gt;(150,500);

    public static void initRaftRpcServer(String serverId){
        RaftNodeConfig currentNodeConfig = RaftClusterGlobalConfig.raftNodeConfigList
            .stream().filter(item-&gt;item.getServerId().equals(serverId)).findAny()
            .orElseThrow(() -&gt; new MyRaftException("serverId must in raftNodeConfigList"));

        List&lt;RaftNodeConfig&gt; otherNodeList = RaftClusterGlobalConfig.raftNodeConfigList
            .stream().filter(item-&gt;!item.getServerId().equals(serverId)).collect(Collectors.toList());

        RaftConfig raftConfig = new RaftConfig(
            currentNodeConfig,RaftClusterGlobalConfig.raftNodeConfigList);
        raftConfig.setElectionTimeout(RaftClusterGlobalConfig.electionTimeout);
        raftConfig.setDebugElectionTimeout(RaftClusterGlobalConfig.debugElectionTimeout);

        raftConfig.setHeartbeatInternal(RaftClusterGlobalConfig.HeartbeatInterval);
        raftConfig.setLeaderAutoFailCount(RaftClusterGlobalConfig.leaderAutoFailCount);
        // éšæœºåŒ–é€‰ä¸¾è¶…æ—¶æ—¶é—´çš„èŒƒå›´
        raftConfig.setElectionTimeoutRandomRange(RaftClusterGlobalConfig.electionTimeoutRandomRange);

        RaftRpcServer raftRpcServer = new RaftRpcServer(raftConfig, RaftClusterGlobalConfig.registry);

        List&lt;RaftService&gt; raftServiceList = raftRpcServer.getRpcProxyList(otherNodeList);
        // raftæœåŠ¡ï¼Œå¯åŠ¨ï¼
        raftRpcServer.init(raftServiceList);
    }
}
Copy<br>éªŒè¯lab1ä¸­MyRaft leaderé€‰ä¸¾å®ç°çš„æ­£ç¡®æ€§ï¼Œå¯ä»¥é€šè¿‡ä»¥ä¸‹å‡ ä¸ªcaseç®€å•çš„éªŒè¯ä¸‹ï¼š<br>
<br>å¯åŠ¨5ä¸ªèŠ‚ç‚¹ï¼Œçœ‹çœ‹æ˜¯å¦èƒ½å¤Ÿåœ¨çŸ­æ—¶é—´å†…é€‰ä¸¾å‡ºä¸€ä¸ªleaderï¼Œleaderæ˜¯å¦èƒ½æŠ‘åˆ¶åç»­çš„é€‰ä¸¾(leaderå®šæ—¶å¿ƒè·³æœ‰æ—¥å¿—èƒ½è§‚å¯Ÿåˆ°)ã€‚
<br>å°†leaderæ€æ‰(5èŠ‚ç‚¹é›†ç¾¤æœ€å¤šèƒ½å®¹å¿2ä¸ªèŠ‚ç‚¹æ•…éšœ)ï¼Œçœ‹æ˜¯å¦åœ¨é€‰ä¸¾è¶…æ—¶åè§¦å‘æ–°ä¸€è½®é€‰ä¸¾ï¼Œå¹¶ä¸”æˆåŠŸé€‰å‡ºæ–°çš„leaderã€‚
<br>å°†ä¹‹å‰æ€æ‰çš„leaderå†å¯åŠ¨ï¼Œçœ‹èƒ½å¦æˆåŠŸçš„å›åˆ°é›†ç¾¤ä¸­ã€‚
<br><br>åœ¨åŸå§‹çš„raftç®—æ³•çš„leaderé€‰ä¸¾ä¸­å­˜åœ¨ä¸€ä¸ªé—®é¢˜ã€‚å…·ä½“åœºæ™¯ä¸¾ä¾‹å¦‚ä¸‹ï¼š<br>
<br>ä¸€ä¸ª5èŠ‚ç‚¹çš„rafté›†ç¾¤ï¼Œçªç„¶å…¶ä¸­2ä¸ªfollowerèŠ‚ç‚¹ä¸å¦å¤–ä¸‰ä¸ªèŠ‚ç‚¹(åŒ…å«å½“å‰leader)ä¹‹é—´å‡ºç°äº†ç½‘ç»œåˆ†åŒºï¼Œä¸åŒç½‘ç»œåˆ†åŒºçš„èŠ‚ç‚¹æ— æ³•æ­£å¸¸é€šä¿¡ã€‚
<br>æ­¤æ—¶3èŠ‚ç‚¹æ‰€åœ¨çš„ç½‘ç»œåˆ†åŒºæ˜¯å¤šæ•°åˆ†åŒºï¼Œå› æ­¤å¯ä»¥æ­£å¸¸å·¥ä½œã€‚è€Œ2ä¸ªèŠ‚ç‚¹æ‰€åœ¨çš„åˆ†åŒºæ˜¯å°‘æ•°åˆ†åŒºï¼Œç”±äºæ— æ³•æ¥åˆ°leaderå¿ƒè·³è€Œè§¦å‘æ–°çš„é€‰ä¸¾ã€‚<br>
raftçš„è®ºæ–‡ä¸­æåˆ°ï¼Œå‘èµ·æ–°é€‰ä¸¾éœ€è¦å…ˆå°†è‡ªå·±çš„ä»»æœŸå€¼termè‡ªå¢1ï¼Œç„¶åå‘èµ·å¹¶è¡Œçš„requestVoteã€‚<br>
ä½†æ­¤æ—¶2èŠ‚ç‚¹æ‰€åœ¨çš„å°‘æ•°åˆ†åŒºæ˜¯æ— æ³•æˆåŠŸè·å¾—å¤§å¤šæ•°é€‰ç¥¨çš„ï¼Œå› æ­¤åœ¨è¿™ä¸ªåˆ†åŒºä¸­çš„èŠ‚ç‚¹ä¼šä¸æ–­çš„å‘èµ·ä¸€è½®åˆä¸€è½®çš„leaderé€‰ä¸¾ï¼Œtermå€¼ä¹Ÿä¼šåœ¨å¾ˆçŸ­çš„æ—¶é—´å†…å¿«é€Ÿå¢é•¿ã€‚
<br>åœ¨ä¸€æ®µæ—¶é—´åç½‘ç»œåˆ†åŒºé—®é¢˜æ¢å¤åï¼Œé›†ç¾¤ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹åˆèƒ½äº’ç›¸é€šä¿¡äº†ï¼Œæ­¤æ—¶å°‘æ•°åˆ†åŒºèŠ‚ç‚¹çš„termå€¼å¤§æ¦‚ç‡è¿œå¤§äºæ­£å¸¸å·¥ä½œçš„å¤šæ•°åˆ†åŒºä¸­çš„èŠ‚ç‚¹ã€‚<br>
åœ¨å°‘æ•°åˆ†åŒºèŠ‚ç‚¹æ”¶åˆ°æ¥è‡ªå¤šæ•°åˆ†åŒºèŠ‚ç‚¹çš„leaderçš„rpcè¯·æ±‚æ—¶ï¼Œå…¶ä¼šå“åº”ä¸€ä¸ªæ›´å¤§çš„termå€¼ã€‚æ­¤æ—¶ä½äºå¤šæ•°åˆ†åŒºä¸­çš„leaderä¼šå› ä¸ºå“åº”çš„termå€¼é«˜äºè‡ªå·±è€Œä¸»åŠ¨é€€ä½ï¼Œé›†ç¾¤å†…ä¼šå‘èµ·ä¸€è½®æ–°çš„é€‰ä¸¾ã€‚
<br>ä»æœ¬è´¨ä¸Šæ¥è¯´ï¼Œè¿™ä¸ªåˆ†åŒºæ¢å¤åè¿›è¡Œçš„æ–°é€‰ä¸¾æ˜¯æ— æ„ä¹‰çš„ã€‚ä¸”ç”±äºè¿›è¡Œé€‰ä¸¾ä¼šé€ æˆé›†ç¾¤çŸ­æš‚çš„ä¸å¯ç”¨ï¼Œå› æ­¤æœ€å¥½èƒ½é¿å…è¿™ä¸ªé—®é¢˜ã€‚<br>ä¸šç•Œç»™å‡ºçš„è§£å†³æ–¹æ³•æ˜¯åœ¨çœŸæ­£çš„é€‰ä¸¾å‰å…ˆå‘èµ·ä¸€è½®é¢„é€‰ä¸¾(preVote)ã€‚<br>
<br>é¢„é€‰ä¸¾çš„æ“ä½œå’Œé€‰ä¸¾ä¸€æ ·ï¼Œä¹Ÿæ˜¯å¹¶è¡Œçš„å‘èµ·requestVoteè¯·æ±‚ï¼Œä¸»è¦çš„åŒºåˆ«åœ¨äºå‘èµ·é¢„é€‰ä¸¾çš„èŠ‚ç‚¹å¹¶ä¸äº‹å…ˆå°†termå€¼è‡ªå¢ï¼Œè€Œæ˜¯ç»´æŒä¸å˜ã€‚èŠ‚ç‚¹çš„çŠ¶æ€ä¹Ÿåœ¨candidateçš„åŸºç¡€ä¸Šæ–°å¢äº†ä¸€ä¸ªpreCandidateçŠ¶æ€ã€‚
<br>å‘èµ·é¢„é€‰ä¸¾çš„èŠ‚ç‚¹éœ€è¦æ ¹æ®é¢„é€‰ä¸¾ä¸­å‘èµ·çš„å¹¶è¡ŒrequestVoteç»“æœæ¥å†³å®šæ˜¯å¦å¼€å¯å®é™…çš„leaderé€‰ä¸¾ã€‚<br>
å¦‚æœé¢„é€‰ä¸¾ä¸­å‘èµ·çš„å¹¶è¡ŒrequestVoteå¾—åˆ°äº†å¤šæ•°ç¥¨ï¼Œåˆ™å¯ä»¥æ¥ç€å‘èµ·å®é™…çš„é€‰ä¸¾ã€‚è€Œå¦‚æœæ²¡æœ‰å¾—åˆ°å¤šæ•°ç¥¨ï¼Œåˆ™ä¸è¿›è¡Œå®é™…çš„é€‰ä¸¾ã€‚
<br>å¼•å…¥äº†é¢„é€‰ä¸¾çš„æœºåˆ¶åï¼Œä¸Šé¢æ‰€è¯´çš„ç½‘ç»œåˆ†åŒºå‘ç”Ÿæ—¶ï¼Œå°‘æ•°åˆ†åŒºçš„èŠ‚ç‚¹ç”±äºæ— æ³•åœ¨é¢„é€‰ä¸¾ä¸­è·å¾—å¤§å¤šæ•°ç¥¨ï¼Œå› æ­¤åªä¼šä¸æ–­çš„å‘èµ·ä¸€è½®åˆä¸€è½®çš„é¢„é€‰ä¸¾ã€‚<br>
å› æ­¤ï¼Œå…¶termå€¼ä¸ä¼šä¸æ–­å¢åŠ è€Œæ˜¯ä¸€ç›´ç»´æŒåœ¨åˆ†åŒºå‘ç”Ÿæ—¶çš„å€¼ã€‚åœ¨åˆ†åŒºé—®é¢˜æ¢å¤åï¼Œå…¶termå€¼ä¸€å®šæ˜¯å°äºæˆ–ç­‰äºå¤šæ•°åˆ†åŒºå†…leaderçš„termå€¼ï¼Œè€Œä¸ä¼šè¿›è¡Œä¸€è½®æ— æ•ˆçš„é€‰ä¸¾ï¼Œä»è€Œè§£å†³ä¸Šè¿°çš„é—®é¢˜ã€‚<br>
ä½†éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¼•å…¥é¢„é€‰ä¸¾æœºåˆ¶ä¹Ÿä¼šå¢åŠ æ­£å¸¸çŠ¶å†µä¸‹å‘èµ·æ­£å¸¸é€‰ä¸¾çš„å¼€é”€ã€‚
<br>MyRaftä¸ºäº†ä¿æŒå®ç°çš„ç®€å•æ€§ï¼Œå¹¶æ²¡æœ‰å®ç°é¢„é€‰ä¸¾æœºåˆ¶ã€‚ä½†etcdã€sofa-jraftç­‰æµè¡Œçš„å¼€æºraftç³»ç»Ÿéƒ½æ˜¯å®ç°äº†é¢„é€‰ä¸¾ä¼˜åŒ–çš„ï¼Œæ‰€ä»¥åœ¨è¿™é‡Œè¿˜æ˜¯ç®€å•ä»‹ç»ä¸€ä¸‹ã€‚<br><br>
<br>ä½œä¸ºæ‰‹å†™raftç³»åˆ—åšå®¢çš„ç¬¬ä¸€ç¯‡ï¼Œåœ¨åšå®¢çš„ç¬¬ä¸€ã€äºŒèŠ‚ç®€å•ä»‹ç»äº†raftç®—æ³•å’ŒMyRaftï¼Œç¬¬3èŠ‚åˆ™è¯¦ç»†åˆ†æäº†leaderé€‰ä¸¾çš„å…³é”®ç»†èŠ‚å¹¶åŸºäºæºç è¯¦ç»†åˆ†æäº†MyRaftæ˜¯å¦‚ä½•å®ç°leaderé€‰ä¸¾çš„ã€‚
<br>å•çº¯å®ç°Raftçš„leaderé€‰ä¸¾å¹¶æ²¡æœ‰ä»€ä¹ˆéš¾åº¦ã€‚ä»¥æˆ‘ä¸ªäººçš„å®è·µç»éªŒæ¥è¯´ï¼ŒçœŸæ­£çš„å›°éš¾ä¹‹å¤„åœ¨äºåç»­åŠŸèƒ½çš„å åŠ ã€‚<br>
ç”±äºraftçš„è®ºæ–‡ä¸­ä»‹ç»çš„å‡ ä¸ªæ¨¡å—å½¼æ­¤ä¹‹é—´æ˜¯ç´§å¯†å…³è”çš„ã€‚å› æ­¤åç»­æ—¥å¿—å¤åˆ¶ã€æ—¥å¿—å‹ç¼©ä»¥åŠæˆå‘˜åŠ¨æ€å˜æ›´è¿™å‡ ä¸ªåŠŸèƒ½çš„é€æ­¥å®ç°ä¸­ï¼Œæ¯å®Œæˆä¸€ä¸ªéƒ½ä¼šå¯¹ä¸Šä¸ªç‰ˆæœ¬çš„ä»£ç åœ¨ç»†èŠ‚ä¸Šæœ‰ä¸å°çš„è°ƒæ•´ï¼Œå¤§å¤§å¢åŠ äº†æ•´ä½“çš„å¤æ‚åº¦ã€‚
<br>åšå®¢ä¸­å±•ç¤ºçš„å®Œæ•´ä»£ç åœ¨æˆ‘çš„githubä¸Šï¼š<a rel="noopener" class="external-link" href="https://github.com/1399852153/MyRaft" target="_blank">https://github.com/1399852153/MyRaft</a> (release/lab1_leader_electionåˆ†æ”¯)ï¼Œå¸Œæœ›èƒ½å¸®åŠ©åˆ°å¯¹raftç®—æ³•æ„Ÿå…´è¶£çš„å°ä¼™ä¼´ã€‚<br>
å†…å®¹å¦‚æœ‰é”™è¯¯ï¼Œè¿˜è¯·å¤šå¤šæŒ‡æ•™ã€‚
]]></description><link>https://muqiuhan.github.io/wiki/computer-science/distributed-system/raftå®ç°/raftå®ç°-ä¸€è‡´æ€§ç®—æ³•ä»‹ç».html</link><guid isPermaLink="false">Computer Science/Distributed System/Raftå®ç°/Raftå®ç° - ä¸€è‡´æ€§ç®—æ³•ä»‹ç».md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Thu, 25 Jul 2024 09:23:38 GMT</pubDate><enclosure url="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raftå®ç°/pasted-image-20240725172248.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raftå®ç°/pasted-image-20240725172248.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Raftå®ç° - å®ç°æ—¥å¿—å‹ç¼©]]></title><description><![CDATA[ 
 <br><br>æˆ‘ä»¬çŸ¥é“raftåè®®æ˜¯åŸºäºæ—¥å¿—å¤åˆ¶çš„åè®®ï¼Œæ—¥å¿—æ•°æ®æ˜¯raftçš„æ ¸å¿ƒã€‚ä½†éšç€rafté›†ç¾¤çš„æŒç»­å·¥ä½œï¼Œraftçš„æ—¥å¿—æ–‡ä»¶å°†ä¼šç»´æŠ¤è¶Šæ¥è¶Šå¤šçš„æ—¥å¿—ï¼Œè€Œè¿™ä¼šå¸¦æ¥ä»¥ä¸‹å‡ ä¸ªé—®é¢˜ã€‚<br>
<br>æ—¥å¿—æ–‡ä»¶è¿‡å¤§ä¼šå ç”¨æ‰€åœ¨æœºå™¨è¿‡å¤šçš„æœ¬åœ°ç£ç›˜ç©ºé—´ã€‚
<br>å¯¹äºæ–°åŠ å…¥é›†ç¾¤çš„followerï¼Œleaderä¸è¯¥followerä¹‹é—´å®Œæˆæ—¥å¿—åŒæ­¥ä¼šéå¸¸ç¼“æ…¢ã€‚
<br>å¯¹äºè‡ªèº«ä¸è¿›è¡ŒæŒä¹…åŒ–çš„çŠ¶æ€æœºï¼ŒraftèŠ‚ç‚¹é‡å¯åå›æ”¾æ—¥å¿—ä¹Ÿä¼šéå¸¸ç¼“æ…¢ã€‚
<br>è€ƒè™‘åˆ°ç»å¤§å¤šæ•°çš„çŠ¶æ€æœºä¸­å­˜å‚¨çš„æ•°æ®å¹¶ä¸éƒ½æ˜¯æ–°å¢ï¼Œè€Œæ›´å¤šçš„æ˜¯å¯¹å·²æœ‰æ•°æ®çš„æ›´æ–°ï¼Œåˆ™çŠ¶æ€æœºä¸­æ‰€å­˜å‚¨çš„æ•°æ®é‡é€šå¸¸ä¼šè¿œå°äºraftæ—¥å¿—çš„æ€»å¤§å°ã€‚ä¾‹å¦‚K/Væ•°æ®åº“ï¼Œå¯¹ç›¸åŒkeyçš„Næ¬¡æ“ä½œ(æ•´ä½“æ›´æ–°æ“ä½œ)ï¼Œåªæœ‰æœ€åä¸€æ¬¡æ“ä½œæ˜¯å®é™…æœ‰æ•ˆçš„ï¼Œè€Œåœ¨æ­¤ä¹‹å‰çš„é’ˆå¯¹è¯¥keyçš„raftæ—¥å¿—å…¶å®å·²ç»æ²¡æœ‰ä¿å­˜çš„å¿…è¦äº†ã€‚<br>
å› æ­¤raftçš„ä½œè€…åœ¨è®ºæ–‡çš„æ—¥å¿—å‹ç¼©ä¸€èŠ‚ä¸­æåˆ°äº†å‡ ç§æ—¥å¿—å‹ç¼©çš„ç®—æ³•(åŸºäºå¿«ç…§çš„ã€åŸºäºLSMæ ‘çš„)ï¼Œrafté€‰æ‹©äº†æ›´å®¹æ˜“ç†è§£å’Œå®ç°çš„ã€åŸºäºçŠ¶æ€æœºå¿«ç…§çš„ç®—æ³•ä½œä¸ºæ—¥å¿—å‹ç¼©çš„åŸºç¡€ã€‚<br><br>raftæ—¥å¿—å‹ç¼©å®ç°ä¸­æœ‰ä»¥ä¸‹å‡ ä¸ªå…³é”®ç‚¹ï¼š<br>
<br>raftçš„å„ä¸ªèŠ‚ç‚¹å¯ä»¥æŒ‰ç…§æŸç§ç­–ç•¥ç‹¬ç«‹çš„ç”Ÿæˆå¿«ç…§(æ¯”å¦‚å®šæœŸæ£€æµ‹æ—¥å¿—æ–‡ä»¶å¤§å°æ˜¯å¦è¶…è¿‡é˜ˆå€¼)ï¼Œå¿«ç…§çš„ä¸»è¦å†…å®¹æ˜¯çŠ¶æ€æœºå½“å‰ç¬é—´æ‰€ç»´æŠ¤çš„æ‰€æœ‰æ•°æ®çš„å¿«ç…§ã€‚<br>
MyRaftçš„çŠ¶æ€æœºæ˜¯ä¸€ä¸ªçº¯å†…å­˜çš„K/Væ•°æ®åº“ï¼Œæ‰€ä»¥å¿«ç…§å°±æ˜¯å†…å­˜ä¸­å¯¹åº”Mapæ•°æ®åºåˆ—åŒ–åçš„å†…å®¹ã€‚
<br>å½“å‰çŠ¶æ€æœºä¸­çš„å¿«ç…§å®é™…ä¸Šç­‰åŒäºæ‰€æœ‰å·²æäº¤æ—¥å¿—çš„é¡ºåºæ‰§è¡Œçš„æœ€ç»ˆç»“æœï¼Œå¿«ç…§æ–‡ä»¶ç”Ÿæˆåä¼šå°†æ‰€æœ‰å·²æäº¤çš„æ—¥å¿—å…¨éƒ¨åˆ é™¤ä»¥è¾¾æˆå‹ç¼©çš„ç›®çš„ã€‚<br>
è€Œåœ¨å¤„ç†appendEntriesæ—¶ï¼Œleaderéœ€è¦åœ¨å‚æ•°ä¸­è®¾ç½®å½“å‰ä¼ è¾“æ—¥å¿—çš„å‰ä¸€æ¡æ—¥å¿—çš„indexå’Œtermå€¼ï¼Œå¦‚æœæ­¤æ—¶leaderå‰ä¸€æ¡æ—¥å¿—æ°å¥½æ˜¯å·²æäº¤çš„å¹¶ä¸”è¢«å‹ç¼©åˆ°å¿«ç…§é‡Œè€Œè¢«åˆ é™¤äº†ï¼Œåˆ™è·å–ä¸åˆ°è¿™ä¸ªå€¼äº†ã€‚<br>
ç›¸å¯¹åº”çš„ï¼Œfollowerä¹Ÿå¯èƒ½å‡ºç°ç±»ä¼¼çš„æƒ…å†µï¼Œå³å½“å‰æ‰€æœ‰æ—¥å¿—éƒ½æ˜¯å·²æäº¤çš„å¹¶ä¸”ç”±äºæ—¥å¿—å‹ç¼©è¢«åˆ é™¤äº†ï¼Œè¿›è¡ŒprevIndex/prevTermæ ¡éªŒæ—¶ï¼Œä¹Ÿéœ€è¦è¿™ä¸ªæ•°æ®ã€‚<br>
å› æ­¤ï¼Œæœ€ç»ˆçš„å¿«ç…§ä¸­åŒ…å«äº†æœ€åä¸€æ¡å·²æäº¤æ—¥å¿—çš„indexå’Œtermå€¼è¿™ä¸€å…³é”®çš„å…ƒæ•°æ®ã€‚
<br>åœ¨leaderå’Œæ—¥å¿—è¿›åº¦è¾ƒæ…¢çš„followerè¿›è¡Œé€šä¿¡æ—¶ï¼Œå¦‚æœfolloweræ‰€éœ€è¦çš„æ—¥å¿—æ˜¯å¾ˆæ—©çš„ï¼Œè€Œleaderè¿™è¾¹å¯¹åº”indexçš„æ—¥å¿—åˆè¢«å¿«ç…§å‹ç¼©è€Œåˆ é™¤äº†ï¼Œæ²¡æ³•é€šè¿‡appendEntriesè¿›è¡ŒåŒæ­¥ã€‚<br>
raftå¯¹æ­¤æ–°å¢åŠ äº†ä¸€ä¸ªrpcæ¥å£installSnapshotä¸“é—¨ç”¨äºè§£å†³è¿™ä¸ªé—®é¢˜ã€‚åœ¨leaderå‘ç°followeræ‰€éœ€çš„æ—¥å¿—å·²ç»è¢«è‡ªå·±å‹ç¼©åˆ°å¿«ç…§é‡Œæ—¶ï¼Œåˆ™ä¼šé€šè¿‡installSnapshotå°†è‡ªå·±å®Œæ•´çš„å¿«ç…§ç›´æ¥å¤åˆ¶ç»™followerã€‚<br>
ç”±äºå¿«ç…§å¯èƒ½å¾ˆå¤§ï¼Œæ‰€ä»¥installSnapshotä¸€æ¬¡åªä¼šä¼ è¾“å°‘é‡çš„æ—¥å¿—ï¼Œé€šè¿‡å¤šæ¬¡çš„äº¤äº’åå®Œæˆæ•´ä¸ªå¿«ç…§çš„å®‰è£…ã€‚å½“followerä¾§å®Œæˆäº†å¿«ç…§åŒæ­¥åï¼Œåç»­æ‰€éœ€è¦åŒæ­¥çš„æ—¥å¿—å°±éƒ½æ˜¯leaderæ—¥å¿—æ–‡ä»¶ä¸­è¿˜ä¿ç•™çš„ï¼Œåç»­çš„æ—¥å¿—æ¥ç€ä½¿ç”¨appendEntriesåŒæ­¥å³å¯ã€‚
<br>ä¸‹é¢å¼€å§‹ç»“åˆæºç åˆ†æMyRaftçš„æ—¥å¿—å‹ç¼©åŠŸèƒ½<br><br>
<br>raftå¿«ç…§æ•°æ®ç”±RaftSnapshotå¯¹è±¡æ‰¿è½½ï¼Œé™¤äº†äºŒè¿›åˆ¶çš„çŠ¶æ€æœºçŠ¶æ€æ•°æ®å¤–ï¼Œè¿˜åŒ…æ‹¬äº†å¿«ç…§æœ€åä¸€æ¡æ—¥å¿—çš„indexå’Œtermçš„å€¼ã€‚
<br>MyRaftå…³äºå¿«ç…§æ•°æ®è¯»å†™çš„é€»è¾‘é›†ä¸­ç»´æŠ¤åœ¨SnapshotModuleä¸­ï¼Œç®€å•èµ·è§ä½¿ç”¨ä¸€æŠŠå…¨å±€çš„è¯»å†™é”æ¥é˜²æ­¢å¹¶å‘è€Œä¸è¿‡å¤šçš„è€ƒè™‘æ€§èƒ½ã€‚<br>
åœ¨SnapshotModuleä¸­é€šè¿‡å¼•å…¥ä¸´æ—¶æ–‡ä»¶çš„æ–¹å¼æ¥è§£å†³æ–°å¿«ç…§æ–‡ä»¶åœ¨ç”Ÿæˆè¿‡ç¨‹ä¸­å¯èƒ½çªç„¶å®•æœºçš„é—®é¢˜ã€‚
<br>/**
 * raftå¿«ç…§å¯¹è±¡
 * */
public class RaftSnapshot {

    /**
     * å¿«ç…§æ‰€åŒ…å«çš„æœ€åä¸€æ¡logçš„ç´¢å¼•ç¼–å·
     * */
    private long lastIncludedIndex;

    /**
     * å¿«ç…§æ‰€åŒ…å«çš„æœ€åä¸€æ¡logçš„ä»»æœŸç¼–å·
     * */
    private int lastIncludedTerm;

    /**
     * å¿«ç…§æ•°æ®
     * (æ³¨æ„ï¼šæš‚ä¸è€ƒè™‘å¿«ç…§è¿‡å¤§å¯¼è‡´byteæ•°ç»„æ”¾ä¸ä¸‹çš„æƒ…å†µ)
     * */
    private byte[] snapshotData = new byte[0];
}
Copy<br><img alt="Pasted image 20240725172559.png" src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raftå®ç°/pasted-image-20240725172559.png"><br>public class SnapshotModule {
    private static final Logger logger = LoggerFactory.getLogger(SnapshotModule.class);

    private final RaftServer currentServer;

    private final File snapshotFile;

    private final ReentrantReadWriteLock reentrantLock = new ReentrantReadWriteLock();
    private final ReentrantReadWriteLock.WriteLock writeLock = reentrantLock.writeLock();
    private final ReentrantReadWriteLock.ReadLock readLock = reentrantLock.readLock();

    private static final String snapshotFileName = "snapshot.txt";
    private static final String snapshotTempFileName = "snapshot-temp.txt";

    /**
     * å­˜æ”¾å¿«ç…§å®é™…æ•°æ®çš„åç§»é‡(lastIncludedIndex + lastIncludedTerm å…±ä¸¤ä¸ªå­—æ®µåå­˜æ”¾å¿«ç…§)
     * */
    private static final int actualDataOffset = 4 + 8;

    public SnapshotModule(RaftServer currentServer) {
        this.currentServer = currentServer;

        // ä¿è¯ç›®å½•æ˜¯å­˜åœ¨çš„
        String snapshotFileDir = getSnapshotFileDir();
        new File(snapshotFileDir).mkdirs();

        snapshotFile = new File(snapshotFileDir + File.separator + snapshotFileName);

        File snapshotTempFile = new File(snapshotFileDir + File.separator + snapshotTempFileName);

        if(!snapshotFile.exists() &amp;&amp; snapshotTempFile.exists()){
            // å¿«ç…§æ–‡ä»¶ä¸å­˜åœ¨ï¼Œä½†æ˜¯å¿«ç…§çš„ä¸´æ—¶æ–‡ä»¶å­˜åœ¨ã€‚è¯´æ˜åœ¨å†™å®Œä¸´æ—¶æ–‡ä»¶å¹¶é‡å‘½åä¹‹å‰å®•æœºäº†(ä¸´æ—¶æ–‡ä»¶æ˜¯æœ€æ–°çš„å®Œæ•´å¿«ç…§)

            // å°†tempFileé‡å‘½åä¸ºå¿«ç…§æ–‡ä»¶
            snapshotTempFile.renameTo(snapshotFile);

            logger.info("snapshot-temp file rename to snapshot file success!");
        }
    }

    /**
     * æŒä¹…åŒ–ä¸€ä¸ªæ–°çš„å¿«ç…§æ–‡ä»¶
     * (æš‚ä¸è€ƒè™‘å¿«ç…§å¤ªå¤§çš„é—®é¢˜)
     * */
    public void persistentNewSnapshotFile(RaftSnapshot raftSnapshot){
        logger.info("do persistentNewSnapshotFile raftSnapshot={}",raftSnapshot);
        writeLock.lock();

        try {
            String userPath = getSnapshotFileDir();

            // æ–°çš„æ–‡ä»¶åæ˜¯tempFile
            String newSnapshotFilePath = userPath + File.separator + snapshotTempFileName;
            logger.info("do persistentNewSnapshotFile newSnapshotFilePath={}", newSnapshotFilePath);

            File snapshotTempFile = new File(newSnapshotFilePath);
            try (RandomAccessFile newSnapshotFile = new RandomAccessFile(snapshotTempFile, "rw")) {
                MyRaftFileUtil.createFile(snapshotTempFile);

                newSnapshotFile.writeInt(raftSnapshot.getLastIncludedTerm());
                newSnapshotFile.writeLong(raftSnapshot.getLastIncludedIndex());
                newSnapshotFile.write(raftSnapshot.getSnapshotData());

                logger.info("do persistentNewSnapshotFile success! raftSnapshot={}", raftSnapshot);
            } catch (IOException e) {
                throw new MyRaftException("persistentNewSnapshotFile error", e);
            }

            // å…ˆåˆ æ‰åŸæ¥çš„å¿«ç…§æ–‡ä»¶ï¼Œç„¶åæŠŠä¸´æ—¶æ–‡ä»¶é‡ååä¸ºå¿«ç…§æ–‡ä»¶(deleteåã€é‡å‘½åå‰å¯èƒ½å®•æœºï¼Œä½†æ˜¯æ²¡å…³ç³»ï¼Œé‡å¯åæ„é€ æ–¹æ³•é‡Œåšäº†å¯¹åº”å¤„ç†)
            snapshotFile.delete();
            snapshotTempFile.renameTo(snapshotFile);
        }finally {
            writeLock.unlock();
        }
    }

    /**
     * å®‰è£…å¿«ç…§
     * */
    public void appendInstallSnapshot(InstallSnapshotRpcParam installSnapshotRpcParam){
        logger.info("do appendInstallSnapshot installSnapshotRpcParam={}",installSnapshotRpcParam);
        writeLock.lock();

        String userPath = getSnapshotFileDir();

        // æ–°çš„æ–‡ä»¶åæ˜¯tempFile
        String newSnapshotFilePath = userPath + File.separator + snapshotTempFileName;
        logger.info("do appendInstallSnapshot newSnapshotFilePath={}", newSnapshotFilePath);

        File snapshotTempFile = new File(newSnapshotFilePath);
        try (RandomAccessFile newSnapshotFile = new RandomAccessFile(snapshotTempFile, "rw")) {
            MyRaftFileUtil.createFile(snapshotTempFile);

            if(installSnapshotRpcParam.getOffset() == 0){
                newSnapshotFile.setLength(0);
            }

            newSnapshotFile.seek(0);
            newSnapshotFile.writeInt(installSnapshotRpcParam.getLastIncludedTerm());
            newSnapshotFile.writeLong(installSnapshotRpcParam.getLastIncludedIndex());

            // æ–‡ä»¶æŒ‡é’ˆåç§»ï¼Œæ‰¾åˆ°å®é™…åº”è¯¥å†™å…¥å¿«ç…§æ•°æ®çš„åœ°æ–¹
            newSnapshotFile.seek(actualDataOffset + installSnapshotRpcParam.getOffset());
            // å†™å…¥å¿«ç…§æ•°æ®
            newSnapshotFile.write(installSnapshotRpcParam.getData());

            logger.info("do appendInstallSnapshot success! installSnapshotRpcParam={}", installSnapshotRpcParam);
        } catch (IOException e) {
            throw new MyRaftException("appendInstallSnapshot error", e);
        } finally {
            writeLock.unlock();
        }

        if(installSnapshotRpcParam.isDone()) {
            writeLock.lock();
            try {
                // å…ˆåˆ æ‰åŸæ¥çš„å¿«ç…§æ–‡ä»¶ï¼Œç„¶åæŠŠä¸´æ—¶æ–‡ä»¶é‡ååä¸ºå¿«ç…§æ–‡ä»¶(deleteåã€é‡å‘½åå‰å¯èƒ½å®•æœºï¼Œä½†æ˜¯æ²¡å…³ç³»ï¼Œé‡å¯åæ„é€ æ–¹æ³•é‡Œåšäº†å¯¹åº”å¤„ç†)
                snapshotFile.delete();
                snapshotTempFile.renameTo(snapshotFile);
            } finally {
                writeLock.unlock();
            }
        }
    }

    /**
     * æ²¡æœ‰å®é™…å¿«ç…§æ•°æ®ï¼Œåªæœ‰å…ƒæ•°æ®
     * */
    public RaftSnapshot readSnapshotMetaData(){
        if(this.snapshotFile.length() == 0){
            return null;
        }

        readLock.lock();

        try(RandomAccessFile latestSnapshotRaFile = new RandomAccessFile(this.snapshotFile, "r")) {
            RaftSnapshot raftSnapshot = new RaftSnapshot();
            raftSnapshot.setLastIncludedTerm(latestSnapshotRaFile.readInt());
            raftSnapshot.setLastIncludedIndex(latestSnapshotRaFile.readLong());

            return raftSnapshot;
        } catch (IOException e) {
            throw new MyRaftException("readSnapshotNoData error",e);
        } finally {
            readLock.unlock();
        }
    }

    public RaftSnapshot readSnapshot(){
        logger.info("do readSnapshot");

        if(this.snapshotFile.length() == 0){
            logger.info("snapshotFile is empty!");
            return null;
        }

        readLock.lock();

        try(RandomAccessFile latestSnapshotRaFile = new RandomAccessFile(this.snapshotFile, "r")) {
            logger.info("do readSnapshot");

            RaftSnapshot latestSnapshot = new RaftSnapshot();
            latestSnapshot.setLastIncludedTerm(latestSnapshotRaFile.readInt());
            latestSnapshot.setLastIncludedIndex(latestSnapshotRaFile.readLong());

            // è¯»å–snapshotçš„å®é™…æ•°æ®(ç®€å•èµ·è§ï¼Œæš‚ä¸è€ƒè™‘å¿«ç…§å¤ªå¤§å†…å­˜æº¢å‡ºçš„é—®é¢˜ï¼Œå¯ä»¥ä¼˜åŒ–ä¸ºæŒ‰ç…§åç§»é‡å¤šæ¬¡è¯»å–)
            byte[] snapshotData = new byte[(int) (this.snapshotFile.length() - actualDataOffset)];
            latestSnapshotRaFile.read(snapshotData);
            latestSnapshot.setSnapshotData(snapshotData);

            logger.info("readSnapshot success! readSnapshot={}",latestSnapshot);
            return latestSnapshot;
        } catch (IOException e) {
            throw new MyRaftException("readSnapshot error",e);
        } finally {
            readLock.unlock();
        }
    }

    private String getSnapshotFileDir(){
        return System.getProperty("user.dir")
            + File.separator + currentServer.getServerId()
            + File.separator + "snapshot";
    }
}
Copy<br><br>
<br>ç›¸æ¯”lab2ï¼Œlab3ä¸­MyRaftçš„æ—¥å¿—æ¨¡å—æ–°å¢åŠ äº†ä¸€ä¸ªå®šæ—¶ä»»åŠ¡ï¼Œç”¨äºæ£€æŸ¥å½“å‰æ—¥å¿—æ–‡ä»¶çš„å¤§å°æ˜¯å¦è¶…è¿‡äº†æŒ‡å®šçš„é˜ˆå€¼ï¼Œå¦‚æœè¶…è¿‡äº†é˜ˆå€¼åˆ™ä¼šè§¦å‘ç”Ÿæˆæ–°æ—¥å¿—å¿«ç…§çš„é€»è¾‘ã€‚<br>
å’Œå¿«ç…§æ¨¡å—ç±»ä¼¼ï¼Œè€ƒè™‘åˆ°æ—¥å¿—æ–‡ä»¶å‹ç¼©æ—¶å¯èƒ½å®•æœºçš„é—®é¢˜ï¼ŒåŒæ ·é‡‡ç”¨å¼•å…¥ä¸´æ—¶æ–‡ä»¶çš„æ–¹æ³•è§£å†³ã€‚
<br>ç”Ÿæˆå¿«ç…§çš„é€»è¾‘é‡Œå…ˆå°†æ–°çš„å¿«ç…§é€šè¿‡SnapshotModuleæŒä¹…åŒ–ï¼Œç„¶åå°†å½“å‰å·²æäº¤çš„æ—¥å¿—ä»æ—¥å¿—æ–‡ä»¶ä¸­åˆ é™¤æ‰ã€‚<br>
æ—¥å¿—æ–‡ä»¶æ˜¯ä»å‰å†™åˆ°åçš„ï¼Œç›´æ¥æ“ä½œåŸæ—¥å¿—æ–‡ä»¶ä¼šæ¯”è¾ƒéº»çƒ¦å’Œå±é™©ã€‚å› æ­¤MyRaftå°†æ‰€æœ‰æœªæäº¤çš„æ—¥å¿—å†™å…¥ä¸€ä¸ªæ–°çš„ä¸´æ—¶æ—¥å¿—æ–‡ä»¶åï¼Œå†é€šè¿‡ä¸€æ¬¡æ–‡ä»¶åçš„åˆ‡æ¢å®ç°å¯¹å·²æäº¤æ—¥å¿—çš„åˆ é™¤ã€‚
<br>   /**
   * æ„å»ºå¿«ç…§çš„æ£€æŸ¥
   * */
    private void buildSnapshotCheck() {
        try {
            if(!readLock.tryLock(1,TimeUnit.SECONDS)){
                logger.info("buildSnapshotCheck lock fail, quick return!");
                return;
            }
        } catch (InterruptedException e) {
            throw new MyRaftException("buildSnapshotCheck tryLock error!",e);
        }

        try {
            long logFileLength = this.logFile.length();
            long logFileThreshold = currentServer.getRaftConfig().getLogFileThreshold();
            if (logFileLength &lt; logFileThreshold) {
                logger.info("logFileLength not reach threshold, do nothing. logFileLength={},threshold={}", logFileLength, logFileThreshold);
                return;
            }

            logger.info("logFileLength already reach threshold, start buildSnapshot! logFileLength={},threshold={}", logFileLength, logFileThreshold);

            byte[] snapshot = currentServer.getKvReplicationStateMachine().buildSnapshot();
            LogEntry lastCommittedLogEntry = readLocalLog(this.lastCommittedIndex);

            RaftSnapshot raftSnapshot = new RaftSnapshot();
            raftSnapshot.setLastIncludedTerm(lastCommittedLogEntry.getLogTerm());
            raftSnapshot.setLastIncludedIndex(lastCommittedLogEntry.getLogIndex());
            raftSnapshot.setSnapshotData(snapshot);

            // æŒä¹…åŒ–æœ€æ–°çš„ä¸€ä»½å¿«ç…§
            currentServer.getSnapshotModule().persistentNewSnapshotFile(raftSnapshot);
        }finally {
            readLock.unlock();
        }

        try {
            buildNewLogFileRemoveCommittedLog();
        } catch (IOException e) {
            logger.error("buildNewLogFileRemoveCommittedLog error",e);
        }
    }
Copy<br>   /**
     * æ„å»ºä¸€ä¸ªåˆ é™¤äº†å·²æäº¤æ—¥å¿—çš„æ–°æ—¥å¿—æ–‡ä»¶(æ—¥å¿—å‹ç¼©åˆ°å¿«ç…§é‡Œäº†)
     * */
    private void buildNewLogFileRemoveCommittedLog() throws IOException {
        long lastCommitted = getLastCommittedIndex();
        long lastIndex = getLastIndex();

        // æš‚ä¸è€ƒè™‘è¯»å–å¤ªå¤šæ—¥å¿—é€ æˆå†…å­˜æº¢å‡ºçš„é—®é¢˜
        List&lt;LocalLogEntry&gt; logEntryList;
        if(lastCommitted == lastIndex){
            // (lastCommitted == lastIndex) æ‰€æœ‰æ—¥å¿—éƒ½æäº¤äº†ï¼Œåˆ›å»ºä¸€ä¸ªç©ºçš„æ–°æ—¥å¿—æ–‡ä»¶
            logEntryList = new ArrayList&lt;&gt;();
        }else{
            // è¿˜æœ‰æ—¥å¿—æ²¡æäº¤ï¼ŒæŠŠæ²¡æäº¤çš„è®°å½•åˆ°æ–°çš„æ—¥å¿—æ–‡ä»¶ä¸­
            logEntryList = readLocalLog(lastCommitted+1,lastIndex);
        }

        File tempLogFile = new File(getLogFileDir() + File.separator + logTempFileName);
        MyRaftFileUtil.createFile(tempLogFile);
        try(RandomAccessFile randomAccessTempLogFile = new RandomAccessFile(tempLogFile,"rw")) {

            long currentOffset = 0;
            for (LogEntry logEntry : logEntryList) {
                // å†™å…¥æ—¥å¿—
                writeLog(randomAccessTempLogFile, logEntry, currentOffset);

                currentOffset = randomAccessTempLogFile.getFilePointer();
            }

            this.currentOffset = currentOffset;
        }

        File tempLogMeteDataFile = new File(getLogFileDir() + File.separator + logMetaDataTempFileName);
        MyRaftFileUtil.createFile(tempLogMeteDataFile);

        // ä¸´æ—¶çš„æ—¥å¿—å…ƒæ•°æ®æ–‡ä»¶å†™å…¥æ•°æ®
        refreshMetadata(tempLogMeteDataFile,currentOffset);

        writeLock.lock();
        try{
            // å…ˆåˆ æ‰åŸæ¥çš„æ—¥å¿—æ–‡ä»¶ï¼Œç„¶åæŠŠä¸´æ—¶æ–‡ä»¶é‡ååä¸ºæ—¥å¿—æ–‡ä»¶(deleteåã€é‡å‘½åå‰å¯èƒ½å®•æœºï¼Œä½†æ˜¯æ²¡å…³ç³»ï¼Œé‡å¯åæ„é€ æ–¹æ³•é‡Œåšäº†å¯¹åº”å¤„ç†)
            this.logFile.delete();
            boolean renameLogFileResult = tempLogFile.renameTo(this.logFile);
            if(!renameLogFileResult){
                logger.error("renameLogFile error!");
            }

            // å…ˆåˆ æ‰åŸæ¥çš„æ—¥å¿—å…ƒæ•°æ®æ–‡ä»¶ï¼Œç„¶åæŠŠä¸´æ—¶æ–‡ä»¶é‡ååä¸ºæ—¥å¿—å…ƒæ•°æ®æ–‡ä»¶(deleteåã€é‡å‘½åå‰å¯èƒ½å®•æœºï¼Œä½†æ˜¯æ²¡å…³ç³»ï¼Œé‡å¯åæ„é€ æ–¹æ³•é‡Œåšäº†å¯¹åº”å¤„ç†)
            this.logMetaDataFile.delete();
            boolean renameTempLogMeteDataFileResult = tempLogMeteDataFile.renameTo(this.logMetaDataFile);
            if(!renameTempLogMeteDataFileResult){
                logger.error("renameTempLogMeteDataFile error!");
            }
        }finally {
            writeLock.unlock();
        }
    }
Copy<br><br><br>ç›¸æ¯”lab2ï¼Œåœ¨å¼•å…¥äº†å¿«ç…§å‹ç¼©åŠŸèƒ½åï¼Œleaderä¾§çš„æ—¥å¿—å¤åˆ¶é€»è¾‘éœ€è¦è¿›è¡Œä¸€ç‚¹å°å°çš„æ‹“å±•ã€‚<br>
å³å½“è¦å‘followeråŒæ­¥æŸä¸€æ¡æ—¥å¿—æ—¶ï¼Œå¯¹åº”æ—¥å¿—å¯èƒ½å·²ç»è¢«å‹ç¼©æ‰äº†ï¼Œå› æ­¤æ­¤æ—¶éœ€è¦æ”¹ä¸ºä½¿ç”¨installSnapshotRpcæ¥å®Œæˆå¿«ç…§çš„å®‰è£…ã€‚<br><img alt="Pasted image 20240725172616.png" src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raftå®ç°/pasted-image-20240725172616.png"><br>   /**
     * leaderå‘é›†ç¾¤å¹¿æ’­ï¼Œä»¤followerå¤åˆ¶æ–°çš„æ—¥å¿—æ¡ç›®
     * */
    public List&lt;AppendEntriesRpcResult&gt; replicationLogEntry(LogEntry lastEntry) {
        List&lt;RaftService&gt; otherNodeInCluster = currentServer.getOtherNodeInCluster();

        List&lt;Future&lt;AppendEntriesRpcResult&gt;&gt; futureList = new ArrayList&lt;&gt;(otherNodeInCluster.size());

        for(RaftService node : otherNodeInCluster){
            // å¹¶è¡Œå‘é€rpcï¼Œè¦æ±‚followerå¤åˆ¶æ—¥å¿—
            Future&lt;AppendEntriesRpcResult&gt; future = this.rpcThreadPool.submit(()-&gt;{
                logger.info("replicationLogEntry start!");

                long nextIndex = this.currentServer.getNextIndexMap().get(node);

                AppendEntriesRpcResult finallyResult = null;

                // If last log index â‰¥ nextIndex for a follower: send AppendEntries RPC with log entries starting at nextIndex
                while(lastEntry.getLogIndex() &gt;= nextIndex){
                    AppendEntriesRpcParam appendEntriesRpcParam = new AppendEntriesRpcParam();
                    appendEntriesRpcParam.setLeaderId(currentServer.getServerId());
                    appendEntriesRpcParam.setTerm(currentServer.getCurrentTerm());
                    appendEntriesRpcParam.setLeaderCommit(this.lastCommittedIndex);

                    int appendLogEntryBatchNum = this.currentServer.getRaftConfig().getAppendLogEntryBatchNum();

                    // è¦å‘é€çš„æ—¥å¿—æœ€å¤§indexå€¼
                    // (è¿½è¿›åº¦çš„æ—¶å€™ï¼Œå°±æ˜¯nextIndexå¼€å§‹æ‰¹é‡å‘é€appendLogEntryBatchNum-1æ¡(å·¦é—­å³é—­åŒºé—´)ï¼›å¦‚æœè¿›åº¦å·®ä¸å¤šé‚£å°±æ˜¯ä»¥lastEntry.indexä¸ºç•Œé™å…¨éƒ¨å‘é€å‡ºå»)
                    long logIndexEnd = Math.min(nextIndex+(appendLogEntryBatchNum-1), lastEntry.getLogIndex());
                    // è¯»å–å‡º[nextIndex-1,logIndexEnd]çš„æ—¥å¿—(å·¦é—­å³é—­åŒºé—´),-1å¾€å‰ä¸€ä½æ˜¯ä¸ºäº†è¯»å–å‡ºpreLogçš„ä¿¡æ¯
                    List&lt;LocalLogEntry&gt; localLogEntryList = this.readLocalLog(nextIndex-1,logIndexEnd);

                    logger.info("replicationLogEntry doing! nextIndex={},logIndexEnd={},LocalLogEntryList={}",
                        nextIndex,logIndexEnd,JsonUtil.obj2Str(localLogEntryList));

                    List&lt;LogEntry&gt; logEntryList = localLogEntryList.stream()
                        .map(LogEntry::toLogEntry)
                        .collect(Collectors.toList());

                    // ç´¢å¼•åŒºé—´å¤§å°
                    long indexRange = (logIndexEnd - nextIndex + 1);

                    // å‡è®¾ç´¢å¼•åŒºé—´å¤§å°ä¸ºNï¼Œå¯èƒ½æœ‰ä¸‰ç§æƒ…å†µ
                    // 1. æŸ¥å‡ºNæ¡æ—¥å¿—ï¼Œæ‰€éœ€è¦çš„æ—¥å¿—å…¨éƒ½åœ¨æœ¬åœ°æ—¥å¿—æ–‡ä»¶é‡Œæ²¡æœ‰è¢«å‹ç¼©
                    // 2. æŸ¥å‡º1è‡³N-1æ¡æ—¥å¿—ï¼Œéƒ¨åˆ†æ—¥å¿—è¢«å‹ç¼©åˆ°å¿«ç…§é‡Œ or å°±æ˜¯åªæœ‰é‚£ä¹ˆå¤šæ—¥å¿—(ä¸€æ¬¡æ‰¹é‡æŸ¥5æ¡ï¼Œä½†å½“å‰æ€»å…±åªå†™å…¥äº†3æ¡)
                    // 3. æŸ¥å‡º0æ¡æ—¥å¿—ï¼Œéœ€è¦çš„æ—¥å¿—å…¨éƒ¨è¢«å‹ç¼©äº†(å› ä¸ºæ˜¯å…ˆè½ç›˜å†å¹¿æ’­ï¼Œå¦‚æœæ—¢æ²¡æœ‰æ—¥å¿—ä¹Ÿæ²¡æœ‰å¿«ç…§é‚£å°±æ˜¯æœ‰bug)
                    if(logEntryList.size() == indexRange+1){
                        // æŸ¥å‡ºäº†åŒºé—´å†…çš„æ‰€æœ‰æ—¥å¿—(case 1)

                        logger.info("find log size match!");
                        // preLog
                        LogEntry preLogEntry = logEntryList.get(0);
                        // å®é™…éœ€è¦ä¼ è¾“çš„log
                        List&lt;LogEntry&gt; needAppendLogList = logEntryList.subList(1,logEntryList.size());
                        appendEntriesRpcParam.setEntries(needAppendLogList);
                        appendEntriesRpcParam.setPrevLogIndex(preLogEntry.getLogIndex());
                        appendEntriesRpcParam.setPrevLogTerm(preLogEntry.getLogTerm());
                    }else if(logEntryList.size() &gt; 0 &amp;&amp; logEntryList.size() &lt;= indexRange){
                        // æŸ¥å‡ºäº†éƒ¨åˆ†æ—¥å¿—(case 2)
                        // æ–°å¢æ—¥å¿—å‹ç¼©åŠŸèƒ½åï¼ŒæŸ¥å‡ºæ¥çš„æ•°æ®ä¸ªæ•°å°äºæŒ‡å®šçš„åŒºé—´ä¸ä¸€å®šå°±æ˜¯æŸ¥åˆ°ç¬¬ä¸€æ¡æ•°æ®ï¼Œè¿˜æœ‰å¯èƒ½æ˜¯æ—¥å¿—è¢«å‹ç¼©äº†

                        logger.info("find log size not match!");

                        RaftSnapshot readSnapshotNoData = currentServer.getSnapshotModule().readSnapshotMetaData();
                        if(readSnapshotNoData != null){
                            logger.info("has snapshot! readSnapshotNoData={}",readSnapshotNoData);

                            // å­˜åœ¨å¿«ç…§ï¼Œä½¿ç”¨å¿«ç…§é‡Œä¿å­˜çš„ä¸Šä¸€æ¡æ—¥å¿—ä¿¡æ¯
                            appendEntriesRpcParam.setPrevLogIndex(readSnapshotNoData.getLastIncludedIndex());
                            appendEntriesRpcParam.setPrevLogTerm(readSnapshotNoData.getLastIncludedTerm());
                        }else{
                            logger.info("no snapshot! prevLogIndex=-1, prevLogTerm=-1");

                            // æ²¡æœ‰å¿«ç…§ï¼Œè¯´æ˜æ°å¥½å‘é€ç¬¬ä¸€æ¡æ—¥å¿—è®°å½•(æ¯”å¦‚appendLogEntryBatchNum=5ï¼Œä½†ä¸€å…±åªæœ‰3æ¡æ—¥å¿—å…¨æŸ¥å‡ºæ¥äº†)
                            // ç¬¬ä¸€æ¡è®°å½•çš„prevçš„indexå’Œterméƒ½æ˜¯-1
                            appendEntriesRpcParam.setPrevLogIndex(-1);
                            appendEntriesRpcParam.setPrevLogTerm(-1);
                        }

                        appendEntriesRpcParam.setEntries(logEntryList);
                    } else if(logEntryList.isEmpty()){
                        // æ—¥å¿—å‹ç¼©æŠŠè¦åŒæ­¥çš„æ—¥å¿—åˆ é™¤æ‰äº†ï¼Œåªèƒ½ä½¿ç”¨installSnapshotRpcäº†(case 3)
                        logger.info("can not find and log entryï¼Œmaybe delete for log compress");
                        // å¿«ç…§å‹ç¼©å¯¼è‡´leaderæ›´æ—©çš„indexæ—¥å¿—å·²ç»ä¸å­˜åœ¨äº†

                        // åº”è¯¥æ”¹ä¸ºä½¿ç”¨installSnapshotæ¥åŒæ­¥è¿›åº¦
                        RaftSnapshot raftSnapshot = currentServer.getSnapshotModule().readSnapshot();
                        doInstallSnapshotRpc(node,raftSnapshot,currentServer);

                        // èµ°åˆ°è¿™é‡Œï¼Œä¸€èˆ¬æ˜¯æˆåŠŸçš„å®Œæˆäº†å¿«ç…§çš„å®‰è£…ã€‚ç›®æ ‡followerç›®å‰å·²ç»æœ‰äº†åŒ…æ‹¬lastIncludedIndexä»¥åŠä¹‹å‰çš„æ‰€æœ‰æ—¥å¿—
                        // å¦‚æœæ˜¯å› ä¸ºæˆä¸ºfollowerå¿«é€Ÿè¿”å›ï¼Œåˆ™å†å¾ªç¯ä¸€æ¬¡å°±ç»“æŸäº†
                        nextIndex = raftSnapshot.getLastIncludedIndex() + 1;
                        continue;
                    } else{
                        // èµ°åˆ°è¿™é‡Œä¸ç¬¦åˆé¢„æœŸï¼Œæ—¥å¿—æ¨¡å—æœ‰bug
                        throw new MyRaftException("replicationLogEntry logEntryList size error!" +
                            " nextIndex=" + nextIndex + " logEntryList.size=" + logEntryList.size());
                    }

                    logger.info("leader do appendEntries start, node={}, appendEntriesRpcParam={}",node,appendEntriesRpcParam);
                    AppendEntriesRpcResult appendEntriesRpcResult = node.appendEntries(appendEntriesRpcParam);
                    logger.info("leader do appendEntries end, node={}, appendEntriesRpcResult={}",node,appendEntriesRpcResult);

                    finallyResult = appendEntriesRpcResult;
                    // æ”¶åˆ°æ›´é«˜ä»»æœŸçš„å¤„ç†
                    boolean beFollower = currentServer.processCommunicationHigherTerm(appendEntriesRpcResult.getTerm());
                    if(beFollower){
                        return appendEntriesRpcResult;
                    }

                    if(appendEntriesRpcResult.isSuccess()){
                        logger.info("appendEntriesRpcResult is success, node={}",node);

                        // If successful: update nextIndex and matchIndex for follower (Â§5.3)

                        // åŒæ­¥æˆåŠŸäº†ï¼ŒnextIndexé€’å¢ä¸€ä½
                        this.currentServer.getNextIndexMap().put(node,nextIndex+1);
                        this.currentServer.getMatchIndexMap().put(node,nextIndex);

                        nextIndex++;
                    }else{
                        // å› ä¸ºæ—¥å¿—å¯¹ä¸ä¸Šå¯¼è‡´ä¸€è‡´æ€§æ£€æŸ¥æ²¡é€šè¿‡ï¼ŒåŒæ­¥æ²¡æˆåŠŸï¼ŒnextIndexå¾€åé€€ä¸€ä½

                        logger.info("appendEntriesRpcResult is false, node={}",node);

                        // If AppendEntries fails because of log inconsistency: decrement nextIndex and retry (Â§5.3)
                        nextIndex--;
                        this.currentServer.getNextIndexMap().put(node,nextIndex);
                    }
                }

                if(finallyResult == null){
                    // è¯´æ˜æœ‰bug
                    throw new MyRaftException("replicationLogEntry finallyResult is null!");
                }

                logger.info("finallyResult={},node={}",node,finallyResult);

                return finallyResult;
            });

            futureList.add(future);
        }

        // è·å¾—ç»“æœ
        List&lt;AppendEntriesRpcResult&gt; appendEntriesRpcResultList = CommonUtil.concurrentGetRpcFutureResult(
                "do appendEntries", futureList,
                this.rpcThreadPool,2, TimeUnit.SECONDS);

        logger.info("leader replicationLogEntry appendEntriesRpcResultList={}",appendEntriesRpcResultList);

        return appendEntriesRpcResultList;
    }
Copy<br><br>å‰é¢æåˆ°ï¼Œfollowerä¾§åœ¨è¿›è¡Œæ—¥å¿—ä¸€è‡´æ€§æ ¡éªŒæ—¶ï¼Œä¹Ÿå¯èƒ½å‡ºç°æ°å¥½å‰ä¸€æ¡æ—¥å¿—è¢«å‹ç¼©åˆ°å¿«ç…§é‡Œçš„æƒ…å†µã€‚<br>
å› æ­¤éœ€è¦åœ¨å½“å‰æ—¥å¿—ä¸å­˜åœ¨æ—¶ï¼Œå°è¯•é€šè¿‡SnapshotModuleè¯»å–å¿«ç…§æ•°æ®ä¸­çš„å‰ä¸€æ¡æ—¥å¿—ä¿¡æ¯æ¥è¿›è¡Œæ¯”å¯¹ã€‚<br>    public AppendEntriesRpcResult appendEntries(AppendEntriesRpcParam appendEntriesRpcParam) {
        if(appendEntriesRpcParam.getTerm() &lt; this.raftServerMetaDataPersistentModule.getCurrentTerm()){
            // Reply false if term &lt; currentTerm (Â§5.1)
            // æ‹’ç»å¤„ç†ä»»æœŸä½äºè‡ªå·±çš„è€leaderçš„è¯·æ±‚

            logger.info("doAppendEntries term &lt; currentTerm");
            return new AppendEntriesRpcResult(this.raftServerMetaDataPersistentModule.getCurrentTerm(),false);
        }

        if(appendEntriesRpcParam.getTerm() &gt;= this.raftServerMetaDataPersistentModule.getCurrentTerm()){
            // appendEntriesè¯·æ±‚ä¸­ä»»æœŸå€¼å¦‚æœå¤§äºè‡ªå·±ï¼Œè¯´æ˜å·²ç»æœ‰ä¸€ä¸ªæ›´æ–°çš„leaderäº†ï¼Œè‡ªå·±è½¬ä¸ºfollowerï¼Œå¹¶ä¸”ä»¥å¯¹æ–¹æ›´å¤§çš„ä»»æœŸä¸ºå‡†
            this.serverStatusEnum = ServerStatusEnum.FOLLOWER;
            this.currentLeader = appendEntriesRpcParam.getLeaderId();
            this.raftServerMetaDataPersistentModule.setCurrentTerm(appendEntriesRpcParam.getTerm());
        }

        if(appendEntriesRpcParam.getEntries() == null || appendEntriesRpcParam.getEntries().isEmpty()){
            // æ¥è‡ªleaderçš„å¿ƒè·³å¤„ç†ï¼Œæ¸…ç†æ‰ä¹‹å‰é€‰ä¸¾çš„votedFor
            this.cleanVotedFor();
            // entriesä¸ºç©ºï¼Œè¯´æ˜æ˜¯å¿ƒè·³è¯·æ±‚ï¼Œåˆ·æ–°ä¸€ä¸‹æœ€è¿‘æ”¶åˆ°å¿ƒè·³çš„æ—¶é—´
            raftLeaderElectionModule.refreshLastHeartbeatTime();

            long currentLastCommittedIndex = logModule.getLastCommittedIndex();
            logger.debug("doAppendEntries heartbeat leaderCommit={},currentLastCommittedIndex={}",
                appendEntriesRpcParam.getLeaderCommit(),currentLastCommittedIndex);

            if(appendEntriesRpcParam.getLeaderCommit() &gt; currentLastCommittedIndex) {
                // å¿ƒè·³å¤„ç†é‡Œï¼Œå¦‚æœleaderå½“å‰å·²æäº¤çš„æ—¥å¿—è¿›åº¦è¶…è¿‡äº†å½“å‰èŠ‚ç‚¹çš„è¿›åº¦ï¼Œä»¤å½“å‰èŠ‚ç‚¹çŠ¶æ€æœºä¹Ÿè·Ÿä¸Š
                // å¦‚æœleaderCommit &gt;= logModule.getLastIndex(),è¯´æ˜å½“å‰èŠ‚ç‚¹çš„æ—¥å¿—è¿›åº¦ä¸è¶³ï¼Œä½†å¯ä»¥æŠŠç›®å‰å·²æœ‰çš„æ—¥å¿—éƒ½æäº¤ç»™çŠ¶æ€æœºå»æ‰§è¡Œ
                // å¦‚æœleaderCommit &lt; logModule.getLastIndex(),è¯´æ˜å½“å‰èŠ‚ç‚¹è¿›åº¦æ¯”è¾ƒå¿«ï¼Œæœ‰ä¸€äº›æ—¥å¿—æ˜¯leaderå·²å¤åˆ¶ä½†è¿˜æ²¡æäº¤çš„ï¼ŒæŠŠleaderå·²æäº¤çš„é‚£ä¸€éƒ¨åˆ†ä½œç”¨åˆ°çŠ¶æ€æœºå°±è¡Œ
                long minNeedCommittedIndex = Math.min(appendEntriesRpcParam.getLeaderCommit(), logModule.getLastIndex());
                pushStatemachineApply(minNeedCommittedIndex);
            }

            // å¿ƒè·³è¯·æ±‚ï¼Œç›´æ¥è¿”å›
            return new AppendEntriesRpcResult(this.raftServerMetaDataPersistentModule.getCurrentTerm(),true);
        }

        // logEntriesä¸ä¸ºç©ºï¼Œæ˜¯çœŸå®çš„æ—¥å¿—å¤åˆ¶rpc

        logger.info("do real log append! appendEntriesRpcParam={}",appendEntriesRpcParam);
        // AppendEntryå¯é æ€§æ ¡éªŒï¼Œå¦‚æœprevLogIndexå’ŒprevLogTermä¸åŒ¹é…ï¼Œåˆ™éœ€è¦è¿”å›falseï¼Œè®©leaderå‘æ›´æ—©çš„æ—¥å¿—è¿‡æ¥
        {
            LogEntry localPrevLogEntry = logModule.readLocalLog(appendEntriesRpcParam.getPrevLogIndex());
            if(localPrevLogEntry == null){
                // æ²¡æœ‰æŸ¥åˆ°prevLogIndexå¯¹åº”çš„æ—¥å¿—ï¼Œåˆ†ä¸¤ç§æƒ…å†µ
                RaftSnapshot raftSnapshot = snapshotModule.readSnapshotMetaData();
                localPrevLogEntry = new LogEntry();
                if(raftSnapshot == null){
                    // å½“å‰èŠ‚ç‚¹æ—¥å¿—æ¡ç›®ä¸ºç©º,åˆæ²¡æœ‰å¿«ç…§ï¼Œè¯´æ˜å®Œå…¨æ²¡æœ‰æ—¥å¿—(é»˜è®¤ä»»æœŸä¸º-1ï¼Œè¿™ä¸ªæ˜¯çº¦å®š)
                    localPrevLogEntry.setLogIndex(-1);
                    localPrevLogEntry.setLogTerm(-1);
                }else{
                    // æ—¥å¿—é‡Œæ²¡æœ‰ï¼Œä½†æ˜¯æœ‰å¿«ç…§(æŠŠå¿«ç…§é‡Œè®°å½•çš„æœ€åä¸€æ¡æ—¥å¿—ä¿¡æ¯ä¸leaderçš„å‚æ•°æ¯”å¯¹)
                    localPrevLogEntry.setLogIndex(raftSnapshot.getLastIncludedIndex());
                    localPrevLogEntry.setLogTerm(raftSnapshot.getLastIncludedTerm());
                }
            }

            if (localPrevLogEntry.getLogTerm() != appendEntriesRpcParam.getPrevLogTerm()) {
                //  Reply false if log doesnâ€™t contain an entry at prevLogIndex
                //  whose term matches prevLogTerm (Â§5.3)
                //  æœ¬åœ°æ—¥å¿—å’Œå‚æ•°ä¸­çš„PrevLogIndexå’ŒPrevLogTermå¯¹ä¸ä¸Š(å¯¹åº”æ—¥å¿—ä¸å­˜åœ¨ï¼Œæˆ–è€…ä»»æœŸå¯¹ä¸ä¸Š)
                logger.info("doAppendEntries localPrevLogEntry not match, localLogEntry={}",localPrevLogEntry);

                return new AppendEntriesRpcResult(this.raftServerMetaDataPersistentModule.getCurrentTerm(),false);
            }
        }

        // èµ°åˆ°è¿™é‡Œè¯´æ˜æ‰¾åˆ°äº†æœ€æ–°çš„ä¸€æ¡åŒ¹é…çš„è®°å½•
        logger.info("doAppendEntries localEntry is match");

        List&lt;LogEntry&gt; newLogEntryList = appendEntriesRpcParam.getEntries();

        // 1. Append any new entries not already in the log
        // 2. If an existing entry conflicts with a new one (same index but different terms),
        //    delete the existing entry and all that follow it (Â§5.3)
        // æ–°æ—¥å¿—çš„å¤åˆ¶æ“ä½œï¼ˆç›´æ¥æ•´ä¸ªè¦†ç›–æ‰prevLogIndexä¹‹åçš„æ‰€æœ‰æ—¥å¿—,ä»¥leaderå‘è¿‡æ¥çš„æ—¥å¿—ä¸ºå‡†ï¼‰
        logModule.writeLocalLog(newLogEntryList, appendEntriesRpcParam.getPrevLogIndex());

        // If leaderCommit &gt; commitIndex, set commitIndex = min(leaderCommit, index of last new entry)
        if(appendEntriesRpcParam.getLeaderCommit() &gt; logModule.getLastCommittedIndex()){
            // å¦‚æœleaderCommitæ›´å¤§ï¼Œè¯´æ˜å½“å‰èŠ‚ç‚¹çš„åŒæ­¥è¿›åº¦æ…¢äºleaderï¼Œä»¥æ–°çš„entryé‡Œçš„indexä¸ºå‡†(æ›´é«˜çš„indexè¿˜æ²¡æœ‰åœ¨æœ¬åœ°ä¿å­˜(å› ä¸ºä¸Šé¢çš„appendEntryæœ‰æ•ˆæ€§æ£€æŸ¥))
            // å¦‚æœindex of last new entryæ›´å¤§ï¼Œè¯´æ˜å½“å‰èŠ‚ç‚¹çš„åŒæ­¥è¿›åº¦æ˜¯å’Œleaderç›¸åŒ¹é…çš„ï¼ŒcommitIndexä»¥leaderæœ€æ–°æäº¤çš„ä¸ºå‡†

            LogEntry lastNewEntry = newLogEntryList.get(newLogEntryList.size()-1);
            long lastCommittedIndex = Math.min(appendEntriesRpcParam.getLeaderCommit(), lastNewEntry.getLogIndex());
            pushStatemachineApply(lastCommittedIndex);
        }

        // è¿”å›æˆåŠŸ
        return new AppendEntriesRpcResult(this.raftServerMetaDataPersistentModule.getCurrentTerm(), true);
    }
Copy<br><br>
<br>MyRaftä¸­ï¼Œleaderä¾§å®‰è£…å¿«ç…§çš„æ–¹æ³•å®ç°çš„æ¯”è¾ƒç®€å•ï¼Œæœªè€ƒè™‘å¿«ç…§å¯èƒ½å¾ˆå¤§çš„æƒ…å†µï¼Œæ‰€ä»¥ç›´æ¥ä¸€è‚¡è„‘å°†æ•´ä¸ªå¿«ç…§æ–‡ä»¶å…¨éƒ¨è¯»å–åˆ°å†…å­˜ä¸­æ¥äº†(åœ¨å‘å¤šä¸ªfollowerå¹¶å‘å®‰è£…å¿«ç…§æ—¶ä¼šå ç”¨å¾ˆå¤šçš„å†…å­˜ï¼Œå¾…ä¼˜åŒ–)ã€‚
<br>åœ¨å°†å¿«ç…§è¯»å–åˆ°å†…å­˜ä¸­åï¼Œé€šè¿‡ä¸€ä¸ªå¾ªç¯å°†å¿«ç…§æ•°æ®æŒ‰ç…§é…ç½®çš„blockå¤§å°é€æ­¥çš„å‘é€ç»™followerã€‚åœ¨å‘é€å®Œæœ€åä¸€ä¸ªblockæ•°æ®åï¼Œrpcè¯·æ±‚å‚æ•°çš„doneå±æ€§ä¼šè¢«è®¾ç½®ä¸ºtrueæ ‡è¯†ä¸ºåŒæ­¥å®Œæˆã€‚
<br>    public static void doInstallSnapshotRpc(RaftService targetNode, RaftSnapshot raftSnapshot, RaftServer currentServer){
        int installSnapshotBlockSize = currentServer.getRaftConfig().getInstallSnapshotBlockSize();
        byte[] completeSnapshotData = raftSnapshot.getSnapshotData();

        int currentOffset = 0;
        while(true){
            InstallSnapshotRpcParam installSnapshotRpcParam = new InstallSnapshotRpcParam();
            installSnapshotRpcParam.setLastIncludedIndex(raftSnapshot.getLastIncludedIndex());
            installSnapshotRpcParam.setTerm(currentServer.getCurrentTerm());
            installSnapshotRpcParam.setLeaderId(currentServer.getServerId());
            installSnapshotRpcParam.setLastIncludedTerm(raftSnapshot.getLastIncludedTerm());
            installSnapshotRpcParam.setOffset(currentOffset);

            // å¡«å……æ¯æ¬¡ä¼ è¾“çš„æ•°æ®å—
            int blockSize = Math.min(installSnapshotBlockSize,completeSnapshotData.length-currentOffset);
            byte[] block = new byte[blockSize];
            System.arraycopy(completeSnapshotData,currentOffset,block,0,blockSize);
            installSnapshotRpcParam.setData(block);

            currentOffset += installSnapshotBlockSize;
            if(currentOffset &gt;= completeSnapshotData.length){
                installSnapshotRpcParam.setDone(true);
            }else{
                installSnapshotRpcParam.setDone(false);
            }

            InstallSnapshotRpcResult installSnapshotRpcResult = targetNode.installSnapshot(installSnapshotRpcParam);

            boolean beFollower = currentServer.processCommunicationHigherTerm(installSnapshotRpcResult.getTerm());
            if(beFollower){
                // ä¼ è¾“è¿‡ç¨‹ä¸­å‘ç°è‡ªå·±å·²ç»ä¸å†æ˜¯leaderäº†ï¼Œå¿«é€Ÿç»“æŸ
                logger.info("doInstallSnapshotRpc beFollower quick return!");
                return;
            }

            if(installSnapshotRpcParam.isDone()){
                // å¿«ç…§æ•´ä½“å®‰è£…å®Œæ¯•
                logger.info("doInstallSnapshotRpc isDone!");
                return;
            }
        }
    }
Copy<br><br>
<br>followerä¾§å¤„ç†å¿«ç…§å®‰è£…rpcçš„é€»è¾‘ä¸­ï¼Œé™¤äº†å¿…è¦çš„å¯¹å‚æ•°termå¤§å°çš„æ£€æŸ¥ï¼Œå°±æ˜¯ç®€å•çš„é€šè¿‡SnapshotModuleå®Œæˆå¿«ç…§çš„å®‰è£…å·¥ä½œã€‚
<br>åœ¨å¿«ç…§æ•´ä½“æˆåŠŸå®‰è£…å®Œæˆåï¼Œé€šè¿‡LogModule.compressLogBySnapshotæ–¹æ³•å°†æ‰€æœ‰å·²æäº¤çš„æ—¥å¿—å…¨éƒ½åˆ é™¤æ‰ï¼Œå¹¶å°†ä¹‹å‰å®‰è£…å¥½çš„å¿«ç…§æ•´ä½“ä½œç”¨åˆ°followerè‡ªå·±æœ¬åœ°çš„çŠ¶æ€æœºä¸­ã€‚
<br>    public InstallSnapshotRpcResult installSnapshot(InstallSnapshotRpcParam installSnapshotRpcParam) {
        logger.info("installSnapshot start! serverId={},installSnapshotRpcParam={}",this.serverId,installSnapshotRpcParam);

        if(installSnapshotRpcParam.getTerm() &lt; this.raftServerMetaDataPersistentModule.getCurrentTerm()){
            // Reply immediately if term &lt; currentTerm
            // æ‹’ç»å¤„ç†ä»»æœŸä½äºè‡ªå·±çš„è€leaderçš„è¯·æ±‚

            logger.info("installSnapshot term &lt; currentTerm");
            return new InstallSnapshotRpcResult(this.raftServerMetaDataPersistentModule.getCurrentTerm());
        }

        // å®‰è£…å¿«ç…§
        this.snapshotModule.appendInstallSnapshot(installSnapshotRpcParam);

        // å¿«ç…§å·²ç»å®Œå…¨å®‰è£…å¥½äº†
        if(installSnapshotRpcParam.isDone()){
            // discard any existing or partial snapshot with a smaller index
            // å¿«ç…§æ•´ä½“å®‰è£…å®Œæ¯•ï¼Œæ¸…ç†æ‰indexå°äºç­‰äºå¿«ç…§ä¸­lastIncludedIndexçš„æ‰€æœ‰æ—¥å¿—(æ—¥å¿—å‹ç¼©)
            logModule.compressLogBySnapshot(installSnapshotRpcParam);

            // Reset state machine using snapshot contents (and load snapshotâ€™s cluster configuration)
            // followerçš„çŠ¶æ€æœºé‡æ–°å®‰è£…å¿«ç…§
            RaftSnapshot raftSnapshot = this.snapshotModule.readSnapshot();
            kvReplicationStateMachine.installSnapshot(raftSnapshot.getSnapshotData());
        }

        logger.info("installSnapshot end! serverId={}",this.serverId);

        return new InstallSnapshotRpcResult(this.raftServerMetaDataPersistentModule.getCurrentTerm());
    }
Copy<br>    /**
     * discard any existing or partial snapshot with a smaller index
     * å¿«ç…§æ•´ä½“å®‰è£…å®Œæ¯•ï¼Œæ¸…ç†æ‰indexå°äºç­‰äºå¿«ç…§ä¸­lastIncludedIndexçš„æ‰€æœ‰æ—¥å¿—
     * */
    public void compressLogBySnapshot(InstallSnapshotRpcParam installSnapshotRpcParam){
        this.lastCommittedIndex = installSnapshotRpcParam.getLastIncludedIndex();
        if(this.lastIndex &lt; this.lastCommittedIndex){
            this.lastIndex = this.lastCommittedIndex;
        }

        try {
            buildNewLogFileRemoveCommittedLog();
        } catch (IOException e) {
            throw new MyRaftException("compressLogBySnapshot error",e);
        }
    }
Copy<br><br>å’Œlab2ä¸­ä¸€æ ·ï¼Œé€šè¿‡å¯åŠ¨ä¸€ä¸ªrafté›†ç¾¤å¹¶è§¦å‘å‡ ä¸ªcaseå¯ä»¥éªŒè¯MyRaftæ—¥å¿—å‹ç¼©åŠŸèƒ½çš„æ­£ç¡®æ€§ã€‚<br>
<br>å¯åŠ¨5ä¸ªèŠ‚ç‚¹ï¼Œå…³é—­å¿«ç…§å‹ç¼©åŠŸèƒ½ï¼Œæ­£å¸¸çš„è¿›è¡Œå†™å…¥æ“ä½œã€‚<br>
=&gt; çŠ¶æ€æœº/æ—¥å¿—æ–‡ä»¶çš„æ•°æ®æ˜¯å¦ç¬¦åˆé¢„æœŸ
<br>å¯åŠ¨5ä¸ªèŠ‚ç‚¹ï¼Œå¼€å¯å¿«ç…§å‹ç¼©åŠŸèƒ½ï¼Œæ­£å¸¸çš„è¿›è¡Œå†™å…¥æ“ä½œï¼Œå½“æ—¥å¿—æ–‡ä»¶è¶…è¿‡é˜ˆå€¼è§¦å‘æ—¥å¿—å‹ç¼©åã€‚<br>
=&gt; çŠ¶æ€æœº/æ—¥å¿—æ–‡ä»¶/å¿«ç…§æ–‡ä»¶çš„æ•°æ®æ˜¯å¦ç¬¦åˆé¢„æœŸ
<br>å¯åŠ¨5ä¸ªèŠ‚ç‚¹ï¼Œå¼€å¯å¿«ç…§å‹ç¼©åŠŸèƒ½ï¼Œæ­£å¸¸çš„è¿›è¡Œå†™å…¥æ“ä½œï¼Œä¸»åŠ¨å…³é—­ä¸€ä¸ªèŠ‚ç‚¹ã€‚å†è¿›è¡Œä¸€äº›å†™å…¥ï¼Œä»¤leaderç”Ÿæˆæœ€æ–°çš„å¿«ç…§ï¼Œç„¶åè®©å®•æœºçš„èŠ‚ç‚¹å›åˆ°é›†ç¾¤ï¼Œçœ‹leaderæ˜¯å¦é€šè¿‡å¿«ç…§å®‰è£…æ¥å®Œæˆå¿«ç…§/æ—¥å¿—çš„åŒæ­¥ã€‚<br>
=&gt; çŠ¶æ€æœº/æ—¥å¿—æ–‡ä»¶/å¿«ç…§æ–‡ä»¶çš„æ•°æ®æ˜¯å¦ç¬¦åˆé¢„æœŸ
<br><br>
<br>ä½œä¸ºæ‰‹å†™raftç³»åˆ—åšå®¢çš„ç¬¬ä¸‰ç¯‡ï¼Œä¹Ÿæ˜¯ç›®å‰è®¡åˆ’ä¸­çš„æœ€åä¸€ç¯‡åšå®¢(é›†ç¾¤åŠ¨æ€å˜æ›´åŠŸèƒ½æš‚ä¸å®ç°)ã€‚åšå®¢ä¸­ä»‹ç»äº†Raftçš„æ—¥å¿—å‹ç¼©åŠŸèƒ½ä»¥åŠä»æºç å±‚é¢ä¸Šåˆ†æMyRaftå®ç°æ—¥å¿—å‹ç¼©åŠŸèƒ½çš„ç»†èŠ‚ã€‚
<br>raftæ˜¯ä¸€ä¸ªç›¸å¯¹å¤æ‚çš„ç®—æ³•ï¼Œå› æ­¤MyRaftåœ¨åŠŸèƒ½å®ç°ä¸Šä¸ºäº†è¿½æ±‚å®ç°çš„ç®€å•æ€§ï¼Œèˆå¼ƒäº†å¾ˆå¤šæ€§èƒ½æ–¹é¢çš„ä¼˜åŒ–(æ¯”å¦‚ä¸€æŠŠå…¨å±€å¤§é”é˜²å¹¶å‘ï¼Œå¿«ç…§æ•°æ®å®Œæ•´æ”¾åˆ°å†…å­˜ä¸­å¤„ç†ç­‰ç­‰)ã€‚<br>
åŒæ—¶åˆ†å¸ƒå¼ç³»ç»Ÿä¸­å¤„å¤„æœ‰å¹¶å‘ã€æœºå™¨ä¹Ÿæ—¶åˆ»å¯èƒ½å®•æœºï¼Œéœ€è¦è€ƒè™‘çš„ç»†èŠ‚ç¹å¤šã€‚æ‰€ä»¥MyRaftå³ä½¿é€šè¿‡äº†æˆ‘è‡ªå·±è®¾è®¡çš„ä¸€äº›å•æµ‹å’Œé›†æˆæµ‹è¯•çš„caseï¼Œä½†è‚¯å®šè¿˜å­˜åœ¨è®¸å¤šå°šæœªè¢«å‘ç°bugï¼Œè¿˜è¯·å¤šå¤šæŒ‡æ•™ã€‚
<br>åšå®¢ä¸­å±•ç¤ºçš„å®Œæ•´ä»£ç åœ¨æˆ‘çš„githubä¸Šï¼š<a rel="noopener" class="external-link" href="https://github.com/1399852153/MyRaft" target="_blank">https://github.com/1399852153/MyRaft</a> (release/lab3_log_compactionåˆ†æ”¯)ï¼Œå¸Œæœ›èƒ½å¸®åŠ©åˆ°å¯¹raftç®—æ³•æ„Ÿå…´è¶£çš„å°ä¼™ä¼´ã€‚
]]></description><link>https://muqiuhan.github.io/wiki/computer-science/distributed-system/raftå®ç°/raftå®ç°-å®ç°æ—¥å¿—å‹ç¼©.html</link><guid isPermaLink="false">Computer Science/Distributed System/Raftå®ç°/Raftå®ç° - å®ç°æ—¥å¿—å‹ç¼©.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Thu, 25 Jul 2024 09:26:29 GMT</pubDate><enclosure url="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raftå®ç°/pasted-image-20240725172559.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raftå®ç°/pasted-image-20240725172559.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Raftå®ç° - å®ç°æ—¥å¿—å¤åˆ¶]]></title><description><![CDATA[ 
 <br><br>åœ¨ä¸Šä¸€ç¯‡åšå®¢ä¸­MyRaftå®ç°äº†leaderé€‰ä¸¾ï¼Œä¸ºæ¥ä¸‹æ¥å®ç°æ—¥å¿—å¤åˆ¶åŠŸèƒ½æ‰“ä¸‹äº†åŸºç¡€: <a data-tooltip-position="top" aria-label="https://www.cnblogs.com/xiaoxiongcanguan/p/17569697.html" rel="noopener" class="external-link" href="https://www.cnblogs.com/xiaoxiongcanguan/p/17569697.html" target="_blank">æ‰‹å†™raft(ä¸€) å®ç°leaderé€‰ä¸¾</a><br>æ—¥å¿—å¤åˆ¶æ˜¯raftæœ€æ ¸å¿ƒä¹Ÿæ˜¯æœ€å¤æ‚çš„åŠŸèƒ½ï¼Œå¤§ä½“ä¸Šæ¥è¯´ä¸€æ¬¡æ­£å¸¸çš„raftæ—¥å¿—å¤åˆ¶å¤§è‡´å¯ä»¥ç®€åŒ–ä¸ºä»¥ä¸‹å‡ æ­¥å®Œæˆï¼š<br>
<br>å®¢æˆ·ç«¯å‘rafté›†ç¾¤å‘é€ä¸€æ¬¡æ“ä½œè¯·æ±‚(æ¯”å¦‚kvæ•°æ®åº“çŠ¶æ€æœºçš„å†™å‘½ä»¤(set k1 v1))ï¼Œå¦‚æœæ¥å—åˆ°è¯·æ±‚çš„èŠ‚ç‚¹æ˜¯leaderåˆ™å—ç†è¯¥è¯·æ±‚ï¼›<br>
å¦‚æœä¸æ˜¯leaderåˆ™è½¬å‘ç»™è‡ªå·±è®¤ä¸ºçš„leaderæˆ–è€…è¿”å›leaderçš„åœ°å€è®©å®¢æˆ·ç«¯å‘leaderé‡æ–°å‘é€è¯·æ±‚(å¦‚æœè¿‡ç¨‹ä¸­å°æ¦‚ç‡å‘ç”Ÿäº†leaderå˜æ›´ï¼Œåˆ™å¾ªç¯å¾€å¤ç›´åˆ°leaderå—ç†)
<br>leaderåœ¨æ¥å—åˆ°è¯·æ±‚åï¼Œç”Ÿæˆå¯¹åº”çš„raftæ—¥å¿—(logEntry)å¹¶è¿½åŠ å†™å…¥åˆ°leaderèŠ‚ç‚¹æœ¬åœ°çš„æ—¥å¿—æ–‡ä»¶ä¸­(æ•´ä¸ªè¿‡ç¨‹éœ€è¦åŠ é”ï¼Œé˜²æ­¢å¤šä¸ªè¯·æ±‚å¹¶å‘è€Œæ—¥å¿—ä¹±åº)ã€‚
<br>leaderæœ¬åœ°æ—¥å¿—è¿½åŠ å†™å…¥å®Œæˆåï¼Œå‘é›†ç¾¤ä¸­çš„æ‰€æœ‰followerèŠ‚ç‚¹å¹¿æ’­è¯¥æ—¥å¿—(å¹¶è¡Œçš„rpc appendEntries)ï¼Œfolloweræ¥åˆ°è¯¥rpcè¯·æ±‚åä¹Ÿå°†æ—¥å¿—è¿½åŠ å†™å…¥åˆ°è‡ªå·±çš„æœ¬åœ°æ—¥å¿—æ–‡ä»¶ä¸­ï¼Œå¹¶è¿”å›æˆåŠŸã€‚<br>
å½“è¶…è¿‡åŠæ•°çš„followerè¿”å›äº†æˆåŠŸæ—¶ï¼Œleaderè®¤ä¸ºè¯¥æ—¥å¿—å·²ç»æˆåŠŸçš„å¤åˆ¶åˆ°äº†é›†ç¾¤ä¸­ï¼Œå¯ä»¥æäº¤åˆ°çŠ¶æ€æœºä¸­æ‰§è¡Œã€‚<br>
å¦‚æœæˆåŠŸçš„æ•°é‡å°‘äºåŠæ•°åˆ™è®¤ä¸ºè¯¥å®¢æˆ·ç«¯è¯·æ±‚å¤±è´¥ï¼Œä¸æäº¤åˆ°çŠ¶æ€æœºä¸­ï¼Œå¹¶å°†æœ¬åœ°å†™å…¥çš„æ—¥å¿—åˆ é™¤æ‰ï¼Œè®©å®¢æˆ·ç«¯å»é‡è¯•ã€‚
<br>leaderæäº¤æ—¥å¿—ç»™çŠ¶æ€æœºåï¼Œä¼šä¿®æ”¹è‡ªå·±çš„lastAppliedå­—æ®µ(æœ€å¤§å·²æäº¤æ—¥å¿—ç´¢å¼•ç¼–å·)ï¼Œéšåé€šè¿‡å¿ƒè·³ç­‰rpcäº¤äº’ä»¤followerä¹Ÿæäº¤æœ¬åœ°å¯¹åº”ç´¢å¼•çš„æ—¥å¿—åˆ°çŠ¶æ€æœºä¸­
<br>è‡³æ­¤ï¼Œä¸€æ¬¡å®Œæ•´çš„æ—¥å¿—å¤åˆ¶è¿‡ç¨‹å®Œæˆï¼Œä¸€åˆ‡æ­£å¸¸çš„æƒ…å†µä¸‹æ•´ä¸ªé›†ç¾¤ä¸­æ‰€æœ‰èŠ‚ç‚¹çš„æœ¬åœ°æ—¥å¿—ä¸­éƒ½åŒ…å«äº†å¯¹åº”è¯·æ±‚çš„æ—¥å¿—ï¼Œæ¯ä¸ªèŠ‚ç‚¹çš„çŠ¶æ€æœºä¹Ÿæ‰§è¡Œäº†å¯¹åº”æ—¥å¿—åŒ…å«çš„çŠ¶æ€æœºæŒ‡ä»¤ã€‚
<br><br><img alt="Pasted image 20240725172412.png" src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raftå®ç°/pasted-image-20240725172412.png"><br>
<br>ä¸Šé¢å…³äºraftæ—¥å¿—å¤åˆ¶åŠŸèƒ½çš„ä»‹ç»çœ‹èµ·æ¥ä¸ç®—å¤æ‚ï¼Œåœ¨ä¸€åˆ‡æ­£å¸¸çš„æƒ…å†µä¸‹ç³»ç»Ÿä¼¼ä¹èƒ½å¾ˆå¥½çš„å®Œæˆä»»åŠ¡ã€‚ä½†raftæ˜¯ä¸€ä¸ªåˆ†å¸ƒå¼ç³»ç»Ÿï¼Œåˆ†å¸ƒå¼ç³»ç»Ÿä¸­ä¼šå‡ºç°å„ç§éº»çƒ¦çš„å¼‚å¸¸æƒ…å†µï¼Œåœ¨ä¸Šè¿°ä»»åŠ¡çš„æ¯ä¸€æ­¥ã€ä»»ä¸€ç¬é—´éƒ½å¯èƒ½å‡ºç°ç½‘ç»œæ•…éšœã€æœºå™¨å®•æœº(leader/followeréƒ½å¯èƒ½å¤„ç†åˆ°ä¸€åŠå°±å®•æœº)ç­‰é—®é¢˜ï¼Œ<br>
è€Œå¦‚ä½•åœ¨å¼‚å¸¸æƒ…å†µä¸‹ä¾ç„¶èƒ½è®©ç³»ç»Ÿæ­£å¸¸å®Œæˆä»»åŠ¡å°±ä½¿å¾—raftæ—¥å¿—å¤åˆ¶çš„é€»è¾‘å˜å¾—å¤æ‚èµ·æ¥äº†ã€‚
<br>raftè®ºæ–‡ä¸­å¯¹ä¸€äº›å¼‚å¸¸æƒ…å†µè¿›è¡Œäº†ç®€è¦ä»‹ç»ï¼Œå¹¶é€šè¿‡ä¸€äº›ç¤ºä¾‹æ¥è¯æ˜ç®—æ³•çš„æ­£ç¡®æ€§ã€‚ä½†å…·ä½“è½åœ°åˆ°ä»£ç å®ç°ä¸­è¿˜æœ‰æ›´å¤šçš„ç»†èŠ‚éœ€è¦è€ƒè™‘ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆraftè®ºæ–‡ä¸­åå¤å¼ºè°ƒç®—æ³•æ˜“ç†è§£çš„é‡è¦æ€§ã€‚
<br>å› ä¸ºç®—æ³•å®¹æ˜“ç†è§£ï¼Œå®ç°è€…å°±èƒ½å¯¹ç®—æ³•å»ºç«‹èµ·ç›´è§‚çš„ç†è§£ï¼Œå¤„ç†å¼‚å¸¸caseæ—¶å°±èƒ½æ›´å¥½çš„ç†è§£åº”è¯¥å¦‚ä½•åšä»¥åŠä¸ºä»€ä¹ˆè¿™æ ·åšæ˜¯æ­£ç¡®çš„ã€‚åœ¨ä¸‹æ–‡ä¸­å°†ä¼šç»“åˆMyRaftçš„å®ç°æºç æ¥è¯¦ç»†åˆ†æraftæ˜¯å¦‚ä½•å¤„ç†å¼‚å¸¸æƒ…å†µçš„ã€‚
<br><br><br>ä¸ºäº†å®ç°æ—¥å¿—å¤åˆ¶åŠŸèƒ½ï¼Œlab2ç‰ˆæœ¬çš„MyRaftæ¯”èµ·lab1é¢å¤–æ–°å¢äº†3ä¸ªæ¨¡å—ï¼Œåˆ†åˆ«æ˜¯æ—¥å¿—æ¨¡å—LogModuleã€çŠ¶æ€æœºæ¨¡å—SimpleReplicationStateMachineå’Œå®¢æˆ·ç«¯æ¨¡å—RaftClientã€‚<br><br>
<br>MyRaftçš„æ—¥å¿—æ¨¡å—ç”¨äºç»´æŠ¤raftæ—¥å¿—ç›¸å…³çš„é€»è¾‘ï¼Œå‡ºäºå‡å°‘ä¾èµ–çš„åŸå› ï¼ŒMyRaftæ²¡æœ‰å»ä¾èµ–rocksDbç­‰åŸºäºæœ¬åœ°ç£ç›˜çš„æ•°æ®åº“è€Œæ˜¯ç›´æ¥æ“ä½œæœ€åŸå§‹çš„æ—¥å¿—æ–‡ä»¶(RandomAccessFile)æ¥å®ç°æ—¥å¿—å­˜å‚¨åŠŸèƒ½ã€‚
<br>ç®€å•èµ·è§ï¼ŒLogModuleç›´æ¥é€šè¿‡ä¸€æŠŠå…¨å±€çš„è¯»å†™é”æ¥é˜²æ­¢å¹¶å‘é—®é¢˜ã€‚
<br>/**
 * raftæ—¥å¿—æ¡ç›®
 * */
public class LogEntry implements Serializable {

    /**
     * å‘å¸ƒæ—¥å¿—æ—¶çš„leaderçš„ä»»æœŸç¼–å·
     * */
    private int logTerm;

    /**
     * æ—¥å¿—çš„ç´¢å¼•ç¼–å·
     * */
    private long logIndex;

    /**
     * å…·ä½“ä½œç”¨åœ¨çŠ¶æ€æœºä¸Šçš„æŒ‡ä»¤
     * */
    private Command command;
}
Copy<br>LogEntryåœ¨ç£ç›˜æ–‡ä»¶ä¸­å­˜å‚¨çš„ç¤ºæ„å›¾<br>
<img alt="Pasted image 20240725172431.png" src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raftå®ç°/pasted-image-20240725172431.png"><br><a data-tooltip-position="top" aria-label="https://github.com/1399852153/MyRaft/blob/release/lab2_log_replication/raft/src/main/java/myraft/module/LogModule.java" rel="noopener" class="external-link" href="https://github.com/1399852153/MyRaft/blob/release/lab2_log_replication/raft/src/main/java/myraft/module/LogModule.java" target="_blank">logModuleç±»æºç </a><br><br>
<br>çŠ¶æ€æœºæ¨¡å—æ˜¯ä¸€ä¸ªK/Væ•°æ®æ¨¡å‹ï¼Œæœ¬è´¨ä¸Šå°±æ˜¯å†…å­˜ä¸­ç»´æŠ¤äº†ä¸€ä¸ªHashMapã€‚çŠ¶æ€æœºçš„è¯»å†™æ“ä½œå°±æ˜¯å¯¹è¿™ä¸ªHashMapçš„è¯»å†™æ“ä½œï¼Œæ²¡æœ‰é¢å¤–çš„é€»è¾‘ã€‚
<br>åŒæ—¶ä¸ºäº†æ–¹ä¾¿è§‚å¯ŸçŠ¶æ€æœºä¸­çš„æ•°æ®çŠ¶æ€ï¼Œæ¯æ¬¡è¿›è¡Œå†™æ“ä½œæ—¶éƒ½æ•´ä½“åˆ·æ–°è¿™ä¸ªHashMapä¸­çš„æ•°æ®åˆ°å¯¹åº”çš„æœ¬åœ°æ–‡ä»¶ä¸­(ç®€å•èµ·è§æš‚ä¸è€ƒè™‘åŒæ­¥åˆ·ç›˜çš„æ€§èƒ½é—®é¢˜)ã€‚
<br>MyRaftæ˜¯ä¸€ä¸ªæç®€çš„K/Væ•°æ®åº“ï¼Œå…¶åªæ”¯æŒæœ€åŸºæœ¬çš„get/setå‘½ä»¤ï¼Œå› æ­¤ä½œç”¨åœ¨çŠ¶æ€æœºä¸­çš„æ‰€æœ‰æŒ‡ä»¤å¤©ç„¶éƒ½æ˜¯å¹‚ç­‰çš„ï¼Œæ˜¯å¯é‡å¤æ‰§è¡Œçš„ã€‚
<br>/**
 * æŒ‡ä»¤(å–å†³äºå®ç°)
 * */
public interface Command extends Serializable {
}

/**
 * å†™æ“ä½œï¼ŒæŠŠä¸€ä¸ªkeyè®¾ç½®ä¸ºvalue
 * */
public class SetCommand implements Command {

   private String key;
   private String value;
}

public class GetCommand implements Command{

   private String key;
}
Copy<br><br>
<br>Raftå®¢æˆ·ç«¯æ¨¡å—å°±æ˜¯ä¸€ä¸ªrpcçš„å®¢æˆ·ç«¯(ä¸ä¾èµ–æ³¨å†Œä¸­å¿ƒï¼ŒåŸºäºé™æ€æœåŠ¡é…ç½®çš„ç‚¹å¯¹ç‚¹rpc)ï¼Œè¯·æ±‚æ—¶ä½¿ç”¨è´Ÿè½½å‡è¡¡éšæœºçš„è·å¾—ä¸€ä¸ªraftæœåŠ¡èŠ‚ç‚¹è®¿é—®ã€‚
<br>public class RaftClient {

    private final Registry registry;
    private RaftService raftServiceProxy;
    private List&lt;ServiceInfo&gt; serviceInfoList;
    private final LoadBalance loadBalance = new SimpleRoundRobinBalance();

    public RaftClient(Registry registry) {
        this.registry = registry;
    }

    public void init(){
        ConsumerBootstrap consumerBootstrap = new ConsumerBootstrap()
            .registry(registry);

        // æ³¨å†Œæ¶ˆè´¹è€…
        Consumer&lt;RaftService&gt; consumer = consumerBootstrap.registerConsumer(RaftService.class,new FastFailInvoker());
        this.raftServiceProxy = consumer.getProxy();
    }

    public void setRaftNodeConfigList(List&lt;RaftNodeConfig&gt; raftNodeConfigList) {
        this.serviceInfoList = raftNodeConfigList.stream().map(item-&gt;{
            ServiceInfo serviceInfo = new ServiceInfo();
            serviceInfo.setServiceName(RaftService.class.getName());
            serviceInfo.setUrlAddress(new URLAddress(item.getIp(),item.getPort()));
            return serviceInfo;
        }).collect(Collectors.toList());
    }

    public String doRequestRetry(Command command, int retryTime){
        RuntimeException ex = new RuntimeException();
        for(int i=0; i&lt;retryTime; i++){
            try {
                return doRequest(command);
            }catch (Exception e){
                ex = new RuntimeException(e);
                System.out.println("doRequestRetry error, retryTime=" + i);
            }
        }

        // næ¬¡é‡è¯•åè¿˜æ˜¯æ²¡æˆåŠŸ
        throw ex;
    }

    public String doRequest(Command command){
        // å…ˆè®©è´Ÿè½½å‡è¡¡é€‰æ‹©è¯·æ±‚ä»»æ„èŠ‚ç‚¹
        ServiceInfo serviceInfo = loadBalance.select(this.serviceInfoList);
        ClientRequestResult clientRequestResult = doRequest(serviceInfo.getUrlAddress(),command);

        if(clientRequestResult.getLeaderAddress() == null){
            if(!clientRequestResult.isSuccess()){
                throw new MyRpcException("doRequest error!");
            }
            // è®¿é—®åˆ°äº†leaderï¼Œå¾—åˆ°ç»“æœ
            return clientRequestResult.getValue();
        }else{
            // leaderAddressä¸ä¸ºç©ºï¼Œè¯´æ˜è®¿é—®åˆ°äº†followerï¼Œå¾—åˆ°followerç»™å‡ºçš„leaderåœ°å€
            URLAddress urlAddress = clientRequestResult.getLeaderAddress();
            // æŒ‡å®šleaderçš„åœ°å€å»å‘èµ·è¯·æ±‚
            ClientRequestResult result = doRequest(urlAddress,command);

            return result.getValue();
        }
    }

    private ClientRequestResult doRequest(URLAddress urlAddress, Command command){
        // ç›¸å½“äºæ˜¯ç‚¹å¯¹ç‚¹çš„rpcï¼Œç”¨è¿™ç§æ–¹å¼æ¯”è¾ƒå¥‡æ€ªï¼Œä½†å¯ä»¥ä¸ä¾èµ–zookeeperè¿™æ ·çš„æ³¨å†Œä¸­å¿ƒ
        ConsumerRpcContextHolder.getConsumerRpcContext().setTargetProviderAddress(urlAddress);
        ClientRequestParam clientRequestParam = new ClientRequestParam(command);
        ClientRequestResult clientRequestResult = this.raftServiceProxy.clientRequest(clientRequestParam);
        ConsumerRpcContextHolder.removeConsumerRpcContext();

        return clientRequestResult;
    }
}
Copy<br><br><br>
<br>raftæ˜¯ä¸€ä¸ªå¼ºä¸€è‡´çš„è¯»å†™æ¨¡å‹ï¼Œåªæœ‰leaderæ‰èƒ½å¯¹å¤–è¿›è¡ŒæœåŠ¡ã€‚å› æ­¤raftæœåŠ¡èŠ‚ç‚¹æ”¶åˆ°æ¥è‡ªå®¢æˆ·ç«¯çš„è¯·æ±‚æ—¶ï¼Œéœ€è¦åˆ¤æ–­ä¸€ä¸‹è‡ªå·±æ˜¯å¦æ˜¯leaderï¼Œå¦‚æœä¸æ˜¯leaderå°±è¿”å›è‡ªå·±è®¤ä¸ºçš„leaderåœ°å€ç»™å®¢æˆ·ç«¯ï¼Œè®©å®¢æˆ·ç«¯é‡è¯•ã€‚<br>
raftæ˜¯ä¸€ä¸ªåˆ†å¸ƒå¼æ¨¡å‹ï¼Œåœ¨å‡ºç°ç½‘ç»œåˆ†åŒºç­‰æƒ…å†µä¸‹ï¼ŒåŸæ¥æ˜¯leaderçš„èŠ‚ç‚¹(termæ›´å°çš„è€leader)å¯èƒ½å¹¶ä¸æ˜¯ç›®å‰çœŸæ­£çš„leaderï¼Œè€Œè¿™ä¸ªæƒ…å†µä¸‹æ¥åˆ°å®¢æˆ·ç«¯è¯·æ±‚çš„è€leaderå°±ä¼šé”™è¯¯çš„å¤„ç†å®¢æˆ·ç«¯çš„è¯·æ±‚ï¼Œå› è€Œéœ€è¦é¢å¤–çš„æœºåˆ¶æ¥ä¿è¯raftå¼ºä¸€è‡´çš„è¯»å†™ç‰¹æ€§ã€‚
<br>çº¿æ€§å¼ºä¸€è‡´çš„å†™ï¼šraftçš„leaderèŠ‚ç‚¹åœ¨å¤„ç†å®¢æˆ·ç«¯è¯·æ±‚æ—¶ä¼šåŠ å†™é”(çº¿æ€§ä¸€è‡´)ã€‚æäº¤æŒ‡ä»¤åˆ°çŠ¶æ€æœºä¸­æ‰§è¡Œå‰ï¼Œä¼šé¢„å…ˆå†™å…¥ä¸€ä»½æœ¬åœ°æ—¥å¿—ï¼Œå¹¶å°†æœ¬åœ°æ—¥å¿—å¹¿æ’­åˆ°é›†ç¾¤ä¸­çš„æ‰€æœ‰followerèŠ‚ç‚¹ä¸Šã€‚å¦‚æœè‡ªå·±å·²ç»ä¸å†æ˜¯åˆæ³•çš„leaderï¼Œåˆ™æœ¬åœ°æ—¥å¿—çš„å¹¿æ’­æ˜¯æ— æ³•åœ¨è¶…è¿‡åŠæ•°çš„èŠ‚ç‚¹ä¸Šæ‰§è¡ŒæˆåŠŸçš„ã€‚<br>
åè¿‡æ¥è¯´ï¼Œåªè¦å¤§å¤šæ•°çš„èŠ‚ç‚¹éƒ½æˆåŠŸå®Œæˆäº†æ—¥å¿—å¤åˆ¶çš„rpcè¯·æ±‚(appendEntries)ï¼Œåˆ™è¯¥å†™æ“ä½œå°±æ˜¯å¼ºä¸€è‡´ä¸‹çš„å†™ï¼Œå› æ­¤å¯ä»¥å°†å‘½ä»¤å®‰å…¨çš„æäº¤åˆ°çŠ¶æ€æœºä¸­å¹¶å‘å®¢æˆ·ç«¯è¿”å›æˆåŠŸã€‚
<br>çº¿æ€§å¼ºä¸€è‡´çš„è¯»ï¼šå¼ºä¸€è‡´çš„è¯»å°±ä¸èƒ½è®©è€leaderå¤„ç†è¯»è¯·æ±‚ï¼Œå› ä¸ºå¾ˆå¯èƒ½è€leaderç›¸æ¯”å®é™…ä¸Šåˆæ³•çš„æ–°leaderç¼ºå¤±äº†ä¸€äº›æœ€æ–°çš„å†™æ“ä½œï¼Œè€Œå¯¼è‡´è¿”å›è¿‡æ—¶çš„æ•°æ®(ç ´åäº†å¼ºä¸€è‡´è¯»çš„è¯­ä¹‰)ã€‚å› æ­¤å¯¹äºè¯»æŒ‡ä»¤ï¼Œä¸šç•Œæå‡ºäº†å‡ ç§å¸¸è§çš„ç¡®ä¿å¼ºä¸€è‡´è¯»çš„æ–¹æ¡ˆã€‚
<br><br>MyRaftè€ƒè™‘åˆ°å®ç°çš„ç®€å•æ€§ï¼Œé€‰æ‹©äº†æ–¹æ¡ˆ2æ¥å®ç°å¼ºä¸€è‡´çš„è¯»ã€‚<br>    public ClientRequestResult clientRequest(ClientRequestParam clientRequestParam) {
        // ä¸æ˜¯leader
        if(this.serverStatusEnum != ServerStatusEnum.LEADER){
            if(this.currentLeader == null){
                // è‡ªå·±ä¸æ˜¯leaderï¼Œä¹Ÿä¸çŸ¥é“è°æ˜¯leaderç›´æ¥æŠ¥é”™
                throw new MyRaftException("current node not leaderï¼Œand leader is null! serverId=" + this.serverId);
            }

            RaftNodeConfig leaderConfig = this.raftConfig.getRaftNodeConfigList()
                .stream().filter(item-&gt; Objects.equals(item.getServerId(), this.currentLeader)).findAny().get();

            // æŠŠè‡ªå·±è®¤ä¸ºçš„leaderå‘Šè¯‰å®¢æˆ·ç«¯(ä¹Ÿå¯ä»¥æ”¹ä¸ºç›´æ¥è½¬å‘è¯·æ±‚)
            ClientRequestResult clientRequestResult = new ClientRequestResult();
            clientRequestResult.setLeaderAddress(new URLAddress(leaderConfig.getIp(),leaderConfig.getPort()));

            logger.info("not leader response known leader, result={}",clientRequestResult);
            return clientRequestResult;
        }

        // æ˜¯leaderï¼Œå¤„ç†è¯»è¯·æ±‚(çº¿æ€§ä¸€è‡´è¯»)
        if(clientRequestParam.getCommand() instanceof GetCommand){
            // çº¿æ€§å¼ºä¸€è‡´çš„è¯»ï¼Œéœ€è¦å…ˆè¿›è¡Œä¸€æ¬¡å¿ƒè·³å¹¿æ’­ï¼Œåˆ¤æ–­å½“å‰è‡ªå·±æ˜¯å¦è¿˜æ˜¯leader
            boolean stillBeLeader = HeartbeatBroadcastTask.doHeartbeatBroadcast(this);
            if(stillBeLeader){
                // è¿˜æ˜¯leaderï¼Œå¯ä»¥å“åº”å®¢æˆ·ç«¯
                logger.info("do client read op, still be leader");

                // Read-only operations can be handled without writing anything into the log.
                GetCommand getCommand = (GetCommand) clientRequestParam.getCommand();

                // ç›´æ¥ä»çŠ¶æ€æœºä¸­è¯»å–å°±è¡Œ
                String value = this.kvReplicationStateMachine.get(getCommand.getKey());

                ClientRequestResult clientRequestResult = new ClientRequestResult();
                clientRequestResult.setSuccess(true);
                clientRequestResult.setValue(value);

                logger.info("response getCommand, result={}",clientRequestResult);

                return clientRequestResult;
            }else{
                logger.info("do client read op, not still be leader");

                // å¹¿æ’­åå‘ç°è‡ªå·±ä¸å†æ˜¯leaderäº†ï¼ŒæŠ¥é”™ï¼Œè®©å®¢æˆ·ç«¯é‡æ–°è‡ªå·±æ‰¾leader (å®¢æˆ·ç«¯å’Œå½“å‰èŠ‚ç‚¹åŒæ—¶è¯¯åˆ¤ï¼Œå°æ¦‚ç‡å‘ç”Ÿ)
                throw new MyRaftException("do client read op, but not still be leader!" + this.serverId);
            }
        }

        // è‡ªå·±æ˜¯leaderï¼Œéœ€è¦å¤„ç†å®¢æˆ·ç«¯çš„å†™è¯·æ±‚

        // æ„é€ æ–°çš„æ—¥å¿—æ¡ç›®
        LogEntry newLogEntry = new LogEntry();
        newLogEntry.setLogTerm(this.raftServerMetaDataPersistentModule.getCurrentTerm());
        // æ–°æ—¥å¿—çš„ç´¢å¼•å·ä¸ºå½“å‰æœ€å¤§ç´¢å¼•ç¼–å·+1
        newLogEntry.setLogIndex(this.logModule.getLastIndex() + 1);
        newLogEntry.setCommand(clientRequestParam.getCommand());

        logger.info("handle setCommand, do writeLocalLog entry={}",newLogEntry);

        // é¢„å†™å…¥æ—¥å¿—
        logModule.writeLocalLog(Collections.singletonList(newLogEntry));

        logger.info("handle setCommand, do writeLocalLog success!");

        List&lt;AppendEntriesRpcResult&gt; appendEntriesRpcResultList = logModule.replicationLogEntry(newLogEntry);

        logger.info("do replicationLogEntry, result={}",appendEntriesRpcResultList);

        // successNuméœ€è¦åŠ ä¸Šè‡ªå·±çš„1ç¥¨
        long successNum = appendEntriesRpcResultList.stream().filter(AppendEntriesRpcResult::isSuccess).count() + 1;
        if(successNum &gt;= this.raftConfig.getMajorityNum()){
            // If command received from client: append entry to local log, respond after entry applied to state machine (Â§5.3)

            // æˆåŠŸå¤åˆ¶åˆ°å¤šæ•°èŠ‚ç‚¹

            // è®¾ç½®æœ€æ–°çš„å·²æäº¤ç´¢å¼•ç¼–å·
            logModule.setLastCommittedIndex(newLogEntry.getLogIndex());
            // ä½œç”¨åˆ°çŠ¶æ€æœºä¸Š
            this.kvReplicationStateMachine.apply((SetCommand) newLogEntry.getCommand());
            // æ€è€ƒä¸€ä¸‹ï¼šlastAppliedä¸ºä»€ä¹ˆä¸éœ€è¦æŒä¹…åŒ–ï¼Ÿ çŠ¶æ€æœºæŒ‡ä»¤çš„åº”ç”¨å’Œæ›´æ–°lastAppliedéåŸå­æ€§ä¼šäº§ç”Ÿä»€ä¹ˆé—®é¢˜ï¼Ÿ
            logModule.setLastApplied(newLogEntry.getLogIndex());

            // è¿”å›æˆåŠŸ
            ClientRequestResult clientRequestResult = new ClientRequestResult();
            clientRequestResult.setSuccess(true);

            return clientRequestResult;
        }else{
            // æ²¡æœ‰æˆåŠŸå¤åˆ¶åˆ°å¤šæ•°,è¿”å›å¤±è´¥
            ClientRequestResult clientRequestResult = new ClientRequestResult();
            clientRequestResult.setSuccess(false);

            // åˆ æ‰ä¹‹å‰é¢„å†™å…¥çš„æ—¥å¿—æ¡ç›®
            // æ€è€ƒä¸€ä¸‹å¦‚æœåˆ é™¤å®Œæˆä¹‹å‰ï¼Œå®•æœºäº†æœ‰é—®é¢˜å—ï¼Ÿ ä¸ªäººæ„Ÿè§‰æ˜¯okçš„
            logModule.deleteLocalLog(newLogEntry.getLogIndex());

            return clientRequestResult;
        }
    }
Copy<br><br>ä¸‹é¢è¯¦ç»†ä»‹ç»leaderæ˜¯å¦‚ä½•å‘é›†ç¾¤å¹¿æ’­raftLogçš„ã€‚<br>
<br>raftçš„leaderç»´æŠ¤äº†ä¸¤ä¸ªéæŒä¹…åŒ–çš„æ•°æ®(Volatile state on leaders)ï¼Œå³åœ¨å½“å‰leaderè§†è§’ä¸‹followerèŠ‚ç‚¹åŒæ­¥raftLogçš„è¿›åº¦ã€‚<br>
ä¸€ä¸ªæ•°æ®æ˜¯nextIndexï¼Œä»£è¡¨leaderè®¤ä¸ºçš„followeråº”è¯¥æ¥æ”¶çš„ä¸‹ä¸€æ¡logçš„ç´¢å¼•å€¼ï¼Œleaderåˆå§‹åŒ–æ—¶ä¹è§‚çš„ä¼°è®¡è®¾ç½®å…¶ä¸ºleaderå½“å‰æœ€åä¸€æ¡æ—¥å¿—ç´¢å¼•å€¼åŠ 1(ä»£è¡¨ç€ä¹è§‚ä¼°è®¡followerå’Œleaderçš„æ—¥å¿—è¿›åº¦æ˜¯å®Œå…¨ä¸€è‡´çš„)ã€‚<br>
ä¸€ä¸ªæ•°æ®æ˜¯matchIndexï¼Œä»£è¡¨leaderå®é™…ç¡®è®¤çš„followerå·²æ¥å—åˆ°çš„æœ€åä¸€æ¡raftæ—¥å¿—çš„ç´¢å¼•å€¼ï¼Œleaderåˆå§‹åŒ–æ—¶æ‚²è§‚çš„å°†å…¶åˆå§‹åŒ–ä¸º0ã€‚<br>
ç”±äºfolloweræ˜¯ä¸€ä¸ªé›†åˆï¼Œæ‰€ä»¥è®ºæ–‡ä¸­é€šè¿‡nextIndex[],matchIndex[]æ¥æè¿°ï¼Œè€Œåœ¨MyRaftä¸­éƒ½ç”¨Mapç»“æ„æ¥ç»´æŠ¤ã€‚
<br>leaderåŸºäºæ¯ä¸ªfollowerå¯¹åº”çš„nextIndexæŸ¥æ‰¾å‡ºæ‰€è¦å‘é€çš„æ—¥å¿—é›†åˆï¼Œå¹¶è¡Œçš„å‘æ‰€æœ‰followerå‘é€appendEntriesçš„rpcè¯·æ±‚ã€‚<br>
å½“leaderä¸followerè¿›è¡Œrpcäº¤äº’æ—¶ï¼Œå¯èƒ½followerçš„æ—¥å¿—åŒæ­¥è¿›åº¦å¹¶ä¸åƒleaderè®¤ä¸ºçš„é‚£æ ·ä¹è§‚ï¼Œå¾ˆå¯èƒ½å…¶å®é™…æ‰€æ‹¥æœ‰çš„æ—¥å¿—ç´¢å¼•è¿œå°äºleaderæœ€åä¸€æ¡æ—¥å¿—çš„ç´¢å¼•(followerä¾§çš„é€»è¾‘åœ¨ä¸‹ä¸€èŠ‚åˆ†æ)ã€‚<br>
å› æ­¤followeråœ¨è¿™ç§æƒ…å†µä¸‹ä¼šè¿”å›å¤±è´¥ï¼Œæ­¤æ—¶leaderä¼šå°†å¯¹åº”followerçš„nextIndexå¾€å›é€€(è‡ªå‡1)ï¼Œå¾ªç¯å¾€å¤çš„äº¤äº’ç›´åˆ°leaderå‘é€å’Œfolloweræ‰€éœ€çš„æ—¥å¿—ç›¸åŒ¹é…çš„é‚£æ¡æ—¥å¿—(æœ€åæƒ…å†µä¸‹followerä¸€æ¡æ—¥å¿—éƒ½æ²¡æœ‰ï¼Œleaderä»ç¬¬ä¸€æ¡æ—¥å¿—å¼€å§‹åŒæ­¥)
<br>å½“followerå“åº”æˆåŠŸåï¼Œleaderå°†ä¼šæ›´æ–°å¯¹åº”followerçš„nextIndexå’ŒmatchIndexçš„å€¼ã€‚å½“è¶…è¿‡åŠæ•°çš„followeréƒ½å“åº”äº†å¯¹åº”indexæ—¥å¿—çš„appendEntriesåï¼Œleaderè®¤ä¸ºå½“å‰æ—¥å¿—å·²ç»æˆåŠŸçš„å¤åˆ¶åˆ°é›†ç¾¤ä¸­å¤šæ•°çš„èŠ‚ç‚¹ä¸­äº†ï¼Œåˆ™å¯ä»¥å®‰å…¨çš„å°†æ—¥å¿—æäº¤åˆ°çŠ¶æ€æœºä¸­äº†ã€‚
<br>/**
     * å‘é›†ç¾¤å¹¿æ’­ï¼Œä»¤followerå¤åˆ¶æ–°çš„æ—¥å¿—æ¡ç›®
     * */
    public List&lt;AppendEntriesRpcResult&gt; replicationLogEntry(LogEntry lastEntry) {
        List&lt;RaftService&gt; otherNodeInCluster = currentServer.getOtherNodeInCluster();

        List&lt;Future&lt;AppendEntriesRpcResult&gt;&gt; futureList = new ArrayList&lt;&gt;(otherNodeInCluster.size());

        for(RaftService node : otherNodeInCluster){
            // å¹¶è¡Œå‘é€rpcï¼Œè¦æ±‚followerå¤åˆ¶æ—¥å¿—
            Future&lt;AppendEntriesRpcResult&gt; future = this.rpcThreadPool.submit(()-&gt;{
                logger.info("replicationLogEntry start!");

                long nextIndex = this.currentServer.getNextIndexMap().get(node);

                AppendEntriesRpcResult finallyResult = null;

                // If last log index â‰¥ nextIndex for a follower: send AppendEntries RPC with log entries starting at nextIndex
                while(lastEntry.getLogIndex() &gt;= nextIndex){
                    AppendEntriesRpcParam appendEntriesRpcParam = new AppendEntriesRpcParam();
                    appendEntriesRpcParam.setLeaderId(currentServer.getServerId());
                    appendEntriesRpcParam.setTerm(currentServer.getCurrentTerm());
                    appendEntriesRpcParam.setLeaderCommit(this.lastCommittedIndex);

                    int appendLogEntryBatchNum = this.currentServer.getRaftConfig().getAppendLogEntryBatchNum();

                    // è¦å‘é€çš„æ—¥å¿—æœ€å¤§indexå€¼
                    // (è¿½è¿›åº¦çš„æ—¶å€™ï¼Œå°±æ˜¯nextIndexå¼€å§‹æ‰¹é‡å‘é€appendLogEntryBatchNum-1æ¡(å·¦é—­å³é—­åŒºé—´)ï¼›å¦‚æœè¿›åº¦å·®ä¸å¤šé‚£å°±æ˜¯ä»¥lastEntry.indexä¸ºç•Œé™å…¨éƒ¨å‘é€å‡ºå»)
                    long logIndexEnd = Math.min(nextIndex+(appendLogEntryBatchNum-1), lastEntry.getLogIndex());
                    // è¯»å–å‡º[nextIndex-1,logIndexEnd]çš„æ—¥å¿—(å·¦é—­å³é—­åŒºé—´),-1å¾€å‰ä¸€ä½æ˜¯ä¸ºäº†è¯»å–å‡ºpreLogçš„ä¿¡æ¯
                    List&lt;LocalLogEntry&gt; localLogEntryList = this.readLocalLog(nextIndex-1,logIndexEnd);

                    logger.info("replicationLogEntry doing! nextIndex={},logIndexEnd={},LocalLogEntryList={}",
                        nextIndex,logIndexEnd,JsonUtil.obj2Str(localLogEntryList));

                    List&lt;LogEntry&gt; logEntryList = localLogEntryList.stream()
                        .map(LogEntry::toLogEntry)
                        .collect(Collectors.toList());

                    // ç´¢å¼•åŒºé—´å¤§å°
                    long indexRange = (logIndexEnd - nextIndex + 1);
                    if(logEntryList.size() == indexRange+1){
                        // ä¸€èˆ¬æƒ…å†µèƒ½æŸ¥å‡ºåŒºé—´å†…çš„æ‰€æœ‰æ—¥å¿—

                        logger.info("find log size match!");
                        // preLog
                        LogEntry preLogEntry = logEntryList.get(0);
                        // å®é™…éœ€è¦ä¼ è¾“çš„log
                        List&lt;LogEntry&gt; needAppendLogList = logEntryList.subList(1,logEntryList.size());
                        appendEntriesRpcParam.setEntries(needAppendLogList);
                        appendEntriesRpcParam.setPrevLogIndex(preLogEntry.getLogIndex());
                        appendEntriesRpcParam.setPrevLogTerm(preLogEntry.getLogTerm());
                    }else if(logEntryList.size() &gt; 0 &amp;&amp; logEntryList.size() &lt;= indexRange){
                        logger.info("find log size not match!");
                        // æ—¥å¿—é•¿åº¦å°äºç´¢å¼•åŒºé—´å€¼ï¼Œè¯´æ˜å·²ç»æŸ¥åˆ°æœ€å‰é¢çš„æ—¥å¿— (æ¯”å¦‚appendLogEntryBatchNum=5ï¼Œä½†ä¸€å…±åªæœ‰3æ¡æ—¥å¿—å…¨æŸ¥å‡ºæ¥äº†)
                        appendEntriesRpcParam.setEntries(logEntryList);

                        // çº¦å®šå¥½ç¬¬ä¸€æ¡è®°å½•çš„prevçš„indexå’Œterméƒ½æ˜¯-1
                        appendEntriesRpcParam.setPrevLogIndex(-1);
                        appendEntriesRpcParam.setPrevLogTerm(-1);
                    } else{
                        // æ­£å¸¸æƒ…å†µæ˜¯å…ˆæŒä¹…åŒ–ç„¶åå†å¹¿æ’­åŒæ­¥æ—¥å¿—ï¼Œæ‰€ä»¥sizeè‚¯å®šä¼šå¤§äº0ï¼Œä¹Ÿä¸åº”è¯¥è¶…è¿‡ç´¢å¼•åŒºé—´å€¼
                        // èµ°åˆ°è¿™é‡Œä¸ç¬¦åˆé¢„æœŸï¼Œæ—¥å¿—æ¨¡å—æœ‰bug
                        throw new MyRaftException("replicationLogEntry logEntryList size error!" +
                            " nextIndex=" + nextIndex + " logEntryList.size=" + logEntryList.size());
                    }

                    logger.info("leader do appendEntries start, node={}, appendEntriesRpcParam={}",node,appendEntriesRpcParam);
                    AppendEntriesRpcResult appendEntriesRpcResult = node.appendEntries(appendEntriesRpcParam);
                    logger.info("leader do appendEntries end, node={}, appendEntriesRpcResult={}",node,appendEntriesRpcResult);

                    finallyResult = appendEntriesRpcResult;
                    // æ”¶åˆ°æ›´é«˜ä»»æœŸçš„å¤„ç†
                    boolean beFollower = currentServer.processCommunicationHigherTerm(appendEntriesRpcResult.getTerm());
                    if(beFollower){
                        return appendEntriesRpcResult;
                    }

                    if(appendEntriesRpcResult.isSuccess()){
                        logger.info("appendEntriesRpcResult is success, node={}",node);

                        // If successful: update nextIndex and matchIndex for follower (Â§5.3)

                        // åŒæ­¥æˆåŠŸäº†ï¼ŒnextIndexé€’å¢ä¸€ä½
                        this.currentServer.getNextIndexMap().put(node,nextIndex+1);
                        this.currentServer.getMatchIndexMap().put(node,nextIndex);

                        nextIndex++;
                    }else{
                        // å› ä¸ºæ—¥å¿—å¯¹ä¸ä¸Šå¯¼è‡´ä¸€è‡´æ€§æ£€æŸ¥æ²¡é€šè¿‡ï¼ŒåŒæ­¥æ²¡æˆåŠŸï¼ŒnextIndexå¾€åé€€ä¸€ä½

                        logger.info("appendEntriesRpcResult is false, node={}",node);

                        // If AppendEntries fails because of log inconsistency: decrement nextIndex and retry (Â§5.3)
                        nextIndex--;
                        this.currentServer.getNextIndexMap().put(node,nextIndex);
                    }
                }

                if(finallyResult == null){
                    // è¯´æ˜æœ‰bug
                    throw new MyRaftException("replicationLogEntry finallyResult is null!");
                }

                logger.info("finallyResult={},node={}",node,finallyResult);

                return finallyResult;
            });

            futureList.add(future);
        }

        // è·å¾—ç»“æœ
        List&lt;AppendEntriesRpcResult&gt; appendEntriesRpcResultList = CommonUtil.concurrentGetRpcFutureResult(
                "do appendEntries", futureList,
                this.rpcThreadPool,2, TimeUnit.SECONDS);

        logger.info("leader replicationLogEntry appendEntriesRpcResultList={}",appendEntriesRpcResultList);

        return appendEntriesRpcResultList;
    }
Copy<br><br>
<br>ç›¸æ¯”lab1ï¼Œlab2ç‰ˆæœ¬çš„appendEntriesé™¤äº†ä¹‹å‰å·²æœ‰çš„é’ˆå¯¹leaderä»»æœŸç›¸å…³çš„æ ¡éªŒå’Œå¤„ç†é€»è¾‘å¤–ï¼Œè¿˜æ–°å¢äº†æ—¥å¿—å¤åˆ¶ç›¸å…³çš„é€»è¾‘ã€‚
<br>raftLogæ˜¯é¡ºåºä¿å­˜çš„ï¼Œä¸ºäº†æ—¥å¿—å¤åˆ¶çš„å®‰å…¨æ€§ï¼Œraftçš„followerèŠ‚ç‚¹ä¹Ÿå¿…é¡»å’Œleaderä¿æŒä¸€è‡´ï¼Œå°†æ—¥å¿—æŒ‰ç…§indexç´¢å¼•å€¼ä»¥ä»å°åˆ°å¤§çš„é¡ºåºå­˜åœ¨æœ¬åœ°çš„raftæ—¥å¿—æ–‡ä»¶ä¸­ã€‚<br>
å› æ­¤åªæœ‰åœ¨å·²æœ‰ç¬¬0-ç¬¬Næ¡æ—¥å¿—çš„æƒ…å†µä¸‹ï¼Œfolloweræ‰èƒ½å¤Ÿå®‰å…¨çš„å°†ç¬¬N+1æ¡æ—¥å¿—è¿½åŠ åˆ°æœ¬åœ°æ—¥å¿—æ–‡ä»¶ä¸­ã€‚ä¸ºæ­¤raftä½œè€…è®¾è®¡äº†ä¸€ç³»åˆ—çš„æ ¡éªŒè§„åˆ™æ¥ä¿è¯è¿™ä¸€ç‚¹ã€‚
<br>é¦–å…ˆï¼Œleaderåœ¨å‘èµ·appendEntrieså‘½ä»¤followerå¤åˆ¶ç¬¬Næ¡(logIndex=N)æ—¥å¿—æ—¶ï¼Œä¼šå°†ç¬¬å‰ä¸€æ¡æ—¥å¿—(N-1)çš„termå€¼(prevLogTerm)å’Œindexå€¼(prevLogIndex)ä½œä¸ºå‚æ•°ä¸€å¹¶ä¼ é€’ï¼Œfollowerä¼šå¯¹è¿™ä¸¤ä¸ªå€¼è¿›è¡Œæ ¡éªŒä»¥å†³å®šæ˜¯å¦èƒ½å®‰å…¨çš„å¤åˆ¶æ—¥å¿—ã€‚<br>
followerä¼šæŸ¥è¯¢å‡ºå¯¹åº”ç´¢å¼•ä¸ºprevLogIndexçš„æ—¥å¿—ï¼Œå¦‚æœæ²¡æŸ¥å‡ºæ¥è¯´æ˜è¿›åº¦æ²¡è·Ÿä¸Šleaderé‚£è‡ªç„¶è¦è¿”å›å¤åˆ¶å¤±è´¥ï¼Œè®©leaderé‡è¯•æŠŠlogIndexæ›´å°ã€æ›´å‰é¢çš„æ—¥å¿—å‘è¿‡æ¥ã€‚<br>
å¦‚æœæŸ¥å‡ºæ¥äº†å¯¹åº”çš„æ—¥å¿—åˆ™è¿˜éœ€è¦è¿›ä¸€æ­¥å¯¹æ¯”è¯·æ±‚å‚æ•°ä¸­çš„prevLogTermå’Œfolloweræœ¬åœ°å¯¹åº”æ—¥å¿—çš„termå€¼æ˜¯å¦ä¸€è‡´ï¼Œå¦‚æœä¸€è‡´åˆ™æ ¡éªŒé€šè¿‡ï¼›å¦‚æœä¸ä¸€è‡´åˆ™è¯´æ˜followerä¿å­˜äº†ä¸€ä¸ªå’Œleaderä¸ä¸€è‡´ä¸”æœªæœ€ç»ˆæäº¤çš„æ—¥å¿—ï¼Œä¹Ÿè¦è¿”å›å¤±è´¥ï¼Œè®©leaderæŠŠæ›´å‰é¢çš„æ—¥å¿—å‘è¿‡æ¥(å…·ä½“åŸç†åé¢ä¼šåˆ†æ)ã€‚
<br>å½“followerè¿™è¾¹å¯¹äºprevLogTermå’ŒprevLogIndexçš„æ ¡éªŒéƒ½é€šè¿‡äº†åï¼Œè¯´æ˜leaderæ­¤æ—¶å·²ç»æ‰¾åˆ°äº†followeræ°å¥½éœ€è¦çš„æ—¥å¿—(æ—¥å¿—åŒæ­¥çš„è¿›åº¦åŒ¹é…ä¸Šäº†)ï¼Œåˆ™followeréœ€è¦å°†å‘é€è¿‡æ¥çš„æ—¥å¿—å†™å…¥æœ¬åœ°æ—¥å¿—æ–‡ä»¶ä¸­ã€‚<br>
å¦‚æœleaderå‘è¿‡æ¥çš„æ—¥å¿—é‡Œå¯¹åº”indexçš„æœ¬åœ°æ—¥å¿—ä¸å­˜åœ¨åˆ™ç›´æ¥è¿½åŠ åˆ°followeræœ¬åœ°æ—¥å¿—æ–‡ä»¶ä¸­å³å¯ï¼›å¦‚æœä¹‹å‰å·²å­˜åœ¨åˆ™è¦†ç›–æ‰åŸæ¥çš„æ—¥å¿—å³å¯ã€‚
<br>å½“ä¸€å¼€å§‹followeræ²¡æœ‰è¿½ä¸Šleaderçš„æ—¥å¿—è¿›åº¦æ—¶(æ¯”å¦‚followerå®•æœºäº†ä¸€æ®µæ—¶é—´å†å›åˆ°é›†ç¾¤)ï¼Œfollowerä¼šä¸€ç›´è¿”å›åŒæ­¥å¤±è´¥ï¼Œleaderåˆ™ä¼šä¸€ç›´å‘å‰æ‰¾ç›´åˆ°æ‰¾åˆ°followeræ‰€æ°å¥½éœ€è¦çš„é‚£æ¡æ—¥å¿—ã€‚åœ¨è¿™ä¹‹åçš„æ—¥å¿—åŒæ­¥å°±ä¼šååˆ†é¡ºåˆ©äº†ï¼Œç›´åˆ°followerå’Œleaderçš„æ—¥å¿—å®Œå…¨ä¸€è‡´ã€‚
<br>è€ƒè™‘åˆ°followerå¯èƒ½å’Œleaderçš„æ—¥å¿—è¿›åº¦ç›¸å·®è¿‡å¤§ï¼Œä¸€æ¬¡å›é€€ä¸€ä¸ªç´¢å¼•å€¼çš„åŒ¹é…ç­–ç•¥æ•ˆç‡å¹¶ä¸é«˜ã€‚è®ºæ–‡ä¸­æåˆ°ä¸€ç§å¯è¡Œçš„ä¼˜åŒ–æ˜¯è®©followerç›´æ¥æŠŠè‡ªå·±çš„æœ€åä¸€ä¸ªæ—¥å¿—ï¼Œæˆ–è€…å€’æ•°ç¬¬Nä¸ªæ—¥å¿—çš„ä¿¡æ¯(termå’Œindex)è¿”å›ç»™leaderï¼Œleaderå°±èƒ½å¤Ÿå¾ˆå¿«çš„ä»æ­£ç¡®çš„æ—¥å¿—ä½ç‚¹å¼€å§‹åŒæ­¥ã€‚<br>
ä½†è¿™æ ·ä¼šå¢åŠ ç¨‹åºçš„å¤æ‚åº¦å¹¶é™ä½æ­£å¸¸æƒ…å†µä¸‹è¿›åº¦ä¸€è‡´æ—¶æ—¥å¿—åŒæ­¥çš„æ•ˆç‡ï¼Œè®ºæ–‡çš„ä½œè€…è®¤ä¸ºå‡ºç°è¿™ä¸€é—®é¢˜çš„æ¦‚ç‡å¾ˆä½å› æ­¤è¯¥ä¼˜åŒ–æ˜¯ä¸å¿…è¦çš„ï¼Œç®€å•èµ·è§MyRaftä¹Ÿæ²¡æœ‰åšç›¸å…³çš„ä¼˜åŒ–ã€‚
<br>followeråœ¨æˆåŠŸå°†æ—¥å¿—è½ç›˜åï¼Œæ ¹æ®è¯·æ±‚å‚æ•°ä¸­çš„leaderCommitå€¼å’Œè‡ªå·±æœ¬åœ°çš„lastCommittedIndex(æœ€å¤§å·²æäº¤æ—¥å¿—ç´¢å¼•å·)æ¥åˆ¤æ–­æ˜¯å¦åº”è¯¥å°†æœ¬åœ°çš„raftLogæäº¤åˆ°çŠ¶æ€æœºä¸­æ‰§è¡Œã€‚<br>
å¦‚æœå‚æ•°leaderCommitå¤§äºæœ¬åœ°çš„lastCommittedIndexï¼Œè¯´æ˜leaderå·²ç»æŠŠä¸€äº›æ—¥å¿—æäº¤åˆ°çŠ¶æ€æœºä¸­äº†ï¼Œè€Œfollowerè¿˜æ²¡æœ‰ã€‚é‚£ä¹ˆfolloweréœ€è¦è·Ÿä¸Šleaderçš„è¿›åº¦(ä¸ä½†æ—¥å¿—è¿›åº¦è¦åŒ¹é…ï¼ŒçŠ¶æ€æœºè¿›åº¦ä¹Ÿè¦åŒ¹é…)ã€‚<br>
éœ€è¦æäº¤åˆ°çŠ¶æ€æœºä¸­æ—¥å¿—æœ€å¤§çš„indexå€¼ä¸ºleaderCommitå’Œå½“å‰æœ€æ–°ä¸€æ¡æ—¥å¿—çš„indexæœ€å°å€¼(index of last new entry)ï¼Œå¦‚æœleaderCommitæ˜¯æœ€å°å€¼ï¼Œè¯´æ˜followerå·²ç»èµ¶ä¸Šäº†leaderï¼Œleaderæäº¤çš„æ—¥å¿—followeræœ¬åœ°éƒ½æœ‰ã€‚<br>
è€Œå¦‚æœindex of last new entryæ˜¯æ›´å°çš„ï¼Œè¯´æ˜å½“å‰followerè¿˜æ²¡æœ‰è¿½ä¸Šleaderæäº¤åˆ°çŠ¶æ€æœºçš„è¿›åº¦ï¼ŒæŠŠå½“å‰å·²æœ‰çš„æ‰€æœ‰æœ¬åœ°æ—¥å¿—éƒ½æäº¤åˆ°çŠ¶æ€æœºä¸­å³å¯(pushStatemachineApplyæ–¹æ³•)ã€‚
<br><br>raftè®ºæ–‡åœ¨ç¬¬5.3èŠ‚é‡ç‚¹è§£é‡Šäº†ä¸€ä¸‹åŸå› ã€‚<br>
<br>ä¸¾ä¸ªä¾‹å­ï¼Œä¸€ä¸ª5èŠ‚ç‚¹çš„é›†ç¾¤ï¼ŒèŠ‚ç‚¹ç¼–å·åˆ†åˆ«æ˜¯abcdeã€‚åœ¨ä»»æœŸ1ä¸­aæ˜¯leaderï¼Œå°è¯•å‘é›†ç¾¤å¤åˆ¶ä¸€ä¸ªæ—¥å¿—(index=1ï¼Œterm=1ï¼Œset k1=v1)ï¼Œä½†æ˜¯å¤åˆ¶æ—¶å¤±è´¥äº†ï¼Œåªæœ‰èŠ‚ç‚¹bæˆåŠŸçš„å¤åˆ¶äº†è¯¥æ—¥å¿—ï¼Œè€Œcdeéƒ½æ²¡æœ‰æŒæœ‰æ—¥å¿—ã€‚
<br>æ°å¥½è¿™æ—¶leader aå®•æœºäº†ï¼Œè§¦å‘æ–°é€‰ä¸¾åèŠ‚ç‚¹cæˆä¸ºäº†æ–°çš„leader(ä»»æœŸterm=2)ã€‚cæ¥å—åˆ°å®¢æˆ·ç«¯è¯·æ±‚ï¼Œä¹Ÿå°è¯•å‘é›†ç¾¤å¤åˆ¶ä¸€ä¸ªæ—¥å¿—(index=1ï¼Œterm=2, set k1=v2)ï¼Œè¿™ä¸ªæ—¶å€™èŠ‚ç‚¹bæœ‰ä¸€ä¸ªindex=1ï¼Œè¿™ä¸ªæ—¶å€™èŠ‚ç‚¹bå¿…é¡»è®©æ–°çš„æ—¥å¿—è¦†ç›–æ‰è€çš„æ—¥å¿—æ‰èƒ½å’Œleaderä¿æŒä¸€è‡´ã€‚
<br>cçš„è¿™æ¬¡æ—¥å¿—å¤åˆ¶æˆåŠŸäº†ï¼Œbcdeå››ä¸ªèŠ‚ç‚¹éƒ½æŒæœ‰äº†è¯¥æ—¥å¿—ï¼Œåˆ™rafté›†ç¾¤ä¾¿å¯ä»¥å°†è¿™ä¸ªæ—¥å¿—æäº¤åˆ°çŠ¶æ€æœºä¸­äº†ï¼Œæœ€åé›†ç¾¤çš„æ‰€æœ‰çŠ¶æ€æœºä¸­k1çš„å€¼å°†ä¼šæ˜¯v2ï¼Œè€Œä¸æ˜¯ä¹‹å‰å¤åˆ¶å¤±è´¥è€Œæœªæäº¤çš„v1ã€‚<br>
<img alt="Pasted image 20240725172453.png" src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raftå®ç°/pasted-image-20240725172453.png">
<br>    public AppendEntriesRpcResult appendEntries(AppendEntriesRpcParam appendEntriesRpcParam) {
        if(appendEntriesRpcParam.getTerm() &lt; this.raftServerMetaDataPersistentModule.getCurrentTerm()){
            // Reply false if term &lt; currentTerm (Â§5.1)
            // æ‹’ç»å¤„ç†ä»»æœŸä½äºè‡ªå·±çš„è€leaderçš„è¯·æ±‚

            logger.info("doAppendEntries term &lt; currentTerm");
            return new AppendEntriesRpcResult(this.raftServerMetaDataPersistentModule.getCurrentTerm(),false);
        }

        if(appendEntriesRpcParam.getTerm() &gt;= this.raftServerMetaDataPersistentModule.getCurrentTerm()){
            // appendEntriesè¯·æ±‚ä¸­ä»»æœŸå€¼å¦‚æœå¤§äºè‡ªå·±ï¼Œè¯´æ˜å·²ç»æœ‰ä¸€ä¸ªæ›´æ–°çš„leaderäº†ï¼Œè‡ªå·±è½¬ä¸ºfollowerï¼Œå¹¶ä¸”ä»¥å¯¹æ–¹æ›´å¤§çš„ä»»æœŸä¸ºå‡†
            this.serverStatusEnum = ServerStatusEnum.FOLLOWER;
            this.currentLeader = appendEntriesRpcParam.getLeaderId();
            this.raftServerMetaDataPersistentModule.setCurrentTerm(appendEntriesRpcParam.getTerm());
        }

        if(appendEntriesRpcParam.getEntries() == null || appendEntriesRpcParam.getEntries().isEmpty()){
            // æ¥è‡ªleaderçš„å¿ƒè·³å¤„ç†ï¼Œæ¸…ç†æ‰ä¹‹å‰é€‰ä¸¾çš„votedFor
            this.cleanVotedFor();
            // entriesä¸ºç©ºï¼Œè¯´æ˜æ˜¯å¿ƒè·³è¯·æ±‚ï¼Œåˆ·æ–°ä¸€ä¸‹æœ€è¿‘æ”¶åˆ°å¿ƒè·³çš„æ—¶é—´
            raftLeaderElectionModule.refreshLastHeartbeatTime();

            long currentLastCommittedIndex = logModule.getLastCommittedIndex();
            logger.debug("doAppendEntries heartbeat leaderCommit={},currentLastCommittedIndex={}",
                appendEntriesRpcParam.getLeaderCommit(),currentLastCommittedIndex);

            if(appendEntriesRpcParam.getLeaderCommit() &gt; currentLastCommittedIndex) {
                // å¿ƒè·³å¤„ç†é‡Œï¼Œå¦‚æœleaderå½“å‰å·²æäº¤çš„æ—¥å¿—è¿›åº¦è¶…è¿‡äº†å½“å‰èŠ‚ç‚¹çš„è¿›åº¦ï¼Œä»¤å½“å‰èŠ‚ç‚¹çŠ¶æ€æœºä¹Ÿè·Ÿä¸Š
                // å¦‚æœleaderCommit &gt;= logModule.getLastIndex(),è¯´æ˜å½“å‰èŠ‚ç‚¹çš„æ—¥å¿—è¿›åº¦ä¸è¶³ï¼Œä½†å¯ä»¥æŠŠç›®å‰å·²æœ‰çš„æ—¥å¿—éƒ½æäº¤ç»™çŠ¶æ€æœºå»æ‰§è¡Œ
                // å¦‚æœleaderCommit &lt; logModule.getLastIndex(),è¯´æ˜å½“å‰èŠ‚ç‚¹è¿›åº¦æ¯”è¾ƒå¿«ï¼Œæœ‰ä¸€äº›æ—¥å¿—æ˜¯leaderå·²å¤åˆ¶ä½†è¿˜æ²¡æäº¤çš„ï¼ŒæŠŠleaderå·²æäº¤çš„é‚£ä¸€éƒ¨åˆ†ä½œç”¨åˆ°çŠ¶æ€æœºå°±è¡Œ
                long minNeedCommittedIndex = Math.min(appendEntriesRpcParam.getLeaderCommit(), logModule.getLastIndex());
                pushStatemachineApply(minNeedCommittedIndex);
            }

            // å¿ƒè·³è¯·æ±‚ï¼Œç›´æ¥è¿”å›
            return new AppendEntriesRpcResult(this.raftServerMetaDataPersistentModule.getCurrentTerm(),true);
        }

        // logEntriesä¸ä¸ºç©ºï¼Œæ˜¯çœŸå®çš„æ—¥å¿—å¤åˆ¶rpc

        logger.info("do real log append! appendEntriesRpcParam={}",appendEntriesRpcParam);
        // AppendEntryå¯é æ€§æ ¡éªŒï¼Œå¦‚æœprevLogIndexå’ŒprevLogTermä¸åŒ¹é…ï¼Œåˆ™éœ€è¦è¿”å›falseï¼Œè®©leaderå‘æ›´æ—©çš„æ—¥å¿—è¿‡æ¥
        {
            LogEntry localPrevLogEntry = logModule.readLocalLog(appendEntriesRpcParam.getPrevLogIndex());
            if(localPrevLogEntry == null){
                // å½“å‰èŠ‚ç‚¹æ—¥å¿—æ¡ç›®ä¸ºç©ºï¼Œè¯´æ˜å®Œå…¨æ²¡æœ‰æ—¥å¿—(é»˜è®¤ä»»æœŸä¸º-1ï¼Œè¿™ä¸ªæ˜¯çº¦å®š)
                localPrevLogEntry = LogEntry.getEmptyLogEntry();
            }

            if (localPrevLogEntry.getLogTerm() != appendEntriesRpcParam.getPrevLogTerm()) {
                //  Reply false if log doesnâ€™t contain an entry at prevLogIndex
                //  whose term matches prevLogTerm (Â§5.3)
                //  æœ¬åœ°æ—¥å¿—å’Œå‚æ•°ä¸­çš„PrevLogIndexå’ŒPrevLogTermå¯¹ä¸ä¸Š(å¯¹åº”æ—¥å¿—ä¸å­˜åœ¨ï¼Œæˆ–è€…ä»»æœŸå¯¹ä¸ä¸Š)
                logger.info("doAppendEntries localPrevLogEntry not match, localLogEntry={}",localPrevLogEntry);

                return new AppendEntriesRpcResult(this.raftServerMetaDataPersistentModule.getCurrentTerm(),false);
            }
        }

        // èµ°åˆ°è¿™é‡Œè¯´æ˜æ‰¾åˆ°äº†æœ€æ–°çš„ä¸€æ¡åŒ¹é…çš„è®°å½•
        logger.info("doAppendEntries localEntry is match");

        List&lt;LogEntry&gt; newLogEntryList = appendEntriesRpcParam.getEntries();

        // 1. Append any new entries not already in the log
        // 2. If an existing entry conflicts with a new one (same index but different terms),
        //    delete the existing entry and all that follow it (Â§5.3)
        // æ–°æ—¥å¿—çš„å¤åˆ¶æ“ä½œï¼ˆç›´æ¥æ•´ä¸ªè¦†ç›–æ‰prevLogIndexä¹‹åçš„æ‰€æœ‰æ—¥å¿—,ä»¥leaderå‘è¿‡æ¥çš„æ—¥å¿—ä¸ºå‡†ï¼‰
        logModule.writeLocalLog(newLogEntryList, appendEntriesRpcParam.getPrevLogIndex());

        // If leaderCommit &gt; commitIndex, set commitIndex = min(leaderCommit, index of last new entry)
        if(appendEntriesRpcParam.getLeaderCommit() &gt; logModule.getLastCommittedIndex()){
            // å¦‚æœleaderCommitæ›´å¤§ï¼Œè¯´æ˜å½“å‰èŠ‚ç‚¹çš„åŒæ­¥è¿›åº¦æ…¢äºleaderï¼Œä»¥æ–°çš„entryé‡Œçš„indexä¸ºå‡†(æ›´é«˜çš„indexè¿˜æ²¡æœ‰åœ¨æœ¬åœ°ä¿å­˜(å› ä¸ºä¸Šé¢çš„appendEntryæœ‰æ•ˆæ€§æ£€æŸ¥))
            // å¦‚æœindex of last new entryæ›´å¤§ï¼Œè¯´æ˜å½“å‰èŠ‚ç‚¹çš„åŒæ­¥è¿›åº¦æ˜¯å’Œleaderç›¸åŒ¹é…çš„ï¼ŒcommitIndexä»¥leaderæœ€æ–°æäº¤çš„ä¸ºå‡†

            LogEntry lastNewEntry = newLogEntryList.get(newLogEntryList.size()-1);
            long lastCommittedIndex = Math.min(appendEntriesRpcParam.getLeaderCommit(), lastNewEntry.getLogIndex());
            pushStatemachineApply(lastCommittedIndex);
        }

        // è¿”å›æˆåŠŸ
        return new AppendEntriesRpcResult(this.raftServerMetaDataPersistentModule.getCurrentTerm(), true);
    }

    private void pushStatemachineApply(long lastCommittedIndex){
        long lastApplied = logModule.getLastApplied();

        // If commitIndex &gt; lastApplied: increment lastApplied, apply log[lastApplied] to state machine (Â§5.3)
        if(lastApplied &lt; lastCommittedIndex){
            // ä½œç”¨åœ¨çŠ¶æ€æœºä¸Šçš„æ—¥å¿—ç¼–å·ä½äºé›†ç¾¤ä¸­å·²æäº¤çš„æ—¥å¿—ç¼–å·ï¼Œéœ€è¦æŠŠè¿™äº›å·²æäº¤çš„æ—¥å¿—éƒ½ä½œç”¨åˆ°çŠ¶æ€æœºä¸Šå»
            logger.info("pushStatemachineApply.apply, lastApplied={},lastCommittedIndex={}",lastApplied,lastCommittedIndex);

            // å…¨è¯»å–å‡ºæ¥(è¯»å–å‡ºæ¥æ˜¯æŒ‰ç…§indexä»å°åˆ°å¤§æ’å¥½åºçš„)
            List&lt;LocalLogEntry&gt; logEntryList = logModule.readLocalLog(lastApplied+1,lastCommittedIndex);

            logger.info("pushStatemachineApply.apply, logEntryList={}",logEntryList);

            List&lt;SetCommand&gt; setCommandList = logEntryList.stream()
                .filter(item-&gt;item.getCommand() instanceof SetCommand)
                .map(item-&gt;(SetCommand)item.getCommand())
                .collect(Collectors.toList());

            // æŒ‰ç…§é¡ºåºä¾æ¬¡ä½œç”¨åˆ°çŠ¶æ€æœºä¸­
            this.kvReplicationStateMachine.batchApply(setCommandList);
        }

        this.logModule.setLastCommittedIndex(lastCommittedIndex);
        this.logModule.setLastApplied(lastCommittedIndex);
    }
Copy<br><br>
<br>å‰é¢çš„ä¾‹å­é‡Œæåˆ°åœ¨è€leaderå®•æœºè§¦å‘é€‰ä¸¾åï¼Œæ–°çš„leaderæ˜¯å¯èƒ½æŠŠä¸€äº›ä¸ä¸€è‡´çš„æ—¥å¿—ç»™è¦†ç›–æ¸…é™¤æ‰ä»¥ä¿è¯æ—¥å¿—ä¸€è‡´æ€§ã€‚<br>
å½“leaderå¹¿æ’­æ—¥å¿—å¹¶åœ¨åŠæ•°ä»¥ä¸ŠfolloweræˆåŠŸå¤åˆ¶åï¼Œå¹¶æäº¤raftLogåˆ°çŠ¶æ€æœºä¸­åå¦‚æœleaderçªç„¶å®•æœºäº†ï¼Œraftæ˜¯å¦‚ä½•ä¿è¯æ–°çš„leaderä¸ä¼šæ¸…ç†æ‰å·²æäº¤åˆ°çŠ¶æ€æœºä¸­çš„æ—¥å¿—çš„å‘¢ï¼Ÿ
<br>raftçš„è®ºæ–‡åœ¨5.4èŠ‚å®‰å…¨æ€§ä¸€èŠ‚ä¸­æåˆ°äº†è¿™ä¸€ç‚¹ï¼Œraftä½œè€…é€šè¿‡åœ¨leaderé€‰ä¸¾è¿‡ç¨‹ä¸­followeræŠ•ç¥¨çš„ç¯èŠ‚ä¸­æ·»åŠ å¯¹åŒæ–¹æ—¥å¿—çš„æ ¡éªŒæ¥ä¿è¯å·²æäº¤åˆ°çŠ¶æ€æœºçš„æ—¥å¿—ç»å¯¹ä¸ä¼šè¢«è¦†ç›–ã€‚<br>
raftè®ºæ–‡ä¸­ä¿è¯å®‰å…¨æ€§çš„æ ¸å¿ƒæ€è·¯å…±ä¸¤ç‚¹ï¼šä¸€æ˜¯candidateå¿…é¡»å’Œè¶…è¿‡åŠæ•°çš„followerè¿›è¡Œé€šä¿¡å¹¶å¾—åˆ°é€‰ç¥¨ï¼›äºŒæ˜¯candidateçš„æ—¥å¿—è‡³å°‘è¦å’Œfollowerä¸€æ ·æ–°(å³followeræœ‰çš„æ—¥å¿—candidateå¿…é¡»æœ¬åœ°ä¹Ÿæœ‰ï¼Œåä¹‹åˆ™ä¸éœ€è¦æˆç«‹)ã€‚<br>
åŸºäºè¿™ä¸¤ç‚¹åèƒ½ä»¥æ­¤æ¨å¯¼ï¼šå·²æäº¤çš„æ—¥å¿—ä¸€å®šåœ¨é›†ç¾¤ä¸­è¶…è¿‡åŠæ•°çš„èŠ‚ç‚¹ä¸­å­˜åœ¨ + æ–°å½“é€‰çš„leaderæ‰€åŒ…å«çš„æ—¥å¿—ä¸€å®šæ¯”é›†ç¾¤ä¸­è¶…è¿‡åŠæ•°çš„èŠ‚ç‚¹æ›´å…¨é¢(è‡³å°‘ä¸€æ ·å…¨é¢) =&gt; æ–°çš„leaderä¸€å®šåŒ…å«æ‰€æœ‰å·²æäº¤çš„æ—¥å¿—(åªæœ‰åŒ…å«æ‰€æœ‰å·²æäº¤æ—¥å¿—çš„èŠ‚ç‚¹æ‰èƒ½è¢«é€‰ä¸ºleader)
<br>é‚£raftæ˜¯å¦‚ä½•åœ¨é€‰ä¸¾æŠ•ç¥¨æ—¶ä»¤followerå’Œcandidateè¿›è¡Œæ—¥å¿—å®Œæ•´ç¨‹åº¦æ¯”å¯¹çš„å‘¢ï¼Ÿraftè®ºæ–‡çš„5.4èŠ‚ä¸­ä¹Ÿæåˆ°äº†ï¼Œå…·ä½“è§„åˆ™å¦‚ä¸‹ï¼š<br>
Rafté€šè¿‡æ¯”è¾ƒä¸¤ä¸ªèŠ‚ç‚¹ä¸­æ—¥å¿—ä¸­æœ€åä¸€ä¸ªæ¡ç›®çš„ç´¢å¼•å’Œä»»æœŸæ¥å†³å®šè°æ˜¯æœ€æ–°çš„ã€‚

<br>å¦‚æœä¸¤ä¸ªæ—¥å¿—ä¸­æœ€åçš„æ¡ç›®æœ‰ç€ä¸åŒçš„ä»»æœŸï¼Œåˆ™ä»»æœŸè¾ƒåçš„æ—¥å¿—æ˜¯æ›´æ–°çš„ã€‚
<br>å¦‚æœä¸¤ä¸ªæ—¥å¿—ä¸­æœ€åçš„æ¡ç›®æœ‰ç€ç›¸åŒçš„ä»»æœŸï¼Œåˆ™è¾ƒé•¿çš„(æ³¨ï¼šç´¢å¼•å€¼æ›´å¤§çš„)é‚£ä¸ªæ—¥å¿—æ˜¯æ›´æ–°çš„ã€‚


<br>candidateçš„requestVoteçš„è¯·æ±‚ä¸­ä¼šå¸¦ä¸Šcandidateè‡ªå·±æœ€åä¸€æ¡æ—¥å¿—çš„ä»»æœŸ(lastLogTerm)å’Œç´¢å¼•å€¼(lastLogIndex),è€Œå¤„ç†è¯·æ±‚çš„followerä¹Ÿéœ€è¦æŸ¥è¯¢å‡ºè‡ªå·±æœ¬åœ°çš„æœ€åä¸€æ¡æ—¥å¿—å‡ºæ¥ï¼Œå¹¶åŸºäºä¸Šè¿°è§„åˆ™æ¯”è¾ƒåˆ°åº•æ˜¯å“ªè¾¹çš„æ—¥å¿—æ›´æ–°ï¼Œæ›´å…¨é¢ã€‚<br>
åªæœ‰å½“candidateçš„æ—¥å¿—å®Œæ•´ç¨‹åº¦å¤§äº(æ›´æ–°)æˆ–ç­‰äº(ä¸€æ ·æ–°)followeræœ¬åœ°çš„æ—¥å¿—æ—¶ï¼Œfolloweræ‰èƒ½å°†é€‰ç¥¨ç»™åˆ°candidateã€‚
<br>æœ‰äº†åœ¨é€‰ä¸¾é€»è¾‘ä¸­å…³äºæ—¥å¿—çš„å®Œæ•´æ€§çš„æ ¡éªŒï¼Œraftçš„æ—¥å¿—å¤åˆ¶åŠŸèƒ½å°±ç®—åŸºæœ¬å®Œæˆäº†ã€‚è€Œä¸ºä»€ä¹ˆè¿™æ ·çš„è®¾è®¡èƒ½ä¿è¯æ—¥å¿—å¤åˆ¶çš„å®‰å…¨æ€§ï¼Œä¸ä¼šé€ æˆèŠ‚ç‚¹é—´æ•°æ®çš„ä¸ä¸€è‡´ï¼Œåœ¨raftçš„è®ºæ–‡ä¸­æœ‰æåˆ°ï¼Œåœ¨è¿™é‡Œå°±ä¸å†èµ˜è¿°äº†ã€‚<br>
raftè®ºæ–‡ä¸­ç»™å‡ºçš„å…³äºæ—¥å¿—å¤åˆ¶æ­£ç¡®æ€§çš„ç»“è®ºå¹¶ä¸æ˜¯é‚£ä¹ˆæ˜¾ç„¶(å› ä¸ºæœ‰ä¸å°‘å¼‚å¸¸çš„caseéœ€è¦ç¢ç£¨)ï¼Œå¸Œæœ›è¯»è€…èƒ½é€šè¿‡ä»”ç»†æ¨æ•²è®ºæ–‡å¹¶è‡ªå·±åŠ¨æ‰‹å®ç°raftæ¥åŠ æ·±ç†è§£ã€‚
<br>åœ¨ä¸Šä¸€å°èŠ‚çš„ä¾‹å­ä¸­ï¼Œå‡è®¾ä»»æœŸ1ä¸­çš„aæˆåŠŸçš„å¤åˆ¶äº†æ—¥å¿—ï¼Œå¹¶ä¸”åœ¨bã€cèŠ‚ç‚¹ä¸Šå¤åˆ¶æˆåŠŸï¼Œè€Œdã€eä¸Šæ²¡æœ‰å¤åˆ¶æˆåŠŸã€‚é‚£ä¹ˆå¦‚æœaåœ¨æäº¤æ—¥å¿—åˆ°çŠ¶æ€æœºåå®•æœºï¼Œåˆ™åªæœ‰bã€cæ‰å¯èƒ½è¢«é€‰ä¸¾ä¸ºleaderï¼Œå› ä¸ºbã€cä¼šæ‹’ç»æ¥è‡ªdã€eçš„requestVote(bã€cçš„æ—¥å¿—æ¯”dã€eçš„æ–°)è€Œä»¤å…¶æ— æ³•è·å¾—åŠæ•°ä»¥ä¸Šçš„é€‰ç¥¨ï¼Œè€Œåè¿‡æ¥dã€eåˆ™ä¼šåŒæ„æŠ•ç¥¨ç»™bã€cã€‚<br> /**
     * å¤„ç†æŠ•ç¥¨è¯·æ±‚
     * æ³¨æ„ï¼šsynchronizedä¿®é¥°é˜²æ­¢ä¸åŒcandidateå¹¶å‘çš„æŠ•ç¥¨ç”³è¯·å¤„ç†ï¼Œä»¥FIFOçš„æ–¹å¼å¤„ç†
     * */
    public synchronized RequestVoteRpcResult requestVoteProcess(RequestVoteRpcParam requestVoteRpcParam){
        if(this.currentServer.getCurrentTerm() &gt; requestVoteRpcParam.getTerm()){
            // Reply false if term &lt; currentTerm (Â§5.1)
            // å‘èµ·æŠ•ç¥¨çš„candidateä»»æœŸå°äºå½“å‰æœåŠ¡å™¨ä»»æœŸï¼Œæ‹’ç»æŠ•ç¥¨ç»™å®ƒ
            logger.info("reject requestVoteProcess! term &lt; currentTerm, currentServerId={}",currentServer.getServerId());
            return new RequestVoteRpcResult(this.currentServer.getCurrentTerm(),false);
        }

        // å‘èµ·æŠ•ç¥¨çš„èŠ‚ç‚¹ä»»æœŸé«˜äºå½“å‰èŠ‚ç‚¹ï¼Œæ— æ¡ä»¶æŠ•ç¥¨ç»™å®ƒ(ä»»æœŸé«˜çš„è¯´äº†ç®—)
        if(this.currentServer.getCurrentTerm() &lt; requestVoteRpcParam.getTerm()){
            // åˆ·æ–°å…ƒæ•°æ®
            this.currentServer.refreshRaftServerMetaData(
                new RaftServerMetaData(requestVoteRpcParam.getTerm(),requestVoteRpcParam.getCandidateId()));
            // ä»»æœŸæ²¡å®ƒé«˜ï¼Œè‡ªå·±è½¬ä¸ºfollower
            this.currentServer.setServerStatusEnum(ServerStatusEnum.FOLLOWER);
            return new RequestVoteRpcResult(this.currentServer.getCurrentTerm(),true);
        }

        // termä»»æœŸå€¼ç›¸åŒï¼Œéœ€è¦é¿å…åŒä¸€ä»»æœŸå†…æŠ•ç¥¨ç»™ä¸åŒçš„èŠ‚ç‚¹è€Œè„‘è£‚
        if(this.currentServer.getVotedFor() != null &amp;&amp; !this.currentServer.getVotedFor().equals(requestVoteRpcParam.getCandidateId())){
            // If votedFor is null or candidateIdï¼ˆå–åçš„å«è¯­å¥ï¼‰
            // å½“å‰æœåŠ¡å™¨å·²ç»æŠŠç¥¨æŠ•ç»™äº†åˆ«äºº,æ‹’ç»æŠ•ç¥¨ç»™å‘èµ·æŠ•ç¥¨çš„candidate
            logger.info("reject requestVoteProcess! votedFor={},currentServerId={}",
                currentServer.getVotedFor(),currentServer.getServerId());
            return new RequestVoteRpcResult(this.currentServer.getCurrentTerm(),false);
        }

        // è€ƒè™‘æ—¥å¿—æ¡ç›®ç´¢å¼•ä»¥åŠä»»æœŸå€¼æ˜¯å¦æ»¡è¶³æ¡ä»¶çš„æƒ…å†µï¼ˆç¬¬5.4èŠ‚ä¸­æåˆ°çš„å®‰å…¨æ€§ï¼‰
        // ä¿è¯leaderå¿…é¡»æ‹¥æœ‰æ‰€æœ‰å·²æäº¤çš„æ—¥å¿—ï¼Œå³å‘èµ·æŠ•ç¥¨çš„candidateæ—¥å¿—ä¸€å®šè¦æ¯”æŠ•ç¥¨ç»™å®ƒçš„èŠ‚ç‚¹æ›´æ–°
        LogEntry lastLogEntry = currentServer.getLogModule().getLastLogEntry();
        logger.info("requestVoteProcess lastLogEntry={}",lastLogEntry);
        if(lastLogEntry.getLogTerm() &gt; requestVoteRpcParam.getLastLogTerm()){
            // If the logs have last entries with different terms, then the log with the later term is more up-to-date.
            // å½“å‰èŠ‚ç‚¹çš„lastæ—¥å¿—ä»»æœŸæ¯”å‘èµ·æŠ•ç¥¨çš„candidateæ›´é«˜(æ¯”candidateæ›´æ–°)ï¼Œä¸æŠ•ç¥¨ç»™å®ƒ
            logger.info("lastLogEntry.term &gt; candidate.lastLogTerm! voteGranted=false");
            return new RequestVoteRpcResult(this.currentServer.getCurrentTerm(),false);
        }else if(lastLogEntry.getLogTerm() == requestVoteRpcParam.getLastLogTerm() &amp;&amp;
            lastLogEntry.getLogIndex() &gt; requestVoteRpcParam.getLastLogIndex()){
            // If the logs end with the same term, then whichever log is longer is more up-to-date.
            // å½“å‰èŠ‚ç‚¹çš„lastæ—¥å¿—å’Œå‘èµ·æŠ•ç¥¨çš„candidateä»»æœŸä¸€æ ·ï¼Œä½†æ˜¯indexæ¯”candidateçš„é«˜(æ¯”candidateæ›´æ–°)ï¼Œä¸æŠ•ç¥¨ç»™å®ƒ

            logger.info("lastLogEntry.term == candidate.lastLogTerm &amp;&amp; " +
                "lastLogEntry.index &gt; candidate.lastLogIndex! voteGranted=false");
            return new RequestVoteRpcResult(this.currentServer.getCurrentTerm(),false);
        }else{
            // candidateçš„æ—¥å¿—è‡³å°‘ä¸å½“å‰èŠ‚ç‚¹ä¸€æ ·æ–°(æˆ–è€…æ›´æ–°)ï¼Œé€šè¿‡æ£€æŸ¥ï¼Œå¯ä»¥æŠ•ç¥¨ç»™å®ƒ
            logger.info("candidate log at least as new as the current node, valid passed!");
        }

        // æŠ•ç¥¨æ ¡éªŒé€šè¿‡,åˆ·æ–°å…ƒæ•°æ®
        this.currentServer.refreshRaftServerMetaData(
            new RaftServerMetaData(requestVoteRpcParam.getTerm(),requestVoteRpcParam.getCandidateId()));
        this.currentServer.processCommunicationHigherTerm(requestVoteRpcParam.getTerm());
        return new RequestVoteRpcResult(this.currentServer.getCurrentTerm(),true);
    }
Copy<br><br>åœ¨raftæ—¥å¿—å¤åˆ¶çš„è¿‡ç¨‹ä¸­çš„ä»»æ„ç¬é—´ï¼Œé›†ç¾¤ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹éƒ½å¯èƒ½å‡ºç°å®•æœºã€ç½‘ç»œè¶…æ—¶ç­‰å¼‚å¸¸æƒ…å†µã€‚ä¸‹é¢åˆ†æåœ¨å‡ºç°è¿™äº›å¼‚å¸¸æ—¶ï¼Œraftæ˜¯å¦‚ä½•ä¿è¯é›†ç¾¤æ­£å¸¸å·¥ä½œçš„ã€‚<br><br>clientè¯·æ±‚æŠ¥é”™ï¼Œclienté‡è¯•ç›´åˆ°raftæœåŠ¡é›†ç¾¤é€‰ä¸¾å‡ºæ–°çš„leaderåæ¢å¤å·¥ä½œã€‚<br><br>clientè¯·æ±‚æŠ¥é”™ï¼Œé‡è¯•ç›´åˆ°é€‰ä¸¾å‡ºæ–°leader(ä¸‹é¢çš„å¼‚å¸¸æƒ…å†µclientä¹Ÿæ˜¯ä¸€æ ·çš„å¤„ç†)ã€‚<br>
rafté›†ç¾¤ä¼šè¿›è¡Œé€‰ä¸¾é€‰å‡ºæ–°leaderã€‚å®•æœºçš„è€leaderåœ¨å›åˆ°é›†ç¾¤åå¯¹åº”indexçš„æœ¬åœ°æ—¥å¿—å°†ä¼šè¢«æ–°leaderç»™è¦†ç›–æ‰ã€‚<br><br>å½“leaderå¹¿æ’­å°†æ—¥å¿—å¤åˆ¶åˆ°å°‘æ•°èŠ‚ç‚¹ä¸­å®•æœºï¼Œåˆ™å¯èƒ½å­˜åœ¨ä¸¤ç§æƒ…å†µã€‚<br>
<br>æˆåŠŸè½ç›˜çš„å°‘æ•°èŠ‚ç‚¹åœ¨æ–°ä¸€è½®é€‰ä¸¾ä¸­å½“é€‰leaderï¼Œåˆ™å®•æœºçš„è€leaderå›åˆ°é›†ç¾¤åå·²ç»è½ç›˜çš„å¯¹åº”raftLogä¼šè¢«ä¿ç•™ä¸‹æ¥ã€‚
<br>æœªæˆåŠŸè½ç›˜çš„èŠ‚ç‚¹å½“é€‰äº†æ–°leaderï¼Œåˆ™å®•æœºçš„è€leaderå·²ç»è½ç›˜çš„å¯¹åº”raftLogå°†ä¼šè¢«è¦†ç›–æ¸…é™¤æ‰ã€‚<br>
è¿™ä¸¤ç§æƒ…å†µéƒ½æ˜¯æ­£ç¡®çš„ï¼Œå› ä¸ºæœªæäº¤åˆ°çŠ¶æ€æœºä¸­çš„æ—¥å¿—æ— è®ºæ˜¯è¢«è¦†ç›–æ¸…é™¤è¿˜æ˜¯æœ€ç»ˆè¢«æäº¤ï¼Œéƒ½æ˜¯åˆç†çš„ã€‚
<br><br>å¦‚æœå¯¹åº”logæˆåŠŸå¤åˆ¶åˆ°äº†å¤šæ•°èŠ‚ç‚¹ä¸­ï¼Œåˆ™æŒ‰ç…§ä¸Šé¢æ‰€åˆ†æçš„rafté€‰ä¸¾å®‰å…¨æ€§ï¼Œåªæœ‰æ‹¥æœ‰æœ€æ–°raftLogçš„é‚£å¤šæ•°çš„èŠ‚ç‚¹æ‰æœ‰æœºä¼šå½“é€‰ä¸ºæ–°leaderã€‚<br>
å› æ­¤å®•æœºçš„è€leaderé‡æ–°å›åˆ°é›†ç¾¤åï¼Œè½ç›˜çš„raftLogå°†ä¼šè¢«ä¿ç•™ä¸‹æ¥ã€‚<br><br>æ•´ä¸ªé›†ç¾¤çš„å¤„ç†å’Œ3.4ä¸€æ ·ï¼Œå®•æœºçš„è€leaderé‡æ–°å›åˆ°é›†ç¾¤åï¼Œè½ç›˜çš„raftLogå°†ä¼šè¢«ä¿ç•™ä¸‹æ¥ã€‚å”¯ä¸€çš„åŒºåˆ«åœ¨äºå®•æœºleaderèŠ‚ç‚¹çš„çŠ¶æ€æœºå°†ä¼šé‡å¤æ‰§è¡ŒåŒä¸€æ¡raftLogã€‚<br>
è§£å†³è¿™ä¸€é—®é¢˜çš„æ–¹æ³•ä¸»è¦æœ‰ä¸¤ç§ï¼š<br>
<br>è¦æ±‚çŠ¶æ€æœºçš„å…·ä½“å®ç°èƒ½å¤Ÿå®¹å¿raftLogé‡å¤çš„æ‰§è¡Œï¼Œæˆ–è€…è®¾è®¡å¯¹ç›¸åŒlogå¹‚ç­‰çš„é˜²æŠ¤(MyRaftçš„æ–¹æ¡ˆï¼ŒçŠ¶æ€æœºæ•°æ®ä¸æŒä¹…åŒ–å¹¶ä¸”åªæœ‰çº¯setæ“ä½œï¼Œæ— è‡ªå¢/è‡ªå‡ç­‰éå¹‚ç­‰æ“ä½œ)ã€‚
<br>raftåè®®çš„å®ç°ä¸­å°†lastAppliedå±æ€§æŒä¹…åŒ–ï¼Œé€šè¿‡æŒä¹…åŒ–lastAppliedçš„æ–¹å¼æ¥é¿å…å®•æœºæ¢å¤åé‡å¤æ‰§è¡Œæ—¥å¿—ã€‚
<br><a data-tooltip-position="top" aria-label="https://www.zhihu.com/question/382888510/answer/2478166051" rel="noopener" class="external-link" href="https://www.zhihu.com/question/382888510/answer/2478166051" target="_blank">ä¸ºä»€ä¹ˆ Raft çš„ ApplyIndex å’Œ CommitIndex ä¸éœ€è¦æŒä¹…åŒ–ï¼Ÿ</a><br><br><br>MyRaftå®ç°äº†ä¸€ä¸ªéå¸¸åŸºç¡€çš„å‘½ä»¤è¡Œäº¤äº’å¼å®¢æˆ·ç«¯(RpcCmdInteractiveClient)ç”¨äºæµ‹è¯•MyRaftè¿™ä¸€kvæ•°æ®åº“çš„è¯»å†™åŠŸèƒ½ã€‚<br>/**
 * å‘½ä»¤è¡Œäº¤äº’çš„å®¢æˆ·ç«¯
 *
 * åªæ”¯æŒä»¥ä¸‹å‘½ä»¤
 * 1. get [key]
 * 2. set [key] [value]
 * 3. quit
 * */
public class RpcCmdInteractiveClient {

    public static void main(String[] args) {
        // å®¢æˆ·ç«¯çš„è¶…æ—¶æ—¶é—´å¿…é¡»å¤§äºraftå†…éƒ¨rpcçš„è¶…æ—¶æ—¶é—´ï¼Œå¦åˆ™åœ¨èŠ‚ç‚¹æ•…éšœæ—¶rpcä¼šä¸€ç›´è¶…æ—¶
        DefaultFuture.DEFAULT_TIME_OUT = 3000L;

        RaftClient raftClient = new RaftClient(RaftClusterGlobalConfig.registry);
        raftClient.init();
        raftClient.setRaftNodeConfigList(RaftClusterGlobalConfig.raftNodeConfigList);

        Scanner scan = new Scanner(System.in);

        System.out.println("RpcCmdInteractiveClient start, please input command:");

        while(scan.hasNext()) {
            String input = scan.nextLine();
            if(input.length() == 0){
                continue;
            }

            if (Objects.equals(input, "quit")) {
                scan.close();
                System.out.println("RpcCmdInteractiveClient quit success!");
                return;
            }

            if (input.startsWith("get")) {
                processGetCmd(raftClient,input);
            }else if(input.startsWith("set")){
                processSetCmd(raftClient,input);
            }else{
                System.out.println("un support cmd, please retryï¼");
            }
        }
    }

    private static void processGetCmd(RaftClient raftClient, String input){
        try {
            String[] cmdItem = input.split(" ");
            if (cmdItem.length != 2) {
                System.out.println("get cmd error, please retryï¼");
                return;
            }

            String key = cmdItem[1];
            String result = raftClient.doRequestRetry(new GetCommand(key),2);
            System.out.println("processGet result=" + result);
        }catch (Exception e){
            System.out.println("processGet error!");
            e.printStackTrace();
        }
    }

    private static void processSetCmd(RaftClient raftClient, String input){
        try {
            String[] cmdItem = input.split(" ");
            if (cmdItem.length != 3) {
                System.out.println("set cmd error, please retryï¼");
                return;
            }

            String key = cmdItem[1];
            String value = cmdItem[2];
            String result = raftClient.doRequestRetry(new SetCommand(key, value),2);
            System.out.println("processSet success=" + result);
        }catch (Exception e){
            System.out.println("processSetCmd error!");
            e.printStackTrace();
        }
    }
}
Copy<br><br><img alt="Pasted image 20240725172512.png" src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raftå®ç°/pasted-image-20240725172512.png"><br><br>åœ¨githubæºç ä¸­çš„testç›®å½•ä¸‹ä¸­æœ‰RpcClientNode(1-5)ç±»,å…¨éƒ¨ä»¥mainæ–¹æ³•å¯åŠ¨åä¾¿å¯å½¢æˆä¸€ä¸ª5èŠ‚ç‚¹çš„rafté›†ç¾¤ã€‚é€šè¿‡RpcCmdInteractiveClientä¾¿å¯ä»¥é€šè¿‡ä»¥ä¸‹å‡ ä¸ªcaseç®€å•éªŒè¯MyRaftå…³äºæ—¥å¿—å¤åˆ¶çš„åŸºæœ¬åŠŸèƒ½ã€‚<br>
<br>å¯åŠ¨æ‰€æœ‰èŠ‚ç‚¹ï¼Œè¿›è¡Œä¸€ç³»åˆ—çš„è¯»å†™æ“ä½œã€‚æ£€æŸ¥æ¯ä¸ªèŠ‚ç‚¹ä¸­æ—¥å¿—/çŠ¶æ€æœºä¸­çš„æ•°æ®æ˜¯å¦ç¬¦åˆé¢„æœŸ
<br>å°†ä»»æ„ä¸€ä¸ªèŠ‚ç‚¹å…³é—­ï¼Œåˆ é™¤æ‰çŠ¶æ€æœºå¯¹åº”çš„æ–‡ä»¶(ç›¸å½“äºæ¸…ç©ºäº†kvçŠ¶æ€æœºé‡Œçš„æ•°æ®)ï¼Œé‡æ–°å¯åŠ¨åleaderçš„å¿ƒè·³ä¼šè§¦å‘å…¨é‡æ—¥å¿—å†ä¸€æ¬¡ä½œç”¨åˆ°çŠ¶æ€æœºä¸­ã€‚æ£€æŸ¥çŠ¶æ€æœºçš„æ•°æ®æ˜¯å¦ç¬¦åˆé¢„æœŸ
<br>å°†ä»»æ„ä¸€ä¸ªèŠ‚ç‚¹å…³é—­ï¼Œç»§ç»­è¿›è¡Œä¸€ç³»åˆ—çš„è¯»å†™æ“ä½œã€‚ç„¶åå°†èŠ‚ç‚¹é‡å¯æ¢å¤ï¼Œåœ¨è¿›è¡Œæ–°çš„å†™æ“ä½œåï¼Œleaderä¼šå°†å®•æœºæ—¶ä¸¢å¤±çš„é‚£éƒ¨åˆ†æ—¥å¿—åŒæ­¥åˆ°è¯¥èŠ‚ç‚¹ï¼Œå¹¶ä¸”æ—¥å¿—æ˜¯å¦æˆåŠŸçš„æäº¤åˆ°çŠ¶æ€æœºä¸­æ‰§è¡Œã€‚æ£€æŸ¥æ—¥å¿—/çŠ¶æ€æœºçš„æ•°æ®æ˜¯å¦ç¬¦åˆé¢„æœŸ
<br><br>
<br>ä½œä¸ºæ‰‹å†™raftç³»åˆ—åšå®¢çš„ç¬¬äºŒç¯‡ï¼Œåœ¨åšå®¢çš„ç¬¬1èŠ‚ç®€å•ä»‹ç»äº†raftçš„æ—¥å¿—å¤åˆ¶åŠŸèƒ½ï¼Œç¬¬2èŠ‚è¯¦ç»†åˆ†æäº†MyRaftå…³äºæ—¥å¿—å¤åˆ¶åŠŸèƒ½çš„å®ç°æºç ï¼Œç¬¬3èŠ‚é€šè¿‡åˆ†ææ—¥å¿—å¤åˆ¶è¿‡ç¨‹ä¸­å¼‚å¸¸æƒ…å†µçš„å¤„ç†æ¥è¯æ˜raftæ—¥å¿—å¤åˆ¶åŠŸèƒ½çš„æ­£ç¡®æ€§ã€‚
<br>raftçš„æ—¥å¿—å¤åˆ¶åŠŸèƒ½æ˜¯raftç®—æ³•ä¸­æœ€å¤æ‚çš„ä¸€éƒ¨åˆ†ï¼Œé™¤äº†æ­£å¸¸æ‰§è¡Œé€»è¾‘ä»¥å¤–è¿˜åŒ…å«äº†å¤§é‡å¼‚å¸¸æƒ…å†µçš„å¤„ç†ã€‚åœ¨åšå®¢ä¸­æˆ‘ç»“åˆMyRaftçš„æºç å°½å¯èƒ½çš„å°†è‡ªå·±ç†è§£çš„å„ç§ç»†èŠ‚åˆ†äº«å‡ºæ¥ï¼Œå¸Œæœ›èƒ½å¸®åˆ°å¯¹raftå®ç°ç»†èŠ‚ã€æ­£ç¡®æ€§è¯æ˜ç­‰ç›¸å…³å†…å®¹æ„Ÿå…´è¶£çš„è¯»è€…ã€‚
<br>åšå®¢ä¸­å±•ç¤ºçš„å®Œæ•´ä»£ç åœ¨æˆ‘çš„githubä¸Šï¼š<a rel="noopener" class="external-link" href="https://github.com/1399852153/MyRaft" target="_blank">https://github.com/1399852153/MyRaft</a> (release/lab2_log_replicationåˆ†æ”¯)ï¼Œå†…å®¹å¦‚æœ‰é”™è¯¯ï¼Œè¿˜è¯·å¤šå¤šæŒ‡æ•™ã€‚
]]></description><link>https://muqiuhan.github.io/wiki/computer-science/distributed-system/raftå®ç°/raftå®ç°-å®ç°æ—¥å¿—å¤åˆ¶.html</link><guid isPermaLink="false">Computer Science/Distributed System/Raftå®ç°/Raftå®ç° - å®ç°æ—¥å¿—å¤åˆ¶.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Thu, 25 Jul 2024 09:25:24 GMT</pubDate><enclosure url="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raftå®ç°/pasted-image-20240725172412.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/raftå®ç°/pasted-image-20240725172412.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[è‡ªå·±åŠ¨æ‰‹å®ç°rpcæ¡†æ¶(ä¸€) å®ç°ç‚¹å¯¹ç‚¹çš„rpcé€šä¿¡]]></title><description><![CDATA[ 
 <br><br>RPCæ˜¯è¿œè¿‡ç¨‹è°ƒç”¨(Remote Procedure Call)çš„ç¼©å†™å½¢å¼ï¼Œå…¶åŒºåˆ«äºä¸€ä¸ªç¨‹åºå†…éƒ¨åŸºæœ¬çš„è¿‡ç¨‹è°ƒç”¨(æˆ–è€…å«å‡½æ•°/æ–¹æ³•è°ƒç”¨)ã€‚<br>éšç€åº”ç”¨ç¨‹åºå˜å¾—è¶Šæ¥è¶Šå¤æ‚ï¼Œåœ¨å•ä¸ªæœºå™¨ä¸Šä¸­ä»…é€šè¿‡ä¸€ä¸ªè¿›ç¨‹æ¥è¿è¡Œæ•´ä¸ªåº”ç”¨ç¨‹åºçš„æ–¹å¼å·²ç»éš¾ä»¥æ»¡è¶³ç°å®ä¸­æ—¥ç›Šå¢é•¿çš„éœ€æ±‚ã€‚<br>
å¼€å‘è€…å¯¹åº”ç”¨ç¨‹åºè¿›è¡Œæ¨¡å—åŒ–çš„æ‹†åˆ†ï¼Œä»¥åˆ†å¸ƒå¼éƒ¨ç½²çš„æ–¹å¼æ¥é™ä½ç¨‹åºæ•´ä½“çš„å¤æ‚åº¦å’Œæå‡æ€§èƒ½æ–¹é¢çš„å¯æ‹“å±•æ€§(åˆ†è€Œæ²»ä¹‹çš„æ€æƒ³)ã€‚<br>æ‹†åˆ†åéƒ¨ç½²åœ¨ä¸åŒæœºå™¨ä¸Šçš„å„ä¸ªæ¨¡å—æ— æ³•åƒä¹‹å‰é‚£æ ·é€šè¿‡å†…å­˜å¯»å€çš„æ–¹å¼æ¥äº’ç›¸è®¿é—®ï¼Œè€Œæ˜¯éœ€è¦é€šè¿‡ç½‘ç»œæ¥è¿›è¡Œé€šä¿¡ã€‚<br>
RPCæœ€ä¸»è¦çš„åŠŸèƒ½å°±æ˜¯åœ¨æä¾›ä¸åŒæ¨¡å—æœåŠ¡é—´çš„ç½‘ç»œé€šä¿¡èƒ½åŠ›çš„åŒæ—¶ï¼Œåˆå°½å¯èƒ½çš„ä¸ä¸¢å¤±æœ¬åœ°è°ƒç”¨æ—¶è¯­ä¹‰çš„ç®€æ´æ€§ã€‚rpcå¯ä»¥è®¤ä¸ºæ˜¯åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ç±»ä¼¼äººä½“ç»ç»œä¸€æ ·çš„åŸºç¡€è®¾æ–½ï¼Œå› æ­¤æœ‰å¿…è¦å¯¹å…¶å·¥ä½œåŸç†æœ‰ä¸€å®šçš„äº†è§£ã€‚<br><br>è¦å­¦ä¹ rpcçš„åŸç†ï¼Œç†è®ºä¸Šæœ€å¥½çš„åŠæ³•å°±æ˜¯å»çœ‹æµè¡Œçš„å¼€æºæ¡†æ¶æºç ã€‚ä½†dubboè¿™æ ·æˆç†Ÿçš„rpcæ¡†æ¶ç”±äºå·²ç»è¿­ä»£äº†å¾ˆå¤šå¹´ï¼Œä¸ºäº†æ»¡è¶³å¤šæ ·çš„éœ€æ±‚è€Œæœ‰ç€å¤æ‚çš„æ¶æ„å’Œåºå¤§çš„ä»£ç é‡ã€‚å¯¹äºæ™®é€šåˆå­¦è€…æ¥è¯´å¾€å¾€å¾ˆéš¾ä»å±‚å±‚æŠ½è±¡å°è£…ä¸­æŠŠæ¡ä½å…³äºrpcæ¡†æ¶æœ€æ ¸å¿ƒçš„å†…å®¹ã€‚<br>MyRpcæ˜¯æˆ‘æœ€è¿‘åœ¨å­¦ä¹ MIT6.824åˆ†å¸ƒå¼ç³»ç»Ÿå…¬å¼€è¯¾æ—¶ï¼Œä½¿ç”¨javaå¹¶åŸºäºnettyå®ç°çš„ä¸€ä¸ªç®€æ˜“rpcæ¡†æ¶ï¼Œå®ç°çš„è¿‡ç¨‹ä¸­è®¸å¤šåœ°æ–¹éƒ½å‚è€ƒäº†dubboä»¥åŠä¸€äº›demoçº§åˆ«çš„rpcæ¡†æ¶ã€‚<br>
MyRpcæ˜¯demoçº§åˆ«çš„æ¡†æ¶ï¼Œç†è§£èµ·æ¥ä¼šè½»æ¾ä¸å°‘ã€‚åœ¨å¯¹åŸºç¡€çš„rpcå®ç°åŸç†æœ‰ä¸€å®šäº†è§£åï¼Œèƒ½å¯¹åç»­ç ”ç©¶dubboç­‰å¼€æºrpcæ¡†æ¶å¸¦æ¥å¾ˆå¤§çš„å¸®åŠ©ã€‚<br>ç›®å‰MyRpcå®ç°äº†ä»¥ä¸‹åŠŸèƒ½<br>
<br>ç½‘ç»œé€šä¿¡(nettyåšå®¢æˆ·ç«¯ã€æœåŠ¡ç«¯ç½‘ç»œäº¤äº’ï¼ŒæœåŠ¡ç«¯ä½¿ç”¨ä¸€ä¸ªçº¿ç¨‹æ± å¤„ç†ä¸šåŠ¡é€»è¾‘)
<br>å®ç°æ¶ˆæ¯çš„åºåˆ—åŒ–ï¼ˆå®ç°åºåˆ—åŒ–æ–¹å¼çš„æŠ½è±¡ï¼Œæ”¯æŒjsonã€hessianã€jdkåºåˆ—åŒ–ç­‰ï¼‰
<br>å®¢æˆ·ç«¯ä»£ç†ç”Ÿæˆ(ç›®å‰åªå®ç°äº†jdkåŠ¨æ€ä»£ç†)
<br>æœåŠ¡æ³¨å†Œ + æ³¨å†Œä¸­å¿ƒé›†æˆ(å®ç°æ³¨å†Œä¸­å¿ƒçš„æŠ½è±¡ï¼Œä½†ç›®å‰åªæ”¯æŒç”¨zookeeperåšæ³¨å†Œä¸­å¿ƒ)
<br>é›†ç¾¤è´Ÿè½½å‡è¡¡ç­–ç•¥(å®ç°è´Ÿè½½å‡è¡¡ç­–ç•¥çš„æŠ½è±¡ï¼Œæ”¯æŒroundRobinè½®è®­ï¼Œéšæœºç­‰)
<br>ä½¿ç”¨æ—¶é—´è½®ï¼Œæ”¯æŒè®¾ç½®æ¶ˆè´¹è€…è°ƒç”¨è¶…æ—¶æ—¶é—´
<br>é™äºç¯‡å¹…ï¼Œä»¥ä¸ŠåŠŸèƒ½ä¼šæ‹†åˆ†ä¸ºä¸¤ç¯‡åšå®¢åˆ†åˆ«ä»‹ç»ã€‚å…¶ä¸­å‰3ä¸ªåŠŸèƒ½å®ç°äº†åŸºæœ¬çš„ç‚¹å¯¹ç‚¹é€šä¿¡çš„rpcåŠŸèƒ½ï¼Œå°†åœ¨æœ¬ç¯‡åšå®¢ä¸­ç»“åˆæºç è¯¦ç»†åˆ†æã€‚<br><img alt="Pasted image 20240725171915.png" src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/rpcæ¡†æ¶çš„å®ç°/pasted-image-20240725171915.png"><br><br><br>MyRpcæ˜¯ä»¥nettyä¸ºåŸºç¡€çš„ï¼Œä¸‹é¢å±•ç¤ºä¸€ä¸ªæœ€åŸºç¡€çš„nettyå®¢æˆ·ç«¯/æœåŠ¡ç«¯äº¤äº’çš„demoã€‚<br>nettyæœåŠ¡ç«¯ï¼š<br>/**
 * æœ€åŸå§‹çš„nettyæœåŠ¡ç«¯demo
 * */
public class PureNettyServer {

    public static void main(String[] args) throws InterruptedException {
        ServerBootstrap bootstrap = new ServerBootstrap();
        EventLoopGroup bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory("NettyServerBoss", true));
        EventLoopGroup workerGroup = new NioEventLoopGroup(8,new DefaultThreadFactory("NettyServerWorker", true));

        bootstrap.group(bossGroup, workerGroup)
            .channel(NioServerSocketChannel.class)
            .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {
                @Override
                protected void initChannel(SocketChannel socketChannel) {
                    socketChannel.pipeline()
                        // å®é™…è°ƒç”¨ä¸šåŠ¡æ–¹æ³•çš„å¤„ç†å™¨
                        .addLast("serverHandler", new SimpleChannelInboundHandler&lt;ByteBuf&gt;() {
                            @Override
                            protected void channelRead0(ChannelHandlerContext channelHandlerContext, ByteBuf requestByteBuf) {
                                String requestStr = requestByteBuf.toString(CharsetUtil.UTF_8);
                                System.out.println("PureNettyServer read request=" + JsonUtil.json2Obj(requestStr, User.class));

                                // æœåŠ¡ç«¯å“åº”echo
                                ByteBuf byteBuf = Unpooled.copiedBuffer("echo:" + requestStr,CharsetUtil.UTF_8);
                                channelHandlerContext.writeAndFlush(byteBuf);
                            }
                        })
                    ;
                }
            });

        ChannelFuture channelFuture = bootstrap.bind("127.0.0.1", 8888).sync();

        System.out.println("netty server started!");
        // ä¸€ç›´é˜»å¡åœ¨è¿™é‡Œ
        channelFuture.channel().closeFuture().sync();
    }
}
Copy<br>nettyå®¢æˆ·ç«¯ï¼š<br>/**
 * æœ€åŸå§‹çš„nettyå®¢æˆ·ç«¯demo
 * */
public class PureNettyClient {

    public static void main(String[] args) throws InterruptedException {
        Bootstrap bootstrap = new Bootstrap();
        EventLoopGroup eventLoopGroup = new NioEventLoopGroup(8,
            new DefaultThreadFactory("NettyClientWorker", true));

        bootstrap.group(eventLoopGroup)
            .channel(NioSocketChannel.class)
            .handler(new ChannelInitializer&lt;SocketChannel&gt;() {
                @Override
                protected void initChannel(SocketChannel socketChannel) {
                    socketChannel.pipeline()
                        .addLast("clientHandler", new SimpleChannelInboundHandler&lt;ByteBuf&gt;() {
                            @Override
                            protected void channelRead0(ChannelHandlerContext channelHandlerContext, ByteBuf responseByteBuf) {
                                String responseStr = responseByteBuf.toString(CharsetUtil.UTF_8);
                                System.out.println("PureNettyClient received response=" + responseStr);
                            }
                        })
                    ;
                }
            });

        ChannelFuture channelFuture = bootstrap.connect("127.0.0.1", 8888).sync();
        Channel channel = channelFuture.sync().channel();

        // å‘é€ä¸€ä¸ªuserå¯¹è±¡çš„jsonä¸²
        User user = new User("Tom",10);
        ByteBuf requestByteBuf = Unpooled.copiedBuffer(JsonUtil.obj2Str(user), CharsetUtil.UTF_8);
        channel.writeAndFlush(requestByteBuf);

        System.out.println("netty client send request success!");
        channelFuture.channel().closeFuture().sync();
    }
}
Copy<br>
<br>demoç¤ºä¾‹ä¸­ï¼Œnettyçš„æœåŠ¡ç«¯å¯åŠ¨åç»‘å®šåœ¨æœ¬æœº127.0.0.1çš„8888ç«¯å£ä¸Šï¼Œç­‰å¾…æ¥è‡ªå®¢æˆ·ç«¯çš„è¿æ¥ã€‚
<br>nettyå®¢æˆ·ç«¯å‘æœåŠ¡ç«¯å‘èµ·è¿æ¥è¯·æ±‚ï¼Œåœ¨æˆåŠŸå»ºç«‹è¿æ¥åå‘æœåŠ¡ç«¯å‘é€äº†ä¸€ä¸ªUserå¯¹è±¡å­—ç¬¦ä¸²å¯¹åº”çš„å­—èŠ‚æ•°ç»„ã€‚
<br>æœåŠ¡ç«¯åœ¨æ¥å—åˆ°è¿™ä¸€å­—èŠ‚æ•°ç»„åååºåˆ—åŒ–ä¸ºUserå¯¹è±¡å¹¶æ‰“å°åœ¨æ§åˆ¶å°ï¼Œéšåechoå“åº”äº†ä¸€ä¸ªå­—ç¬¦ä¸²ã€‚å®¢æˆ·ç«¯åœ¨æ¥å—åˆ°å“åº”åï¼Œå°†echoå­—ç¬¦ä¸²æ‰“å°åœ¨äº†æ§åˆ¶å°ä¸Š
<br><br>ä¸Šé¢å±•ç¤ºäº†ä¸€ä¸ªæœ€åŸºç¡€çš„nettyç½‘ç»œé€šä¿¡çš„demoï¼Œä¼¼ä¹ä¸€ä¸ªç‚¹å¯¹ç‚¹çš„ä¼ è¾“åŠŸèƒ½å·²ç»å¾—åˆ°äº†è‰¯å¥½çš„å®ç°ã€‚<br>
ä½†ä½œä¸ºä¸€ä¸ªrpcæ¡†æ¶ï¼Œè¿˜éœ€è¦è§£å†³tcpä¼ è¾“å±‚åŸºäºå­—èŠ‚æµçš„æ¶ˆæ¯é»åŒ…/æ‹†åŒ…é—®é¢˜ã€‚<br><br>æ“ä½œç³»ç»Ÿå®ç°çš„ä¼ è¾“å±‚tcpåè®®ä¸­ï¼Œå‘ä¸Šå±‚çš„åº”ç”¨ä¿è¯å°½æœ€å¤§å¯èƒ½çš„(best effort delivery)ã€å¯é çš„ä¼ è¾“å­—èŠ‚æµï¼Œä½†å¹¶ä¸å…³å¿ƒå®é™…ä¼ è¾“çš„æ•°æ®åŒ…æ˜¯å¦æ€»æ˜¯ç¬¦åˆåº”ç”¨å±‚çš„è¦æ±‚ã€‚<br>
<br>é»åŒ…é—®é¢˜ï¼š å‡è®¾åº”ç”¨å±‚å‘é€çš„ä¸€æ¬¡è¯·æ±‚æ•°æ®é‡æ¯”è¾ƒå°(æ¯”å¦‚0.1kb)ï¼Œtcpå±‚å¯èƒ½ä¸ä¼šåœ¨æ¥åˆ°åº”ç”¨è¯·æ±‚åç«‹å³è¿›è¡Œä¼ è¾“ï¼Œè€Œæ˜¯ä¼šç¨å¾®ç­‰å¾…ä¸€å°ä¼šã€‚<br>
è¿™æ ·å¦‚æœåº”ç”¨å±‚åœ¨çŸ­æ—¶é—´å†…éœ€è¦ä¼ è¾“å¤šæ¬¡0.1kbçš„è¯·æ±‚ï¼Œå°±å¯ä»¥æ”’åœ¨ä¸€èµ·æ‰¹é‡ä¼ è¾“ï¼Œä¼ è¾“æ•ˆç‡ä¼šé«˜å¾ˆå¤šã€‚<br>
ä½†è¿™å¸¦æ¥çš„é—®é¢˜å°±æ˜¯æ¥æ”¶ç«¯ä¸€æ¬¡æ¥å—åˆ°çš„æ•°æ®åŒ…å†…åº”ç”¨ç¨‹åºé€»è¾‘ä¸Šçš„å¤šæ¬¡è¯·æ±‚é»è¿åœ¨äº†ä¸€èµ·ï¼Œéœ€è¦é€šè¿‡ä¸€äº›æ–¹æ³•æ¥å°†å…¶æ‹†åˆ†è¿˜åŸä¸ºä¸€ä¸ªä¸ªç‹¬ç«‹çš„ä¿¡æ¯ç»™åº”ç”¨å±‚ã€‚
<br>æ‹†åŒ…é—®é¢˜ï¼š å‡è®¾åº”ç”¨å±‚å‘é€çš„ä¸€æ¬¡è¯·æ±‚æ•°æ®é‡æ¯”è¾ƒå¤§(æ¯”å¦‚100Mb)ï¼Œè€Œtcpå±‚çš„æ•°æ®åŒ…å®¹é‡çš„æœ€å¤§å€¼æ˜¯æœ‰é™çš„ï¼Œæ‰€ä»¥åº”ç”¨å±‚è¾ƒå¤§çš„ä¸€æ¬¡è¯·æ±‚æ•°æ®ä¼šè¢«æ‹†åˆ†ä¸ºå¤šä¸ªåŒ…åˆ†å¼€å‘é€ã€‚<br>
è¿™å°±å¯¼è‡´æ¥æ”¶ç«¯æ¥å—åˆ°çš„æŸä¸ªæ•°æ®åŒ…å…¶å®å¹¶ä¸æ˜¯å®Œæ•´çš„åº”ç”¨å±‚è¯·æ±‚æ•°æ®ï¼Œæ²¡æ³•ç›´æ¥äº¤ç»™åº”ç”¨ç¨‹åºå»ä½¿ç”¨ï¼Œ<br>
è€Œå¿…é¡»ç­‰å¾…åç»­å¯¹åº”è¯·æ±‚çš„æ‰€æœ‰æ•°æ®åŒ…éƒ½æ¥å—å®Œæˆåï¼Œæ‰èƒ½ç»„è£…æˆå®Œæ•´çš„è¯·æ±‚å¯¹è±¡å†äº¤ç»™åº”ç”¨å±‚å¤„ç†ã€‚
<br>å¯ä»¥çœ‹åˆ°ï¼Œä¸Šè¿°çš„é»åŒ…/æ‹†åŒ…é—®é¢˜å¹¶ä¸èƒ½çœ‹åšæ˜¯tcpçš„é—®é¢˜ï¼Œè€Œæ˜¯åº”ç”¨å±‚æœ€ç»ˆéœ€æ±‚ä¸tcpä¼ è¾“å±‚åŠŸèƒ½ä¸åŒ¹é…å¯¼è‡´çš„é—®é¢˜ã€‚<br>
tcpå‡ºäºä¼ è¾“æ•ˆç‡çš„è€ƒè™‘æ— æ³•è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæ‰€ä»¥é»åŒ…æ‹†åŒ…é—®é¢˜æœ€ç»ˆåªèƒ½åœ¨æ›´ä¸Šé¢çš„åº”ç”¨å±‚è‡ªå·±æ¥å¤„ç†ã€‚
<br>ä¸€ä¸ªæ•°æ®åŒ…ä¸­å¯èƒ½åŒæ—¶å­˜åœ¨é»åŒ…é—®é¢˜å’Œæ‹†åŒ…é—®é¢˜(å¦‚ä¸‹å›¾æ‰€ç¤º)<br>
<img alt="Pasted image 20240725171936.png" src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/rpcæ¡†æ¶çš„å®ç°/pasted-image-20240725171936.png"><br><br>è§£å†³é»åŒ…/æ‹†åŒ…é—®é¢˜æœ€æ ¸å¿ƒçš„æ€è·¯æ˜¯ï¼Œå¦‚ä½•çŸ¥é“ä¸€ä¸ªåº”ç”¨å±‚å®Œæ•´è¯·æ±‚çš„è¾¹ç•Œã€‚<br>
å¯¹äºé»åŒ…é—®é¢˜ï¼ŒåŸºäºè¾¹ç•Œå¯ä»¥ç‹¬ç«‹çš„æ‹†åˆ†å‡ºæ¯ä¸€ä¸ªè¯·æ±‚ï¼›å¯¹äºæ‹†åŒ…é—®é¢˜ï¼Œå¦‚æœå‘ç°æ”¶åˆ°çš„æ•°æ®åŒ…æœ«å°¾æ²¡æœ‰è¾¹ç•Œï¼Œåˆ™ç»§ç»­ç­‰å¾…æ–°çš„æ•°æ®åŒ…ï¼Œç›´åˆ°å‘ç°è¾¹ç•Œåå†ä¸€å¹¶ä¸Šäº¤ç»™åº”ç”¨ç¨‹åºã€‚<br>ä¸»æµçš„è§£å†³é»åŒ…æ‹†åŒ…çš„åº”ç”¨å±‚åè®®è®¾è®¡æ–¹æ¡ˆæœ‰ä¸‰ç§ï¼š<br><br>å¯¹äºæµè¡Œçš„rpcæ¡†æ¶ï¼Œä¸€èˆ¬éƒ½æ˜¯é€‰ç”¨æ€§èƒ½ä¸å…¼å®¹æ€§çš†æœ‰çš„æ–¹æ¡ˆ3ï¼šå³è‡ªå·±è®¾è®¡ä¸€ä¸ªå›ºå®šå¤§å°çš„ã€åŒ…å«äº†è¯·æ±‚ä½“é•¿åº¦å­—æ®µçš„è¯·æ±‚å¤´ã€‚MyRpcå‚è€ƒdubboï¼Œä¹Ÿè®¾è®¡äº†ä¸€ä¸ªå›ºå®š16å­—èŠ‚å¤§å°çš„è¯·æ±‚å¤´(é‡Œé¢æœ‰å‡ ä¸ªå­—æ®µæš‚æ—¶æ²¡ç”¨ä¸Š)ã€‚<br>è¯·æ±‚å¤´: MessageHeader<br>/**
 * å…±16å­—èŠ‚çš„è¯·æ±‚å¤´
 * */
public class MessageHeader implements Serializable {

    public static final int MESSAGE_HEADER_LENGTH = 16;
    public static final int MESSAGE_SERIALIZE_TYPE_LENGTH = 5;
    public static final short MAGIC = (short)0x2233;

    // ================================ æ¶ˆæ¯å¤´ =================================
    /**
     * é­”æ•°(å 2å­—èŠ‚)
     * */
    private short magicNumber = MAGIC;

    /**
     * æ¶ˆæ¯æ ‡è¯†(0ä»£è¡¨è¯·æ±‚äº‹ä»¶ï¼›1ä»£è¡¨å“åº”äº‹ä»¶ï¼Œ å 1ä½)
     * @see MessageFlagEnums
     * */
    private Boolean messageFlag;

    /**
     * æ˜¯å¦æ˜¯åŒå‘è¯·æ±‚(0ä»£è¡¨oneWayè¯·æ±‚ï¼›1ä»£è¡¨twoWayè¯·æ±‚ï¼‰
     * ï¼ˆåŒå‘ä»£è¡¨å®¢æˆ·ç«¯ä¼šç­‰å¾…æœåŠ¡ç«¯çš„å“åº”ï¼Œå•å‘åˆ™è¯·æ±‚å‘é€å®Œæˆåå³å‘ä¸Šå±‚è¿”å›æˆåŠŸ)
     * */
    private Boolean twoWayFlag;

    /**
     * æ˜¯å¦æ˜¯å¿ƒè·³æ¶ˆæ¯(0ä»£è¡¨æ­£å¸¸æ¶ˆæ¯ï¼›1ä»£è¡¨å¿ƒè·³æ¶ˆæ¯ï¼Œ å 1ä½)
     * */
    private Boolean eventFlag;

    /**
     * æ¶ˆæ¯ä½“åºåˆ—åŒ–ç±»å‹(å 5ä½ï¼Œå³æ‰€æ”¯æŒçš„åºåˆ—åŒ–ç±»å‹ä¸å¾—è¶…è¿‡2çš„5æ¬¡æ–¹ï¼Œ32ç§)
     * @see MessageSerializeType
     * */
    private Boolean[] serializeType;

    /**
     * å“åº”çŠ¶æ€(å 1å­—èŠ‚)
     * */
    private byte responseStatus;

    /**
     * æ¶ˆæ¯çš„å”¯ä¸€idï¼ˆå 8å­—èŠ‚ï¼‰
     * */
    private long messageId;

    /**
     * ä¸šåŠ¡æ•°æ®é•¿åº¦ï¼ˆå 4å­—èŠ‚ï¼‰
     * */
    private int bizDataLength;
}
Copy<br>å®Œæ•´çš„æ¶ˆæ¯å¯¹è±¡: MessageProtocol<br>public class MessageProtocol&lt;T&gt; implements Serializable {
    /**
     * è¯·æ±‚å¤´
     * */
    private MessageHeader messageHeader;

    /**
     * è¯·æ±‚ä½“(å®é™…çš„ä¸šåŠ¡æ¶ˆæ¯å¯¹è±¡)
     * */
    private T bizDataBody;
}
Copy<br><img alt="Pasted image 20240725172037.png" src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/rpcæ¡†æ¶çš„å®ç°/pasted-image-20240725172037.png"><br><br>/**
 * rpcè¯·æ±‚å¯¹è±¡
 * */
public class RpcRequest implements Serializable {

    private static final AtomicLong INVOKE_ID = new AtomicLong(0);

    /**
     * æ¶ˆæ¯çš„å”¯ä¸€idï¼ˆå 8å­—èŠ‚ï¼‰
     * */
    private final long messageId;

    /**
     * æ¥å£å
     * */
    private String interfaceName;

    /**
     * æ–¹æ³•å
     * */
    private String methodName;

    /**
     * å‚æ•°ç±»å‹æ•°ç»„(æ¯ä¸ªå‚æ•°ä¸€é¡¹)
     * */
    private Class&lt;?&gt;[] parameterClasses;

    /**
     * å®é™…å‚æ•°å¯¹è±¡æ•°ç»„(æ¯ä¸ªå‚æ•°ä¸€é¡¹)
     * */
    private Object[] params;

    public RpcRequest() {
        // æ¯ä¸ªè¯·æ±‚å¯¹è±¡ç”Ÿæˆæ—¶éƒ½è‡ªåŠ¨ç”Ÿæˆå•æœºå…¨å±€å”¯ä¸€çš„è‡ªå¢id
        this.messageId = INVOKE_ID.getAndIncrement();
    }
}
Copy<br>/**
 * rpcå“åº”å¯¹è±¡
 * */
public class RpcResponse implements Serializable {

    /**
     * æ¶ˆæ¯çš„å”¯ä¸€idï¼ˆå 8å­—èŠ‚ï¼‰
     * */
    private long messageId;

    /**
     * è¿”å›å€¼
     */
    private Object returnValue;

    /**
     * å¼‚å¸¸å€¼
     */
    private Exception exceptionValue;
}
Copy<br><br>åœ¨ä¸Šä¸€èŠ‚çš„netty demoä¸­çš„æ¶ˆæ¯å¤„ç†å™¨ä¸­ï¼Œä¸€å…±åšäº†ä¸¤ä»¶äº‹æƒ…ï¼›ä¸€æ˜¯å°†åŸå§‹æ•°æ®åŒ…çš„å­—èŠ‚æµè½¬åŒ–æˆäº†åº”ç”¨ç¨‹åºæ‰€éœ€çš„Stringå¯¹è±¡ï¼›äºŒæ˜¯æ‹¿åˆ°Stringå¯¹è±¡åè¿›è¡Œå“åº”çš„ä¸šåŠ¡å¤„ç†(æ¯”å¦‚æ‰“å°åœ¨æ§åˆ¶å°ä¸Š)ã€‚<br>
è€Œnettyæ¡†æ¶å…è®¸é…ç½®å¤šä¸ªæ¶ˆæ¯å¤„ç†å™¨ç»„æˆé“¾æ¡ï¼ŒæŒ‰çº¦å®šçš„é¡ºåºå¤„ç†å‡ºç«™/å…¥ç«™çš„æ¶ˆæ¯ï¼›å› æ­¤ä»æ¨¡å—åŒ–çš„å‡ºå‘ï¼Œåº”è¯¥å°†ç¼–ç /è§£ç çš„é€»è¾‘å’Œå®é™…ä¸šåŠ¡çš„å¤„ç†æ‹†åˆ†æˆå¤šä¸ªå¤„ç†å™¨ã€‚<br>åœ¨è‡ªå®šä¹‰çš„æ¶ˆæ¯ç¼–ç å™¨ã€è§£ç å™¨ä¸­è¿›è¡Œåº”ç”¨å±‚è¯·æ±‚/å“åº”æ•°æ®çš„åºåˆ—åŒ–/ååºåˆ—åŒ–ï¼ŒåŒæ—¶å¤„ç†ä¸Šè¿°çš„é»åŒ…/æ‹†åŒ…é—®é¢˜ã€‚<br>ç¼–è§£ç å·¥å…·ç±»<br>public class MessageCodecUtil {

    /**
     * æŠ¥æ–‡åè®®ç¼–ç 
     * */
    public static &lt;T&gt; void messageEncode(MessageProtocol&lt;T&gt; messageProtocol, ByteBuf byteBuf) {
        MessageHeader messageHeader = messageProtocol.getMessageHeader();
        // å†™å…¥é­”æ•°
        byteBuf.writeShort(MessageHeader.MAGIC);

        // å†™å…¥æ¶ˆæ¯æ ‡è¯†
        byteBuf.writeBoolean(messageHeader.getMessageFlag());
        // å†™å…¥å•/åŒå‘æ ‡è¯†
        byteBuf.writeBoolean(messageHeader.getTwoWayFlag());
        // å†™å…¥æ¶ˆæ¯äº‹ä»¶æ ‡è¯†
        byteBuf.writeBoolean(messageHeader.getEventFlag());
        // å†™å…¥åºåˆ—åŒ–ç±»å‹
        for(boolean b : messageHeader.getSerializeType()){
            byteBuf.writeBoolean(b);
        }
        // å†™å…¥å“åº”çŠ¶æ€
        byteBuf.writeByte(messageHeader.getResponseStatus());
        // å†™å…¥æ¶ˆæ¯uuid
        byteBuf.writeLong(messageHeader.getMessageId());

        // åºåˆ—åŒ–æ¶ˆæ¯ä½“
        MyRpcSerializer myRpcSerializer = MyRpcSerializerManager.getSerializer(messageHeader.getSerializeType());
        byte[] bizMessageBytes = myRpcSerializer.serialize(messageProtocol.getBizDataBody());
        // è·å¾—å¹¶å†™å…¥æ¶ˆæ¯æ­£æ–‡é•¿åº¦
        byteBuf.writeInt(bizMessageBytes.length);
        // å†™å…¥æ¶ˆæ¯æ­£æ–‡å†…å®¹
        byteBuf.writeBytes(bizMessageBytes);
    }

    /**
     * æŠ¥æ–‡åè®®headerå¤´è§£ç 
     * */
    public static MessageHeader messageHeaderDecode(ByteBuf byteBuf){
        MessageHeader messageHeader = new MessageHeader();
        // è¯»å–é­”æ•°
        messageHeader.setMagicNumber(byteBuf.readShort());
        // è¯»å–æ¶ˆæ¯æ ‡è¯†
        messageHeader.setMessageFlag(byteBuf.readBoolean());
        // è¯»å–å•/åŒå‘æ ‡è¯†
        messageHeader.setTwoWayFlag(byteBuf.readBoolean());
        // è¯»å–æ¶ˆæ¯äº‹ä»¶æ ‡è¯†
        messageHeader.setEventFlag(byteBuf.readBoolean());

        // è¯»å–åºåˆ—åŒ–ç±»å‹
        Boolean[] serializeTypeBytes = new Boolean[MessageHeader.MESSAGE_SERIALIZE_TYPE_LENGTH];
        for(int i=0; i&lt;MessageHeader.MESSAGE_SERIALIZE_TYPE_LENGTH; i++){
            serializeTypeBytes[i] = byteBuf.readBoolean();
        }
        messageHeader.setSerializeType(serializeTypeBytes);

        // è¯»å–å“åº”çŠ¶æ€
        messageHeader.setResponseStatus(byteBuf.readByte());
        // è¯»å–æ¶ˆæ¯uuid
        messageHeader.setMessageId(byteBuf.readLong());

        // è¯»å–æ¶ˆæ¯æ­£æ–‡é•¿åº¦
        int bizDataLength = byteBuf.readInt();
        messageHeader.setBizDataLength(bizDataLength);

        return messageHeader;
    }

    /**
     * æŠ¥æ–‡åè®®æ­£æ–‡bodyè§£ç 
     * */
    public static &lt;T&gt; T messageBizDataDecode(MessageHeader messageHeader, ByteBuf byteBuf, Class&lt;T&gt; messageBizDataType){
        // è¯»å–æ¶ˆæ¯æ­£æ–‡
        byte[] bizDataBytes = new byte[messageHeader.getBizDataLength()];
        byteBuf.readBytes(bizDataBytes);

        // ååºåˆ—åŒ–æ¶ˆæ¯ä½“
        MyRpcSerializer myRpcSerializer = MyRpcSerializerManager.getSerializer(messageHeader.getSerializeType());
        return (T) myRpcSerializer.deserialize(bizDataBytes,messageBizDataType);
    }
}
Copy<br>è‡ªå®šä¹‰ç¼–ç å™¨: NettyEncoder<br>public class NettyEncoder&lt;T&gt; extends MessageToByteEncoder&lt;MessageProtocol&lt;T&gt;&gt; {

    @Override
    protected void encode(ChannelHandlerContext channelHandlerContext, MessageProtocol&lt;T&gt; messageProtocol, ByteBuf byteBuf) {
        // ç»§æ‰¿è‡ªMessageToByteEncoderä¸­ï¼Œåªéœ€è¦å°†ç¼–ç åçš„æ•°æ®å†™å…¥å‚æ•°ä¸­æŒ‡å®šçš„byteBufä¸­å³å¯
        // MessageToByteEncoderæºç é€»è¾‘ä¸­ä¼šè‡ªå·±å»å°†byteBufå†™å…¥channelçš„
        MessageCodecUtil.messageEncode(messageProtocol,byteBuf);
    }
}
Copy<br>è‡ªå®šä¹‰è§£ç å™¨: NettyDecoder<br>/**
 * netty è§£ç å™¨
 */
public class NettyDecoder extends ByteToMessageDecoder {

    private static final Logger logger = LoggerFactory.getLogger(NettyDecoder.class);

    @Override
    protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list){
        do{
            try {
                // ä¿å­˜è¯»å–å‰çš„è¯»æŒ‡é’ˆ
                int beforeReadIndex = byteBuf.readerIndex();
                MessageDecodeResult messageDecodeResult = decodeHeader(byteBuf);

                if (messageDecodeResult.isNeedMoreData()) {
                    // å‡ºç°æ‹†åŒ…æ²¡æœ‰è¯»å–åˆ°ä¸€ä¸ªå®Œæ•´çš„rpcè¯·æ±‚ï¼Œè¿˜åŸbyteBufè¯»æŒ‡é’ˆï¼Œç­‰å¾…ä¸‹ä¸€æ¬¡è¯»äº‹ä»¶
                    byteBuf.readerIndex(beforeReadIndex);
                    break;
                } else {
                    // æ­£å¸¸è§£æå®Œä¸€ä¸ªå®Œæ•´çš„messageï¼Œäº¤ç»™åé¢çš„handlerå¤„ç†
                    list.add(messageDecodeResult.getMessageProtocol());
                }
            }catch (Exception e){
                // æ¯”å¦‚decodeHeaderé‡Œjsonåºåˆ—åŒ–å¤±è´¥äº†ç­‰ç­‰.ç›´æ¥è·³è¿‡è¿™ä¸ªæ•°æ®åŒ…ä¸è¿˜åŸäº†
                logger.error("NettyDecoder error!",e);
            }

            // å¾ªç¯ï¼Œç›´åˆ°æ•´ä¸ªByteBufè¯»å–å®Œ
        }while(byteBuf.isReadable());
    }
    
    private MessageDecodeResult decodeHeader(ByteBuf byteBuf){
        int readable = byteBuf.readableBytes();
        if(readable &lt; MessageHeader.MESSAGE_HEADER_LENGTH){
            // æ— æ³•è¯»å–åˆ°ä¸€ä¸ªå®Œæ•´çš„headerï¼Œè¯´æ˜å‡ºç°äº†æ‹†åŒ…ï¼Œç­‰å¾…æ›´å¤šçš„æ•°æ®
            return MessageDecodeResult.needMoreData();
        }

        // è¯»å–headerå¤´
        MessageHeader messageHeader = MessageCodecUtil.messageHeaderDecode(byteBuf);

        int bizDataLength = messageHeader.getBizDataLength();
        if(byteBuf.readableBytes() &lt; bizDataLength){
            // æ— æ³•è¯»å–åˆ°ä¸€ä¸ªå®Œæ•´çš„æ­£æ–‡å†…å®¹ï¼Œè¯´æ˜å‡ºç°äº†æ‹†åŒ…ï¼Œç­‰å¾…æ›´å¤šçš„æ•°æ®
            return MessageDecodeResult.needMoreData();
        }

        // åŸºäºæ¶ˆæ¯ç±»å‹æ ‡è¯†ï¼Œè§£ærpcæ­£æ–‡å¯¹è±¡
        boolean messageFlag = messageHeader.getMessageFlag();
        if(messageFlag == MessageFlagEnums.REQUEST.getCode()){
            RpcRequest rpcRequest = MessageCodecUtil.messageBizDataDecode(messageHeader,byteBuf,RpcRequest.class);
            MessageProtocol&lt;RpcRequest&gt; messageProtocol = new MessageProtocol&lt;&gt;(messageHeader,rpcRequest);
            // æ­£ç¡®çš„è§£æå®Œä¸€ä¸ªrpcè¯·æ±‚æ¶ˆæ¯
            return MessageDecodeResult.decodeSuccess(messageProtocol);
        }else{
            RpcResponse rpcResponse = MessageCodecUtil.messageBizDataDecode(messageHeader,byteBuf,RpcResponse.class);
            MessageProtocol&lt;RpcResponse&gt; messageProtocol = new MessageProtocol&lt;&gt;(messageHeader,rpcResponse);
            // æ­£ç¡®çš„è§£æå®Œä¸€ä¸ªrpcå“åº”æ¶ˆæ¯
            return MessageDecodeResult.decodeSuccess(messageProtocol);
        }
    }
}
Copy<br><br>demoçš„æœåŠ¡ç¤ºä¾‹:<br>public class User implements Serializable {

    private String name;
    private Integer age;
}
Copy<br>public interface UserService {

    User getUserFriend(User user, String message);
}
Copy<br>public class UserServiceImpl implements UserService {
    @Override
    public User getUserFriend(User user, String message) {
        System.out.println("execute getUserFriend, user=" + user + ",message=" + message);

        // demoè¿”å›ä¸€ä¸ªä¸åŒçš„userå¯¹è±¡å›å»
        return new User(user.getName() + ".friend", user.getAge() + 1);
    }
}
Copy<br>nettyæœåŠ¡ç«¯ï¼š<br>public class RpcServer {

    private static final Map&lt;String,Object&gt; interfaceImplMap = new HashMap&lt;&gt;();

    static{
        /**
         * ç®€å•ä¸€ç‚¹é…ç½®æ­»å®ç°
         * */
        interfaceImplMap.put(UserService.class.getName(), new UserServiceImpl());
    }

    public static void main(String[] args) throws InterruptedException {
        ServerBootstrap bootstrap = new ServerBootstrap();
        EventLoopGroup bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory("NettyServerBoss", true));
        EventLoopGroup workerGroup = new NioEventLoopGroup(8,new DefaultThreadFactory("NettyServerWorker", true));

        bootstrap.group(bossGroup, workerGroup)
            .channel(NioServerSocketChannel.class)
            .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {
                @Override
                protected void initChannel(SocketChannel socketChannel) {
                    socketChannel.pipeline()
                        // ç¼–ç ã€è§£ç å¤„ç†å™¨
                        .addLast("encoder", new NettyEncoder&lt;&gt;())
                        .addLast("decoder", new NettyDecoder())
                        // å®é™…è°ƒç”¨ä¸šåŠ¡æ–¹æ³•çš„å¤„ç†å™¨
                        .addLast("serverHandler", new SimpleChannelInboundHandler&lt;MessageProtocol&lt;RpcRequest&gt;&gt;() {
                            @Override
                            protected void channelRead0(ChannelHandlerContext ctx, MessageProtocol&lt;RpcRequest&gt; msg) {
                                // æ‰¾åˆ°æœ¬åœ°çš„æ–¹æ³•è¿›è¡Œè°ƒç”¨ï¼Œå¹¶è·å¾—è¿”å›å€¼(demoï¼Œç®€å•èµ·è§ç›´æ¥åŒæ­¥è°ƒç”¨)
                                MessageProtocol&lt;RpcResponse&gt; result = handlerRpcRequest(msg);

                                // å°†è¿”å›å€¼å“åº”ç»™å®¢æˆ·ç«¯
                                ctx.writeAndFlush(result);
                            }
                        });
                }
            });

        ChannelFuture channelFuture = bootstrap.bind("127.0.0.1", 8888).sync();

        System.out.println("netty server started!");
        // ä¸€ç›´é˜»å¡åœ¨è¿™é‡Œ
        channelFuture.channel().closeFuture().sync();
    }

    private static MessageProtocol&lt;RpcResponse&gt; handlerRpcRequest(MessageProtocol&lt;RpcRequest&gt; rpcRequestMessageProtocol){
        long requestMessageId = rpcRequestMessageProtocol.getMessageHeader().getMessageId();

        MessageHeader messageHeader = new MessageHeader();
        messageHeader.setMessageId(requestMessageId);
        messageHeader.setMessageFlag(MessageFlagEnums.RESPONSE.getCode());
        messageHeader.setTwoWayFlag(false);
        messageHeader.setEventFlag(false);
        messageHeader.setSerializeType(rpcRequestMessageProtocol.getMessageHeader().getSerializeType());

        RpcResponse rpcResponse = new RpcResponse();
        rpcResponse.setMessageId(requestMessageId);

        try {
            // åå°„è°ƒç”¨å…·ä½“çš„å®ç°æ–¹æ³•
            Object result = invokeTargetService(rpcRequestMessageProtocol.getBizDataBody());

            // è®¾ç½®è¿”å›å€¼
            rpcResponse.setReturnValue(result);
        }catch (Exception e){
            // è°ƒç”¨å…·ä½“å®ç°ç±»æ—¶ï¼Œå‡ºç°å¼‚å¸¸ï¼Œè®¾ç½®å¼‚å¸¸çš„å€¼
            rpcResponse.setExceptionValue(e);
        }

        return new MessageProtocol&lt;&gt;(messageHeader,rpcResponse);
    }

    private static Object invokeTargetService(RpcRequest rpcRequest) throws Exception {
        String interfaceName = rpcRequest.getInterfaceName();
        Object serviceImpl = interfaceImplMap.get(interfaceName);

        // æŒ‰ç…§è¯·æ±‚é‡Œçš„æ–¹æ³•åå’Œå‚æ•°åˆ—è¡¨æ‰¾åˆ°å¯¹åº”çš„æ–¹æ³•
        final Method method = serviceImpl.getClass().getMethod(rpcRequest.getMethodName(), rpcRequest.getParameterClasses());

        // ä¼ é€’å‚æ•°ï¼Œåå°„è°ƒç”¨è¯¥æ–¹æ³•å¹¶è¿”å›ç»“æœ
        return method.invoke(serviceImpl, rpcRequest.getParams());
    }
}
Copy<br>nettyå®¢æˆ·ç«¯ï¼š<br>public class RpcClientNoProxy {

    public static void main(String[] args) throws InterruptedException {
        Bootstrap bootstrap = new Bootstrap();
        EventLoopGroup eventLoopGroup = new NioEventLoopGroup(8,
            new DefaultThreadFactory("NettyClientWorker", true));

        bootstrap.group(eventLoopGroup)
            .channel(NioSocketChannel.class)
            .handler(new ChannelInitializer&lt;SocketChannel&gt;() {
                @Override
                protected void initChannel(SocketChannel socketChannel) {
                    socketChannel.pipeline()
                        // ç¼–ç ã€è§£ç å¤„ç†å™¨
                        .addLast("encoder", new NettyEncoder&lt;&gt;())
                        .addLast("decoder", new NettyDecoder())
                        .addLast("clientHandler", new SimpleChannelInboundHandler&lt;MessageProtocol&gt;() {
                            @Override
                            protected void channelRead0(ChannelHandlerContext channelHandlerContext, MessageProtocol messageProtocol) {
                                System.out.println("PureNettyClient received messageProtocol=" + messageProtocol);
                            }
                        })
                    ;
                }
            });

        ChannelFuture channelFuture = bootstrap.connect("127.0.0.1", 8888).sync();
        Channel channel = channelFuture.sync().channel();

        // æ„é€ æ¶ˆæ¯å¯¹è±¡
        MessageProtocol&lt;RpcRequest&gt; messageProtocol = buildMessage();
        // å‘é€æ¶ˆæ¯
        channel.writeAndFlush(messageProtocol);

        System.out.println("RpcClientNoProxy send request success!");
        channelFuture.channel().closeFuture().sync();
    }

    private static MessageProtocol&lt;RpcRequest&gt; buildMessage(){
        // æ„é€ è¯·æ±‚
        RpcRequest rpcRequest = new RpcRequest();
        rpcRequest.setInterfaceName("myrpc.demo.common.service.UserService");
        rpcRequest.setMethodName("getUserFriend");
        rpcRequest.setParameterClasses(new Class[]{User.class,String.class});

        User user = new User("Jerry",10);
        String message = "hello hello!";
        rpcRequest.setParams(new Object[]{user,message});

        // æ„é€ åè®®å¤´
        MessageHeader messageHeader = new MessageHeader();
        messageHeader.setMessageFlag(MessageFlagEnums.REQUEST.getCode());
        messageHeader.setTwoWayFlag(false);
        messageHeader.setEventFlag(true);
        messageHeader.setSerializeType(MessageSerializeType.JSON.getCode());
        messageHeader.setMessageId(rpcRequest.getMessageId());

        return new MessageProtocol&lt;&gt;(messageHeader,rpcRequest);
    }
}
Copy<br><img alt="Pasted image 20240725172059.png" src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/rpcæ¡†æ¶çš„å®ç°/pasted-image-20240725172059.png"><br><br>æˆªæ­¢ç›®å‰ï¼Œæˆ‘ä»¬å·²ç»å®ç°äº†ä¸€ä¸ªç‚¹å¯¹ç‚¹rpcå®¢æˆ·ç«¯/æœåŠ¡ç«¯äº¤äº’çš„åŠŸèƒ½ï¼Œä½†æ˜¯å®¢æˆ·ç«¯è¿™è¾¹çš„é€»è¾‘ä¾ç„¶æ¯”è¾ƒå¤æ‚(buildMessageæ–¹æ³•)ã€‚<br>
å‰é¢æåˆ°ï¼Œrpcä¸­å¾ˆé‡è¦çš„åŠŸèƒ½å°±æ˜¯ä¿æŒæœ¬åœ°è°ƒç”¨æ—¶è¯­ä¹‰çš„ç®€æ´æ€§ï¼Œå³å®¢æˆ·ç«¯å®é™…ä½¿ç”¨æ—¶æ˜¯å¸Œæœ›ç›´æ¥ç”¨ä»¥ä¸‹è¿™ç§æ–¹å¼æ¥è¿›è¡Œè°ƒç”¨ï¼Œè€Œä¸æ˜¯å»ç¹ççš„å¤„ç†åº•å±‚çš„ç½‘ç»œäº¤äº’é€»è¾‘ã€‚<br>    User user = new User("Jerry",10);
    String message = "hello hello!";
    // å‘èµ·rpcè°ƒç”¨å¹¶è·å¾—è¿”å›å€¼
    User userFriend = userService.getUserFriend(user,message);
    System.out.println("userService.getUserFriend result=" + userFriend);
Copy<br>rpcæ¡†æ¶éœ€è¦å±è”½æ‰æ„é€ åº•å±‚æ¶ˆæ¯å‘é€/æ¥å—ï¼Œåºåˆ—åŒ–/ååºåˆ—åŒ–ç›¸å…³çš„å¤æ‚æ€§ï¼Œè€Œè¿™æ—¶å€™å°±éœ€è¦å¼•å…¥ä»£ç†æ¨¡å¼(åŠ¨æ€ä»£ç†)äº†ã€‚<br>
åœ¨MyRpcçš„åº•å±‚ï¼Œæˆ‘ä»¬å°†å®¢æˆ·ç«¯éœ€è¦è°ƒç”¨çš„ä¸€ä¸ªæœåŠ¡(æ¯”å¦‚UserService)æŠ½è±¡ä¸ºConsumerå¯¹è±¡ï¼ŒæœåŠ¡ç«¯çš„ä¸€ä¸ªå…·ä½“æœåŠ¡å®ç°æŠ½è±¡ä¸ºProviderå¯¹è±¡ã€‚<br>
å…¶ä¸­åŒ…å«äº†å¯¹åº”çš„æœåŠ¡çš„ç±»ä»¥åŠå¯¹åº”çš„æœåŠ¡åœ°å€ï¼Œå®¢æˆ·ç«¯è¿™è¾¹ä½¿ç”¨jdkçš„åŠ¨æ€ä»£ç†ç”Ÿæˆä»£ç†å¯¹è±¡ï¼Œå°†å¤æ‚çš„ã€éœ€è¦å±è”½çš„æ¶ˆæ¯å¤„ç†/ç½‘ç»œäº¤äº’ç­‰é€»è¾‘éƒ½å°è£…åœ¨è¿™ä¸ªä»£ç†å¯¹è±¡ä¸­ã€‚<br>public class Consumer&lt;T&gt; {

    private Class&lt;?&gt; interfaceClass;
    private T proxy;

    private Bootstrap bootstrap;
    private URLAddress urlAddress;

    public Consumer(Class&lt;?&gt; interfaceClass, Bootstrap bootstrap, URLAddress urlAddress) {
        this.interfaceClass = interfaceClass;
        this.bootstrap = bootstrap;
        this.urlAddress = urlAddress;

        ClientDynamicProxy clientDynamicProxy = new ClientDynamicProxy(bootstrap,urlAddress);

        this.proxy = (T) Proxy.newProxyInstance(
            clientDynamicProxy.getClass().getClassLoader(),
            new Class[]{interfaceClass},
            clientDynamicProxy);
    }

    public T getProxy() {
        return proxy;
    }

    public Class&lt;?&gt; getInterfaceClass() {
        return interfaceClass;
    }
}
Copy<br>public class ConsumerBootstrap {

    private final Map&lt;Class&lt;?&gt;,Consumer&lt;?&gt;&gt; consumerMap = new HashMap&lt;&gt;();
    private final Bootstrap bootstrap;
    private final URLAddress urlAddress;

    public ConsumerBootstrap(Bootstrap bootstrap, URLAddress urlAddress) {
        this.bootstrap = bootstrap;
        this.urlAddress = urlAddress;
    }

    public &lt;T&gt; Consumer&lt;T&gt; registerConsumer(Class&lt;T&gt; clazz){
        if(!consumerMap.containsKey(clazz)){
            Consumer&lt;T&gt; consumer = new Consumer&lt;&gt;(clazz,this.bootstrap,this.urlAddress);
            consumerMap.put(clazz,consumer);
            return consumer;
        }

        throw new MyRpcException("duplicate consumer! clazz=" + clazz);
    }
}
Copy<br>public class Provider&lt;T&gt; {

    private Class&lt;?&gt; interfaceClass;
    private T ref;
    private URLAddress urlAddress;
}
Copy<br><br>/**
 * å®¢æˆ·ç«¯åŠ¨æ€ä»£ç†
 * */
public class ClientDynamicProxy implements InvocationHandler {

    private static final Logger logger = LoggerFactory.getLogger(ClientDynamicProxy.class);

    private final Bootstrap bootstrap;
    private final URLAddress urlAddress;

    public ClientDynamicProxy(Bootstrap bootstrap, URLAddress urlAddress) {
        this.bootstrap = bootstrap;
        this.urlAddress = urlAddress;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Tuple&lt;Object,Boolean&gt; localMethodResult = processLocalMethod(proxy,method,args);
        if(localMethodResult.getRight()){
            // rightä¸ºtrue,ä»£è¡¨æ˜¯æœ¬åœ°æ–¹æ³•ï¼Œè¿”å›toStringç­‰å¯¹è±¡è‡ªå¸¦æ–¹æ³•çš„æ‰§è¡Œç»“æœï¼Œä¸å‘èµ·rpcè°ƒç”¨
            return localMethodResult.getLeft();
        }

        logger.debug("ClientDynamicProxy before: methodName=" + method.getName());

        // æ„é€ è¯·æ±‚å’Œåè®®å¤´
        RpcRequest rpcRequest = new RpcRequest();
        rpcRequest.setInterfaceName(method.getDeclaringClass().getName());
        rpcRequest.setMethodName(method.getName());
        rpcRequest.setParameterClasses(method.getParameterTypes());
        rpcRequest.setParams(args);

        MessageHeader messageHeader = new MessageHeader();
        messageHeader.setMessageFlag(MessageFlagEnums.REQUEST.getCode());
        messageHeader.setTwoWayFlag(false);
        messageHeader.setEventFlag(true);
        messageHeader.setSerializeType(GlobalConfig.messageSerializeType.getCode());
        messageHeader.setResponseStatus((byte)'a');
        messageHeader.setMessageId(rpcRequest.getMessageId());

        logger.debug("ClientDynamicProxy rpcRequest={}", JsonUtil.obj2Str(rpcRequest));

        ChannelFuture channelFuture = bootstrap.connect(urlAddress.getHost(),urlAddress.getPort()).sync();
        Channel channel = channelFuture.sync().channel();
        // é€šè¿‡Promiseï¼Œå°†nettyçš„å¼‚æ­¥è½¬ä¸ºåŒæ­¥,å‚è€ƒdubbo DefaultFuture
        DefaultFuture&lt;RpcResponse&gt; defaultFuture = DefaultFutureManager.createNewFuture(channel,rpcRequest);

        channel.writeAndFlush(new MessageProtocol&lt;&gt;(messageHeader,rpcRequest));
        logger.debug("ClientDynamicProxy writeAndFlush success, wait result");

        // è°ƒç”¨æ–¹é˜»å¡åœ¨è¿™é‡Œ
        RpcResponse rpcResponse = defaultFuture.get();

        logger.debug("ClientDynamicProxy defaultFuture.get() rpcResponse={}",rpcResponse);

        return processRpcResponse(rpcResponse);
    }

    /**
     * å¤„ç†æœ¬åœ°æ–¹æ³•
     * @return tuple.right æ ‡è¯†æ˜¯å¦æ˜¯æœ¬åœ°æ–¹æ³•ï¼Œ trueæ˜¯
     * */
    private Tuple&lt;Object,Boolean&gt; processLocalMethod(Object proxy, Method method, Object[] args) throws Exception {
        // å¤„ç†toStringç­‰å¯¹è±¡è‡ªå¸¦æ–¹æ³•ï¼Œä¸å‘èµ·rpcè°ƒç”¨
        if (method.getDeclaringClass() == Object.class) {
            return new Tuple&lt;&gt;(method.invoke(proxy, args),true);
        }
        String methodName = method.getName();
        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();
        if (parameterTypes.length == 0) {
            if ("toString".equals(methodName)) {
                return new Tuple&lt;&gt;(proxy.toString(),true);
            } else if ("hashCode".equals(methodName)) {
                return new Tuple&lt;&gt;(proxy.hashCode(),true);
            }
        } else if (parameterTypes.length == 1 &amp;&amp; "equals".equals(methodName)) {
            return new Tuple&lt;&gt;(proxy.equals(args[0]),true);
        }

        // è¿”å›nullæ ‡è¯†éæœ¬åœ°æ–¹æ³•ï¼Œéœ€è¦è¿›è¡Œrpcè°ƒç”¨
        return new Tuple&lt;&gt;(null,false);
    }

    private Object processRpcResponse(RpcResponse rpcResponse){
        if(rpcResponse.getExceptionValue() == null){
            // æ²¡æœ‰å¼‚å¸¸ï¼Œreturnæ­£å¸¸çš„è¿”å›å€¼
            return rpcResponse.getReturnValue();
        }else{
            // æœ‰å¼‚å¸¸ï¼Œå¾€å¤–æŠ›å‡ºå»
            throw new MyRpcRemotingException(rpcResponse.getExceptionValue());
        }
    }
}
Copy<br><br>/**
 * å®¢æˆ·ç«¯ rpcå“åº”å¤„ç†å™¨
 */
public class NettyRpcResponseHandler extends SimpleChannelInboundHandler&lt;MessageProtocol&lt;RpcResponse&gt;&gt; {

    private static final Logger logger = LoggerFactory.getLogger(NettyRpcResponseHandler.class);

    @Override
    protected void channelRead0(ChannelHandlerContext channelHandlerContext, MessageProtocol&lt;RpcResponse&gt; rpcResponseMessageProtocol) throws Exception {
        logger.debug("NettyRpcResponseHandler channelRead0={}",JsonUtil.obj2Str(rpcResponseMessageProtocol));

        // è§¦å‘å®¢æˆ·ç«¯çš„futureï¼Œä»¤å…¶åŒæ­¥é˜»å¡çš„çº¿ç¨‹å¾—åˆ°ç»“æœ
        DefaultFutureManager.received(rpcResponseMessageProtocol.getBizDataBody());
    }
}
Copy<br>public class DefaultFutureManager {

    private static Logger logger = LoggerFactory.getLogger(DefaultFutureManager.class);

    public static final Map&lt;Long,DefaultFuture&gt; DEFAULT_FUTURE_CACHE = new ConcurrentHashMap&lt;&gt;();

    public static void received(RpcResponse rpcResponse){
        Long messageId = rpcResponse.getMessageId();

        logger.debug("received rpcResponse={},DEFAULT_FUTURE_CACHE={}",rpcResponse,DEFAULT_FUTURE_CACHE);
        DefaultFuture defaultFuture = DEFAULT_FUTURE_CACHE.remove(messageId);

        if(defaultFuture != null){
            logger.debug("remove defaultFuture success");
            if(rpcResponse.getExceptionValue() != null){
                // å¼‚å¸¸å¤„ç†
                defaultFuture.completeExceptionally(rpcResponse.getExceptionValue());
            }else{
                // æ­£å¸¸è¿”å›
                defaultFuture.complete(rpcResponse);
            }
        }else{
            logger.debug("remove defaultFuture fail");
        }
    }

    public static DefaultFuture createNewFuture(Channel channel, RpcRequest rpcRequest){
        DefaultFuture defaultFuture = new DefaultFuture(channel,rpcRequest);

        return defaultFuture;
    }
}
Copy<br><br>public class RpcClientProxy {

    public static void main(String[] args) throws InterruptedException {
        Bootstrap bootstrap = new Bootstrap();
        EventLoopGroup eventLoopGroup = new NioEventLoopGroup(8, new DefaultThreadFactory("NettyClientWorker", true));

        bootstrap.group(eventLoopGroup)
            .channel(NioSocketChannel.class)
            .handler(new ChannelInitializer&lt;SocketChannel&gt;() {
                @Override
                protected void initChannel(SocketChannel socketChannel) {
                    socketChannel.pipeline()
                        // ç¼–ç ã€è§£ç å¤„ç†å™¨
                        .addLast("encoder", new NettyEncoder&lt;&gt;())
                        .addLast("decoder", new NettyDecoder())

                        // å“åº”å¤„ç†å™¨
                        .addLast("clientHandler", new NettyRpcResponseHandler())
                    ;
                }
            });

        ConsumerBootstrap consumerBootstrap = new ConsumerBootstrap(bootstrap, new URLAddress("127.0.0.1", 8888));
        Consumer&lt;UserService&gt; userServiceConsumer = consumerBootstrap.registerConsumer(UserService.class);

        // è·å¾—UserServiceçš„ä»£ç†å¯¹è±¡
        UserService userService = userServiceConsumer.getProxy();

        User user = new User("Jerry", 10);
        String message = "hello hello!";
        // å‘èµ·rpcè°ƒç”¨å¹¶è·å¾—è¿”å›å€¼
        User userFriend = userService.getUserFriend(user, message);
        System.out.println("userService.getUserFriend result=" + userFriend);
    }
}
Copy<br>å¯ä»¥çœ‹åˆ°ï¼Œå¼•å…¥äº†ä»£ç†æ¨¡å¼åçš„ä½¿ç”¨æ–¹å¼å°±å˜å¾—ç®€å•å¾ˆå¤šäº†ã€‚<br>
åˆ°è¿™ä¸€æ­¥ï¼Œæˆ‘ä»¬å·²ç»å®ç°äº†ä¸€ä¸ªç‚¹å¯¹ç‚¹çš„rpcé€šä¿¡çš„èƒ½åŠ›ï¼Œå¹¶ä¸”å¦‚åšå®¢å¼€å¤´ä¸­æ‰€æåˆ°çš„ï¼Œæ²¡æœ‰ä¸§å¤±æœ¬åœ°è°ƒç”¨è¯­ä¹‰çš„ç®€æ´æ€§ã€‚<br><br>
<br>è¿™ç¯‡åšå®¢æ˜¯æˆ‘å…³äºMit6.824åˆ†å¸ƒå¼ç³»ç»Ÿå…¬å¼€è¯¾labçš„ç¬¬ä¸€ç¯‡åšå®¢ï¼ŒæŒ‰ç…§è®¡åˆ’ä¼šå°†å®ç°ç®€æ˜“ç‰ˆrpcå’Œraft k/væ•°æ®åº“çš„å¿ƒå¾—ä»¥åšå®¢çš„å½¢å¼åˆ†äº«å‡ºæ¥ï¼Œå¸Œæœ›èƒ½å¸®åŠ©åˆ°å¯¹åˆ†å¸ƒå¼ç³»ç»Ÿç›¸å…³æŠ€æœ¯çš„å°ä¼™ä¼´ã€‚
<br>æ‰“ä¸ªå¹¿å‘Šï¼šå¯¹äºè‹±è¯­ä¸å¥½(æ²¡æ³•ç›´æ¥å•ƒç”Ÿè‚‰)ä½†åˆå¯¹å›½å¤–è‘—åçš„è®¡ç®—æœºå…¬å¼€è¯¾(æ¶‰åŠæ“ä½œç³»ç»Ÿã€æ•°æ®åº“ã€åˆ†å¸ƒå¼ç³»ç»Ÿã€ç¼–è¯‘åŸç†ã€è®¡ç®—æœºç½‘ç»œã€ç®—æ³•ç­‰ç­‰)æ„Ÿå…´è¶£çš„å°ä¼™ä¼´ï¼Œå¯ä»¥å’¨è¯¢simvisoè´­ä¹°ä¸­è‹±ç¿»è¯‘è´¨é‡å¾ˆé«˜çš„å…¬å¼€è¯¾è§†é¢‘(æ¯”å¦‚Mit6.824ï¼Œbç«™ä¸Šå¼€æ”¾äº†ä¸€éƒ¨åˆ†å…è´¹çš„è§†é¢‘ï¼š<a rel="noopener" class="external-link" href="https://www.bilibili.com/video/BV1x7411M7Sf" target="_blank">https://www.bilibili.com/video/BV1x7411M7Sf</a>)ã€‚
<br>åšå®¢ä¸­å±•ç¤ºçš„å®Œæ•´ä»£ç åœ¨æˆ‘çš„githubä¸Šï¼š<a rel="noopener" class="external-link" href="https://github.com/1399852153/MyRpc" target="_blank">https://github.com/1399852153/MyRpc</a> (release/lab1åˆ†æ”¯)ï¼Œå†…å®¹å¦‚æœ‰é”™è¯¯ï¼Œè¿˜è¯·å¤šå¤šæŒ‡æ•™ã€‚
]]></description><link>https://muqiuhan.github.io/wiki/computer-science/distributed-system/rpcæ¡†æ¶çš„å®ç°/è‡ªå·±åŠ¨æ‰‹å®ç°rpcæ¡†æ¶(ä¸€)-å®ç°ç‚¹å¯¹ç‚¹çš„rpcé€šä¿¡.html</link><guid isPermaLink="false">Computer Science/Distributed System/RPCæ¡†æ¶çš„å®ç°/è‡ªå·±åŠ¨æ‰‹å®ç°rpcæ¡†æ¶(ä¸€) å®ç°ç‚¹å¯¹ç‚¹çš„rpcé€šä¿¡.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Thu, 25 Jul 2024 09:21:13 GMT</pubDate><enclosure url="https://muqiuhan.github.io/wiki/computer-science/distributed-system/rpcæ¡†æ¶çš„å®ç°/pasted-image-20240725171915.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/rpcæ¡†æ¶çš„å®ç°/pasted-image-20240725171915.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[è‡ªå·±åŠ¨æ‰‹å®ç°rpcæ¡†æ¶(äºŒ) å®ç°é›†ç¾¤é—´rpcé€šä¿¡]]></title><description><![CDATA[ 
 <br><br>ä¸Šä¸€ç¯‡åšå®¢ä¸­MyRpcæ¡†æ¶å®ç°äº†åŸºæœ¬çš„ç‚¹å¯¹ç‚¹rpcé€šä¿¡åŠŸèƒ½ã€‚è€Œåœ¨è¿™ç¯‡åšå®¢ä¸­æˆ‘ä»¬éœ€è¦å®ç°MyRpcçš„é›†ç¾¤é—´rpcé€šä¿¡åŠŸèƒ½ã€‚<br>
<br><a data-tooltip-position="top" aria-label="https://www.cnblogs.com/xiaoxiongcanguan/p/17506728.html" rel="noopener" class="external-link" href="https://www.cnblogs.com/xiaoxiongcanguan/p/17506728.html" target="_blank">è‡ªå·±åŠ¨æ‰‹å®ç°rpcæ¡†æ¶(ä¸€) å®ç°ç‚¹å¯¹ç‚¹çš„rpcé€šä¿¡</a>
<br>ä¸Šç¯‡åšå®¢çš„ç‚¹å¯¹ç‚¹rpcé€šä¿¡å®ç°ä¸­ï¼Œå®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯çš„ipåœ°å€å’Œç«¯å£éƒ½æ˜¯å›ºå®šé…ç½®æ­»çš„ã€‚è€Œé€šå¸¸ä¸ºäº†æå‡æœåŠ¡æ€»è´Ÿè½½ï¼Œå®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯éƒ½æ˜¯ä»¥é›†ç¾¤çš„æ–¹å¼éƒ¨ç½²çš„(æ°´å¹³æ‹“å±•)ï¼Œå®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯çš„èŠ‚ç‚¹éƒ½ä¸æ­¢1ä¸ªã€‚<br>é›†ç¾¤æ¡ä»¶ä¸‹å‡ºç°äº†å¾ˆå¤šæ–°çš„é—®é¢˜éœ€è¦è§£å†³ï¼š<br>
<br>å¯¹äºæŸä¸€ç‰¹å®šæœåŠ¡ï¼Œå®¢æˆ·ç«¯è¯¥å¦‚ä½•çŸ¥é“å½“å‰ç¯å¢ƒä¸‹å“ªäº›æœºå™¨èƒ½æä¾›è¿™ä¸€æœåŠ¡?
<br>æœåŠ¡ç«¯é›†ç¾¤ä¸­çš„æŸäº›èŠ‚ç‚¹å¦‚æœå‘ç”Ÿäº†å˜åŒ–(æ¯”å¦‚è€èŠ‚ç‚¹ä¸‹çº¿æˆ–å®•æœº)ï¼Œå®¢æˆ·ç«¯è¯¥å¦‚ä½•åŠæ—¶çš„æ„ŸçŸ¥åˆ°ï¼Œè€Œä¸ä¼šè°ƒç”¨åˆ°å·²ç»åœæ­¢æœåŠ¡çš„èŠ‚ç‚¹ä¸Šï¼Ÿ
<br>å­˜åœ¨å¤šä¸ªæœåŠ¡ç«¯æ—¶ï¼Œå®¢æˆ·ç«¯åº”è¯¥å‘å“ªä¸€ä¸ªæœåŠ¡ç«¯èŠ‚ç‚¹å‘èµ·è¯·æ±‚ï¼Ÿæ€æ ·æ‰èƒ½ä½¿å¾—æ¯ä¸ªæœåŠ¡ç«¯çš„è´Ÿè½½å°½é‡å‡è¡¡ï¼Œè€Œä¸ä¼šè®©æŸäº›æœåŠ¡ç«¯é¥¥é¥¿æˆ–è€…å‹åŠ›è¿‡å¤§ã€‚
<br><br>
<br>é’ˆå¯¹ç¬¬ä¸€ä¸ªé—®é¢˜ï¼Œæœ€å…ˆæƒ³åˆ°çš„è‡ªç„¶æ˜¯ç›´æ¥åœ¨æ¯ä¸ªå®¢æˆ·ç«¯éƒ½é…ç½®ä¸€ä¸ªå›ºå®šçš„æœåŠ¡ç«¯èŠ‚ç‚¹åˆ—è¡¨ï¼Œä½†è¿™ä¸€æ–¹æ¡ˆæ— æ³•å¾ˆå¥½çš„è§£å†³æœåŠ¡ç«¯èŠ‚ç‚¹åŠ¨æ€å˜åŒ–çš„é—®é¢˜ã€‚<br>
å¦‚æœä¸€ä¸ªæœåŠ¡ç«¯èŠ‚ç‚¹ä¸‹çº¿äº†ï¼Œå°±éœ€è¦äººå·¥çš„å»ä¿®æ”¹æ¯ä¸ªå®¢æˆ·ç«¯é‚£é‡Œç»´æŠ¤çš„æœåŠ¡ç«¯èŠ‚ç‚¹åˆ—è¡¨çš„è¯ï¼Œåœ¨é›†ç¾¤èŠ‚ç‚¹æ•°é‡è¾ƒå¤šã€æœåŠ¡ç«¯èŠ‚ç‚¹ä¸Šä¸‹çº¿é¢‘ç¹çš„åœºæ™¯ä¸‹æ˜¯ä¸å¯æ¥å—çš„ã€‚
<br>è§£å†³è¿™ä¸€é—®é¢˜çš„æ€è·¯æ˜¯æœåŠ¡ç«¯èŠ‚ç‚¹ä¿¡æ¯çš„ä¸­å¿ƒåŒ–ï¼Œå°†æœåŠ¡ç«¯èŠ‚ç‚¹çš„ä¿¡æ¯éƒ½é›†ä¸­ç»´æŠ¤åœ¨ä¸€ä¸ªåœ°æ–¹ã€‚<br>
æœåŠ¡ç«¯åœ¨å¯åŠ¨æˆåŠŸåå°†è‡ªå·±çš„ä¿¡æ¯æ³¨å†Œåœ¨ä¸Šé¢(æœåŠ¡æ³¨å†Œ)ï¼Œè€Œå®¢æˆ·ç«¯ä¹Ÿèƒ½å®æ—¶çš„æŸ¥è¯¢å‡ºæœ€æ–°çš„æœåŠ¡ç«¯åˆ—è¡¨(æœåŠ¡å‘ç°)ã€‚<br>
è¿™ä¸ªç»Ÿä¸€ç»´æŠ¤æœåŠ¡ç«¯èŠ‚ç‚¹ä¿¡æ¯çš„åœ°æ–¹è¢«å«åšæ³¨å†Œä¸­å¿ƒï¼Œä¸€èˆ¬æ˜¯ä»¥ç‹¬ç«‹æœåŠ¡çš„å½¢å¼ä¸rpcçš„æœåŠ¡ç«¯/å®¢æˆ·ç«¯æœºå™¨éƒ¨ç½²åœ¨åŒä¸€ç¯å¢ƒå†…ã€‚
<br>ç”±äºèŠ‚ç‚¹ä¿¡æ¯çš„ä¸­å¿ƒåŒ–ï¼Œæ‰€ä»¥æ³¨å†Œä¸­å¿ƒéœ€è¦å…·å¤‡é«˜å¯ç”¨èƒ½åŠ›(é›†ç¾¤éƒ¨ç½²æ¥æä¾›å®¹é”™èƒ½åŠ›)ï¼Œé¿å…å•ç‚¹æ•…éšœè€Œå¯¼è‡´æ•´ä¸ªrpcé›†ç¾¤çš„ä¸å¯ç”¨ã€‚<br>
åŒæ—¶åœ¨æœåŠ¡ç«¯èŠ‚ç‚¹å› ä¸ºä¸€äº›åŸå› ä¸å¯ç”¨æ—¶èƒ½å®æ—¶çš„æ„ŸçŸ¥å¹¶ç§»é™¤æ‰å¯¹åº”èŠ‚ç‚¹ï¼ŒåŒæ—¶é€šçŸ¥ç›‘å¬å˜æ›´å®¢æˆ·ç«¯(è§£å†³ç¬¬äºŒä¸ªå…³äºproviderä¿¡æ¯å®æ—¶æ€§çš„é—®é¢˜)ã€‚<br>
å› æ­¤zookeeperã€eurekaã€nacosã€etcdç­‰ç­‰å…·å¤‡ä¸Šè¿°èƒ½åŠ›çš„ä¸­é—´ä»¶éƒ½è¢«å¹¿æ³›çš„ç”¨ä½œrpcæ¡†æ¶çš„æ³¨å†Œä¸­å¿ƒã€‚
<br><br>MyRpcç›®å‰æ”¯æŒä½¿ç”¨zookeeperä½œä¸ºæ³¨å†Œä¸­å¿ƒã€‚<br>
zookeeperä½œä¸ºä¸€ä¸ªé«˜æ€§èƒ½çš„åˆ†å¸ƒå¼åè°ƒå™¨ï¼Œå­˜å‚¨çš„æ•°æ®ä»¥ZNodeèŠ‚ç‚¹æ ‘çš„å½¢å¼å­˜åœ¨ã€‚ZNodeèŠ‚ç‚¹æœ‰ä¸¤ç§å±æ€§ï¼Œæœ‰åº/æ— åºï¼ŒæŒä¹…/ä¸´æ—¶ã€‚<br>
<br>rpcæ¡†æ¶ä¸­ä¸€èˆ¬è®¾ç½®ä¸€ä¸ªæŒä¹…çš„æ ¹è·¯å¾„èŠ‚ç‚¹ç”¨äºä¸zkä¸Šå­˜å‚¨å…¶å®ƒçš„ä¸šåŠ¡æ•°æ®ä½œåŒºåˆ†(ä¾‹å¦‚/my_rpc)ã€‚
<br>åœ¨æ ¹èŠ‚ç‚¹ä¸‹æœ‰ç€ä»£è¡¨ç€æŸä¸€ç‰¹å®šæœåŠ¡çš„å­èŠ‚ç‚¹ï¼Œå…¶ä¹Ÿæ˜¯æŒä¹…èŠ‚ç‚¹ã€‚æœåŠ¡å­èŠ‚ç‚¹çš„è·¯å¾„åæ˜¯æ ‡è¯†æ¥å£çš„å”¯ä¸€åç§°(æ¯”å¦‚åŒ…å+ç±»åï¼šmyrpc.demo.common.service.UserService)
<br>è€ŒæœåŠ¡èŠ‚ç‚¹ä¸‹åˆ™å¯ä»¥å­˜å‚¨å„ç§å…³äºproviderã€consumerç­‰ç­‰ç›¸å…³çš„å…ƒæ•°æ®ã€‚<br>
MyRpcä¸­ä¸ºäº†ç®€å•èµ·è§ï¼ŒæœåŠ¡èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ç›´æ¥å°±æ˜¯å¯¹åº”ç‰¹å®šprovideræ³¨å†Œçš„ä¸´æ—¶èŠ‚ç‚¹ã€‚ä¸´æ—¶èŠ‚ç‚¹ä¸­æ•°æ®ä¿å­˜äº†providerçš„ip/portç­‰å¿…è¦çš„ä¿¡æ¯ã€‚<br>
ç”±äºæ˜¯ä¸´æ—¶èŠ‚ç‚¹ï¼Œåœ¨providerå› ä¸ºå„ç§æ•…éšœè€Œä¸å¯ç”¨è€Œå¯¼è‡´ä¸zookeeperçš„è¿æ¥æ–­å¼€ï¼Œzookeeperä¼šåœ¨ç­‰å¾…ä¸€å°ä¼šåå°†è¯¥ä¸´æ—¶èŠ‚ç‚¹åˆ é™¤ï¼Œå¹¶é€šçŸ¥ç›‘å¬è¯¥æœåŠ¡çš„å®¢æˆ·ç«¯ä»¥åˆ·æ–°å®¢æˆ·ç«¯çš„å¯¹åº”é…ç½®ã€‚
<br><img alt="Pasted image 20240725172146.png" src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/rpcæ¡†æ¶çš„å®ç°/pasted-image-20240725172146.png"><br>æ³¨å†Œä¸­å¿ƒæ¥å£<br>/**
 * æ³¨å†Œä¸­å¿ƒçš„æŠ½è±¡
 * */
public interface Registry {

    /**
     * æœåŠ¡æ³¨å†Œ
     * */
    void doRegistry(ServiceInfo serviceInfo);

    /**
     * æœåŠ¡å‘ç°
     * */
    List&lt;ServiceInfo&gt; discovery(String serviceName);
}
Copy<br>zookeeperæ³¨å†Œä¸­å¿ƒå®ç°(åŸå§‹çš„zkå®¢æˆ·ç«¯)<br>/**
 * ç®€æ˜“çš„zkæ³¨å†Œä¸­å¿ƒ(åŸå§‹çš„zkå®¢æˆ·ç«¯å¾ˆå¤šåœ°æ–¹éƒ½éœ€è¦ç”¨æˆ·å»å¤„ç†å¼‚å¸¸ï¼Œä½†ä¸ºäº†æ›´ç®€å•çš„å±•ç¤ºzkæ³¨å†Œä¸­å¿ƒçš„ä½¿ç”¨ï¼ŒåŸºæœ¬ä¸Šæ²¡æœ‰å¤„ç†è¿™äº›å¼‚å¸¸æƒ…å†µ)
 * */
public class ZookeeperRegistry implements Registry{

    private static final Logger logger = LoggerFactory.getLogger(ZookeeperRegistry.class);

    private final ZooKeeper zooKeeper;

    private final ConcurrentHashMap&lt;String,List&lt;ServiceInfo&gt;&gt; serviceInfoCacheMap = new ConcurrentHashMap&lt;&gt;();

    public ZookeeperRegistry(String zkServerAddress) {
        try {
            this.zooKeeper = new ZooKeeper(zkServerAddress,2000, event -&gt; {});

            // ç¡®ä¿rootèŠ‚ç‚¹æ˜¯ä¸€å®šå­˜åœ¨çš„
            createPersistentNode(MyRpcRegistryConstants.BASE_PATH);
        } catch (Exception e) {
            throw new MyRpcException("init zkClient error",e);
        }
    }

    @Override
    public void doRegistry(ServiceInfo serviceInfo) {
        // å…ˆåˆ›å»ºæ°¸ä¹…çš„æœåŠ¡åèŠ‚ç‚¹
        createServiceNameNode(serviceInfo.getServiceName());
        // å†åˆ›å»ºä¸´æ—¶çš„providerInfoèŠ‚ç‚¹
        createProviderInfoNode(serviceInfo);
    }

    @Override
    public List&lt;ServiceInfo&gt; discovery(String serviceName) {
        return serviceInfoCacheMap.computeIfAbsent(serviceName,(key)-&gt; findProviderInfoList(serviceName));
    }

    private String getServiceNameNodePath(String serviceName){
        return MyRpcRegistryConstants.BASE_PATH + "/" + serviceName;
    }

    // ================================ zkå·¥å…·æ–¹æ³• ==================================
    private void createServiceNameNode(String serviceName){
        try {
            String serviceNameNodePath = getServiceNameNodePath(serviceName);

            // æœåŠ¡åèŠ‚ç‚¹æ˜¯æ°¸ä¹…èŠ‚ç‚¹
            createPersistentNode(serviceNameNodePath);
            logger.info("createServiceNameNode success! serviceNameNodePath={}",serviceNameNodePath);
        } catch (Exception e) {
            throw new MyRpcException("createServiceNameNode error",e);
        }
    }

    private void createProviderInfoNode(ServiceInfo serviceInfo){
        try {
            String serviceNameNodePath = getServiceNameNodePath(serviceInfo.getServiceName());
            // å­èŠ‚ç‚¹ç”¨ä¸€ä¸ªuuidåšpathé˜²é‡å¤
            String providerInfoNodePath = serviceNameNodePath + "/" + UUID.randomUUID();

            String providerInfoJsonStr = JsonUtil.obj2Str(serviceInfo);
            // providerInfoèŠ‚ç‚¹æ˜¯ä¸´æ—¶èŠ‚ç‚¹(å¦‚æœèŠ‚ç‚¹å®•æœºäº†ï¼Œzkçš„è¿æ¥æ–­å¼€ä¸€æ®µæ—¶é—´åï¼Œä¸´æ—¶èŠ‚ç‚¹ä¼šè¢«è‡ªåŠ¨åˆ é™¤)
            zooKeeper.create(providerInfoNodePath, providerInfoJsonStr.getBytes(StandardCharsets.UTF_8), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);
            logger.info("createProviderInfoNode success! path={}",providerInfoNodePath);
        } catch (Exception e) {
            throw new MyRpcException("createProviderInfoNode error",e);
        }
    }

    private void createPersistentNode(String path){
        try {
            if (zooKeeper.exists(path, false) == null) {
                // æœåŠ¡åèŠ‚ç‚¹æ˜¯æ°¸ä¹…èŠ‚ç‚¹
                zooKeeper.create(path, "".getBytes(StandardCharsets.UTF_8), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
            }
        }catch (Exception e){
            throw new MyRpcException("createPersistentNode error",e);
        }
    }

    private List&lt;ServiceInfo&gt; findProviderInfoList(String serviceName){
        String serviceNameNodePath = getServiceNameNodePath(serviceName);

        List&lt;ServiceInfo&gt; serviceInfoList = new ArrayList&lt;&gt;();
        try {
            List&lt;String&gt; providerInfoPathList = zooKeeper.getChildren(serviceNameNodePath, new ZookeeperListener(serviceNameNodePath));
            for(String providerInfoPath : providerInfoPathList){
                try{
                    String fullProviderInfoPath = serviceNameNodePath + "/" + providerInfoPath;
                    byte[] data = zooKeeper.getData(fullProviderInfoPath,false,null);
                    String jsonStr = new String(data,StandardCharsets.UTF_8);
                    ServiceInfo serviceInfo = JsonUtil.json2Obj(jsonStr,ServiceInfo.class);

                    serviceInfoList.add(serviceInfo);
                }catch (Exception e){
                    logger.error("findProviderInfoList getData error",e);
                }
            }

            logger.info("findProviderInfoList={}",JsonUtil.obj2Str(serviceInfoList));
            return serviceInfoList;
        } catch (Exception e) {
            throw new MyRpcException("findProviderInfoList error",e);
        }
    }

    private class ZookeeperListener implements Watcher{
        private final String path;
        private final String serviceName;

        public ZookeeperListener(String serviceName) {
            this.path = getServiceNameNodePath(serviceName);
            this.serviceName = serviceName;
        }

        @Override
        public void process(WatchedEvent event) {
            logger.info("ZookeeperListener process! path={}",path);

            try {
                // åˆ·æ–°ç¼“å­˜
                List&lt;ServiceInfo&gt; serviceInfoList = findProviderInfoList(path);
                serviceInfoCacheMap.put(serviceName,serviceInfoList);
            } catch (Exception e) {
                logger.error("ZookeeperListener getChildren error! path={}",path,e);
            }
        }
    }
}
Copy<br>zookeeperæ³¨å†Œä¸­å¿ƒå®ç°(curatorå®¢æˆ·ç«¯ï¼Œé€šè¿‡è‡ªåŠ¨é‡è¯•ç­‰æ“ä½œè§£å†³äº†åŸç”Ÿå®¢æˆ·ç«¯çš„ä¸€äº›å‘)<br>public class ZkCuratorRegistry implements Registry {
    private static final Logger logger = LoggerFactory.getLogger(ZkCuratorRegistry.class);

    private CuratorFramework curatorZkClient;

    private final ConcurrentHashMap&lt;String, List&lt;ServiceInfo&gt;&gt; serviceInfoCacheMap = new ConcurrentHashMap&lt;&gt;();
    private static ConcurrentHashMap&lt;String, PathChildrenCache&gt; nodeCacheMap = new ConcurrentHashMap&lt;&gt;();


    public ZkCuratorRegistry(String zkServerAddress) {
        try {
            this.curatorZkClient = CuratorFrameworkFactory.newClient(zkServerAddress, new ExponentialBackoffRetry(3000, 1));
            this.curatorZkClient.start();
        } catch (Exception e) {
            throw new MyRpcException("init zkClient error", e);
        }
    }

    @Override
    public void doRegistry(ServiceInfo serviceInfo) {
        // å…ˆåˆ›å»ºæ°¸ä¹…çš„æœåŠ¡åèŠ‚ç‚¹
        createServiceNameNode(serviceInfo.getServiceName());
        // å†åˆ›å»ºä¸´æ—¶çš„providerInfoèŠ‚ç‚¹
        createProviderInfoNode(serviceInfo);
    }

    @Override
    public List&lt;ServiceInfo&gt; discovery(String serviceName) {
        return this.serviceInfoCacheMap.computeIfAbsent(serviceName,(key)-&gt;{
            List&lt;ServiceInfo&gt; serviceInfoList = findProviderInfoList(serviceName);

            // åˆ›å»ºå¯¹å­èŠ‚ç‚¹çš„ç›‘å¬
            String serviceNodePath = getServiceNameNodePath(serviceName);
            PathChildrenCache pathChildrenCache = new PathChildrenCache(curatorZkClient, serviceNodePath, true);
            try {
                pathChildrenCache.start();
                nodeCacheMap.put(serviceName,pathChildrenCache);
                pathChildrenCache.getListenable().addListener(new ZkCuratorListener(serviceName));
            } catch (Exception e) {
                throw new MyRpcException("PathChildrenCache start error!",e);
            }

            return serviceInfoList;
        });
    }

    private void createServiceNameNode(String serviceName) {
        try {
            String serviceNameNodePath = getServiceNameNodePath(serviceName);

            // æœåŠ¡åèŠ‚ç‚¹æ˜¯æ°¸ä¹…èŠ‚ç‚¹
            if (curatorZkClient.checkExists().forPath(serviceNameNodePath) == null) {
                curatorZkClient.create()
                    .creatingParentsIfNeeded()
                    .withMode(CreateMode.PERSISTENT)
                    .forPath(serviceNameNodePath);
            }

            logger.info("createServiceNameNode success! serviceNameNodePath={}", serviceNameNodePath);
        } catch (Exception e) {
            throw new MyRpcException("createServiceNameNode error", e);
        }
    }

    private void createProviderInfoNode(ServiceInfo serviceInfo) {
        try {
            String serviceNameNodePath = getServiceNameNodePath(serviceInfo.getServiceName());
            // å­èŠ‚ç‚¹ç”¨ä¸€ä¸ªuuidåšpathé˜²é‡å¤
            String providerInfoNodePath = serviceNameNodePath + "/" + UUID.randomUUID();

            String providerInfoJsonStr = JsonUtil.obj2Str(serviceInfo);

            // providerInfoèŠ‚ç‚¹æ˜¯ä¸´æ—¶èŠ‚ç‚¹(å¦‚æœèŠ‚ç‚¹å®•æœºäº†ï¼Œzkçš„è¿æ¥æ–­å¼€ä¸€æ®µæ—¶é—´åï¼Œä¸´æ—¶èŠ‚ç‚¹ä¼šè¢«è‡ªåŠ¨åˆ é™¤)
            curatorZkClient.create()
                .withMode(CreateMode.EPHEMERAL)
                .forPath(providerInfoNodePath, providerInfoJsonStr.getBytes(StandardCharsets.UTF_8));
            logger.info("createProviderInfoNode success! path={}", providerInfoNodePath);
        } catch (Exception e) {
            throw new MyRpcException("createProviderInfoNode error", e);
        }
    }

    private String getServiceNameNodePath(String serviceName) {
        return MyRpcRegistryConstants.BASE_PATH + "/" + serviceName;
    }

    private List&lt;ServiceInfo&gt; findProviderInfoList(String serviceName) {
        String serviceNameNodePath = getServiceNameNodePath(serviceName);

        try {
            List&lt;String&gt; providerInfoPathList = curatorZkClient.getChildren().forPath(serviceNameNodePath);
            List&lt;ServiceInfo&gt; serviceInfoList = new ArrayList&lt;&gt;();

            for(String providerInfoPath : providerInfoPathList){
                try{
                    String fullProviderInfoPath = serviceNameNodePath + "/" + providerInfoPath;
                    byte[] data = curatorZkClient.getData().forPath(fullProviderInfoPath);
                    String jsonStr = new String(data,StandardCharsets.UTF_8);
                    ServiceInfo serviceInfo = JsonUtil.json2Obj(jsonStr,ServiceInfo.class);

                    serviceInfoList.add(serviceInfo);
                }catch (Exception e){
                    logger.error("findProviderInfoList getData error",e);
                }
            }

            logger.info("findProviderInfoList={}",JsonUtil.obj2Str(serviceInfoList));
            return serviceInfoList;
        } catch (Exception e) {
            throw new MyRpcException("findProviderInfoList error",e);
        }
    }

    private class ZkCuratorListener implements PathChildrenCacheListener {
        private final String serviceName;

        public ZkCuratorListener(String serviceName) {
            this.serviceName = serviceName;
        }

        @Override
        public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) {
            logger.info("ZookeeperListener process! serviceName={}",serviceName);

            try {
                // åˆ·æ–°ç¼“å­˜
                List&lt;ServiceInfo&gt; serviceInfoList = findProviderInfoList(serviceName);
                serviceInfoCacheMap.put(serviceName,serviceInfoList);
            } catch (Exception e) {
                logger.error("ZookeeperListener getChildren error! serviceName={}",serviceName,e);
            }
        }
    }
}
Copy<br><br>ç°åœ¨å®¢æˆ·ç«¯å·²ç»èƒ½é€šè¿‡æœåŠ¡å‘ç°å¾—åˆ°å®æ—¶çš„provideré›†åˆäº†ï¼Œé‚£ä¹ˆå®¢æˆ·ç«¯å‘èµ·è¯·æ±‚æ—¶åº”è¯¥å¦‚ä½•å†³å®šå‘å“ªä¸ªproviderå‘èµ·è¯·æ±‚ä»¥å®ç°providerä¾§çš„è´Ÿè½½å‡è¡¡å‘¢ï¼Ÿ<br>
<br>å¸¸è§çš„è´Ÿè½½å‡è¡¡ç®—æ³•æœ‰å¾ˆå¤šï¼ŒMyRpcæŠ½è±¡å‡ºäº†è´Ÿè½½å‡è¡¡ç®—æ³•çš„æ¥å£ï¼Œå¹¶å®ç°äº†æœ€ç®€å•çš„ä¸¤ç§è´Ÿè½½å‡è¡¡ç®—æ³•(æ— æƒé‡çš„çº¯éšæœº + roundRobin)ã€‚
<br>åœ¨å®é™…çš„ç¯å¢ƒä¸­ï¼Œæ¯ä¸ªproviderå¯èƒ½æœºå™¨çš„é…ç½®ã€ç½‘ç»œå»¶è¿Ÿã€è¿è¡Œæ—¶çš„åŠ¨æ€è´Ÿè½½ã€è¯·æ±‚å¤„ç†çš„å»¶è¿Ÿç­‰éƒ½å„æœ‰ä¸åŒï¼Œä¼˜ç§€çš„è´Ÿè½½å‡è¡¡ç®—æ³•èƒ½å¤Ÿé€šè¿‡é¢„å…ˆçš„é…ç½®å’Œé‡‡é›†è¿è¡Œæ—¶çš„å„é¡¹æŒ‡æ ‡æ¥è®¡ç®—å‡ºæœ€ä¼˜çš„è¯·æ±‚é¡ºåºã€‚<br>
MyRpcå®ç°çš„è´Ÿè½½å‡è¡¡ç®—æ³•åœ¨è¿™é‡Œåªèµ·åˆ°ä¸€ä¸ªæŠ›ç –å¼•ç‰çš„å‚è€ƒä½œç”¨ã€‚
<br>è´Ÿè½½å‡è¡¡æ¥å£<br>/**
 * è´Ÿè½½å‡è¡¡é€‰æ‹©å™¨
 * */
public interface LoadBalance {

    ServiceInfo select(List&lt;ServiceInfo&gt; serviceInfoList);
}
Copy<br>éšæœºè´Ÿè½½å‡è¡¡<br>/**
 * æ— æƒé‡ï¼Œçº¯éšæœºçš„è´Ÿè½½å‡è¡¡é€‰æ‹©å™¨
 * */
public class RandomLoadBalance implements LoadBalance{
    @Override
    public ServiceInfo select(List&lt;ServiceInfo&gt; serviceInfoList) {
        int selectedIndex = ThreadLocalRandom.current().nextInt(serviceInfoList.size());
        return serviceInfoList.get(selectedIndex);
    }
}
Copy<br>/**
 * æ— æƒé‡çš„è½®è®­è´Ÿè½½å‡è¡¡ï¼ˆåç»­å¢åŠ å¸¦æƒé‡çš„è½®è®­ï¼‰
 * */
public class SimpleRoundRobinBalance implements LoadBalance{

    private final AtomicInteger count = new AtomicInteger();

    @Override
    public ServiceInfo select(List&lt;ServiceInfo&gt; serviceInfoList) {
        if(serviceInfoList.isEmpty()){
            throw new MyRpcException("serviceInfoList is empty!");
        }

        // è€ƒè™‘ä¸€ä¸‹æº¢å‡ºï¼Œå–ç»å¯¹å€¼
        int selectedIndex = Math.abs(count.getAndIncrement());
        return serviceInfoList.get(selectedIndex % serviceInfoList.size());
    }
}
Copy<br><br>ç”±äºéœ€è¦é€šè¿‡ç½‘ç»œå‘èµ·rpcè°ƒç”¨ï¼Œæ¯”èµ·æœ¬åœ°è°ƒç”¨å¾ˆå®¹æ˜“å› ä¸ºç½‘ç»œæ³¢åŠ¨ã€è¿œç«¯æœºå™¨æ•…éšœç­‰åŸå› è€Œå¯¼è‡´è°ƒç”¨å¤±è´¥ã€‚<br>
å®¢æˆ·ç«¯æœ‰æ—¶å¸Œæœ›èƒ½é€šè¿‡é‡è¯•ç­‰æ–¹å¼å±è”½æ‰å¯èƒ½å‡ºç°çš„å¶å‘é”™è¯¯ï¼Œå°½å¯èƒ½çš„ä¿è¯rpcè¯·æ±‚çš„æˆåŠŸç‡ï¼Œæœ€å¥½rpcæ¡†æ¶èƒ½è§£å†³è¿™ä¸ªé—®é¢˜ã€‚ä½†å¦ä¸€æ–¹é¢ï¼Œèƒ½å¤Ÿå®‰å…¨é‡è¯•çš„åŸºç¡€æ˜¯ä¸‹æ¸¸æœåŠ¡èƒ½å¤Ÿåšåˆ°å¹‚ç­‰ï¼Œå¦åˆ™é‡å¤çš„è¯·æ±‚ä¼šå¸¦æ¥æ„æƒ³ä¸åˆ°çš„åæœï¼Œè€Œä¸å¹‚ç­‰çš„ä¸‹æ¸¸æœåŠ¡åªèƒ½è‡³å¤šè°ƒç”¨ä¸€æ¬¡ã€‚<br>
å› æ­¤rpcæ¡†æ¶éœ€è¦èƒ½å…è®¸ç”¨æˆ·ä¸åŒçš„æœåŠ¡å¯ä»¥æœ‰ä¸åŒçš„é›†ç¾¤æœåŠ¡è°ƒç”¨æ–¹å¼ï¼Œè¿™æ ·å¹‚ç­‰çš„æœåŠ¡å¯ä»¥é…ç½®æˆå¯è‡ªåŠ¨é‡è¯•Næ¬¡çš„failoverè°ƒç”¨ã€åªèƒ½è°ƒç”¨1æ¬¡çš„fast-failè°ƒç”¨æˆ–è€…å¹¿æ’­è°ƒç”¨ç­‰ç­‰æ–¹å¼ã€‚<br>MyRpcçš„Invokeræ¥å£ç”¨äºæŠ½è±¡ä¸Šè¿°çš„ä¸åŒé›†ç¾¤è°ƒç”¨æ–¹å¼ï¼Œå¹¶ç®€å•çš„å®ç°äº†failoverå’Œfast-failç­‰å¤šç§è°ƒç”¨æ–¹å¼ï¼ˆå‚è€ƒdubboï¼‰ã€‚<br>public interface InvokerCallable {
    RpcResponse invoke(NettyClient nettyClient);
}
Copy<br>/**
 * ä¸åŒçš„é›†ç¾¤è°ƒç”¨æ–¹å¼
 * */
public interface Invoker {

    RpcResponse invoke(InvokerCallable callable, String serviceName,
                                      Registry registry, LoadBalance loadBalance);
}
Copy<br>/**
 * å¿«é€Ÿå¤±è´¥ï¼Œæ— è®ºæˆåŠŸä¸å¦è°ƒç”¨1æ¬¡å°±è¿”å›
 * */
public class FastFailInvoker implements Invoker {

  private static final Logger logger = LoggerFactory.getLogger(FastFailInvoker.class);

  @Override
  public RpcResponse invoke(InvokerCallable callable, String serviceName,
                            Registry registry, LoadBalance loadBalance) {
    List&lt;ServiceInfo&gt; serviceInfoList = registry.discovery(serviceName);
    logger.debug("serviceInfoList.size={},serviceInfoList={}",serviceInfoList.size(), JsonUtil.obj2Str(serviceInfoList));
    NettyClient nettyClient = InvokerUtil.getTargetClient(serviceInfoList,loadBalance);
    logger.info("ClientDynamicProxy getTargetClient={}", nettyClient);

    // fast-failï¼Œç®€å•çš„è°ƒç”¨ä¸€æ¬¡å°±è¡Œï¼Œæœ‰é”™è¯¯å°±ç›´æ¥å‘ä¸ŠæŠ›
    return callable.invoke(nettyClient);
  }
}
Copy<br>/**
 * æ•…éšœè½¬ç§»è°ƒç”¨(å¦‚æœè°ƒç”¨å‡ºç°äº†é”™è¯¯ï¼Œåˆ™é‡è¯•æŒ‡å®šæ¬¡æ•°)
 * 1 å¦‚æœé‡è¯•è¿‡ç¨‹ä¸­æˆåŠŸäº†ï¼Œåˆ™å¿«è¯»è¿”å›
 * 2 å¦‚æœé‡è¯•äº†æŒ‡å®šæ¬¡æ•°åè¿˜æ˜¯æ²¡æˆåŠŸï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸
 * */
public class FailoverInvoker implements Invoker {

    private static final Logger logger = LoggerFactory.getLogger(FailoverInvoker.class);

    private final int defaultRetryCount = 2;
    private final int retryCount;

    public FailoverInvoker() {
        this.retryCount = defaultRetryCount;
    }

    public FailoverInvoker(int retryCount) {
        this.retryCount = Math.max(retryCount,1);
    }

    @Override
    public RpcResponse invoke(InvokerCallable callable, String serviceName, Registry registry, LoadBalance loadBalance) {
        MyRpcException myRpcException = null;

        for(int i=0; i&lt;retryCount; i++){
            List&lt;ServiceInfo&gt; serviceInfoList = registry.discovery(serviceName);
            logger.debug("serviceInfoList.size={},serviceInfoList={}",serviceInfoList.size(), JsonUtil.obj2Str(serviceInfoList));
            NettyClient nettyClient = InvokerUtil.getTargetClient(serviceInfoList,loadBalance);
            logger.info("ClientDynamicProxy getTargetClient={}", nettyClient);

            try {
                RpcResponse rpcResponse = callable.invoke(nettyClient);
                if(myRpcException != null){
                    // è™½ç„¶æœ€ç»ˆé‡è¯•æˆåŠŸäº†ï¼Œä½†æ˜¯ä¹‹å‰è¯·æ±‚å¤±è´¥è¿‡
                    logger.warn("FailRetryInvoker finally success, but there have been failed providers");
                }
                return rpcResponse;
            }catch (Exception e){
                myRpcException = new MyRpcException(e);

                logger.warn("FailRetryInvoker callable.invoke error",e);
            }
        }

        // èµ°åˆ°è¿™é‡Œè¯´æ˜ç»è¿‡äº†retryCountæ¬¡é‡è¯•ä¾ç„¶ä¸æˆåŠŸï¼ŒmyRpcExceptionä¸€å®šä¸ä¸ºnull
        throw myRpcException;
    }
}
Copy<br><br>/**
 * å®¢æˆ·ç«¯åŠ¨æ€ä»£ç†
 * */
public class ClientDynamicProxy implements InvocationHandler {

    private static final Logger logger = LoggerFactory.getLogger(ClientDynamicProxy.class);

    private final Registry registry;
    private final LoadBalance loadBalance;
    private final Invoker invoker;

    public ClientDynamicProxy(Registry registry, LoadBalance loadBalance, Invoker invoker) {
        this.registry = registry;
        this.loadBalance = loadBalance;
        this.invoker = invoker;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Tuple&lt;Object,Boolean&gt; localMethodResult = processLocalMethod(proxy,method,args);
        if(localMethodResult.getRight()){
            // rightä¸ºtrue,ä»£è¡¨æ˜¯æœ¬åœ°æ–¹æ³•ï¼Œè¿”å›toStringç­‰å¯¹è±¡è‡ªå¸¦æ–¹æ³•çš„æ‰§è¡Œç»“æœï¼Œä¸å‘èµ·rpcè°ƒç”¨
            return localMethodResult.getLeft();
        }

        logger.debug("ClientDynamicProxy before: methodName=" + method.getName());

        String serviceName = method.getDeclaringClass().getName();

        // æ„é€ è¯·æ±‚å’Œåè®®å¤´
        RpcRequest rpcRequest = new RpcRequest();
        rpcRequest.setInterfaceName(method.getDeclaringClass().getName());
        rpcRequest.setMethodName(method.getName());
        rpcRequest.setParameterClasses(method.getParameterTypes());
        rpcRequest.setParams(args);

        MessageHeader messageHeader = new MessageHeader();
        messageHeader.setMessageFlag(MessageFlagEnums.REQUEST.getCode());
        messageHeader.setTwoWayFlag(false);
        messageHeader.setEventFlag(true);
        messageHeader.setSerializeType(GlobalConfig.messageSerializeType.getCode());
        messageHeader.setResponseStatus((byte)'a');
        messageHeader.setMessageId(rpcRequest.getMessageId());

        logger.debug("ClientDynamicProxy rpcRequest={}", JsonUtil.obj2Str(rpcRequest));

        RpcResponse rpcResponse = this.invoker.invoke((nettyClient)-&gt;{
            Channel channel = nettyClient.getChannel();
            // å°†nettyçš„å¼‚æ­¥è½¬ä¸ºåŒæ­¥,å‚è€ƒdubbo DefaultFuture
            DefaultFuture&lt;RpcResponse&gt; newDefaultFuture = DefaultFutureManager.createNewFuture(channel,rpcRequest);

            try {
                nettyClient.send(new MessageProtocol&lt;&gt;(messageHeader,rpcRequest));

                // è°ƒç”¨æ–¹é˜»å¡åœ¨è¿™é‡Œ
                return newDefaultFuture.get();
            } catch (Exception e) {
                throw new MyRpcException("InvokerCallable error!",e);
            }
        },serviceName,registry,loadBalance);

        logger.debug("ClientDynamicProxy defaultFuture.get() rpcResponse={}",rpcResponse);

        return processRpcResponse(rpcResponse);
    }

    /**
     * å¤„ç†æœ¬åœ°æ–¹æ³•
     * @return tuple.right æ ‡è¯†æ˜¯å¦æ˜¯æœ¬åœ°æ–¹æ³•ï¼Œ trueæ˜¯
     * */
    private Tuple&lt;Object,Boolean&gt; processLocalMethod(Object proxy, Method method, Object[] args) throws Exception {
        // å¤„ç†toStringç­‰å¯¹è±¡è‡ªå¸¦æ–¹æ³•ï¼Œä¸å‘èµ·rpcè°ƒç”¨
        if (method.getDeclaringClass() == Object.class) {
            return new Tuple&lt;&gt;(method.invoke(proxy, args),true);
        }
        String methodName = method.getName();
        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();
        if (parameterTypes.length == 0) {
            if ("toString".equals(methodName)) {
                return new Tuple&lt;&gt;(proxy.toString(),true);
            } else if ("hashCode".equals(methodName)) {
                return new Tuple&lt;&gt;(proxy.hashCode(),true);
            }
        } else if (parameterTypes.length == 1 &amp;&amp; "equals".equals(methodName)) {
            return new Tuple&lt;&gt;(proxy.equals(args[0]),true);
        }

        // è¿”å›nullæ ‡è¯†éæœ¬åœ°æ–¹æ³•ï¼Œéœ€è¦è¿›è¡Œrpcè°ƒç”¨
        return new Tuple&lt;&gt;(null,false);
    }

    private Object processRpcResponse(RpcResponse rpcResponse){
        if(rpcResponse.getExceptionValue() == null){
            // æ²¡æœ‰å¼‚å¸¸ï¼Œreturnæ­£å¸¸çš„è¿”å›å€¼
            return rpcResponse.getReturnValue();
        }else{
            // æœ‰å¼‚å¸¸ï¼Œå¾€å¤–æŠ›å‡ºå»
            throw new MyRpcRemotingException(rpcResponse.getExceptionValue());
        }
    }
}
Copy<br><br>å®¢æˆ·ç«¯å‘èµ·è¯·æ±‚åï¼Œå¯èƒ½ç”±äºç½‘ç»œåŸå› ï¼Œå¯èƒ½ç”±äºæœåŠ¡ç«¯è´Ÿè½½è¿‡å¤§ç­‰åŸå› è€Œè¿Ÿè¿Ÿæ— æ³•æ”¶åˆ°å›å¤ã€‚<br>
å‡ºäºæ€§èƒ½æˆ–è€…è‡ªèº«ä¸šåŠ¡çš„è€ƒè™‘ï¼Œå®¢æˆ·ç«¯ä¸èƒ½æ— é™åˆ¶çš„ç­‰å¾…ä¸‹å»ï¼Œå› æ­¤rpcæ¡†æ¶éœ€è¦èƒ½å…è®¸å®¢æˆ·ç«¯è®¾ç½®è¯·æ±‚çš„è¶…æ—¶æ—¶é—´ã€‚åœ¨ä¸€å®šçš„æ—¶é—´å†…å¦‚æœæ— æ³•æ”¶åˆ°å“åº”åˆ™éœ€è¦æŠ›å‡ºè¶…æ—¶å¼‚å¸¸ï¼Œä»¤è°ƒç”¨è€…åŠæ—¶çš„æ„ŸçŸ¥åˆ°é—®é¢˜ã€‚<br>åœ¨å®¢æˆ·ç«¯ä¾§DefaultFuture.getæ–¹æ³•ï¼ŒæŒ‡å®šè¶…æ—¶æ—¶é—´æ˜¯å¯ä»¥åšåˆ°è¿™ä¸€ç‚¹çš„ã€‚<br>
ä½†å…¶ä¾èµ–åº•å±‚æ“ä½œç³»ç»Ÿçš„å®šæ—¶ä»»åŠ¡æœºåˆ¶ï¼Œè™½ç„¶è¶…æ—¶æ—¶é—´çš„ç²¾åº¦å¾ˆé«˜(nanosçº§åˆ«)ï¼Œä½†åœ¨é«˜å¹¶å‘åœºæ™¯ä¸‹æ€§èƒ½ä¸å¦‚æ—¶é—´è½®ã€‚<br>
å…·ä½“åŸç†å¯ä»¥å‚è€ƒæˆ‘ä¹‹å‰çš„åšå®¢ï¼š<a data-tooltip-position="top" aria-label="https://www.cnblogs.com/xiaoxiongcanguan/p/17128575.html" rel="noopener" class="external-link" href="https://www.cnblogs.com/xiaoxiongcanguan/p/17128575.html" target="_blank">æ—¶é—´è½®TimeWheelå·¥ä½œåŸç†è§£æ</a><br>MyRpcå‚è€ƒdubboï¼Œå¼•å…¥æ—¶é—´è½®æ¥å®ç°å®¢æˆ·ç«¯è®¾ç½®è¯·æ±‚è¶…æ—¶æ—¶é—´çš„åŠŸèƒ½ã€‚<br>public class DefaultFutureManager {

    private static final Logger logger = LoggerFactory.getLogger(DefaultFutureManager.class);

    public static final Map&lt;Long,DefaultFuture&gt; DEFAULT_FUTURE_CACHE = new ConcurrentHashMap&lt;&gt;();
    public static final HashedWheelTimer TIMER = new HashedWheelTimer();

    public static void received(RpcResponse rpcResponse){
        Long messageId = rpcResponse.getMessageId();

        logger.debug("received rpcResponse={},DEFAULT_FUTURE_CACHE={}",rpcResponse,DEFAULT_FUTURE_CACHE);
        DefaultFuture defaultFuture = DEFAULT_FUTURE_CACHE.remove(messageId);

        if(defaultFuture != null){
            logger.debug("remove defaultFuture success");
            if(rpcResponse.getExceptionValue() != null){
                // å¼‚å¸¸å¤„ç†
                defaultFuture.completeExceptionally(rpcResponse.getExceptionValue());
            }else{
                // æ­£å¸¸è¿”å›
                defaultFuture.complete(rpcResponse);
            }
        }else{
            // å¯èƒ½è¶…æ—¶äº†ï¼Œæ¥åˆ°å“åº”å‰å·²ç»removeæ‰äº†è¿™ä¸ªfuture(è¶…æ—¶å’Œå®é™…æ¥åˆ°è¯·æ±‚éƒ½ä¼šè°ƒç”¨receivedæ–¹æ³•)
            logger.debug("remove defaultFuture fail");
        }
    }

    public static DefaultFuture createNewFuture(Channel channel, RpcRequest rpcRequest){
        DefaultFuture defaultFuture = new DefaultFuture(channel,rpcRequest);
        // å¢åŠ è¶…æ—¶å¤„ç†çš„é€»è¾‘
        newTimeoutCheck(defaultFuture);

        return defaultFuture;
    }

    public static DefaultFuture getFuture(long messageId){
        return DEFAULT_FUTURE_CACHE.get(messageId);
    }

    /**
     * å¢åŠ è¯·æ±‚è¶…æ—¶çš„æ£€æŸ¥ä»»åŠ¡
     * */
    public static void newTimeoutCheck(DefaultFuture defaultFuture){
        TimeoutCheckTask timeoutCheckTask = new TimeoutCheckTask(defaultFuture.getMessageId());
        TIMER.newTimeout(timeoutCheckTask, defaultFuture.getTimeout(), TimeUnit.MILLISECONDS);
    }
}
Copy<br>public class TimeoutCheckTask implements TimerTask {

    private final long messageId;

    public TimeoutCheckTask(long messageId) {
        this.messageId = messageId;
    }

    @Override
    public void run(Timeout timeout) {
        DefaultFuture defaultFuture = DefaultFutureManager.getFuture(this.messageId);
        if(defaultFuture == null || defaultFuture.isDone()){
            // è¯·æ±‚å·²ç»åœ¨è¶…æ—¶å‰è¿”å›ï¼Œå¤„ç†è¿‡äº†,ç›´æ¥è¿”å›å³å¯
            return;
        }

        // æ„é€ è¶…æ—¶çš„å“åº”
        RpcResponse rpcResponse = new RpcResponse();
        rpcResponse.setMessageId(this.messageId);
        rpcResponse.setExceptionValue(new MyRpcTimeoutException(
            "request timeoutï¼š" + defaultFuture.getTimeout() + " channel=" + defaultFuture.getChannel()));

        DefaultFutureManager.received(rpcResponse);
    }
}
Copy<br><br>
<br>ç»è¿‡ä¸¤ä¸ªè¿­ä»£ï¼Œç›®å‰MyRpcå·²ç»æ˜¯ä¸€ä¸ªéº»é›€è™½å°äº”è„ä¿±å…¨çš„rpcæ¡†æ¶äº†ã€‚<br>
è™½ç„¶æ— è®ºåœ¨åŠŸèƒ½ä¸Šè¿˜æ˜¯åœ¨å„ç§ç»†èŠ‚çš„å¤„ç†ä¸Šéƒ½è¿˜æœ‰å¾ˆå¤šéœ€è¦ä¼˜åŒ–çš„åœ°æ–¹ï¼Œä½†ä½œä¸ºä¸€ä¸ªdemoçº§åˆ«çš„æ¡†æ¶ï¼Œå…¶æ²¡æœ‰è¿‡å¤šçš„æŠ½è±¡å°è£…ï¼Œæ›´æœ‰åˆ©äºrpcæ¡†æ¶çš„åˆå­¦è€…å»ç†è§£ã€‚
<br>åšä¸ºMit6.824è¯¾ç¨‹å­¦ä¹ çš„ä¸€éƒ¨åˆ†ï¼Œrpcçš„å®ç°åˆ°æ­¤å°±æš‚æ—¶å‘Šä¸€æ®µè½ã€‚åç»­æˆ‘ä¼šç»§ç»­åˆ†äº«å®ç°ç®€æ˜“raft kvæ•°æ®åº“çš„å­¦ä¹ å¿ƒå¾—ã€‚
<br>åšå®¢ä¸­å±•ç¤ºçš„å®Œæ•´ä»£ç åœ¨æˆ‘çš„githubä¸Šï¼š<a rel="noopener" class="external-link" href="https://github.com/1399852153/MyRpc" target="_blank">https://github.com/1399852153/MyRpc</a> (release/lab2åˆ†æ”¯)ï¼Œå†…å®¹å¦‚æœ‰é”™è¯¯ï¼Œè¿˜è¯·å¤šå¤šæŒ‡æ•™ã€‚
]]></description><link>https://muqiuhan.github.io/wiki/computer-science/distributed-system/rpcæ¡†æ¶çš„å®ç°/è‡ªå·±åŠ¨æ‰‹å®ç°rpcæ¡†æ¶(äºŒ)-å®ç°é›†ç¾¤é—´rpcé€šä¿¡.html</link><guid isPermaLink="false">Computer Science/Distributed System/RPCæ¡†æ¶çš„å®ç°/è‡ªå·±åŠ¨æ‰‹å®ç°rpcæ¡†æ¶(äºŒ) å®ç°é›†ç¾¤é—´rpcé€šä¿¡.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Thu, 25 Jul 2024 09:22:05 GMT</pubDate><enclosure url="https://muqiuhan.github.io/wiki/computer-science/distributed-system/rpcæ¡†æ¶çš„å®ç°/pasted-image-20240725172146.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/rpcæ¡†æ¶çš„å®ç°/pasted-image-20240725172146.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦æ¡†æ¶]]></title><description><![CDATA[ 
 <br>å‰æ®µæ—¶é—´ï¼Œå…¬å¸è¦æ”¹é€ ç°æœ‰çš„å•èŠ‚ç‚¹è°ƒåº¦ä¸ºåˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦ï¼Œç„¶åå°±ç ”ç©¶äº†ç›®å‰å¸‚é¢ä¸Šä¸»æµçš„å¼€æºåˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦æ¡†æ¶ï¼Œç”¨èµ·æ¥å°±ä¸€ä¸ªæ„Ÿè§‰ï¼šéº»çƒ¦ï¼ç‰¹åˆ«æ˜¯ä¹‹å‰åœ¨ä¸€ä¸ªç±»é‡Œå†™äº†å¥½å¤šä¸ªè°ƒåº¦ä»»åŠ¡ï¼Œæ”¹é€ èµ·æ¥æ›´åŠ éº»çƒ¦ã€‚æˆ‘è¿™äººåˆæ¯”è¾ƒæ‡’ï¼Œæ€»æ„Ÿè§‰ç”¨äº†åˆ«äººå†™å¥½çš„å·¥å…·è¿˜è¦æ”¹ä¸€å¤§å †ï¼Œå¿ƒé‡Œå°±æœ‰ç‚¹ä¸èˆ’æœã€‚äºæ˜¯æˆ‘å°±æƒ³è‡ªå·±å†™ä¸€ä¸ªæ¡†æ¶ï¼Œæ¯•ç«Ÿè‡ªå·±è§‰å¾—åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦åœ¨æ‰€æœ‰åˆ†å¸ƒå¼ç³»ç»Ÿä¸­æ˜¯æœ€ç®€å•çš„ï¼Œå› ä¸ºä¸€èˆ¬å…¬å¸ä»»åŠ¡è°ƒåº¦æœ¬èº«ä¸å¯èƒ½åŒæ—¶è°ƒåº¦æµ·é‡çš„ä»»åŠ¡ï¼Œå¾ˆå¤§çš„å¹¶å‘ï¼Œæ”¹é€ æˆåˆ†å¸ƒå¼ä¸»è¦è¿˜æ˜¯ä¸ºäº†åˆ†æ•£ä»»åŠ¡åˆ°å¤šä¸ªèŠ‚ç‚¹ï¼Œä»¥ä¾¿åŒä¸€æ—¶é—´å¤„ç†æ›´å¤šçš„ä»»åŠ¡ã€‚åé¢æœ‰ä¸€å¤©ï¼Œæˆ‘åœ¨å…¬å¸å‰å°å–å¿«é€’ï¼Œçœ‹åˆ°è¿™æ ·ä¸€ä¸ªç°è±¡:æˆ‘ä»¬å¥½å‡ ä¸ªåŒäº‹(åŒ…æ‹¬æˆ‘)åœ¨å‰å°é‚£ä»å¤´åˆ°å°¾çœ‹å¿«é€’æ˜¯ä¸æ˜¯è‡ªå·±çš„ï¼Œæ˜¯è‡ªå·±çš„å°±å–èµ°ï¼Œä¸æ˜¯å°±å¿½ç•¥ï¼Œç„¶åæˆ‘å°±æ”¶åˆ°äº†å¯å‘ã€‚è¿™ä¸ªåœºæ™¯ç±»æ¯”åˆ°åˆ†å¸ƒå¼è°ƒåº¦ç³»ç»Ÿä¸­ï¼Œæˆ‘ä»¬å¯ä»¥è®¤ä¸ºæ˜¯å¿«é€’å…¬å¸æˆ–è€…å¿«é€’å‘˜å·²ç»æŠŠæ¯ä¸ªå¿«é€’æŒ‰ç…§æˆ‘ä»¬åå­—ç”µè¯åˆ†å¥½äº†å¿«é€’ï¼Œæˆ‘ä»¬åªéœ€è¦å–èµ°è‡ªå·±çš„å°±è¡Œäº†ã€‚ä½†æ˜¯ä»å¦å¤–ä¸€ä¸ªè§’åº¦çœ‹ï¼Œä¹Ÿå¯ä»¥ç†è§£æˆæˆ‘ä»¬æ¯ä¸ªäººéƒ½æ˜¯ä»å¤´åˆ°å°¾çœ‹äº†æ‰€æœ‰å¿«é€’ï¼Œç„¶åæŒ‰ç…§æŸç§çº¦å®šçš„è§„åˆ™ï¼Œå¦‚æœæ˜¯è‡ªå·±çš„å¿«é€’å°±æ‹¿èµ°ï¼Œä¸æ˜¯è‡ªå·±çš„å°±å¿½ç•¥ç»§ç»­çœ‹ä¸‹ä¸€ä¸ªã€‚å¦‚æœæŠŠå¿«é€’æƒ³è±¡æˆä»»åŠ¡ï¼Œä¸€å †äººå»æ‹¿ä¸€å †å¿«é€’ä¹Ÿå¯ä»¥å¾ˆé¡ºåˆ©çš„æ‹¿åˆ°å„è‡ªçš„å¿«é€’ï¼Œé‚£ä¹ˆä¸€å †èŠ‚ç‚¹è‡ªå·±å»å–ä»»åŠ¡æ˜¯ä¸æ˜¯ä¹Ÿå¯ä»¥å¾ˆå¥½çš„å¤„ç†å„è‡ªçš„ä»»åŠ¡å‘¢?<br>ä¼ ç»Ÿçš„åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦éƒ½æœ‰ä¸€ä¸ªè°ƒåº¦ä¸­å¿ƒï¼Œè¿™ä¸ªè°ƒåº¦ä¸­å¿ƒä¹Ÿéƒ½è¦éƒ¨ç½²ç§°å¤šèŠ‚ç‚¹çš„é›†ç¾¤ï¼Œé¿å…å•ç‚¹æ•…éšœï¼Œç„¶åè¿˜æœ‰ä¸€å †æ‰§è¡Œå™¨ï¼Œæ‰§è¡Œå™¨è´Ÿè´£æ‰§è¡Œè°ƒåº¦ä¸­å¿ƒåˆ†å‘çš„ä»»åŠ¡ã€‚æŒ‰ç…§ä¸Šé¢çš„å¯å‘ï¼Œæˆ‘çš„æ€è·¯æ˜¯æ”¾å¼ƒä¸­å¿ƒå¼çš„è°ƒåº¦ä¸­å¿ƒç›´æ¥ç”±å„ä¸ªæ‰§è¡Œå™¨èŠ‚ç‚¹å»å…¬å…±çš„åœ°æ–¹æŒ‰ç…§çº¦å®šçš„è§„åˆ™å»å–ä»»åŠ¡ï¼Œç„¶åæ‰§è¡Œã€‚è®¾è®¡ç¤ºæ„å›¾å¦‚ä¸‹<br><img alt="Pasted image 20240507114701.png" src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦æ¡†æ¶/pasted-image-20240507114701.png">æœ‰äººå¯èƒ½æ€€ç–‘é‚£ä»»åŠ¡dbåº“ä¸æ˜¯æœ‰å•ç‚¹é—®é¢˜å—ï¼Œæˆ‘æƒ³åé—®ä¸‹ï¼Œéš¾é“å…¶ä»–çš„åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦æ¡†æ¶æ²¡æœ‰è¿™ä¸ªé—®é¢˜å—ï¼Ÿé’ˆå¯¹æ•°æ®åº“å•ç‚¹æˆ‘ä»¬å¯ä»¥å•ç‹¬ç±»ä¼¼ä¸šåŠ¡åº“é‚£æ ·è€ƒè™‘é«˜å¯ç”¨æ–¹æ¡ˆï¼Œè¿™é‡Œä¸æ˜¯è¿™ç¯‡æ–‡ç« çš„è®¨è®ºé‡ç‚¹ã€‚å¾ˆæ˜æ˜¾æˆ‘ä»¬é‡ç‚¹æ”¾åœ¨æ‰§è¡ŒèŠ‚ç‚¹é‚£é‡Œåˆ°åº•æ€ä¹ˆä¿è¯é«˜å¯ç”¨ï¼Œå•ä¸ªä»»åŠ¡ä¸ä¼šè¢«å¤šä¸ªèŠ‚ç‚¹åŒæ—¶æ‰§è¡Œï¼Œå•ä¸ªèŠ‚ç‚¹æ‰§è¡Œåˆ°ä¸€åŠçªç„¶å¤±è”äº†ï¼Œè¿™ä¸ªä»»åŠ¡æ€ä¹ˆåŠç­‰å¤æ‚çš„é—®é¢˜ã€‚åç»­æˆ‘ä»¬ä½¿ç”¨æœªç»ä¿®é¥°çš„ä»£ç çš„æ–¹å¼ä¸€ä¸€è§£å†³è¿™ä¸ªé—®é¢˜ï¼ˆæœªç»ä¿®é¥°ä¸»è¦æ˜¯æ²¡æœ‰ä¼˜åŒ–ç»“æ„æµæ°´è´¦å¼çš„ä»£ç é£æ ¼ï¼Œä¸»è¦æ˜¯å¾ˆå¤šäººåŒ…æ‹¬æˆ‘è‡ªå·±çœ‹åˆ«äººæºç æ—¶æ€»æ˜¯æ„Ÿè§‰æ™•å¤´è½¬å‘çš„ï¼Œä»¿ä½›ç½®èº«è¿·å®«èˆ¬ï¼Œçœ‹èµ·æ¥ç‰¹åˆ«è´¹åŠ²ï¼Œå¯èƒ½æ˜¯æˆ‘è‡ªå·±å¢ƒç•Œæœªåˆ°å§ï¼‰<br>æ—¢ç„¶çœç•¥äº†é›†ä¸­å¼çš„è°ƒåº¦ï¼Œé‚£ä¹ˆæ—¢ç„¶å«ä»»åŠ¡è°ƒåº¦å¾ˆæ˜æ˜¾å¿…é¡»è¦æœ‰è°ƒåº¦çš„è¿‡ç¨‹ï¼Œä¸ç„¶å¤šä¸ªèŠ‚ç‚¹å»æŠ¢ä¸€ä¸ªä»»åŠ¡æ€ä¹ˆé¿å…å†²çªå‘¢?æˆ‘è¿™é‡Œè§£å†³æ–¹å¼æ˜¯ï¼šé¦–å…ˆå…ˆæ˜ç¡®ä¸€ä¸ªä»»åŠ¡çš„å‡ ç§çŠ¶æ€:å¾…æ‰§è¡Œï¼Œæ‰§è¡Œä¸­ï¼Œæœ‰å¼‚å¸¸ï¼Œå·²å®Œæˆã€‚æ¯ä¸ªèŠ‚ç‚¹èµ·ä¸€ä¸ªçº¿ç¨‹ä¸€ç›´å»æŸ¥å¾ˆå¿«å°±è¦å¼€å§‹æ‰§è¡Œçš„å¾…æ‰§è¡Œä»»åŠ¡ï¼Œç„¶åéå†è¿™äº›ä»»åŠ¡ï¼Œä½¿ç”¨ä¹è§‚é”çš„æ–¹å¼å…ˆæ›´æ–°è¿™ä¸ªä»»åŠ¡çš„ç‰ˆæœ¬å·ï¼ˆç‰ˆæœ¬å·+1ï¼‰å’ŒçŠ¶æ€ï¼ˆå˜æˆæ‰§è¡Œä¸­ï¼‰ï¼Œå¦‚æœæ›´æ–°æˆåŠŸå°±æ”¾å…¥èŠ‚ç‚¹è‡ªå·±çš„å»¶æ—¶é˜Ÿåˆ—ä¸­ç­‰å¾…æ‰§è¡Œã€‚ç”±äºæ¯ä¸ªèŠ‚ç‚¹çš„çº¿ç¨‹éƒ½æ˜¯å»æ•°æ®åº“æŸ¥å¾…æ‰§è¡Œçš„ä»»åŠ¡ï¼Œå¾ˆæ˜æ˜¾å˜æˆæ‰§è¡Œä¸­çš„ä»»åŠ¡ä¸‹æ¬¡å°±ä¸ä¼šè¢«å…¶ä»–èŠ‚ç‚¹å†æŸ¥è¯¢åˆ°äº†ï¼Œè‡³äºå¯¹äºé‚£äº›åœ¨æœ¬èŠ‚ç‚¹æ›´æ–°çŠ¶æ€ä¹‹å‰å°±æŸ¥åˆ°çš„å¾…æ‰§è¡Œä»»åŠ¡ä¹Ÿä¼šç»è¿‡ä¹è§‚é”å°è¯•åæ›´æ–°å¤±è´¥ä»è€Œè·³è¿‡è¿™ä¸ªä»»åŠ¡ï¼Œè¿™æ ·å°±å¯ä»¥é¿å…ä¸€ä¸ªä»»åŠ¡åŒæ—¶è¢«å¤šä¸ªèŠ‚ç‚¹é‡å¤æ‰§è¡Œã€‚å…³é”®ä»£ç å¦‚ä¸‹:<br>package com.rdpaas.task.scheduler;

import com.rdpaas.task.common.*;
import com.rdpaas.task.config.EasyJobConfig;
import com.rdpaas.task.repository.NodeRepository;
import com.rdpaas.task.repository.TaskRepository;
import com.rdpaas.task.strategy.Strategy;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;

import java.util.Date;
import java.util.List;
import java.util.concurrent.*;

/**
 * ä»»åŠ¡è°ƒåº¦å™¨
 * @author rongdi
 * @date 2019-03-13 21:15
 */
@Component
public class TaskExecutor {

    private static final Logger logger = LoggerFactory.getLogger(TaskExecutor.class);

    @Autowired
    private TaskRepository taskRepository;

    @Autowired
    private NodeRepository nodeRepository;

    @Autowired
    private EasyJobConfig config;/**
     * åˆ›å»ºä»»åŠ¡åˆ°æœŸå»¶æ—¶é˜Ÿåˆ—
      */
	    private DelayQueue&lt;DelayItem&lt;Task&gt;&gt; taskQueue = new DelayQueue&lt;&gt;();

    /**
     * å¯ä»¥æ˜ç¡®çŸ¥é“æœ€å¤šåªä¼šè¿è¡Œ2ä¸ªçº¿ç¨‹ï¼Œç›´æ¥ä½¿ç”¨ç³»ç»Ÿè‡ªå¸¦å·¥å…·å°±å¯ä»¥äº†
     */
    private ExecutorService bossPool = Executors.newFixedThreadPool(2);

    /**
     * å£°æ˜å·¥ä½œçº¿ç¨‹æ± 
     */
    private ThreadPoolExecutor workerPool;


    @PostConstruct
    public void init() {
/**
         * è‡ªå®šä¹‰çº¿ç¨‹æ± ï¼Œåˆå§‹çº¿ç¨‹æ•°é‡corePoolSizeï¼Œçº¿ç¨‹æ± ç­‰å¾…é˜Ÿåˆ—å¤§å°queueSizeï¼Œå½“åˆå§‹çº¿ç¨‹éƒ½æœ‰ä»»åŠ¡ï¼Œå¹¶ä¸”ç­‰å¾…é˜Ÿåˆ—æ»¡å
         * çº¿ç¨‹æ•°é‡ä¼šè‡ªåŠ¨æ‰©å……æœ€å¤§çº¿ç¨‹æ•°maxSizeï¼Œå½“æ–°æ‰©å……çš„çº¿ç¨‹ç©ºé—²60såè‡ªåŠ¨å›æ”¶.è‡ªå®šä¹‰çº¿ç¨‹æ± æ˜¯å› ä¸ºExecutorsé‚£å‡ ä¸ªçº¿ç¨‹å·¥å…·
         * å„æœ‰å„çš„å¼Šç«¯ï¼Œä¸é€‚åˆç”Ÿäº§ä½¿ç”¨
         */
        workerPool = new ThreadPoolExecutor(config.getCorePoolSize(), config.getMaxPoolSize(), 60, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(config.getQueueSize()));
        /**
         * æ‰§è¡Œå¾…å¤„ç†ä»»åŠ¡åŠ è½½çº¿ç¨‹
         */
        bossPool.execute(new Loader());
        /**
         * æ‰§è¡Œä»»åŠ¡è°ƒåº¦çº¿ç¨‹
         */
        bossPool.execute(new Boss());
    
    }

    class Loader implements Runnable {

        @Override
        public void run() {
            for(;;) {
                try { 
            /**
                     * æŸ¥æ‰¾è¿˜æœ‰æŒ‡å®šæ—¶é—´(å•ä½ç§’)å¼€å§‹çš„ä¸»ä»»åŠ¡åˆ—è¡¨
                     */
                    List&lt;Task&gt; tasks = taskRepository.listPeddingTasks(config.getFetchDuration());
                    if(tasks == null || tasks.isEmpty()) {
                        continue;
                    }
                    for(Task task:tasks) {
                        
                        task.setStatus(TaskStatus.DOING);
                        task.setNodeId(config.getNodeId());
                        /**
                         * ä½¿ç”¨ä¹è§‚é”å°è¯•æ›´æ–°çŠ¶æ€ï¼Œå¦‚æœæ›´æ–°æˆåŠŸï¼Œå…¶ä»–èŠ‚ç‚¹å°±ä¸ä¼šæ›´æ–°æˆåŠŸã€‚å¦‚æœåœ¨æŸ¥è¯¢å¾…æ‰§è¡Œä»»åŠ¡åˆ—è¡¨
                         * å’Œå½“å‰è¿™æ®µæ—¶é—´æœ‰èŠ‚ç‚¹å·²ç»æ›´æ–°äº†è¿™ä¸ªä»»åŠ¡ï¼Œversionå¿…ç„¶å’ŒæŸ¥å‡ºæ¥æ—¶å€™çš„versionä¸ä¸€æ ·äº†,è¿™é‡Œæ›´æ–°
                         * å¿…ç„¶ä¼šè¿”å›0äº†
                         */
                        int n = taskRepository.updateWithVersion(task);
                        Date nextStartTime = task.getNextStartTime();
                        if(n == 0 || nextStartTime == null) {
                            continue;
                        }
                        /**
                         * å°è£…æˆå»¶æ—¶å¯¹è±¡æ”¾å…¥å»¶æ—¶é˜Ÿåˆ—
                         */
                        task = taskRepository.get(task.getId());
                        DelayItem&lt;Task&gt; delayItem = new DelayItem&lt;Task&gt;(nextStartTime.getTime() - new Date().getTime(), task);
                        taskQueue.offer(delayItem);
                        
                    }
                    Thread.sleep(config.getFetchPeriod());
                } catch(Exception e) {
                    logger.error("fetch task list failed,cause by:{}", e);
                }
            }
        }
        
    }
    
    class Boss implements Runnable {
        @Override
        public void run() {
            for (;;) {
                try {
                     /**
                     * æ—¶é—´åˆ°äº†å°±å¯ä»¥ä»å»¶æ—¶é˜Ÿåˆ—æ‹¿å‡ºä»»åŠ¡å¯¹è±¡,ç„¶åäº¤ç»™workerçº¿ç¨‹æ± å»æ‰§è¡Œ
                     */
                    DelayItem&lt;Task&gt; item = taskQueue.take();
                    if(item != null &amp;&amp; item.getItem() != null) {
                        Task task = item.getItem();
                        workerPool.execute(new Worker(task));
                    }
                     
                } catch (Exception e) {
                    logger.error("fetch task failed,cause by:{}", e);
                }
            }
        }

    }

    class Worker implements Runnable {

        private Task task;

        public Worker(Task task) {
            this.task = task;
        }

        @Override
        public void run() {
            logger.info("Begin to execute task:{}",task.getId());
            TaskDetail detail = null;
            try {
                //å¼€å§‹ä»»åŠ¡
                detail = taskRepository.start(task);
                if(detail == null) return;
                //æ‰§è¡Œä»»åŠ¡
                task.getInvokor().invoke();
                //å®Œæˆä»»åŠ¡
                finish(task,detail);
                logger.info("finished execute task:{}",task.getId());
            } catch (Exception e) {
                logger.error("execute task:{} error,cause by:{}",task.getId(), e);
                try {
                    taskRepository.fail(task,detail,e.getCause().getMessage());
                } catch(Exception e1) {
                    logger.error("fail task:{} error,cause by:{}",task.getId(), e);
                }
            }
        }

    }

    /**
     * å®Œæˆå­ä»»åŠ¡ï¼Œå¦‚æœçˆ¶ä»»åŠ¡å¤±è´¥äº†ï¼Œå­ä»»åŠ¡ä¸ä¼šæ‰§è¡Œ
     * @param task
     * @param detail
     * @throws Exception
     */
    private void finish(Task task,TaskDetail detail) throws Exception {

        //æŸ¥çœ‹æ˜¯å¦æœ‰å­ç±»ä»»åŠ¡
        List&lt;Task&gt; childTasks = taskRepository.getChilds(task.getId());
        if(childTasks == null || childTasks.isEmpty()) {
            //å½“æ²¡æœ‰å­ä»»åŠ¡æ—¶å®Œæˆçˆ¶ä»»åŠ¡
            taskRepository.finish(task,detail);
            return;
        } else {
            for (Task childTask : childTasks) {
                //å¼€å§‹ä»»åŠ¡
                TaskDetail childDetail = null;
                try {
                    //å°†å­ä»»åŠ¡çŠ¶æ€æ”¹æˆæ‰§è¡Œä¸­
                    childTask.setStatus(TaskStatus.DOING);
                    childTask.setNodeId(config.getNodeId());
                    //å¼€å§‹å­ä»»åŠ¡
                    childDetail = taskRepository.startChild(childTask,detail);
                    //ä½¿ç”¨ä¹è§‚é”æ›´æ–°ä¸‹çŠ¶æ€ï¼Œä¸ç„¶è¿™é‡Œå¯èƒ½å’Œæ¢å¤çº¿ç¨‹äº§ç”Ÿå¹¶å‘é—®é¢˜
                    int n = taskRepository.updateWithVersion(childTask);
                    if (n &gt; 0) {
                        //å†ä»æ•°æ®åº“å–ä¸€ä¸‹ï¼Œé¿å…ä¸Šé¢updateä¿®æ”¹åversionä¸åŒæ­¥
                        childTask = taskRepository.get(childTask.getId());
                        //æ‰§è¡Œå­ä»»åŠ¡
                        childTask.getInvokor().invoke();
                        //å®Œæˆå­ä»»åŠ¡
                        finish(childTask, childDetail);
                    }
                } catch (Exception e) {
                    logger.error("execute child task error,cause by:{}", e);
                    try {
                        taskRepository.fail(childTask, childDetail, e.getCause().getMessage());
                    } catch (Exception e1) {
                        logger.error("fail child task error,cause by:{}", e);
                    }
                }
            }
            /**
             * å½“æœ‰å­ä»»åŠ¡æ—¶å®Œæˆå­ä»»åŠ¡åå†å®Œæˆçˆ¶ä»»åŠ¡
             */
            taskRepository.finish(task,detail);

        }

    }

}
Copy<br>å¦‚ä¸Šæ‰€è¿°ï¼Œå¯ä»¥ä¿è¯ä¸€ä¸ªä»»åŠ¡åŒä¸€ä¸ªæ—¶é—´åªä¼šè¢«ä¸€ä¸ªèŠ‚ç‚¹è°ƒåº¦æ‰§è¡Œã€‚è¿™æ—¶å€™å¦‚æœéƒ¨ç½²å¤šä¸ªèŠ‚ç‚¹ï¼Œæ­£å¸¸åº”è¯¥å¯ä»¥å¾ˆé¡ºåˆ©çš„å°†ä»»åŠ¡åº“ä¸­çš„ä»»åŠ¡éƒ½æ‰§è¡Œåˆ°ï¼Œå°±åƒä¸€å †äººå»å‰å°å–å¿«é€’ä¸€æ ·ï¼Œå¯ä»¥å¾ˆé¡ºåˆ©çš„æ‹¿èµ°æ‰€æœ‰å¿«é€’ã€‚æ¯•ç«Ÿå¯¹äºæ¯ä¸ªå¿«é€’ä¸æ˜¯è‡ªå·±çš„å°±æ˜¯å…¶ä»–äººçš„ï¼Œè‡ªå·±çš„å¿«é€’ä¹Ÿä¸ä¼šæ˜¯å…¶ä»–äººçš„ã€‚ä½†æ˜¯è¿™é‡Œçš„è°ƒåº¦å’Œå–å¿«é€’æœ‰ä¸€ç‚¹ä¸ä¸€æ ·ï¼Œå–å¿«é€’çš„æ¯ä¸ªäººéƒ½çŸ¥é“æ€ä¹ˆå»åŒºåˆ†åˆ°åº•å“ªä¸ªå¿«é€’æ˜¯è‡ªå·±çš„ã€‚è¿™é‡Œçš„è°ƒåº¦å®Œå…¨æ²¡è¿™ä¸ªæ¦‚å¿µï¼Œå®Œå…¨æ˜¯å“ªä¸ªèŠ‚ç‚¹è¿æ°”å¥½ä½¿ç”¨ä¹è§‚é”æ›´æ–°äº†è¿™ä¸ªä»»åŠ¡çŠ¶æ€å°±æ˜¯å“ªä¸ªèŠ‚ç‚¹çš„ã€‚æ€»çš„æ¥è¯´åŒºåˆ«å°±æ˜¯éœ€è¦ä¸€ä¸ªçº¦å®šçš„è§„åˆ™ï¼Œå¿«é€’æ˜¯ä¸æ˜¯è‡ªå·±çš„ï¼Œç›´æ¥çœ‹å¿«é€’ä¸Šçš„åå­—å’Œæ‰‹æœºå·ç å°±çŸ¥é“äº†ã€‚ä»»åŠ¡åˆ°åº•è¯¥ä¸è¯¥è‡ªå·±æ‰§è¡Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å‡ºä¸€ä¸ªè¿™ç§è§„åˆ™ï¼Œæ˜ç¡®å“ªäº›ä»»åŠ¡é‚£äº›åº”è¯¥æ˜¯å“ªäº›èŠ‚ç‚¹å¯ä»¥æ‰§è¡Œï¼Œä»è€Œé¿å…æ— è°“çš„é”ç«äº‰ã€‚è¿™é‡Œå¯ä»¥å€Ÿé‰´è´Ÿè½½å‡è¡¡çš„é‚£äº›ç­–ç•¥ï¼Œç›®å‰æˆ‘æƒ³å®ç°å¦‚ä¸‹è§„åˆ™:<br>
<br>id_hash : æŒ‰ç…§ä»»åŠ¡è‡ªå¢idçš„å¯¹èŠ‚ç‚¹ä¸ªæ•°å–ä½™ï¼Œä½™æ•°å€¼å’Œå½“å‰èŠ‚ç‚¹çš„å®æ—¶åºå·åŒ¹é…ï¼Œå¯ä»¥åŒ¹é…å°±å¯ä»¥æ‹¿èµ°æ‰§è¡Œï¼Œå¦åˆ™è¯·è‡ªè§‰å¿½ç•¥æ‰è¿™ä¸ªä»»åŠ¡ã€‚
<br>least_countï¼šæœ€å°‘æ‰§è¡Œä»»åŠ¡çš„èŠ‚ç‚¹ä¼˜å…ˆå»å–ä»»åŠ¡ã€‚
<br>weightï¼šæŒ‰ç…§èŠ‚ç‚¹æƒé‡å»å–ä»»åŠ¡ã€‚
<br>defaultï¼š é»˜è®¤å…ˆåˆ°å…ˆå¾—ï¼Œæ²¡æœ‰å…¶å®ƒè§„åˆ™ã€‚
<br>æ ¹æ®ä¸Šé¢è§„åˆ™ä¹Ÿå¯ä»¥è¯´æ˜¯ä»»åŠ¡çš„è´Ÿè½½å‡è¡¡ç­–ç•¥å¯ä»¥çŸ¥é“é™¤äº†é»˜è®¤è§„åˆ™ï¼Œå…¶ä½™è§„åˆ™éƒ½éœ€è¦çŸ¥é“å…¨å±€çš„èŠ‚ç‚¹ä¿¡æ¯ï¼Œæ¯”å¦‚èŠ‚ç‚¹æ‰§è¡Œæ¬¡æ•°ï¼ŒèŠ‚ç‚¹åºå·ï¼ŒèŠ‚ç‚¹æƒé‡ç­‰ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ç»™èŠ‚ç‚¹æ·»åŠ ä¸€ä¸ªå¿ƒè·³ï¼Œéš”ä¸€ä¸ªå¿ƒè·³å‘¨æœŸä¸ŠæŠ¥ä¸€ä¸‹è‡ªå·±çš„ä¿¡æ¯åˆ°æ•°æ®åº“ï¼Œå¿ƒè·³æ ¸å¿ƒä»£ç å¦‚ä¸‹:<br>/**
     * åˆ›å»ºèŠ‚ç‚¹å¿ƒè·³å»¶æ—¶é˜Ÿåˆ—
      */
    private DelayQueue&lt;DelayItem&lt;Node&gt;&gt; heartBeatQueue = new DelayQueue&lt;&gt;();
 ã€€ã€€/**
     * å¯ä»¥æ˜ç¡®çŸ¥é“æœ€å¤šåªä¼šè¿è¡Œ2ä¸ªçº¿ç¨‹ï¼Œç›´æ¥ä½¿ç”¨ç³»ç»Ÿè‡ªå¸¦å·¥å…·
     */
    private ExecutorService bossPool = Executors.newFixedThreadPool(2);
ã€€ã€€ã€€ã€€ @PostConstruct
    public void init() {
        /**
         * å¦‚æœæ¢å¤çº¿ç¨‹å¼€å…³æ˜¯å¼€ç€ï¼Œå¹¶ä¸”å¿ƒè·³å¼€å…³ä¹Ÿæ˜¯å¼€ç€
         */
        if(config.isRecoverEnable() &amp;&amp; config.isHeartBeatEnable()) {
            /**
             * åˆå§‹åŒ–ä¸€ä¸ªèŠ‚ç‚¹åˆ°å¿ƒè·³é˜Ÿåˆ—ï¼Œå»¶æ—¶ä¸º0ï¼Œç”¨æ¥æ³¨å†ŒèŠ‚ç‚¹
             */
            heartBeatQueue.offer(new DelayItem&lt;&gt;(0,new Node(config.getNodeId())));
            /**
             * æ‰§è¡Œå¿ƒè·³çº¿ç¨‹
             */
            bossPool.execute(new HeartBeat());
            /**
             * æ‰§è¡Œå¼‚å¸¸æ¢å¤çº¿ç¨‹
             */
            bossPool.execute(new Recover());
        }
    }
 ã€€ã€€class HeartBeat implements Runnable {
        @Override
        public void run() {
            for(;;) {
                try {
                    /**
                     * æ—¶é—´åˆ°äº†å°±å¯ä»¥ä»å»¶æ—¶é˜Ÿåˆ—æ‹¿å‡ºèŠ‚ç‚¹å¯¹è±¡ï¼Œç„¶åæ›´æ–°æ—¶é—´å’Œåºå·ï¼Œ
                     * æœ€åå†æ–°å»ºä¸€ä¸ªè¶…æ—¶æ—¶é—´ä¸ºå¿ƒè·³æ—¶é—´çš„èŠ‚ç‚¹å¯¹è±¡æ”¾å…¥å»¶æ—¶é˜Ÿåˆ—ï¼Œå½¢æˆå¾ªç¯çš„å¿ƒè·³
                     */
                    DelayItem&lt;Node&gt; item = heartBeatQueue.take();
                    if(item != null &amp;&amp; item.getItem() != null) {
                        Node node = item.getItem();
                        handHeartBeat(node);
                    }
                    heartBeatQueue.offer(new DelayItem&lt;&gt;(config.getHeartBeatSeconds() * 1000,new Node(config.getNodeId())));
                } catch (Exception e) {
                    logger.error("task heart beat error,cause by:{} ",e);
                }
            }
        }
    }

    /**
     * å¤„ç†èŠ‚ç‚¹å¿ƒè·³
     * @param node
     */
    private void handHeartBeat(Node node) {
        if(node == null) {
            return;
        }
        /**
         * å…ˆçœ‹çœ‹æ•°æ®åº“æ˜¯å¦å­˜åœ¨è¿™ä¸ªèŠ‚ç‚¹
         * å¦‚æœä¸å­˜åœ¨ï¼šå…ˆæŸ¥æ‰¾ä¸‹ä¸€ä¸ªåºå·ï¼Œç„¶åè®¾ç½®åˆ°nodeå¯¹è±¡ä¸­ï¼Œæœ€åæ’å…¥
         * å¦‚æœå­˜åœ¨ï¼šç›´æ¥æ ¹æ®nodeIdæ›´æ–°å½“å‰èŠ‚ç‚¹çš„åºå·å’Œæ—¶é—´
         */
        Node currNode= nodeRepository.getByNodeId(node.getNodeId());
        if(currNode == null) {
            node.setRownum(nodeRepository.getNextRownum());
            nodeRepository.insert(node);
        } else  {
            nodeRepository.updateHeartBeat(node.getNodeId());
        }

    }
Copy<br>æ•°æ®åº“æœ‰äº†èŠ‚ç‚¹ä¿¡æ¯åï¼Œæˆ‘ä»¬å°±å¯ä»¥å®ç°å„ç§èŠ±å¼çš„å–ä»»åŠ¡çš„ç­–ç•¥äº†ï¼Œä»£ç å¦‚ä¸‹:<br>/**
 * æŠ½è±¡çš„ç­–ç•¥æ¥å£
 * @author rongdi
 * @date 2019-03-16 12:36
 */
public interface Strategy {

    /**
     * é»˜è®¤ç­–ç•¥
     */
    String DEFAULT = "default";
    
    /**
     * æŒ‰ä»»åŠ¡ID hashå–ä½™å†å’Œè‡ªå·±èŠ‚ç‚¹åºå·åŒ¹é…
     */
    String ID_HASH = "id_hash";
    
    /**
     * æœ€å°‘æ‰§è¡Œæ¬¡æ•°
     */
    String LEAST_COUNT = "least_count";
    
    /**
     * æŒ‰èŠ‚ç‚¹æƒé‡
     */
    String WEIGHT = "weight";
    
    
    public static Strategy choose(String key) {
        switch(key) {
            case ID_HASH:
                return new IdHashStrategy();
            case LEAST_COUNT:
                return new LeastCountStrategy();
            case WEIGHT:
                return new WeightStrategy();
            default:
                return new DefaultStrategy();
        }
    }
    
    public boolean accept(List&lt;Node&gt; nodes,Task task,Long myNodeId);
    
}
Copy<br>/**
 * æŒ‰ç…§ä»»åŠ¡ID hashæ–¹å¼é’ˆå¯¹æœ‰æ•ˆèŠ‚ç‚¹ä¸ªæ•°å–ä½™ï¼Œç„¶åä½™æ•°+1åå’Œå„ä¸ªèŠ‚ç‚¹çš„é¡ºåºå·åŒ¹é…ï¼Œ
 * è¿™ç§æ–¹å¼æ•ˆæœå…¶å®ç­‰åŒäºè½®è¯¢ï¼Œå› ä¸ºä»»åŠ¡idæ˜¯è‡ªå¢çš„
 * @author rongdi
 * @date 2019-03-16
 */
public class IdHashStrategy implements Strategy {

    /**
     * è¿™é‡Œçš„nodesé›†åˆå¿…ç„¶ä¸ä¼šä¸ºç©ºï¼Œå¤–é¢è°ƒåº¦é‚£åˆ¤æ–­äº†ï¼Œè€Œä¸”æ˜¯æŒ‰ç…§nodeIdçš„å‡åºæ’åˆ—çš„
     */
    @Override
    public boolean accept(List&lt;Node&gt; nodes, Task task, Long myNodeId) {
        int size = nodes.size();
        long taskId = task.getId();
        /**
         * æ‰¾åˆ°è‡ªå·±çš„èŠ‚ç‚¹
         */
        Node myNode = nodes.stream().filter(node -&gt; node.getNodeId() == myNodeId).findFirst().get();
        return myNode == null ? false : (taskId % size) + 1 == myNode.getRownum();
    }

}
Copy<br>/**
 * æœ€å°‘å¤„ç†ä»»åŠ¡æ¬¡æ•°ç­–ç•¥ï¼Œä¹Ÿå°±æ˜¯æ¯æ¬¡ä»»åŠ¡æ¥äº†ï¼Œçœ‹çœ‹è‡ªå·±æ˜¯ä¸æ˜¯å¤„ç†ä»»åŠ¡æ¬¡æ•°æœ€å°‘çš„ï¼Œæ˜¯å°±å¯ä»¥æ¶ˆè´¹è¿™ä¸ªä»»åŠ¡
 * @author rongdi
 * @date 2019-03-16 21:56
 */
public class LeastCountStrategy implements Strategy {

    @Override
    public boolean accept(List&lt;Node&gt; nodes, Task task, Long myNodeId) {

        /**
         * è·å–æ¬¡æ•°æœ€å°‘çš„é‚£ä¸ªèŠ‚ç‚¹,è¿™é‡Œå¯ä»¥ç±»æ¯”æˆå…ˆæŒ‰countså‡åºæ’åˆ—ç„¶åå–ç¬¬ä¸€ä¸ªå…ƒç´ 
         * ç„¶åæ˜¯è‡ªå·±å°±è¿”å›true
         */
        Optional&lt;Node&gt; min = nodes.stream().min((o1, o2) -&gt; o1.getCounts().compareTo(o2.getCounts()));
        
        return min.isPresent()? min.get().getNodeId() == myNodeId : false;
    }
    
}
Copy<br>/**
 * æŒ‰æƒé‡çš„åˆ†é…ç­–ç•¥,æ–¹æ¡ˆå¦‚ä¸‹ï¼Œå‡å¦‚
 * èŠ‚ç‚¹åºå·   1     ,2     ,3       ,4
 * èŠ‚ç‚¹æƒé‡   2     ,3     ,3       ,2
 * åˆ™å–ä½™å 0,1 | 2,3,4 | 5,6,7 | 8,9
 * åºå·1å¯ä»¥æ¶ˆè´¹æŒ‰ç…§æƒé‡çš„å’Œå–ä½™åå°äº2çš„
 * åºå·2å¯ä»¥æ¶ˆè´¹æŒ‰ç…§æƒé‡çš„å’Œå–ä½™åå¤§äºç­‰äº2å°äº2+3çš„
 * åºå·3å¯ä»¥æ¶ˆè´¹æŒ‰ç…§æƒé‡çš„å’Œå–ä½™åå¤§äºç­‰äº2+3å°äº2+3+3çš„
 * åºå·3å¯ä»¥æ¶ˆè´¹æŒ‰ç…§æƒé‡çš„å’Œå–ä½™åå¤§äºç­‰äº2+3+3å°äº2+3+3+2çš„
 * æ€»ç»“ï¼šæœ¬èŠ‚ç‚¹å¯ä»¥æ¶ˆè´¹çš„æŒ‰ç…§æƒé‡çš„å’Œå–ä½™åå¤§äºç­‰äºå‰é¢èŠ‚ç‚¹çš„æƒé‡å’Œå°äºåŒ…æ‹¬è‡ªå·±çš„æƒé‡å’Œçš„è¿™ä¸ªèŒƒå›´
 * ä¸çŸ¥é“æœ‰æ²¡æœ‰å¤§ç¥æœ‰æ›´å¥½çš„ç®—æ³•æ€è·¯
 * @author rongdi
 * @date 2019-03-16 23:16
 */
public class WeightStrategy implements Strategy {

    @Override
    public boolean accept(List&lt;Node&gt; nodes, Task task, Long myNodeId) {
        Node myNode = nodes.stream().filter(node -&gt; node.getNodeId() == myNodeId).findFirst().get();
        if(myNode == null) {
            return false;
        }
        /**
         * è®¡ç®—æœ¬èŠ‚ç‚¹åºå·å‰é¢çš„èŠ‚ç‚¹çš„æƒé‡å’Œ
         */
        int preWeightSum = nodes.stream().filter(node -&gt; node.getRownum() &lt; myNode.getRownum()).collect(Collectors.summingInt(Node::getWeight));
        /**
         * è®¡ç®—å…¨éƒ¨æƒé‡çš„å’Œ
         */
        int weightSum = nodes.stream().collect(Collectors.summingInt(Node::getWeight));
        /**
         * è®¡ç®—å¯¹æƒé‡å’Œå–ä½™çš„ä½™æ•°
         */
        int remainder = (int)(task.getId() % weightSum);
        return remainder &gt;= preWeightSum &amp;&amp; remainder &lt; preWeightSum + myNode.getWeight();
    }
    
}
Copy<br>ç„¶åæˆ‘ä»¬å†æ”¹é€ ä¸‹è°ƒåº¦ç±»:<br>/**
     * è·å–ä»»åŠ¡çš„ç­–ç•¥
     */
    private Strategy strategy;


    @PostConstruct
    public void init() {
        /**
         * æ ¹æ®é…ç½®é€‰æ‹©ä¸€ä¸ªèŠ‚ç‚¹è·å–ä»»åŠ¡çš„ç­–ç•¥
         */
        strategy = Strategy.choose(config.getNodeStrategy());
        /**
         * è‡ªå®šä¹‰çº¿ç¨‹æ± ï¼Œåˆå§‹çº¿ç¨‹æ•°é‡corePoolSizeï¼Œçº¿ç¨‹æ± ç­‰å¾…é˜Ÿåˆ—å¤§å°queueSizeï¼Œå½“åˆå§‹çº¿ç¨‹éƒ½æœ‰ä»»åŠ¡ï¼Œå¹¶ä¸”ç­‰å¾…é˜Ÿåˆ—æ»¡å
         * çº¿ç¨‹æ•°é‡ä¼šè‡ªåŠ¨æ‰©å……æœ€å¤§çº¿ç¨‹æ•°maxSizeï¼Œå½“æ–°æ‰©å……çš„çº¿ç¨‹ç©ºé—²60såè‡ªåŠ¨å›æ”¶.è‡ªå®šä¹‰çº¿ç¨‹æ± æ˜¯å› ä¸ºExecutorsé‚£å‡ ä¸ªçº¿ç¨‹å·¥å…·
         * å„æœ‰å„çš„å¼Šç«¯ï¼Œä¸é€‚åˆç”Ÿäº§ä½¿ç”¨
         */
        workerPool = new ThreadPoolExecutor(config.getCorePoolSize(), config.getMaxPoolSize(), 60, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(config.getQueueSize()));
        /**
         * æ‰§è¡Œå¾…å¤„ç†ä»»åŠ¡åŠ è½½çº¿ç¨‹
         */
        bossPool.execute(new Loader());
        /**
         * æ‰§è¡Œä»»åŠ¡è°ƒåº¦çº¿ç¨‹
         */
        bossPool.execute(new Boss());
    
    }

    class Loader implements Runnable {

        @Override
        public void run() {
            for(;;) {
                try { 
                    /**
                     * å…ˆè·å–å¯ç”¨çš„èŠ‚ç‚¹åˆ—è¡¨
                     */
                    List&lt;Node&gt; nodes = nodeRepository.getEnableNodes(config.getHeartBeatSeconds() * 2);
                    if(nodes == null || nodes.isEmpty()) {
                        continue;
                    }
                    /**
                     * æŸ¥æ‰¾è¿˜æœ‰æŒ‡å®šæ—¶é—´(å•ä½ç§’)å¼€å§‹çš„ä¸»ä»»åŠ¡åˆ—è¡¨
                     */
                    List&lt;Task&gt; tasks = taskRepository.listPeddingTasks(config.getFetchDuration());
                    if(tasks == null || tasks.isEmpty()) {
                        continue;
                    }
                    for(Task task:tasks) {
                        
                        boolean accept = strategy.accept(nodes, task, config.getNodeId());
                        /**
                         * ä¸è¯¥è‡ªå·±æ‹¿å°±ä¸è¦æŠ¢
                         */
                        if(!accept) {
                            continue;
                        }
                        task.setStatus(TaskStatus.DOING);
                        task.setNodeId(config.getNodeId());
                        /**
                         * ä½¿ç”¨ä¹è§‚é”å°è¯•æ›´æ–°çŠ¶æ€ï¼Œå¦‚æœæ›´æ–°æˆåŠŸï¼Œå…¶ä»–èŠ‚ç‚¹å°±ä¸ä¼šæ›´æ–°æˆåŠŸã€‚å¦‚æœåœ¨æŸ¥è¯¢å¾…æ‰§è¡Œä»»åŠ¡åˆ—è¡¨
                         * å’Œå½“å‰è¿™æ®µæ—¶é—´æœ‰èŠ‚ç‚¹å·²ç»æ›´æ–°äº†è¿™ä¸ªä»»åŠ¡ï¼Œversionå¿…ç„¶å’ŒæŸ¥å‡ºæ¥æ—¶å€™çš„versionä¸ä¸€æ ·äº†,è¿™é‡Œæ›´æ–°
                         * å¿…ç„¶ä¼šè¿”å›0äº†
                         */
                        int n = taskRepository.updateWithVersion(task);
                        Date nextStartTime = task.getNextStartTime();
                        if(n == 0 || nextStartTime == null) {
                            continue;
                        }
                        /**
                         * å°è£…æˆå»¶æ—¶å¯¹è±¡æ”¾å…¥å»¶æ—¶é˜Ÿåˆ—
                         */
                        task = taskRepository.get(task.getId());
                        DelayItem&lt;Task&gt; delayItem = new DelayItem&lt;Task&gt;(nextStartTime.getTime() - new Date().getTime(), task);
                        taskQueue.offer(delayItem);
                        
                    }
                    Thread.sleep(config.getFetchPeriod());
                } catch(Exception e) {
                    logger.error("fetch task list failed,cause by:{}", e);
                }
            }
        }
        
    }
Copy<br>å¦‚ä¸Šå¯ä»¥é€šè¿‡å„ç§èŠ±å¼çš„è´Ÿè½½ç­–ç•¥æ¥å¹³è¡¡å„ä¸ªèŠ‚ç‚¹è·å–çš„ä»»åŠ¡ï¼ŒåŒæ—¶ä¹Ÿå¯ä»¥æ˜¾è‘—é™ä½å„ä¸ªèŠ‚ç‚¹å¯¹åŒä¸€ä¸ªä»»åŠ¡çš„ç«äº‰ã€‚ä½†æ˜¯è¿˜æœ‰ä¸ªé—®é¢˜ï¼Œå‡å¦‚æŸä¸ªèŠ‚ç‚¹æ‹¿åˆ°äº†ä»»åŠ¡æ›´æ–°æˆäº†æ‰§è¡Œä¸­ï¼Œæ‰§è¡Œåˆ°ä¸€åŠï¼Œæ²¡æ‰§è¡Œå®Œä¹Ÿæ²¡å‘ç”Ÿå¼‚å¸¸ï¼Œçªç„¶è¿™ä¸ªèŠ‚ç‚¹ç”±äºå„ç§åŸå› æŒ‚äº†ï¼Œé‚£ä¹ˆè¿™æ—¶å€™è¿™ä¸ªä»»åŠ¡æ°¸è¿œæ²¡æœ‰æœºä¼šå†æ‰§è¡Œäº†ã€‚è¿™å°±æ˜¯ä¼ è¯´ä¸­çš„å ç€èŒ…å‘ä¸æ‹‰å±ã€‚è§£å†³è¿™ä¸ªé—®é¢˜å¯ä»¥ç”¨æœ€ç»ˆä¸€è‡´ç³»ç»Ÿå¸¸è§çš„æ–¹æ³•ï¼Œå¼‚å¸¸æ¢å¤çº¿ç¨‹ã€‚åœ¨è¿™ç§åœºæ™¯ä¸‹åªéœ€è¦æ£€æµ‹ä¸€ä¸‹æŒ‡å®šå¿ƒè·³è¶…æ—¶æ—¶é—´ï¼ˆæ¯”å¦‚é»˜è®¤3ä¸ªå¿ƒè·³å‘¨æœŸï¼‰ä¸‹æ²¡æœ‰æ›´æ–°å¿ƒè·³æ—¶é—´çš„èŠ‚ç‚¹æ‰€å±çš„æœªå®Œæˆä»»åŠ¡ï¼Œå°†è¿™äº›ä»»åŠ¡çŠ¶æ€é‡æ–°æ¢å¤æˆå¾…æ‰§è¡Œï¼Œå¹¶ä¸”ä¸‹æ¬¡æ‰§è¡Œæ—¶é—´æ”¹æˆå½“å‰å°±å¯ä»¥äº†ã€‚æ ¸å¿ƒä»£ç å¦‚ä¸‹:<br>class Recover implements Runnable {
        @Override
        public void run() {
            for (;;) {
                try {
                    /**
                     * æŸ¥æ‰¾éœ€è¦æ¢å¤çš„ä»»åŠ¡,è¿™é‡Œç•Œå®šéœ€è¦æ¢å¤çš„ä»»åŠ¡æ˜¯ä»»åŠ¡è¿˜æ²¡å®Œæˆï¼Œå¹¶ä¸”æ‰€å±æ‰§è¡ŒèŠ‚ç‚¹è¶…è¿‡3ä¸ª
                     * å¿ƒè·³å‘¨æœŸæ²¡æœ‰æ›´æ–°å¿ƒè·³æ—¶é—´ã€‚ç”±äºè¿™äº›ä»»åŠ¡ç”±äºå½“æ—¶æ‰§è¡ŒèŠ‚ç‚¹æ²¡æœ‰æ¥å¾—åŠæ‰§è¡Œå®Œå°±æŒ‚äº†ï¼Œæ‰€ä»¥
                     * åªéœ€è¦æŠŠçŠ¶æ€å†æ”¹å›å¾…æ‰§è¡Œï¼Œå¹¶ä¸”ä¸‹æ¬¡æ‰§è¡Œæ—¶é—´æ”¹æˆå½“å‰æ—¶é—´ï¼Œè®©ä»»åŠ¡å†æ¬¡è¢«è°ƒåº¦ä¸€æ¬¡
                     */
                    List&lt;Task&gt; tasks = taskRepository.listRecoverTasks(config.getHeartBeatSeconds() * 3);
                    if(tasks == null || tasks.isEmpty()) {
                        return;
                    }
                   /**
                    * å…ˆè·å–å¯ç”¨çš„èŠ‚ç‚¹åˆ—è¡¨
                    */
                   List&lt;Node&gt; nodes = nodeRepository.getEnableNodes(config.getHeartBeatSeconds() * 2);
                   if(nodes == null || nodes.isEmpty()) {
                       return;
                   }
                   long maxNodeId = nodes.get(nodes.size() - 1).getNodeId();
                    for (Task task : tasks) {
                        /**
                         * æ¯ä¸ªèŠ‚ç‚¹æœ‰ä¸€ä¸ªæ¢å¤çº¿ç¨‹ï¼Œä¸ºäº†é¿å…ä¸å¿…è¦çš„ç«äº‰,ä»å¯ç”¨èŠ‚ç‚¹æ‰¾åˆ°ä¸€ä¸ªæœ€é è¿‘ä»»åŠ¡æ‰€å±èŠ‚ç‚¹çš„èŠ‚ç‚¹
                         */
                        long currNodeId = chooseNodeId(nodes,maxNodeId,task.getNodeId());
                        long myNodeId = config.getNodeId();
                        /**
                         * å¦‚æœä¸è¯¥å½“å‰èŠ‚ç‚¹å¤„ç†ç›´æ¥è·³è¿‡
                         */
                        if(currNodeId != myNodeId) {
                            continue;
                        }
                        /**
                         * ç›´æ¥å°†ä»»åŠ¡çŠ¶æ€æ”¹æˆå¾…æ‰§è¡Œï¼Œå¹¶ä¸”èŠ‚ç‚¹æ”¹æˆå½“å‰èŠ‚ç‚¹
                         */
                        task.setStatus(TaskStatus.PENDING);
                        task.setNextStartTime(new Date());
                        task.setNodeId(config.getNodeId());
                        taskRepository.updateWithVersion(task);
                    }
                    Thread.sleep(config.getRecoverSeconds() * 1000);
                } catch (Exception e) {
                    logger.error("Get next task failed,cause by:{}", e);
                }
            }
        }

    }
ã€€ã€€/**
     * é€‰æ‹©ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
     * @param nodes
     * @param maxNodeId
     * @param nodeId
     * @return
     */
    private long chooseNodeId(List&lt;Node&gt; nodes,long maxNodeId,long nodeId) {
        if(nodes.size() == 0 || nodeId &gt;= maxNodeId) {
            return nodes.get(0).getNodeId();
        }
        return nodes.stream().filter(node -&gt; node.getNodeId() &gt; nodeId).findFirst().get().getNodeId();
    }
Copy<br>å¦‚ä¸Šä¸ºäº†é¿å…æ¯ä¸ªèŠ‚ç‚¹çš„å¼‚å¸¸æ¢å¤çº¿ç¨‹å¯¹åŒä¸€ä¸ªä»»åŠ¡åšæ— è°“çš„ç«äº‰ï¼Œæ¯ä¸ªå¼‚å¸¸ä»»åŠ¡åªèƒ½è¢«ä»»åŠ¡æ‰€å±èŠ‚ç‚¹IDçš„ä¸‹ä¸€ä¸ªæ­£å¸¸èŠ‚ç‚¹å»æ¢å¤ã€‚è¿™æ ·å¤„ç†åå°±èƒ½ç¡®ä¿å°±ç®—å‡ºç°äº†ä¸Šé¢é‚£ç§ä»»åŠ¡æ²¡æ‰§è¡Œå®ŒèŠ‚ç‚¹æŒ‚äº†çš„æƒ…å†µï¼Œä¸€æ®µæ—¶é—´åä¹Ÿå¯ä»¥è‡ªåŠ¨æ¢å¤ã€‚æ€»çš„æ¥è¯´ä¸Šé¢é‚£äº›ä¸è€ƒè™‘ä¼˜åŒ–åº”è¯¥å¯ä»¥åšä¸ºä¸€ä¸ªè¿˜ä¸é”™çš„ä»»åŠ¡è°ƒåº¦æ¡†æ¶äº†ã€‚å¦‚æœä½ ä»¬ä»¥ä¸ºè¿™æ ·å°±å®Œäº†ï¼Œæˆ‘åªèƒ½è¯´æŠ±æ­‰äº†ï¼Œè¿˜æœ‰ï¼Œå“ˆå“ˆï¼å‰é¢æåˆ°æˆ‘æ˜¯å«Œå¼ƒå…¶å®ƒä»»åŠ¡è°ƒåº¦ç”¨èµ·æ¥éº»çƒ¦ï¼Œç‰¹åˆ«æ˜¯ä¹ æƒ¯ç”¨springçš„æ³¨è§£å†™è°ƒåº¦çš„ï¼Œé‚£äº›å¾ˆå¯èƒ½ä¸€ä¸ªç±»é‡Œå†™äº†nä¸ªå¸¦æœ‰@Scheduledæ³¨è§£çš„è°ƒåº¦æ–¹æ³•ï¼Œè¿™æ ·æ”¹é€ èµ·æ¥æ›´åŠ éº»çƒ¦ï¼Œæˆ‘æ˜¯å¸Œæœ›åšåˆ°å¦‚ä¸‹æ–¹å¼å°±å¯ä»¥ç›´æ¥æ•´åˆåˆ°åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦é‡Œï¼š<br>/**
 * æµ‹è¯•è°ƒåº¦åŠŸèƒ½
 * @author rongdi
 * @date 2019-03-17 16:54
 */
@Component
public class SchedulerTest {

    @Scheduled(cron = "0/10 * * * * ?")
    public void test1() throws InterruptedException {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        Thread.sleep(2000);
        System.out.println("å½“å‰æ—¶é—´1:"+sdf.format(new Date()));
    }
    
    @Scheduled(cron = "0/20 * * * * ?",parent = "test1")
    public void test2() throws InterruptedException {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        Thread.sleep(2000);
        System.out.println("å½“å‰æ—¶é—´2:"+sdf.format(new Date()));
    }

    @Scheduled(cron = "0/10 * * * * ?",parent = "test2")
    public void test3() throws InterruptedException {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        Thread.sleep(2000);
        System.out.println("å½“å‰æ—¶é—´3:"+sdf.format(new Date()));
    }

    @Scheduled(cron = "0/10 * * * * ?",parent = "test3")
    public void test4() throws InterruptedException {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        Thread.sleep(2000);
        System.out.println("å½“å‰æ—¶é—´4:"+sdf.format(new Date()));
    }

}
Copy<br>ä¸ºäº†è¾¾åˆ°ä¸Šè¿°ç›®æ ‡ï¼Œæˆ‘ä»¬è¿˜éœ€è¦åœ¨springå¯åŠ¨ååŠ è½½è‡ªå®šä¹‰çš„æ³¨è§£ï¼ˆåç§°å’Œspringçš„ä¸€æ ·ï¼‰ï¼Œä»£ç å¦‚ä¸‹:<br>/**
 * springå®¹å™¨å¯åŠ¨å®Œåï¼ŒåŠ è½½è‡ªå®šä¹‰æ³¨è§£
 * @author rongdi
 * @date 2019-03-15 21:07
 */
@Component
public class ContextRefreshedListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; {

    @Autowired
    private TaskExecutor taskExecutor;

    /**
     * ç”¨æ¥ä¿å­˜æ–¹æ³•å/ä»»åŠ¡åå’Œä»»åŠ¡æ’å…¥åæ•°æ®åº“çš„IDçš„æ˜ å°„,ç”¨æ¥å¤„ç†å­ä»»åŠ¡æ–°å¢ç”¨
     */
    private Map&lt;String,Long&gt; taskIdMap = new HashMap&lt;&gt;();

    @Override
    public void onApplicationEvent(ContextRefreshedEvent event) {
        /**
         * åˆ¤æ–­æ ¹å®¹å™¨ä¸ºSpringå®¹å™¨ï¼Œé˜²æ­¢å‡ºç°è°ƒç”¨ä¸¤æ¬¡çš„æƒ…å†µï¼ˆmvcåŠ è½½ä¹Ÿä¼šè§¦å‘ä¸€æ¬¡ï¼‰
          */
        if(event.getApplicationContext().getParent()==null){
            /**
             * åˆ¤æ–­è°ƒåº¦å¼€å…³æ˜¯å¦æ‰“å¼€
             * å¦‚æœæ‰“å¼€äº†ï¼šåŠ è½½è°ƒåº¦æ³¨è§£å¹¶å°†è°ƒåº¦æ·»åŠ åˆ°è°ƒåº¦ç®¡ç†ä¸­
             */
            ApplicationContext context = event.getApplicationContext();
            Map&lt;String,Object&gt; beans = context.getBeansWithAnnotation(org.springframework.scheduling.annotation.EnableScheduling.class);
            if(beans == null) {
                return;
            }
            /**
             * ç”¨æ¥å­˜æ”¾è¢«è°ƒåº¦æ³¨è§£ä¿®é¥°çš„æ–¹æ³•åå’ŒMethodçš„æ˜ å°„
             */
            Map&lt;String,Method&gt; methodMap = new HashMap&lt;&gt;();
            /**
             * æŸ¥æ‰¾æ‰€æœ‰ç›´æ¥æˆ–è€…é—´æ¥è¢«Componentæ³¨è§£ä¿®é¥°çš„ç±»ï¼Œå› ä¸ºä¸ç®¡Serviceï¼ŒControllerç­‰éƒ½åŒ…å«äº†Componentï¼Œä¹Ÿå°±æ˜¯
             * åªè¦æ˜¯è¢«çº³å…¥äº†springå®¹å™¨ç®¡ç†çš„ç±»å¿…ç„¶ç›´æ¥æˆ–è€…é—´æ¥çš„è¢«Componentä¿®é¥°
             */
            Map&lt;String,Object&gt; allBeans = context.getBeansWithAnnotation(org.springframework.stereotype.Component.class);
            Set&lt;Map.Entry&lt;String,Object&gt;&gt; entrys = allBeans.entrySet();
            /**
             * éå†beanå’Œé‡Œé¢çš„methodæ‰¾åˆ°è¢«Scheduledæ³¨è§£ä¿®é¥°çš„æ–¹æ³•,ç„¶åå°†ä»»åŠ¡æ”¾å…¥ä»»åŠ¡è°ƒåº¦é‡Œ
             */
            for(Map.Entry entry:entrys){
                Object obj = entry.getValue();
                Class clazz = obj.getClass();
                Method[] methods = clazz.getMethods();
                for(Method m:methods) {
                    if(m.isAnnotationPresent(Scheduled.class)) {
                        methodMap.put(clazz.getName() + Delimiters.DOT + m.getName(),m);
                    }
                }
            }
            /**
             * å¤„ç†Sheduledæ³¨è§£
             */
            handleSheduledAnn(methodMap);
            /**
             * ç”±äºtaskIdMapåªæ˜¯å¯åŠ¨springå®Œæˆåä½¿ç”¨ä¸€æ¬¡ï¼Œè¿™é‡Œå¯ä»¥ç›´æ¥æ¸…ç©º
             */
            taskIdMap.clear();
        }
    }

    /**
     * å¾ªç¯å¤„ç†æ–¹æ³•mapä¸­çš„æ‰€æœ‰Method
     * @param methodMap
     */
    private void handleSheduledAnn(Map&lt;String,Method&gt; methodMap) {
        if(methodMap == null || methodMap.isEmpty()) {
            return;
        }
        Set&lt;Map.Entry&lt;String,Method&gt;&gt; entrys = methodMap.entrySet();
        /**
         * éå†beanå’Œé‡Œé¢çš„methodæ‰¾åˆ°è¢«Scheduledæ³¨è§£ä¿®é¥°çš„æ–¹æ³•,ç„¶åå°†ä»»åŠ¡æ”¾å…¥ä»»åŠ¡è°ƒåº¦é‡Œ
         */
        for(Map.Entry&lt;String,Method&gt; entry:entrys){
            Method m = entry.getValue();
            try {
                handleSheduledAnn(methodMap,m);
            } catch (Exception e) {
                e.printStackTrace();
                continue;
            }
        }
    }

    /**
     * é€’å½’æ·»åŠ çˆ¶å­ä»»åŠ¡
     * @param methodMap
     * @param m
     * @throws Exception
     */
    private void handleSheduledAnn(Map&lt;String,Method&gt; methodMap,Method m) throws Exception {
        Class&lt;?&gt; clazz = m.getDeclaringClass();
        String name = m.getName();
        Scheduled sAnn = m.getAnnotation(Scheduled.class);
        String cron = sAnn.cron();
        String parent = sAnn.parent();
        /**
         * å¦‚æœparentä¸ºç©ºï¼Œè¯´æ˜è¯¥æ–¹æ³•ä»£è¡¨çš„ä»»åŠ¡æ˜¯æ ¹ä»»åŠ¡ï¼Œåˆ™æ·»åŠ åˆ°ä»»åŠ¡è°ƒåº¦å™¨ä¸­ï¼Œå¹¶ä¸”ä¿å­˜åœ¨å…¨å±€mapä¸­
         * å¦‚æœparentä¸ä¸ºç©ºï¼Œåˆ™è¡¨ç¤ºæ˜¯å­ä»»åŠ¡ï¼Œå­ä»»åŠ¡éœ€è¦çŸ¥é“çˆ¶ä»»åŠ¡çš„id
         * å…ˆæ ¹æ®parenté‡Œé¢ä»£è¡¨çš„æ–¹æ³•å…¨åæˆ–è€…æ–¹æ³•åï¼ˆçˆ¶ä»»åŠ¡æ–¹æ³•å’Œå­ä»»åŠ¡æ–¹æ³•åœ¨åŒä¸€ä¸ªç±»ç›´æ¥å¯ä»¥ç”¨æ–¹æ³•åï¼Œ
         * ä¸ç„¶è¦å¸¦ä¸Šç±»çš„å…¨åï¼‰ä»taskIdMapè·å–çˆ¶ä»»åŠ¡ID
         * å¦‚æœæ‰¾ä¸åˆ°çˆ¶ä»»åŠ¡IDï¼Œå…ˆæ ¹æ®çˆ¶æ–¹æ³•å…¨ååœ¨methodMapæ‰¾åˆ°çˆ¶ä»»åŠ¡çš„methodå¯¹è±¡ï¼Œè°ƒç”¨æœ¬æ–¹æ³•é€’å½’ä¸‹å»
         * å¦‚æœæ‰¾åˆ°çˆ¶ä»»åŠ¡IDï¼Œåˆ™æ·»åŠ å­ä»»åŠ¡
         */
        if(StringUtils.isEmpty(parent)) {
            if(!taskIdMap.containsKey(clazz.getName() + Delimiters.DOT + name)) {
                Long taskId = taskExecutor.addTask(name, cron, new Invocation(clazz, name, new Class[]{}, new Object[]{}));
                taskIdMap.put(clazz.getName() + Delimiters.DOT + name, taskId);
            }
        } else {
            String parentMethodName = parent.lastIndexOf(Delimiters.DOT) == -1 ? clazz.getName() + Delimiters.DOT + parent : parent;
            Long parentTaskId = taskIdMap.get(parentMethodName);
            if(parentTaskId == null) {
                Method parentMethod = methodMap.get(parentMethodName);
                handleSheduledAnn(methodMap,parentMethod);
                /**
                 * é€’å½’å›æ¥ä¸€å®šè¦æ›´æ–°ä¸€ä¸‹è¿™ä¸ªçˆ¶ä»»åŠ¡ID
                 */
                parentTaskId = taskIdMap.get(parentMethodName);
            }
            if(parentTaskId != null &amp;&amp; !taskIdMap.containsKey(clazz.getName() + Delimiters.DOT + name)) {
                Long taskId = taskExecutor.addChildTask(parentTaskId, name, cron, new Invocation(clazz, name, new Class[]{}, new Object[]{}));
                taskIdMap.put(clazz.getName() + Delimiters.DOT + name, taskId);
            }

        }


    }
}
Copy<br>ä¸Šè¿°ä»£ç å°±å®Œæˆäº†springåˆå§‹åŒ–å®ŒæˆååŠ è½½äº†è‡ªå·±çš„è‡ªå®šä¹‰ä»»åŠ¡è°ƒåº¦çš„æ³¨è§£ï¼Œå¹¶ä¸”ä¹Ÿå—springçš„è°ƒåº¦å¼€å…³@EnableSchedulingçš„æ§åˆ¶ï¼Œå®ç°æ— ç¼æ•´åˆåˆ°springæˆ–è€…springbootä¸­å»ï¼Œè¾¾åˆ°äº†æˆ‘è¿™ç§çš„æ‡’äººçš„è¦æ±‚ã€‚<br>å¥½äº†å…¶å®å†™è¿™ä¸ªæ¡†æ¶å·®ä¸å¤šå°±ç”¨äº†5å¤©ä¸šä½™æ—¶é—´ï¼Œä¼°è®¡ä¼šæœ‰ä¸€äº›éšè—çš„å‘ï¼Œä¸è¿‡æ˜æ˜¾çš„å‘æˆ‘è‡ªå·±éƒ½è§£å†³äº†ï¼Œå¼€æºå‡ºæ¥çš„ç›®çš„æ—¢æ˜¯ä¸ºäº†æŠ›ç –å¼•ç‰ï¼Œä¹Ÿä¸ºäº†å¹¿å¤§å±Œä¸ç¨‹åºå‘˜æä¾›ä¸€ç§æ–°çš„æ€è·¯ï¼Œå¸Œæœ›å¯¹å¤§å®¶æœ‰æ‰€å¸®åŠ©ï¼ŒåŒæ—¶ä¹Ÿå¸Œæœ›å¤§å®¶å¤šå¸®å¿™æ‰¾æ‰¾bugï¼Œä¸€èµ·æ¥å®Œå–„è¿™ä¸ªä¸œè¥¿,å¤§ç¥ä»¬è¯·å¿½ç•¥ã€‚æ–‡ç¬”ä¸å¥½ï¼Œä¸»è¦æ˜¯å¥½ä¹…æ²¡å†™ä½œæ–‡äº†ï¼Œè¯·å¤§å®¶å¤šå¤šæ‹…å¾…ã€‚è¯¦ç»†çš„æµæ°´è´¦å¼çš„æºç åŠ ä¸Šé•¿ç¯‡å¤§è®ºå¼çš„æ±‰è¯­æ³¨é‡Šå°½æƒ…æŸ¥çœ‹:<a rel="noopener" class="external-link" href="https://github.com/rongdi/easy-job" target="_blank">https://github.com/rongdi/easy-job</a>]]></description><link>https://muqiuhan.github.io/wiki/computer-science/distributed-system/åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦æ¡†æ¶/åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦æ¡†æ¶.html</link><guid isPermaLink="false">Computer Science/Distributed System/åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦æ¡†æ¶/åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦æ¡†æ¶.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Thu, 25 Jul 2024 09:27:09 GMT</pubDate><enclosure url="https://muqiuhan.github.io/wiki/computer-science/distributed-system/åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦æ¡†æ¶/pasted-image-20240507114701.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://muqiuhan.github.io/wiki/computer-science/distributed-system/åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦æ¡†æ¶/pasted-image-20240507114701.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Basic System Architecture]]></title><description><![CDATA[ 
 <br>In this article, weâ€™ll introduce some of the fundamental approaches to scaling a software system. The type of systems this series of articles is oriented towards are the Internet-facing systems we all utilize every day. Iâ€™ll let you name your favorite. These systems accept requests from users through Web and mobile interfaces, store and retrieve data based on user requests or events (e.g. a GPS-based system), and have some intelligent features such as providing recommendations or providing notifications based on previous user interactions.<br>Weâ€™ll start with a simple system design and show how it can be scaled. In the process, several concepts will be introduced that weâ€™ll cover in much more detail later in this series. Hence this article gives a broad overview of these concepts and how they aid in scalability â€” truly a whirlwind tour! If youâ€™ve missed Part 1 in this series, <a data-tooltip-position="top" aria-label="https://medium.com/swlh/building-scalable-distributed-systems-part-1-introduction-to-scalable-systems-9ca471fd77d7" rel="noopener" class="external-link" href="https://medium.com/swlh/building-scalable-distributed-systems-part-1-introduction-to-scalable-systems-9ca471fd77d7" target="_blank">here it is</a>!<br><br>Virtually all massive-scale systems start off small and grow due to their success. Itâ€™s common, and sensible, to start with a development framework such as Ruby on Rails or Django or equivalent that promotes rapid development to get a system quickly up and running. A typical, very simple software architecture for â€˜starterâ€™ systems that closely resembles what you get with rapid development frameworks is shown in Figure 1. This comprises a client tier, application service tier, and a database tier. If you use Rails or equivalent, you also get a framework that hardwires a Model-View-Controller (MVC) pattern for Web application processing and an Object-Relational Mapper (ORM) that generates SQL queries.<br>With this architecture, users submit requests to the application from their mobile app or Web browser across the Internet. The magic of Internet networking delivers these requests to the application service which is running on a machine hosted in some corporate or commercial cloud data center. Communications uses a standard network protocol, typically HTTP.<br>The application service runs code that supports an application programming interface (API) that clients use to format data and send HTTP requests to. Upon receipt of a request, the service executes the code associated with the requested API. In the process, it may read from or write to a database, depending on the semantics of the API. When the request is complete, the server sends the results to the client to display in their app or browser.<br><img alt="Basic system architecture" src="https://miro.medium.com/v2/resize:fit:584/1*MTjAf75AZDXNDLO7iWgsxQ.png" referrerpolicy="no-referrer"><br>Figure 1 Basic Multi-Tier Distributed Systems Architecture<br>Many systems conceptually look exactly like this. The application service code exploits an execution environment that enables multiple requests from multiple users to be processed simultaneously. Thereâ€™s a myriad of these application server technologies â€” JEE and Spring for Java, <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Flask_(web_framework)" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Flask_(web_framework)" target="_blank">Flask for Python</a> â€“ that are widely used in this scenario.<br>This approach leads to what is generally known as a monolithic architecture. Single, monolithic services grow in complexity as the application becomes more feature-rich. This eventually makes it hard to modify and test rapidly, and their execution footprint can become extremely heavyweight as all the API implementations run in the same application service.<br>Still, as long as request loads stay relatively low, this application architecture can suffice. The service has the capacity to process requests with consistently low latency. If request loads keep growing, this means eventually latencies will grow as the server has insufficient CPU/memory capacity for the concurrent request volume and hence requests will take longer to process. In these circumstances, our single server is overloaded and has become a bottleneck.<br>In this case, the first strategy for scaling is usually to â€˜scale upâ€™ the application service hardware. For example, if your application is running on AWS, you might upgrade your server from a modest t3.xlarge instance with 4 (virtual) CPUs and 16GBs of memory to a t3.2xlarge instance <a data-tooltip-position="top" aria-label="https://aws.amazon.com/ec2/instance-types/" rel="noopener" class="external-link" href="https://aws.amazon.com/ec2/instance-types/" target="_blank">which doubles the number of vCPUs and memory available for the application</a>.<br>Scale up is simple. It gets many real-world applications a long way to supporting larger workloads. It obviously just costs more money for hardware, but thatâ€™s scaling for you.<br>Itâ€™s inevitable however that for many applications the load will grow to a level that will swamp a single server node, no matter how many CPUs and how much memory you have. Thatâ€™s when you need a new strategy â€” namely scaling out, or horizontal scaling, that we touched on <a data-tooltip-position="top" aria-label="https://medium.com/swlh/building-scalable-distributed-systems-part-1-introduction-to-scalable-systems-9ca471fd77d7" rel="noopener" class="external-link" href="https://medium.com/swlh/building-scalable-distributed-systems-part-1-introduction-to-scalable-systems-9ca471fd77d7" target="_blank">in the first article in this series</a>.<br><br>Scaling out relies on the ability to replicate a service in the architecture and run multiple copies on multiple server nodes. Requests from clients are distributed across the replicas so that in theory, if we have N replicas, each server node processes {#requests/N} requests. This simple strategy increases an applicationâ€™s capacity and hence scalability.<br>To successfully scale out an application, we need two fundamental elements in our design. As illustrated in Figure 2, these are:<br>A Load balancer: All user requests are sent to a load balancer, which chooses a service replica to process the request. Various strategies exist for choosing a service, all with the core aim of keeping each processing resource equally busy. The load balancer also relays the responses from the service back to the client. Most load balancers belong to a class of Internet components known as <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Reverse_proxy" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Reverse_proxy" target="_blank">reverse proxies</a>, which control access to server resources for client requests. As an intermediary, reverse proxies add an extra network hop for a request, and hence need to be extremely low latency to minimize the overheads they introduce. There are many off-the-shelf load balancing solutions as well as cloud-provider specific ones, and weâ€™ll cover the general characteristics of these in much more detail in a later article.<br>Stateless services: For load balancing to be effective and share requests evenly, the load balancer must be free to send consecutive requests from the same client to different service instances for processing. This means the API implementations in the services must retain no knowledge, or state, associated with an individual clientâ€™s session. When a user accesses an application, a user session is created by the service, and a unique session identified is managed internally to identify the sequence of user interactions and track session state. A classic example of session state is a shopping cart. To use a load balancer effectively, the data representing the current contents of a userâ€™s cart must be stored somewhere â€” typically a data store â€” such that any service replica can access this state when it receives a request as part of a user session. In Figure 2 this is labeled as a Session Store.<br><img alt="Scaling out the service tier with a load balancer" src="https://miro.medium.com/v2/resize:fit:802/1*ZoDFOdsaG-hVdRegLsoR4w.png" referrerpolicy="no-referrer"><br>Figure 2 Scale out Architecture<br>Scale out is attractive as, in theory, you can keep adding new (virtual) hardware and services to handle increased user request loads and keep latencies consistent and low. As soon as you see latencies rising, you deploy another service instance. This requires no code changes and hence is relatively cheap â€” you just pay for the hardware you deploy.<br>Scale out has another highly attractive feature. If one of the services fails, the requests it is processing will be lost. But as the failed service manages no session state, these requests can be simply reissued by the client and sent to another service instance for processing. This means the application is resilient to failures in the application service software and hardware, thus enhancing the applicationâ€™s availability. Availability is a key feature of distributed systems and one we will discuss in-depth in a later article too.<br>Unfortunately, as with any engineering solution, simple scaling out has limits. As you add new service instances, the request processing capacity grows, potentially infinitely. At some stage, however, reality will bite and the capability of your single database to provide low latency query responses will diminish. Slow queries will mean longer response times for clients. If requests keep arriving faster than they are being processed, some system components will fail as resources will be exhausted and clients will see exceptions and request timeouts. Essentially your database has become a bottleneck that you must engineer away in order to scale your application further.<br><br>Scaling up by increasing the number of CPUs, memory and disks in a database server can go a long way to increasing a systemâ€™s capacity. For example, at the time of writing Google Cloud Platform can provision a SQL database on a db-n1-highmem-96 node, which has 96 vCPUs, 624GB of memory, 30TBs of disk and can support 4000 connections. This will cost somewhere between $6K and $16K per year, which sounds a good deal to me. Scaling up is a very common database scalability strategy.<br>Large databases need constant care and attention from highly skilled database administrators to keep them tuned and running fast. Thereâ€™s a lot of wizardry in this job â€” e.g. query tuning, disk partitioning, indexing, on-node caching â€” and hence database administrators are valuable people that you want to be very nice to. They can make your application services highly responsive indeed.<br>In conjunction with scale up, a highly effective approach is to query the database as infrequently as possible in your services. This can be achieved by employing distributed caching in the service tier. A cache stores recently retrieved and commonly accessed database results in memory so they can be quickly retrieved without placing a burden on the database. For data that is frequently read and changes rarely, your processing logic must be modified to first check a distributed cache, such as a <a data-tooltip-position="top" aria-label="https://redis.io/" rel="noopener" class="external-link" href="https://redis.io/" target="_blank">Redis</a> or <a data-tooltip-position="top" aria-label="https://memcached.org/" rel="noopener" class="external-link" href="https://memcached.org/" target="_blank">memcached</a> store. These cache technologies are essentially distributed Key-Value stores with very simple APIs. This scheme is illustrated in Figure 3. Note that the Session Store from Figure 2 has disappeared. This is because we can use a general-purpose distributed cache to store session identifiers along with application data.<br>Accessing the cache requires a remote call from your service, but if the data you need is in the cache, on a fast network this is far less expensive than querying the database instance. Introducing a caching layer also requires your processing logic to be modified to check for cached data. If what you want is not in the cache â€” a cache miss â€” your code must still query the database and load the results into the cache as well as return the results to the caller. You also need to decide when to remove or invalidate cached results â€” this depends on your applicationâ€™s tolerance to serving stale results to clients and the volume of data you cache.<br><img alt="Introducing a distributed cache" src="https://miro.medium.com/v2/resize:fit:762/1*7KFWeMMfq814m5pEnp21_Q.png" referrerpolicy="no-referrer"><br>Figure 3 Introducing Distributed Caching<br>A well-designed caching scheme can be absolutely invaluable in scaling a system. Caching works great for data that rarely changes and is accessed frequently, such as inventory, event and contact data. If you can handle a large percentage, like 80% or more, of read requests from your cache, then you effectively buy extra capacity at your databases as they are not involved in handling requests.<br>Still, many systems need to rapidly access many terabytes and larger data stores, which make a single database effectively prohibitive. In these systems, a distributed database is needed.<br><br>There are more distributed database technologies around in 2020 than you probably want to imagine. Itâ€™s a complex area, and one weâ€™ll cover extensively in another article. In very general terms, there are two major categories:<br>
<br>Distributed SQL stores from major vendors such as Oracle and IBM. These enable organizations to scale out their SQL database relatively seamlessly by storing the data across multiple disks that are queried by multiple database engine replicas. These multiple engines logically appear to the application as a single database, hence minimizing code changes.
<br>Distributed so-called NoSQL stores from a whole array of vendors. These products use a variety of data models and query languages. They distribute data across multiple nodes that run the database engine, each with their own locally attached storage. Again, the location of the data is transparent to the application and typically controlled by the design of the data model through hashing functions on database keys. Leading products in this category are Cassandra, MongoDB and Neo4j.<br>
<img alt="Figure 4 Scaling the Data Tier using a Distributed Database" src="https://miro.medium.com/v2/resize:fit:922/1*i34jGfA1SXllJoszNSz6Jw.png" referrerpolicy="no-referrer">
<br>Figure 4 Scaling the Data Tier using a Distributed Database<br>Figure 4 shows how our architecture incorporates a distributed database. As the data volumes grow, a distributed database has features to enable the number of storage nodes to be increased. As nodes are added (or removed), the data managed across all nodes is rebalanced to attempt to ensure the processing and storage capacity of each node is equally utilized.<br>Distributed databases also promote availability. They support replicating each data storage node so if one node fails or cannot be accessed due to network problems, another copy of the data is available. The models utilized for replication and the trade-offs these require (spoiler â€” consistency) are fodder for another article.<br>If you are utilizing a major cloud provider, there are also two deployment choices for your data tier. You can deploy your own virtual resources and build, configure, and administer your own distributed database servers. Alternatively, you can utilize cloud-hosted databases such as DynamoDB. The latter category simplifies the administrative effort associated with managing, monitoring, and scaling the database, as many of these tasks essentially become the responsibility of the cloud provider you choose. As usual, the no free lunch principle applies.<br><br>Any realistic system that we need to scale will have many different services that interact to process a request. For example, accessing a Web page on the Amazon.com site can require in excess of <a data-tooltip-position="top" aria-label="https://www.allthingsdistributed.com/2019/08/modern-applications-at-aws.html" rel="noopener" class="external-link" href="https://www.allthingsdistributed.com/2019/08/modern-applications-at-aws.html" target="_blank">100 different services being called</a> before an aggregate response is returned to the user.<br>The beauty of the stateless, load-balanced, cached architecture we are elaborating in this article is that we can extend the core design principles and build a multi-tiered, multi-service application. In fulfilling a request, a service can call one or more dependent services, which in turn are replicated and load-balanced. A simple example is shown in Figure 5. There are many nuances in how the services interact, and <a data-tooltip-position="top" aria-label="https://medium.com/@i.gorton/six-rules-of-thumb-for-scaling-software-architectures-a831960414f9" rel="noopener" class="external-link" href="https://medium.com/@i.gorton/six-rules-of-thumb-for-scaling-software-architectures-a831960414f9" target="_blank">how applications ensure rapid responses from dependent services</a>. Again, weâ€™ll cover these in detail in later articles.<br><img alt="Figure 5 Scaling the Processing Capacity across multiple tiers" src="https://miro.medium.com/v2/resize:fit:970/1*5QvIxJtIO5B_bxbyPtmqNg.png" referrerpolicy="no-referrer"><br>Figure 5 Scaling the Processing Capacity across multiple tiers<br>This design also promotes having different, load-balanced services at each tier in the architecture. For example, Figure 6 illustrates two replicated Internet-facing services that both utilized a core service providing database access. Each service is load balanced and employs caching to provide high performance and availability. This design is often used, for example, to provide a service for Web clients and a service for mobile clients, each of which can be scaled independently based on the load they experience. Its commonly called the <a data-tooltip-position="top" aria-label="https://samnewman.io/patterns/architectural/bff/" rel="noopener" class="external-link" href="https://samnewman.io/patterns/architectural/bff/" target="_blank">Backend For Frontend (BFF) pattern</a>.<br><img alt="Figure 6 Scalable Architecture with Multiple Services" src="https://miro.medium.com/v2/resize:fit:1114/1*wGBhGR8D9ZuWutOeYiMJvQ.png" referrerpolicy="no-referrer"><br>Figure 6 Scalable Architecture with Multiple Services<br>In addition, by breaking the application into multiple independent services, we can scale each based on the service demand. If for example, we see an increasing volume of requests from mobile users and decreasing volumes from Web users, we can provision different numbers of instances for each service to satisfy demand. This is a major advantage of refactoring monolithic applications into multiple independent services, which can be separately built, tested, deployed, and scaled.<br><br>Most client application requests expect a response. A user might want to see all auction items for a given product category or see the real estate that is available for sale in a given location. In these examples, the client sends a request and waits until a response is received. The time interval between sending the request and receiving the result is the latency of the request. We can decrease latencies by using caching and precalculated responses, but many requests will still result in database access.<br>A similar scenario exists for requests that update data in an application. If a user updates their delivery address immediately prior to placing an order, the new delivery address must be persisted so that the user can confirm the address before they hit the â€˜purchaseâ€™ button. This is known as â€˜read your own writesâ€™. The latency, in this case, includes the time for the database write, which is confirmed by the response the user receives.<br>Some update requests however can be successfully responded to without fully persisting the data in a database. For example, the skiers and snowboarders amongst you will be familiar with lift ticket scanning systems that check you have a valid pass to ride the lifts that day. They also record which lifts you take, the time you get on, and so on. Nerdy skier/snowboarders can then use the resortâ€™s mobile app to see how many lifts they ride in a day.<br>As a person waits to get on a lift, a scanner device validates the pass using an RFID chip reader. The information about the rider, lift, and time is then sent over the Internet to a data capture service operated by the ski resort. The lift rider doesnâ€™t have to wait for this update to occur, as the latency could slow down the lift loading process. Thereâ€™s also no expectation from the lift rider that they can instantly use their app to ensure this data has been captured. They just get on the lift, talk smack with their friends, and plan their next run.<br>Service implementations can exploit this type of scenario to reduce latencies and improve responsiveness. The data about the event is sent to the service, which acknowledges receipt and concurrently stores the data in a remote queue for subsequent writing to the database. Writing a message to a queue is much faster than writing to a database, and this enables the request to be successfully acknowledged much more quickly. Another backend service is deployed to read messages from the queue and write the data to the database. When the user checks their lift rides â€” maybe 3 hours or 3 days later â€” the data has been persisted successfully.<br>The basic architecture to implement this approach is illustrated in Figure 7.<br><img alt="Figure 7 Increasing Responsiveness with Queueing" src="https://miro.medium.com/v2/resize:fit:1054/1*Te6RjrHDEQ3scq_kVbpwEQ.png" referrerpolicy="no-referrer"><br>Figure 7 Increasing Responsiveness with Queuing<br>Whenever the results of a write operation are not immediately needed, an application can use this approach to improve responsiveness and hence scalability. Many queueing technologies exist that applications can utilize, and weâ€™ll discuss how these operate in later articles. These queueing platforms all provide asynchronous communications. A producer service writes to the queue, which acts as temporary storage, while another consumer service removes messages from the queue and makes the necessary updates to, in our example, a database that stores skier lift ride details.<br>The key is that the data eventually gets persisted. Eventually typically means a few seconds at most, but use cases that employ this design should be resilient to longer delays without impacting the user experience.<br><br>This chapter has provided a whirlwind tour of the major approaches we can utilize to scale out an Internet-facing system as a collection of communicating services and distributed databases. Much detail has been brushed over, and as you all no doubt know, in software systems the devil is in the detail.<br>Another area this chapter has skirted around is the subject of software architecture. Weâ€™ve used the term services for distributed components in an architecture that implement application business logic and database access. These services are independently deployed processes that communicate using remote communications mechanisms such as HTTP. In architectural terms, these services are most closely mirrored by those in the Service Oriented Architecture (SOA) pattern, an established architectural approach for building distributed systems. A more modern evolution of this approach revolves around microservices. These tend to be more cohesive, encapsulated services that promote continuous development and deployment.<br>If youâ€™d like a much more in-depth discussion of these, and software architecture issues in general, then Mark Richardsâ€™ and Neal Fordâ€™s book is an excellent place to start.<br>Mark Richards and Neal Ford, Fundamentals of Software Architecture: An Engineering Approach 1st Edition, Oâ€™Reilly Media, 2020<br>Finally, thereâ€™s a class of big data software architectures that address some of the issues that rise to the fore with very large data collections. One of the most prominent is data reprocessing. This occurs when raw data that has already been stored and analyzed needs to be re-analyzed due to code changes. This reprocessing may occur due to software fixes, or the introduction of new algorithms that can derive more insights from the original raw data. Thereâ€™s a good discussion of the Lambda and Kappa architectures, both of which are prominent in this space, in this article.<br>Jay Krepps, <a data-tooltip-position="top" aria-label="https://www.oreilly.com/radar/questioning-the-lambda-architecture/" rel="noopener" class="external-link" href="https://www.oreilly.com/radar/questioning-the-lambda-architecture/" target="_blank">Questioning the Lambda Architecture</a>,]]></description><link>https://muqiuhan.github.io/wiki/computer-science/distributed-system/building-scalable-distributed-systems-distributed-system-architecture-blueprint-a-whirlwind-tour.html</link><guid isPermaLink="false">Computer Science/Distributed System/Building Scalable Distributed Systems - Distributed System Architecture Blueprint - A Whirlwind Tour.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:28 GMT</pubDate><enclosure url="https://miro.medium.com/v2/resize:fit:584/1*MTjAf75AZDXNDLO7iWgsxQ.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://miro.medium.com/v2/resize:fit:584/1*MTjAf75AZDXNDLO7iWgsxQ.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[What is Scalability?]]></title><description><![CDATA[ 
 <br>The last 20 years have seen unprecedented growth in the size, complexity, and capacity of software systems. This rate of growth is hardly likely to slow down in the next 20 years â€” what these future systems will look like is close to unimaginable right now. The one thing we can guarantee is that more and more software systems will need to be built with constant growth â€” more requests, more data, more analysis â€” as a primary design driver.<br>Scalable is the term used in software engineering to describe software systems that can accommodate growth. In this first part of the series, we will explore what precisely is meant by the ability to scale â€” known, not surprisingly, as scalability. Weâ€™ll also describe a few examples that put hard numbers on the capabilities and characteristics of contemporary applications and give a brief history of the origins of the massive systems we routinely build today. Finally, we will describe two general principles for achieving scalability that will recur in various forms throughout the rest of this series of articles and examine the indelible link between scalability and cost.<br><br>Intuitively, scalability is a pretty straightforward concept. If we ask Wikipedia for a definition, it tells us â€œscalability is the property of a system to handle a growing amount of work by adding resources to the systemâ€. We all know how we scale a highway system â€” we add more traffic lanes so it can handle a greater number of vehicles. Some of my favorite people know how to scale beer production â€” they add more capacity in terms of the number and size of brewing vessels, the number of staff to perform and manage the brewing process, and the number of kegs they can fill with tasty fresh brews. Think of any physical system â€” a transit system, an airport, elevators in a building â€” and how we increase capacity is pretty obvious.<br>Unlike physical systems, software is somewhat amorphous. It is not something you can point at, see, touch, feel, and get a sense of how it behaves internally from external observation. Itâ€™s a digital artifact. At its core, the stream of 1â€™s and 0â€™s that make up executable code and data are hard for anyone to tell apart. So, what does scalability mean in terms of a software system?<br>Put very simply, and without getting into definition wars, scalability defines a software systemâ€™s capability to handle growth in some dimension of its operations. Examples of operational dimensions are:<br>
<br>the number of simultaneous user or external (e.g. sensor) requests a system can process
<br>the amount of data a system can effectively process and manage
<br>the value that can be derived from the data a system stores
<br>For example, imagine a major supermarket chain is rapidly opening new stores and increasing the number of self-checkout kiosks in every store. This requires the core supermarket software systems to:<br>
<br>Handle increased volume from item sale scanning without decreased response time. Instantaneous responses to item scans are necessary to keep customers happy.
<br>Process and store the greater data volumes generated from increased sales. This data is needed for inventory management, accounting, planning and likely many other functions.
<br>Derive â€˜real-timeâ€™ (e.g. hourly) sales data summaries from each store, region and country and compare to historical trends. This trend data can help highlight unusual events in regions (e.g. unexpected weather conditions, large crowds at events, etc.) and help the stores affected quickly respond.
<br>Evolve the stock ordering prediction subsystem to be able to correctly anticipate sales (and hence the need for stock reordering) as the number of stores and customers grow
<br>These dimensions are effectively the scalability requirements of a system. If over a year, the supermarket chain opens 100 new stores and grows sales by 400 times (some of the new stores are big), then the software system needs to scale to provide the necessary processing capacity to enable the supermarket to operate efficiently. If the systems donâ€™t scale, we could lose sales as customers are unhappy. We might hold stock that will not be sold quickly, increasing costs. We might miss opportunities to increase sales by responding to local circumstances with special offerings. All these reduce customer satisfaction and profits. None are good for business.<br>Successfully scaling is therefore crucial for our imaginary supermarketâ€™s business growth, and is in fact the lifeblood of many modern internet applications. But for most business and Government systems, scalability is not a primary quality requirement in the early stages of development and deployment. New features to enhance usability and utility become the drivers of our development cycles. As long as performance is adequate under normal loads, we keep adding user-facing features to enhance the systemâ€™s business value.<br>Still, itâ€™s not uncommon for systems to evolve into a state where enhanced performance and scalability become a matter of urgency or even survival. Attractive features and high utility breed success, which brings more requests to handle and more data to manage. This often heralds a tipping point, where design decisions that made sense under light loads are now suddenly technical debt. External trigger events often cause these tipping points â€” look in the March/April 2020 media at the many reports of Government Unemployment and supermarket online ordering sites crashing under demand caused by the coronavirus pandemic.<br>Increasing a systemsâ€™ capacity in some dimension by increasing resources is commonly called scaling up or scaling out â€” weâ€™ll explore the difference between these later in this series. In addition, unlike physical systems, it is often equally important to be able to scale down the capacity of a system to reduce costs. The canonical example of this is Netflix, which has a predictable regional diurnal load that it needs to process. Simply, a lot more people are watching Netflix in any geographical region at 9 pm than are at 5 am. This enables Netflix to reduce its processing resources during times of lower load. This saves the cost of running the processing nodes that are used in the Amazon cloud, as well as societally worthy things such as reducing data center power consumption. Compare this to a highway. At night when few cars are on the road, we donâ€™t retract lanes (except for repairs). The full road capacity is available for the few drivers to go as fast as they like.<br>Thereâ€™s a lot more to consider about scalability in software systems, but letâ€™s come back to these issues after examining the scale of some contemporary software systems circa 2020.<br><br>Looking ahead in this technology game is always fraught with danger. In 2008 I wrote [1]:<br>â€œWhile petabyte datasets and gigabit data streams are todayâ€™s frontiers for data-intensive applications, no doubt 10 years from now weâ€™ll fondly reminisce about problems of this scale and be worrying about the difficulties that looming exascale applications are posing.â€<br>Reasonable sentiments, it is true, but exascale? Thatâ€™s almost commonplace in todayâ€™s world. Google reported multiple exabytes of <a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=eNliOm9NtCM" rel="noopener" class="external-link" href="https://www.youtube.com/watch?v=eNliOm9NtCM" target="_blank">Gmail in 2014</a>, and by now, do all Google services manage a yottabyte or more? I donâ€™t know. Iâ€™m not even sure I know what a yottabyte is! Google wonâ€™t tell us about their storage, but I wouldnâ€™t bet against it. Similarly, how much data do Amazon store in the various AWS data stores for their clients. And how many requests does, say, DynamoDB process per second collectively, for all client applications supported. Think about these things for too long and your head will explode.<br>A great source of information that sometimes gives insights into contemporary operational scales are the major Internet companyâ€™s technical blogs. There are also Web sites analyzing Internet traffic that are highly illustrative of traffic volumes. Letâ€™s take a couple of â€˜point in timeâ€™ examples to illustrate a few things we do know today. Bear in mind these will look almost quaint in a year or four.<br>
<br>Facebookâ€™s engineering blog describes <a data-tooltip-position="top" aria-label="https://engineering.fb.com/data-infrastructure/scribe/" rel="noopener" class="external-link" href="https://engineering.fb.com/data-infrastructure/scribe/" target="_blank">Scribe</a>, their solution for collecting, aggregating, and delivering petabytes of log data per hour, with low latency and high throughput. Facebookâ€™s computing infrastructure comprises millions of machines, each of which generates log files that capture important events relating to system and application health. Processing these log files, for example, from a Web server, can give development teams insights into their applicationâ€™s behavior and performance, and support fault finding. Scribe is a custom buffered queuing solution that can transport logs from servers at a rate of several terabytes per second and deliver them to downstream analysis and data warehousing systems. That, my friends, is a lot of data!
<br>You can see live Internet traffic for numerous services at <a data-tooltip-position="top" aria-label="http://www.internetlivestats.com" rel="noopener" class="external-link" href="http://www.internetlivestats.com" target="_blank">www.internetlivestats.com</a>. Dig around and youâ€™ll find statistics like Google handles around 3.5 billion search requests a day, Instagram uploads about 65 million photos per day, and there is something like 1.7 billion web sites. It is a fun site with lots of information to amaze you. Note the data is not really â€˜liveâ€™, just estimates based on statistical analyses of multiple data sources.
<br>In 2016 Google published a paper describing the <a data-tooltip-position="top" aria-label="https://cacm.acm.org/magazines/2016/7/204032-why-google-stores-billions-of-lines-of-code-in-a-single-repository/fulltext" rel="noopener" class="external-link" href="https://cacm.acm.org/magazines/2016/7/204032-why-google-stores-billions-of-lines-of-code-in-a-single-repository/fulltext" target="_blank">characteristics of their code base</a>. Amongst the many startling facts reported is: â€œThe repository contains 86TBs of data, including approximately two billion lines of code in nine million unique source files.â€ Remember, this was 2016.
<br>Still, real, concrete data on the scale of the services provided by major Internet sites remain shrouded in commercial-in-confidence secrecy. Luckily, we can get some deep insights into the request and data volumes handled at Internet scale through the annual usage report from one tech company. You can browse their incredibly detailed <a data-tooltip-position="top" aria-label="https://www.pornhub.com/insights/2019-year-in-review" rel="noopener" class="external-link" href="https://www.pornhub.com/insights/2019-year-in-review" target="_blank">usage statistics here from 2019</a>. Itâ€™s a fascinating glimpse into the capabilities of massive scale systems. Beware though, this is Pornhub.com. The report is not for the squeamish. Hereâ€™s one PG-13 illustrative data point â€” they had 42 billion visits in 2019! Iâ€™ll let interested readers browse the data in the report to their heart's content. Some of the statistics will definitely make your eyes bulge!<br><br>I am sure many readers will have trouble believing there was civilized life without Internet search, YouTube, and social media. By coincidence, the day I type this sentence is the 15 year anniversary of the first video <a data-tooltip-position="top" aria-label="https://kogo.iheart.com/content/2020-04-23-youtube-celebrates-15th-anniversary-by-featuring-first-video-ever-posted/" rel="noopener" class="external-link" href="https://kogo.iheart.com/content/2020-04-23-youtube-celebrates-15th-anniversary-by-featuring-first-video-ever-posted/" target="_blank">being uploaded to YouTube</a>. Only 15 years. Yep, it is hard for even me to believe. Thereâ€™s been a lot of wine under the bridge since then. I canâ€™t remember how we survived!<br>So, letâ€™s take a brief look back in time at how we arrived at the scale of todayâ€™s systems. This is from a personal perspective â€” one which started at college in 1981 when my class of 60 had access to a shared lab of 8 state-of-the-art so-called <a data-tooltip-position="top" aria-label="http://pcmuseum.tripod.com/comphis4.html" rel="noopener" class="external-link" href="http://pcmuseum.tripod.com/comphis4.html" target="_blank"><em></em></a>microcomputers. By todayâ€™s standards, micro they were not.<br><br>An age dominated by mainframe and minicomputers. These were basically timeshared multiuser systems where users interacted with the machines via â€˜dumbâ€™ terminals. Personal computers emerged in the early 1980s and developed throughout the decade to become useful business and (relatively) powerful development machines. They were rarely networked, however, especially early in the decade. The <a data-tooltip-position="top" aria-label="https://www.internetsociety.org/internet/history-internet/brief-history-internet/" rel="noopener" class="external-link" href="https://www.internetsociety.org/internet/history-internet/brief-history-internet/" target="_blank">first limited incarnation of the Internet emerged during this time</a>. By the end of the 1980s, development labs, universities, and increasingly businesses had email and access to exotic internet-based resources such as <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Usenet" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Usenet" target="_blank">Usenet discussion forums</a> â€” think of a relatively primitive and incredibly polite Reddit.<br><br>Personal computers and networking technology, both LANs and WANS, continued to improve dramatically through this period. This created an environment ripe for the creation of the World Wide Web (WWW) as we know it today. The catalyst was the HTTP/HTML technology that had been <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/History_of_the_World_Wide_Web" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/History_of_the_World_Wide_Web" target="_blank">pioneered at CERN by Tim Berners-Lee</a> during the 1980s. In 1993 CERN made the WWW technology available on a royalty-free basis. And the rest is history â€” a platform for information sharing and money-making had been created. By 1995, the number of web sites was tiny, but the seeds of the future were planted with companies like Yahoo! in 1994 and Amazon and eBay in 1995<br><br>During this period, the number of web sites grew from <a data-tooltip-position="top" aria-label="https://www.nngroup.com/articles/100-million-websites/" rel="noopener" class="external-link" href="https://www.nngroup.com/articles/100-million-websites/" target="_blank">around 10,000 to 10 million</a>, a truly explosive growth period. Networking bandwidth and access also grew rapidly, with initially dial-up modems for home users (yep, dial-up) and then early broadband technologies becoming available.<br>This surge in users with Internet access heralded a profound change in how we had to think about building systems. Take for example a retail bank. Before providing online services, it was possible to accurately predict the loads the bankâ€™s business systems would experience. You knew how many people worked in the bank and used the internal systems, how many terminals/PCs were connected to the bankâ€™s networks, how many ATMs you had to support, and the number and nature of connections to other financial institutions. Armed with this knowledge, we could build systems that support say a maximum of 3000 concurrent users, safe in the knowledge that this number could not be exceeded. Growth would also be relatively slow, and probably most of the time (eg outside business hours) the load would be a lot less than the peak. This made our software design decisions and hardware provisioning a lot easier.<br>Now imagine our retail bank decides to let all customers have Internet banking access. And the bank has 5 million customers. What is our maximum load now? How will the load be dispersed during a business day? When are the peak periods? What happens if we run a limited-time promotion to try and sign up new customers? Suddenly our relatively simple and contained business systems environment is disrupted by the higher average and peak loads and unpredictability you see from Internet-based user populations.<br>During this period, companies like Amazon, eBay, Google, Yahoo! and the like were pioneering many of the design principles and early versions of advanced technologies for highly scalable systems. They had to, as their request loads and data volumes were growing exponentially.<br><br>The late 1990s and early 2000â€™s saw massive investments in, and technological innovations from so-called â€˜dot comâ€™ companies, all looking to provide innovative and valuable online businesses. Spending was huge, and not all investments were well-targeted. This led to a little event called the â€˜<a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Dot-com_bubble" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Dot-com_bubble" target="_blank">dot com crash</a>â€™ during 2000/2001. By 2002 the technology landscape was littered with failed investments â€” anyone remember Pets.Com? Nope. Me neither. About 50% of dot comâ€™s disappeared during this period. Of those that survived, albeit, with much lower valuations, many have become the staples we all know and use today.<br>The number of Web sites grew from around 10 to 80 million during this period, and new service and business models emerged. In 2005, YouTube was launched. 2006 saw Facebook become available to the public. In the same year, Amazon Web Services, which had low key beginnings in 2004, relaunched with its S3 and EC2 services. The modern era of Internet-scale computing and cloud-hosted systems was born.<br><br>We now live in a world with nearly 2 billion web sites, of which about 20% are active. There are something like <a data-tooltip-position="top" aria-label="https://www.internetworldstats.com/stats.htm" rel="noopener" class="external-link" href="https://www.internetworldstats.com/stats.htm" target="_blank">4 billion Internet users</a>. Huge data centers operated by public cloud operators like AWS, GCP and Azure, along with a myriad of private data centers, for example <a data-tooltip-position="top" aria-label="https://blog.twitter.com/engineering/en_us/topics/infrastructure/2017/the-infrastructure-behind-twitter-scale.html" rel="noopener" class="external-link" href="https://blog.twitter.com/engineering/en_us/topics/infrastructure/2017/the-infrastructure-behind-twitter-scale.html" target="_blank">Twitterâ€™s operational infrastructure</a>, are scattered around the planet. Clouds host millions of applications, with engineers provisioning and operating their computational and data storage systems using sophisticated cloud management portals. Powerful, feature-rich cloud services make it possible for us to build, deploy, and scale our systems literally with a few clicks of a mouse. All you must do is pay your cloud provider bill at the end of the month.<br>This is the world that this series of articles targets. A world where our applications need to exploit the key principles for building scalable systems and leverage highly scalable infrastructure platforms. Bear in mind, in modern applications, most of the code executed is not written by your organization. It is part of the containers, databases, messaging systems, and other components that you compose into your application through API calls and build directives. This makes the selection and use of these components at least as important as the design and development of your own business logic. They are architectural decisions that are not easy to change.<br><br>As we have already discussed, the basic aim of scaling a system is to increase its capacity in some application-specific dimension. A common dimension is increasing the number of requests that a system can process in a given time period. This is known as the systemâ€™s throughput. Letâ€™s use an analogy to explore two basic principles we have available to us for scaling our systems and increasing throughput.<br>In 1932, one of the worldâ€™s great icons, <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Sydney_Harbour_Bridge" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Sydney_Harbour_Bridge" target="_blank">the Sydney Harbor Bridge</a>, was opened. Now it is a fairly safe assumption that traffic volumes in 2020 are somewhat higher than in 1932. If you have driven over the bridge at peak hour in the last 30 years, then you know that its capacity is exceeded considerably every day. So how do we increase throughput on physical infrastructures such as bridges?<br>This issue became very prominent in Sydney in the 1980s, when it was realized that the capacity of the harbor crossing had to be increased. The solution was the rather less iconic <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Sydney_Harbour_Tunnel" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Sydney_Harbour_Tunnel" target="_blank">Sydney Harbor</a> tunnel, which essentially follows the same route underneath the harbor. This provides 4 more lanes of traffic and hence added roughly 1/3rd more capacity to harbor crossings.<br>In not too far away Auckland, their <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Auckland_Harbour_Bridge" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Auckland_Harbour_Bridge" target="_blank">harbor bridge</a> also had a capacity problem as it was built in 1959 with only 4 lanes. In essence, they adopted the same solution as Sydney, namely to increase capacity. But rather than build a tunnel, they ingeniously doubled the number of lanes by expanding the bridge with the hilariously named â€˜<a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Auckland_Harbour_Bridge#'Nippon_clip-ons'" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Auckland_Harbour_Bridge#'Nippon_clip-ons'" target="_blank">Nippon Cliponsâ€™</a>, which widened the bridge on each side. Ask a Kiwi to say â€˜Nippon Cliponsâ€™ and you will understand why this is funny.<br>These examples illustrate the first strategy we have in software systems to increase capacity. We basically replicate the software processing resources to provide more capacity to handle requests and thus increase throughput, as shown in Figure 1. These replicated processing resources are analogous to the laneways on bridges, providing a mostly independent processing pathway for a stream of arriving requests. Luckily, in cloud-based software systems, replication can be achieved at the click of a mouse, and we can effectively replicate our processing resources thousands of times. We have it a lot easier than bridge builders in that respect.<br><img alt="With one server we can process 100 requests per second. If we deploy 3 servers, we can process 300 requests per second." src="https://miro.medium.com/v2/resize:fit:1062/1*N1__-Yxk_qEcuFqzY8gyZg.png" referrerpolicy="no-referrer"><br>Figure 1 Increasing Capacity through Replication<br>The second strategy for scalability can also be illustrated with our bridge example. In Sydney, some observant people realized that in the mornings a lot more vehicles cross the bridge from north to south, and in the afternoon we see the reverse pattern. A smart solution was therefore devised â€” allocate more of the lanes to the high demand direction in the morning, and sometime in the afternoon, switch this around. This effectively increased the capacity of the bridge without allocating any new resources â€” we optimized the resources we already had available.<br>We can follow this same approach in software to scale our systems. If we can somehow optimize our processing, by maybe using more efficient algorithms, adding extra indexes in our databases to speed up queries, or even rewriting our server in a faster programming language, we can increase our capacity without increasing our resources. The canonical example of this is Facebookâ€™s creation of (the now discontinued) <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/HipHop_for_PHP" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/HipHop_for_PHP" target="_blank">HipHop for PHP</a>, which increased the speed of Facebookâ€™s web page generation by up to 6 times by compiling PHP code to C++. This enabled the site to process many more requests with the same resources.<br>Weâ€™ll revisit these two design principles â€” namely replication and optimization â€” many times in the remainder of this series. You will see that there are many complex implications of adopting these principles that arise from the fact that we are building distributed systems. Distributed systems have properties that make designing scalable systems â€˜interestingâ€™, where interesting in this context has both positive and negative connotations.<br><br>Letâ€™s take a trivial hypothetical example to examine the relationship between scalability and costs. Assume we have a Web-based (e.g. web server and database) system that can service a load of 100 concurrent requests with a mean response time of 1 second. We get a business requirement to scale up this system to handle 1000 concurrent requests with the same response time. Without making any changes, a simple load test of this system reveals the performance shown in Figure 2 (left). As the request load increases, we see the mean response time steadily grow to 10 seconds with the projected load. Clearly this is not scalable and cannot satisfy our requirements in its current deployment configuration.<br><img alt="On the left, response times grow rapidly. One the right, response times stay flat as load increases." src="https://miro.medium.com/v2/resize:fit:1400/1*JKhgncDUTSwPe0lw5iIZGA.png" referrerpolicy="no-referrer"><br>Figure 2 Scaling an application. (Left) â€” non-scalable performance. (Right) â€” scalable performance<br>Clearly some engineering effort is needed in order to achieve the required performance. Figure 2 (right) shows the systemâ€™s performance after it has been modified. It now provides the specified response time with 1000 concurrent requests. Hence, we have successfully scaled the system. Party time!<br>A major question looms, however. Namely, how much effort and resources were required to achieve this performance? Perhaps it was simply a case of scaling up by running the Web server on a more powerful (virtual) machine. Performing such reprovisioning on a cloud might take 30 minutes at most. Slightly more complex would be reconfiguring the system to scale out and run multiple instances of the Web server to increase capacity. Again, this should be a simple, low-cost configuration change for the application, with no code changes needed. These would be excellent outcomes.<br>However, scaling a system isnâ€™t always so easy. The reasons for this are many and varied, but here are some possibilities:<br>
<br>the database becomes less responsive with 1000 requests per second, requiring an upgrade to a new machine
<br>the Web server generates a lot of content dynamically and this reduces response time under load. A possible solution is to alter the code to more efficiently generate the content, thus reducing processing time per request.
<br>the request load creates hot spots in the database when many requests try to access and update the same records simultaneously. This requires a schema redesign and subsequent reloading of the database, as well as code changes to the data access layer.
<br>the Web server framework that was selected emphasized ease of development over scalability. The model it enforces means that the code simply cannot be scaled to meet the request load requirements, and a complete rewrite is required. Another framework? Another programming language even?
<br>Thereâ€™s a myriad of other potential causes, but hopefully, these illustrate the increasing effort that might be required as we move from possibility (1) to possibility (4).<br>Now letâ€™s assume option (1), upgrading the database server, requires 15 hours of effort and a thousand dollars extra cloud costs per month for a more powerful server. This is not prohibitively expensive. And letâ€™s assume option (4), a rewrite of the Web application layer, requires 10,000 hours of development due to implementing in a new language (e.g. Java instead of Ruby). Options (2) and (3) fall somewhere in between options (1) and (4). The cost of 10,000 hours of development is seriously significant. Even worse, while the development is underway, the application may be losing market share and hence money due to its inability to satisfy client requests loads. These kinds of situations can cause systems and businesses to fail.<br>This simple scenario illustrates how resource and effort costs are inextricably tied to scalability. If a system is not designed intrinsically to scale, then the downstream costs and resources of increasing its capacity to meet requirements may be massive. For some applications, such as <a data-tooltip-position="top" aria-label="https://www.bloomberg.com/news/articles/2014-09-24/obamacare-website-costs-exceed-2-billion-study-finds" rel="noopener" class="external-link" href="https://www.bloomberg.com/news/articles/2014-09-24/obamacare-website-costs-exceed-2-billion-study-finds" target="_blank">Healthcare.gov</a>, these (more than $2 billion) costs are borne and the system is modified to eventually meet business needs. For others, such as Oregonâ€™s health care exchange, an inability to scale rapidly at low cost can be an expensive ($303million) death knell.<br>We would never expect someone would attempt to scale up the capacity of a family home to become a 50-floor office building. The home doesnâ€™t have the architecture, materials, and foundations for this to be even a remote possibility without being completely demolished and rebuilt. Similarly, we shouldnâ€™t expect software systems that do not employ scalable architectures, mechanisms and technologies to be quickly evolved to meet greater capacity needs. The foundations of scale need to be built in from the beginning, with the recognition that the components will evolve over time. By employing design and development principles that promote scalability, we can more rapidly and cheaply scale systems to meet rapidly growing demands.<br>Software systems that can be scaled exponentially while costs grow linearly are known as hyperscale systems, defined as:<br>â€œHyperscale systems exhibit exponential growth in computational and storage capabilities while exhibiting linear growth rates in the costs of resources required to build, operate, support, and evolve the required software and hardware resources.â€<br>You can read more about hyperscale systems <a data-tooltip-position="top" aria-label="https://www.researchgate.net/publication/318049054_Chapter_2_Hyperscalability_-_The_Changing_Face_of_Software_Architecture" rel="noopener" class="external-link" href="https://www.researchgate.net/publication/318049054_Chapter_2_Hyperscalability_-_The_Changing_Face_of_Software_Architecture" target="_blank">in this article</a>[3].<br><br>The ability to scale an application quickly and cost-effectively should be a defining quality of the software architecture of contemporary Internet-facing applications. We have two basic ways to achieve scalability, namely increasing system capacity, typically through replication, and performance optimization of system components. The rest of this series of articles will delve deeply into how these two basic principles manifest themselves in constructing scalable distributed systems. Get ready for a wild ride.<br><br>
<br>
Ian Gorton, Paul Greenfield, Alex Szalay, and Roy Williams. 2008. Data-Intensive Computing in the 21st Century. Computer 41, 4 (April 2008), 30â€“32.

<br>
Rachel Potvin and Josh Levenberg. 2016. Why Google stores billions of lines of code in a single repository. Commun. ACM 59, 7 (July 2016), 78â€“87.

<br>
Ian Gorton (2017). Chapter 2. Hyperscalability â€” The Changing Face of Software Architecture. 10.1016/B978â€“0â€“12â€“805467â€“3.00002â€“8.

]]></description><link>https://muqiuhan.github.io/wiki/computer-science/distributed-system/building-scalable-distributed-systems-introduction-to-scalable-systems.html</link><guid isPermaLink="false">Computer Science/Distributed System/Building Scalable Distributed Systems - Introduction to Scalable Systems.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:28 GMT</pubDate><enclosure url="https://miro.medium.com/v2/resize:fit:1062/1*N1__-Yxk_qEcuFqzY8gyZg.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://miro.medium.com/v2/resize:fit:1062/1*N1__-Yxk_qEcuFqzY8gyZg.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[æˆ‘ä¸ºä»€ä¹ˆè®¤ä¸º Actor ä¸åˆé€‚ CPU å¯†é›†ä»»åŠ¡]]></title><description><![CDATA[ 
 <br>ä»é¢å‘å¯¹è±¡æ¥è¯´ï¼Œé¢å‘å¯¹è±¡ä¸­ï¼Œå°†ä¸–é—´ä¸‡ç‰©çœ‹ä½œä¸€ä¸ªä¸ªå¯¹è±¡ï¼Œä»ç›¸åŒå¯¹è±¡ä¸­æ€»ç»“ï¼ˆæŠ½è±¡ï¼‰å‡ºä¸€ä¸ªä¸ªç±»ï¼Œæ¯”å¦‚äººç±»ï¼ŒçŒ«ç±»ç­‰ç­‰ï¼Œä½†æ˜¯é¢å‘å¯¹è±¡ç†è®ºåœ¨è½å®çš„ç¼–ç¨‹è¯­è¨€ä¸­æ—¶ï¼Œæ²¡æœ‰è€ƒè™‘åˆ°ä¸–ç•Œçº¿é—®é¢˜ï¼Œå³ä¸–ç•Œçš„æ—¶é—´æµè½¬é—®é¢˜ï¼Œä¸¾ä¸ªä¾‹å­ï¼š<br>è¯¾å ‚ä¸Šï¼Œè€å¸ˆåœ¨è®²å°ä¸Šè®²è¯¾ï¼ˆ teacher å¯¹è±¡çš„ speak æ–¹æ³•æ­£åœ¨æ‰§è¡Œä¸­ï¼‰ï¼Œä¸‹è¾¹çš„å­¦ç”Ÿåœ¨è¯´è¯ï¼ˆstudent å¯¹è±¡çš„ speak ä¹Ÿåœ¨æ‰§è¡Œï¼‰ã€‚ä»ç°å®ç”Ÿæ´»ä¸­çœ‹ï¼Œè¿™ä¸ªæ˜¯è‡ªç„¶è€Œç„¶çš„ï¼Œä½†æ˜¯ï¼Œåœ¨è®¡ç®—æœºä¸–ç•Œï¼Œ è®²è¯¾å’Œè¯´è¯æ“ä½œéƒ½éœ€è¦åœ¨thread ä¸­æ‰èƒ½æ‰§è¡Œã€‚æ‰€ä»¥ï¼Œobject å’Œ thread å°±æœ‰åŒ¹é…é—®é¢˜äº†ï¼Œç†è®ºä¸Šï¼Œä½ åº”è¯¥ä¸ºæ¯ä¸€ä¸ª object éƒ½åŒ¹é…ä¸€ä¸ª thread, æ¯•ç«Ÿç°å®ä¸­å°±æ˜¯è¿™æ ·ï¼Œè€å¸ˆå’Œå­¦ç”Ÿéƒ½æœ‰å„è‡ªçš„ thread,å¯ä»¥åŒæ—¶æ‰§è¡Œæ“ä½œã€‚ä½†æ˜¯è®¡ç®—æœºä¸–ç•Œä¸­çš„é—®é¢˜å°±æ˜¯ä¸å¯èƒ½ä¸ºæ¯ä¸€ä¸ª object èµ·ä¸€ä¸ª threadã€‚æ‰€ä»¥é¢å‘å¯¹è±¡ç¼–ç¨‹è¯­è¨€åœ¨è®¡ç®—æœºä¸­å®ç°æ—¶ï¼Œçº¿ç¨‹é—®é¢˜åšçš„å°±ä¼šæ¯”è¾ƒå¥‡æ€ªäº†ã€‚<br>è€Œ Actor  model å®é™…ä¸Šæ˜¯å±è”½äº† thread æ¦‚å¿µçš„ï¼ˆä¸æ¥è§¦thread,ä¹Ÿä¸éœ€è¦ç†è§£threadæ¦‚å¿µï¼‰ã€‚ Actor  model ä¸­å‡è®¾æ‰€æœ‰çš„ Actor ä¹‹é—´çš„è¿è¡Œæ˜¯å¹¶è¡Œçš„ï¼Œå°±å’Œç°å®ä¸–ç•Œä¸€æ ·çš„ã€‚è€å¸ˆ Actor å’Œå­¦ç”Ÿçš„ Actor çš„è¿è¡Œåº•å±‚æ˜¯ä¸ç›¸å…³çš„ï¼Œç›¸å…³çš„æ˜¯è€å¸ˆåœ¨ speakï¼ˆç›¸å½“äºç¾¤å‘æ¶ˆæ¯ï¼‰ï¼Œå­¦ç”Ÿä¹Ÿåœ¨ speakï¼ˆå•å‘ç»™åŒæ¡Œæˆ–è€…ç»™ååº§çš„äººï¼‰ï¼Œè€å¸ˆå¬åˆ°æœ‰äººåœ¨è¯´è¯ï¼ˆæ¥æ”¶ä¸€ä¸ªæ¶ˆæ¯ï¼‰ï¼Œç„¶åè€å¸ˆæ‹¿ç²‰ç¬”æ‰“äº†è¯´è¯çš„å­¦ç”Ÿï¼ˆå•å‘ä¸€ä¸ªç²‰ç¬”å¤´ç»™é‚£ä¸ªå­¦ç”Ÿï¼‰ã€‚<br>ç”±æ­¤å¯è§ï¼Œ Actor æ˜¯æ¯”é¢å‘å¯¹è±¡æ›´æ¥è¿‘ç°å®çš„æ¨¡å‹ã€‚<br>ä»ä¸Šä¸€ä¸ªé—®é¢˜æ¥çœ‹ï¼Œ Actor æ¨¡å‹æ¯”ooæ›´æ¥è¿‘ç°å®ä¸–ç•Œï¼Œä½†æ˜¯ï¼Œè½å®åœ¨è®¡ç®—æœºä¸­æ—¶ï¼Œå°±æ¶‰åŠåˆ°ï¼Œ Actor æ€ä¹ˆæ‰§è¡Œçš„é—®é¢˜ã€‚å› ä¸ºè®¡ç®—æœºä¸­æ²¡æœ‰é‚£ä¹ˆå¤šçš„thread, æ‰€ä»¥ Actor åœ¨å®ç°æ—¶ï¼Œå¿…ç„¶æ˜¯é€šè¿‡å°‘é‡çš„ thread æ¥æ‰§è¡Œå¤§é‡çš„ Actor å®ä½“ã€‚ å³åœ¨ä¸€ä¸ª thread ä¸­åˆ†æ—¶æ‰§è¡Œå¤šä¸ª Actor ã€‚å½“ç„¶ï¼Œè¿™æ˜¯å¼€å‘ Actor æ¨¡å‹çš„äººéœ€è¦å…³æ³¨çš„é—®é¢˜ï¼Œç”¨ Actor æ¨¡å‹çš„äººå¯ä»¥ä¸å…³æ³¨ã€‚<br>æ‰€ä»¥ï¼Œè¿™é‡Œå°±å¼•å‡ºäº†è¿™ä¸ªé—®é¢˜ï¼šå¦‚æœåœ¨ Actor ä¸­æ‰§è¡Œ CPU å¯†é›†ä»»åŠ¡ä¼šæ€ä¹ˆæ ·ï¼Ÿ<br>ç»“è®ºå°±æ˜¯ï¼ŒCPU å¯†é›†ä»»åŠ¡æŠŠ Actor çš„åº•å±‚æ‰§è¡Œæœºåˆ¶ç»™æ‹–å®äº†ï¼Œthread åœ¨æ‰§è¡Œä¸€ä¸ª Actor æ—¶ï¼Œå› è€—æ—¶å¤ªé•¿ï¼Œå¹¶å ç”¨å¤§é‡ CPU èµ„æºï¼Œå¯¼è‡´å…¶ä»– Actor æ— æ³•æ‰§è¡Œã€‚ Actor çš„æ‰§è¡Œæœºåˆ¶å‡ºç°æ–­æ¡£ï¼Œ Actor ä¸–ç•Œå‡ºç° stop the worldã€‚STW é—®é¢˜å¯¹äº Actor æœ¬èº«ä¸ä¼šæœ‰å•¥å½±å“ï¼Œåæ­£ä¸–ç•Œéƒ½åœäº†ï¼Œæ— éå°±æ˜¯å¤šç­‰ä¸€ä¼šå„¿ã€‚ä½†æ˜¯å¯¹äºæˆ‘ä»¬è¿™ä¸ªä¸Šå¸æ¥è¯´ï¼Œè¿™ä¸ª Actor ä¸–ç•Œå·²ç»ä¸èƒ½æµç•…è¿è¡Œäº†ã€‚<br>æ‰€ä»¥ï¼Œä¸ç®¡æ˜¯ go, è¿˜æ˜¯ akka,æˆ–è€… vert.xï¼Œéƒ½ä¼šæé†’ä½ ï¼Œä¸è¦åœ¨ Actor æˆ–ç±» Actor å®ä¾‹ä¸­æ‰§è¡Œ block å¤ªé•¿çš„ä»»åŠ¡ã€‚<br>æ‰€ä»¥ï¼Œæ€ä¹ˆè§£å†³è¿™ä¸ªé—®é¢˜å‘¢ï¼Ÿ<br>
ç­”æ¡ˆæ˜¯ï¼šä½¿ç”¨å¼‚æ­¥ã€‚<br>
å¼‚æ­¥æ“ä½œå°±å¯ä»¥æŠŠä¸€ä¸ª block å˜æˆä¸ block çš„ä»»åŠ¡ï¼Œä»è€Œåœ¨ Actor ä¸–ç•Œä¸­å®ç°ç›®æ ‡ã€‚<br>æœ€åï¼Œå†è€ƒè™‘ä¸€ä¸‹ç”¨ Actor æ¨¡å‹æ¥æ‰§è¡Œ CPU å¯†é›†ä»»åŠ¡çš„é—®é¢˜ã€‚<br>å¦‚æœåœ¨ Actor ä¸­æ‰§è¡Œä¸€ä¸ª CPU å¯†é›†ä»»åŠ¡ï¼Œé¦–å…ˆä¼šå¯¼è‡´å…¶ä»– Actor çš„æ‰§è¡Œè¢«æ¨è¿Ÿï¼Œå…¶æ¬¡ï¼Œç³»ç»Ÿæœ¬èº«çš„ Actor ï¼ˆæ¯”å¦‚ log, monitor ç­‰ï¼‰ä¹Ÿä¼šæ¨è¿Ÿã€‚å¦‚æœèƒ½æ¥å—è¿™ä¸ªå½±å“ï¼Œé‚£ä¹ˆç”¨ Actor æ¥æ‰§è¡Œ CPU å¯†é›†ä»»åŠ¡ä¹Ÿæ²¡æœ‰é—®é¢˜ã€‚<br>å¦ä¸€ç§æ–¹æ¡ˆæ˜¯ï¼ŒæŠŠCPUå¯†é›† Actor æ”¾åˆ°å•ç‹¬çš„ executor ä¸­ï¼Œä¸å…¶ä»– Actor åˆ†ç¦»ï¼Œå……åˆ†åˆ©ç”¨å¤šçº¿ç¨‹ç‰¹æ€§]]></description><link>https://muqiuhan.github.io/wiki/computer-science/distributed-system/æˆ‘ä¸ºä»€ä¹ˆè®¤ä¸º-actor-ä¸åˆé€‚-cpu-å¯†é›†ä»»åŠ¡.html</link><guid isPermaLink="false">Computer Science/Distributed System/æˆ‘ä¸ºä»€ä¹ˆè®¤ä¸º Actor ä¸åˆé€‚ CPU å¯†é›†ä»»åŠ¡.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Tue, 14 May 2024 14:56:37 GMT</pubDate></item><item><title><![CDATA[Linuxä¸­çš„ç¡¬è¿æ¥å’Œè½¯è¿æ¥]]></title><description><![CDATA[ 
 <br>Linuxé“¾æ¥åˆ†ä¸¤ç§ï¼Œä¸€ç§è¢«ç§°ä¸ºç¡¬é“¾æ¥ï¼ˆHard Linkï¼‰ï¼Œå¦ä¸€ç§è¢«ç§°ä¸ºç¬¦å·é“¾æ¥ï¼ˆSymbolic Linkï¼‰ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œlnå‘½ä»¤äº§ç”Ÿç¡¬é“¾æ¥ã€‚<br><br>ç¡¬è¿æ¥æŒ‡é€šè¿‡ç´¢å¼•èŠ‚ç‚¹æ¥è¿›è¡Œè¿æ¥ã€‚åœ¨Linuxçš„æ–‡ä»¶ç³»ç»Ÿä¸­ï¼Œä¿å­˜åœ¨ç£ç›˜åˆ†åŒºä¸­çš„æ–‡ä»¶ä¸ç®¡æ˜¯ä»€ä¹ˆç±»å‹éƒ½ç»™å®ƒåˆ†é…ä¸€ä¸ªç¼–å·ï¼Œç§°ä¸ºç´¢å¼•èŠ‚ç‚¹å·(Inode Index)ã€‚åœ¨Linuxä¸­ï¼Œå¤šä¸ªæ–‡ä»¶åæŒ‡å‘åŒä¸€ç´¢å¼•èŠ‚ç‚¹æ˜¯å­˜åœ¨çš„ã€‚ä¸€èˆ¬è¿™ç§è¿æ¥å°±æ˜¯ç¡¬è¿æ¥ã€‚ç¡¬è¿æ¥çš„ä½œç”¨æ˜¯å…è®¸ä¸€ä¸ªæ–‡ä»¶æ‹¥æœ‰å¤šä¸ªæœ‰æ•ˆè·¯å¾„åï¼Œè¿™æ ·ç”¨æˆ·å°±å¯ä»¥å»ºç«‹ç¡¬è¿æ¥åˆ°é‡è¦æ–‡ä»¶ï¼Œä»¥é˜²æ­¢â€œè¯¯åˆ â€çš„åŠŸèƒ½ã€‚å…¶åŸå› å¦‚ä¸Šæ‰€è¿°ï¼Œå› ä¸ºå¯¹åº”è¯¥ç›®å½•çš„ç´¢å¼•èŠ‚ç‚¹æœ‰ä¸€ä¸ªä»¥ä¸Šçš„è¿æ¥ã€‚åªåˆ é™¤ä¸€ä¸ªè¿æ¥å¹¶ä¸å½±å“ç´¢å¼•èŠ‚ç‚¹æœ¬èº«å’Œå…¶å®ƒçš„è¿æ¥ï¼Œåªæœ‰å½“æœ€åä¸€ä¸ªè¿æ¥è¢«åˆ é™¤åï¼Œæ–‡ä»¶çš„æ•°æ®å—åŠç›®å½•çš„è¿æ¥æ‰ä¼šè¢«é‡Šæ”¾ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæ–‡ä»¶çœŸæ­£åˆ é™¤çš„æ¡ä»¶æ˜¯ä¸ä¹‹ç›¸å…³çš„æ‰€æœ‰ç¡¬è¿æ¥æ–‡ä»¶å‡è¢«åˆ é™¤ã€‚<br><br>å¦å¤–ä¸€ç§è¿æ¥ç§°ä¹‹ä¸ºç¬¦å·è¿æ¥ï¼ˆSymbolic Linkï¼‰ï¼Œä¹Ÿå«è½¯è¿æ¥ã€‚è½¯é“¾æ¥æ–‡ä»¶æœ‰ç±»ä¼¼äºWindowsçš„å¿«æ·æ–¹å¼ã€‚å®ƒå®é™…ä¸Šæ˜¯ä¸€ä¸ªç‰¹æ®Šçš„æ–‡ä»¶ã€‚åœ¨ç¬¦å·è¿æ¥ä¸­ï¼Œæ–‡ä»¶å®é™…ä¸Šæ˜¯ä¸€ä¸ªæ–‡æœ¬æ–‡ä»¶ï¼Œå…¶ä¸­åŒ…å«çš„æœ‰å¦ä¸€æ–‡ä»¶çš„ä½ç½®ä¿¡æ¯ã€‚<br>2. é€šè¿‡å®éªŒåŠ æ·±ç†è§£<br>[root@Linux]$ touch f1 #åˆ›å»ºä¸€ä¸ªæµ‹è¯•æ–‡ä»¶f1
[root@Linux]$ ln f1 f2 #åˆ›å»ºf1çš„ä¸€ä¸ªç¡¬è¿æ¥æ–‡ä»¶f2
[root@Linux]$ ln -s f1 f3 #åˆ›å»ºf1çš„ä¸€ä¸ªç¬¦å·è¿æ¥æ–‡ä»¶f3
[root@Linux]$ ls -li # -iå‚æ•°æ˜¾ç¤ºæ–‡ä»¶çš„inodeèŠ‚ç‚¹ä¿¡æ¯
total 0
9797648 -rw-r--r-- 2 root root 0 Apr 21 08:11 f1
9797648 -rw-r--r-- 2 root root 0 Apr 21 08:11 f2
9797649 lrwxrwxrwx 1 root root 2 Apr 21 08:11 f3 -&gt; f1
Copy<br>ä»ä¸Šé¢çš„ç»“æœä¸­å¯ä»¥çœ‹å‡ºï¼Œç¡¬è¿æ¥æ–‡ä»¶f2ä¸åŸæ–‡ä»¶f1çš„inodeèŠ‚ç‚¹ç›¸åŒï¼Œå‡ä¸º9797648ï¼Œç„¶è€Œç¬¦å·è¿æ¥æ–‡ä»¶çš„inodeèŠ‚ç‚¹ä¸åŒã€‚<br>[root@Linux]$ echo "I am f1 file" &gt;&gt;f1
[root@Linux]$ cat f1
I am f1 file
[root@Linux]$ cat f2
I am f1 file
[root@Linux]$ cat f3
I am f1 file
[root@Linux]$ rm -f f1
[root@Linux]$ cat f2
I am f1 file
[root@Linux]$ cat f3
cat: f3: No such file or directory
Copy<br>é€šè¿‡ä¸Šé¢çš„æµ‹è¯•å¯ä»¥çœ‹å‡ºï¼šå½“åˆ é™¤åŸå§‹æ–‡ä»¶f1åï¼Œç¡¬è¿æ¥f2ä¸å—å½±å“ï¼Œä½†æ˜¯ç¬¦å·è¿æ¥f1æ–‡ä»¶æ— æ•ˆã€‚<br>3. æ€»ç»“<br>
<br>åˆ é™¤ç¬¦å·è¿æ¥f3,å¯¹f1,f2æ— å½±å“ï¼›
<br>åˆ é™¤ç¡¬è¿æ¥f2ï¼Œå¯¹f1,f3ä¹Ÿæ— å½±å“ï¼›
<br>åˆ é™¤åŸæ–‡ä»¶f1ï¼Œå¯¹ç¡¬è¿æ¥f2æ²¡æœ‰å½±å“ï¼Œå¯¼è‡´ç¬¦å·è¿æ¥f3å¤±æ•ˆï¼›
<br>åŒæ—¶åˆ é™¤åŸæ–‡ä»¶f1,ç¡¬è¿æ¥f2ï¼Œæ•´ä¸ªæ–‡ä»¶ä¼šçœŸæ­£çš„è¢«åˆ é™¤ã€‚
<br><br><br>åœ¨Linuxçš„æ–‡ä»¶ç³»ç»Ÿä¸­ï¼Œä¿å­˜åœ¨ç£ç›˜åˆ†åŒºä¸­çš„æ–‡ä»¶ä¸ç®¡æ˜¯ä»€ä¹ˆç±»å‹éƒ½ç»™å®ƒåˆ†é…ä¸€ä¸ªç¼–å·ï¼Œç§°ä¸ºç´¢å¼•èŠ‚ç‚¹å·inode ã€‚<br>
<br>è½¯è¿æ¥ï¼Œå…¶å®å°±æ˜¯æ–°å»ºç«‹ä¸€ä¸ªæ–‡ä»¶ï¼Œè¿™ä¸ªæ–‡ä»¶å°±æ˜¯ä¸“é—¨ç”¨æ¥æŒ‡å‘åˆ«çš„æ–‡ä»¶çš„ï¼ˆé‚£å°±å’Œwindows ä¸‹çš„å¿«æ·æ–¹å¼çš„é‚£ä¸ªæ–‡ä»¶æœ‰å¾ˆæ¥è¿‘çš„æ„å‘³ï¼‰ã€‚è½¯é“¾æ¥äº§ç”Ÿçš„æ˜¯ä¸€ä¸ªæ–°çš„æ–‡ä»¶ï¼Œä½†è¿™ä¸ªæ–‡ä»¶çš„ä½œç”¨å°±æ˜¯ä¸“é—¨æŒ‡å‘æŸä¸ªæ–‡ä»¶çš„ï¼Œåˆ äº†è¿™ä¸ªè½¯è¿æ¥æ–‡ä»¶ï¼Œé‚£å°±ç­‰äºä¸éœ€è¦è¿™ä¸ªè¿æ¥ï¼Œå’ŒåŸæ¥çš„å­˜åœ¨çš„å®ä½“åŸæ–‡ä»¶æ²¡æœ‰ä»»ä½•å…³ç³»ï¼Œä½†åˆ é™¤åŸæ¥çš„æ–‡ä»¶ï¼Œåˆ™ç›¸åº”çš„è½¯è¿æ¥ä¸å¯ç”¨ï¼ˆcaté‚£ä¸ªè½¯é“¾æ¥æ–‡ä»¶ï¼Œåˆ™æç¤ºâ€œæ²¡æœ‰è¯¥æ–‡ä»¶æˆ–ç›®å½•â€œï¼‰
<br>ç¡¬è¿æ¥æ˜¯ä¸ä¼šå»ºç«‹inodeçš„ï¼Œä»–åªæ˜¯åœ¨æ–‡ä»¶åŸæ¥çš„inode link countåŸŸå†å¢åŠ 1è€Œå·²ï¼Œä¹Ÿå› æ­¤ç¡¬é“¾æ¥æ˜¯ä¸å¯ä»¥è·¨è¶Šæ–‡ä»¶ç³»ç»Ÿçš„ã€‚ç›¸åæ˜¯è½¯è¿æ¥ä¼šé‡æ–°å»ºç«‹ä¸€ä¸ªinodeï¼Œå½“ç„¶inodeçš„ç»“æ„è·Ÿå…¶ä»–çš„ä¸ä¸€æ ·ï¼Œä»–åªæ˜¯ä¸€ä¸ªæŒ‡æ˜æºæ–‡ä»¶çš„å­—ç¬¦ä¸²ä¿¡æ¯ã€‚ä¸€æ—¦åˆ é™¤æºæ–‡ä»¶ï¼Œé‚£ä¹ˆè½¯è¿æ¥å°†å˜å¾—æ¯«æ— æ„ä¹‰ã€‚è€Œç¡¬é“¾æ¥åˆ é™¤çš„æ—¶å€™ï¼Œç³»ç»Ÿè°ƒç”¨ä¼šæ£€æŸ¥inode link countçš„æ•°å€¼ï¼Œå¦‚æœä»–å¤§äºç­‰äº1ï¼Œé‚£ä¹ˆinodeä¸ä¼šè¢«å›æ”¶ã€‚å› æ­¤æ–‡ä»¶çš„å†…å®¹ä¸ä¼šè¢«åˆ é™¤ã€‚
<br>ç¡¬é“¾æ¥å®é™…ä¸Šæ˜¯ä¸ºæ–‡ä»¶å»ºä¸€ä¸ªåˆ«åï¼Œé“¾æ¥æ–‡ä»¶å’ŒåŸæ–‡ä»¶å®é™…ä¸Šæ˜¯åŒä¸€ä¸ªæ–‡ä»¶ã€‚å¯ä»¥é€šè¿‡ls -iæ¥æŸ¥çœ‹ä¸€ä¸‹ï¼Œè¿™ä¸¤ä¸ªæ–‡ä»¶çš„inodeå·æ˜¯åŒä¸€ä¸ªï¼Œè¯´æ˜å®ƒä»¬æ˜¯åŒä¸€ä¸ªæ–‡ä»¶ï¼›è€Œè½¯é“¾æ¥å»ºç«‹çš„æ˜¯ä¸€ä¸ªæŒ‡å‘ï¼Œå³é“¾æ¥æ–‡ä»¶å†…çš„å†…å®¹æ˜¯æŒ‡å‘åŸæ–‡ä»¶çš„æŒ‡é’ˆï¼Œå®ƒä»¬æ˜¯ä¸¤ä¸ªæ–‡ä»¶ã€‚
<br>è½¯é“¾æ¥å¯ä»¥è·¨æ–‡ä»¶ç³»ç»Ÿï¼Œç¡¬é“¾æ¥ä¸å¯ä»¥ï¼›
<br>è½¯é“¾æ¥å¯ä»¥å¯¹ä¸€ä¸ªä¸å­˜åœ¨çš„æ–‡ä»¶å(filename)è¿›è¡Œé“¾æ¥ï¼ˆå½“ç„¶æ­¤æ—¶å¦‚æœä½ viè¿™ä¸ªè½¯é“¾æ¥æ–‡ä»¶ï¼Œlinuxä¼šè‡ªåŠ¨æ–°å»ºä¸€ä¸ªæ–‡ä»¶åä¸ºfilenameçš„æ–‡ä»¶ï¼‰,ç¡¬é“¾æ¥ä¸å¯ä»¥ï¼ˆå…¶æ–‡ä»¶å¿…é¡»å­˜åœ¨ï¼Œinodeå¿…é¡»å­˜åœ¨ï¼‰ï¼›
<br>è½¯é“¾æ¥å¯ä»¥å¯¹ç›®å½•è¿›è¡Œè¿æ¥ï¼Œç¡¬é“¾æ¥ä¸å¯ä»¥ã€‚
<br>ä¸¤ç§é“¾æ¥éƒ½å¯ä»¥é€šè¿‡å‘½ä»¤ ln æ¥åˆ›å»ºã€‚ln é»˜è®¤åˆ›å»ºçš„æ˜¯ç¡¬é“¾æ¥ã€‚
<br>ä½¿ç”¨ -s å¼€å…³å¯ä»¥åˆ›å»ºè½¯é“¾æ¥ã€‚
<br><br><br>é“¾æ¥ç®€å•è¯´å®é™…ä¸Šæ˜¯ä¸€ç§æ–‡ä»¶å…±äº«çš„æ–¹å¼ï¼Œæ˜¯ POSIX ä¸­çš„æ¦‚å¿µï¼Œä¸»æµæ–‡ä»¶ç³»ç»Ÿéƒ½æ”¯æŒé“¾æ¥æ–‡ä»¶ã€‚<br><br>ä½ å¯ä»¥å°†é“¾æ¥ç®€å•åœ°ç†è§£ä¸º Windows ä¸­å¸¸è§çš„å¿«æ·æ–¹å¼ï¼ˆæˆ–æ˜¯ OS X ä¸­çš„æ›¿èº«ï¼‰ï¼ŒLinux ä¸­å¸¸ç”¨å®ƒæ¥è§£å†³ä¸€äº›åº“ç‰ˆæœ¬çš„é—®é¢˜ï¼Œé€šå¸¸ä¹Ÿä¼šå°†ä¸€äº›ç›®å½•å±‚æ¬¡è¾ƒæ·±çš„æ–‡ä»¶é“¾æ¥åˆ°ä¸€ä¸ªæ›´æ˜“è®¿é—®çš„ç›®å½•ä¸­ã€‚åœ¨è¿™äº›ç”¨é€”ä¸Šï¼Œæˆ‘ä»¬é€šå¸¸ä¼šä½¿ç”¨åˆ°è½¯é“¾æ¥ï¼ˆä¹Ÿç§°ç¬¦å·é“¾æ¥ï¼‰ã€‚<br><br>ä¸‹é¢æˆ‘ä»¬è¿›å…¥æ­£é¢˜ï¼Œæ¥æ¢è®¨ä¸€ä¸‹è½¯ç¡¬ä¸¤ç§é“¾æ¥åˆ°åº•æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ<br>é¦–å…ˆï¼Œä»ä½¿ç”¨çš„è§’åº¦è®²ï¼Œä¸¤è€…æ²¡æœ‰ä»»ä½•åŒºåˆ«ï¼Œéƒ½ä¸æ­£å¸¸çš„æ–‡ä»¶è®¿é—®æ–¹å¼ä¸€æ ·ï¼Œæ”¯æŒè¯»å†™ï¼Œå¦‚æœæ˜¯å¯æ‰§è¡Œæ–‡ä»¶çš„è¯ä¹Ÿå¯ä»¥ç›´æ¥æ‰§è¡Œã€‚<br>é‚£åŒºåˆ«åœ¨å“ªå‘¢ï¼Ÿåœ¨åº•å±‚çš„åŸç†ä¸Šã€‚<br>ä¸ºäº†è§£é‡Šæ¸…æ¥šï¼Œæˆ‘ä»¬é¦–å…ˆåœ¨è‡ªå·±çš„ä¸€ä¸ªå·¥ä½œç›®å½•ä¸‹åˆ›å»ºä¸€ä¸ªæ–‡ä»¶ï¼Œç„¶åå¯¹è¿™ä¸ªæ–‡ä»¶è¿›è¡Œé“¾æ¥çš„åˆ›å»ºï¼š<br>$ touch myfile &amp;&amp; echo "This is a plain text file." &gt; myfile
$ cat myfile
 
This is a plain text file.
Copy<br>ç°åœ¨æˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªæ™®é€šåœ°ä¸èƒ½å†æ™®é€šçš„æ–‡ä»¶äº†ã€‚ç„¶åæˆ‘ä»¬å¯¹å®ƒåˆ›å»ºä¸€ä¸ªç¡¬é“¾æ¥ï¼Œå¹¶æŸ¥çœ‹ä¸€ä¸‹å½“å‰ç›®å½•ï¼š<br>$ ln myfile hard
$ ls -li
 
25869085 -rw-r--r-- 2 unixzii staff 27 7 8 17:39 hard
25869085 -rw-r--r-- 2 unixzii staff 27 7 8 17:39 myfile
Copy<br>åœ¨ ls ç»“æœçš„æœ€å·¦è¾¹ä¸€åˆ—ï¼Œæ˜¯æ–‡ä»¶çš„ inode å€¼ï¼Œä½ å¯ä»¥ç®€å•æŠŠå®ƒæƒ³æˆ C è¯­è¨€ä¸­çš„æŒ‡é’ˆã€‚å®ƒæŒ‡å‘äº†ç‰©ç†ç¡¬ç›˜çš„ä¸€ä¸ªåŒºå—ï¼Œäº‹å®ä¸Šæ–‡ä»¶ç³»ç»Ÿä¼šç»´æŠ¤ä¸€ä¸ªå¼•ç”¨è®¡æ•°ï¼Œåªè¦æœ‰æ–‡ä»¶æŒ‡å‘è¿™ä¸ªåŒºå—ï¼Œå®ƒå°±ä¸ä¼šä»ç¡¬ç›˜ä¸Šæ¶ˆå¤±ã€‚<br>ä½ ä¹Ÿçœ‹åˆ°äº†ï¼Œè¿™ä¸¤ä¸ªæ–‡ä»¶å°±å¦‚åŒä¸€ä¸ªæ–‡ä»¶ä¸€æ ·ï¼Œinode å€¼ç›¸åŒï¼Œéƒ½æŒ‡å‘åŒä¸€ä¸ªåŒºå—ã€‚<br>ç„¶åæˆ‘ä»¬ä¿®æ”¹ä¸€ä¸‹åˆšæ‰åˆ›å»ºçš„ hard é“¾æ¥æ–‡ä»¶ï¼š<br>$ echo "New line" &gt;&gt; hard
$ cat myfile
 
This is a plain text file.
New line
Copy<br>å¯ä»¥çœ‹åˆ°ï¼Œè¿™ä¸¤ä¸ªæ–‡ä»¶æœçœŸå°±æ˜¯ä¸€ä¸ªæ–‡ä»¶ã€‚<br>
ä¸‹é¢æˆ‘ä»¬çœ‹çœ‹è½¯é“¾æ¥ï¼ˆä¹Ÿå°±æ˜¯ç¬¦å·é“¾æ¥ï¼‰å’Œå®ƒæœ‰ä»€ä¹ˆåŒºåˆ«ã€‚<br>$ ln -s myfile soft
$ ls -li
 
25869085 -rw-r--r-- 2 unixzii staff 36 7 8 17:45 hard
25869085 -rw-r--r-- 2 unixzii staff 36 7 8 17:45 myfile
25869216 lrwxr-xr-x 1 unixzii staff 6 7 8 17:47 soft -&gt; myfile
Copy<br>è¯¶ï¼Œä½ ä¼šå‘ç°ï¼Œè¿™ä¸ªè½¯é“¾æ¥çš„ inode ç«Ÿç„¶ä¸ä¸€æ ·å•Šï¼Œå¹¶ä¸”å®ƒçš„æ–‡ä»¶å±æ€§ä¸Šä¹Ÿæœ‰ä¸€ä¸ª l çš„ flagï¼Œè¿™å°±è¯´æ˜å®ƒä¸ä¹‹å‰æˆ‘ä»¬åˆ›å»ºçš„ä¸¤ä¸ªæ–‡ä»¶æ ¹æœ¬ä¸æ˜¯ä¸€ä¸ªç±»å‹ã€‚<br>ä¸‹é¢æˆ‘ä»¬è¯•ç€åˆ é™¤ myfile æ–‡ä»¶ï¼Œç„¶ååˆ†åˆ«è¾“å‡ºè½¯ç¡¬é“¾æ¥çš„æ–‡ä»¶å†…å®¹ï¼š<br>$ rm myfile
$ cat hard
 
This is a plain text file.
New line
Copy<br>$ cat soft
 
cat: soft: No such file or directory
Copy<br>ä¹‹å‰çš„ç¡¬é“¾æ¥æ²¡æœ‰ä¸æ¯«åœ°å½±å“ï¼Œå› ä¸ºå®ƒ inode æ‰€æŒ‡å‘çš„åŒºå—ç”±äºæœ‰ä¸€ä¸ªç¡¬é“¾æ¥åœ¨æŒ‡å‘å®ƒï¼Œæ‰€ä»¥è¿™ä¸ªåŒºå—ä»ç„¶æœ‰æ•ˆï¼Œå¹¶ä¸”å¯ä»¥è®¿é—®åˆ°ã€‚<br>
ç„¶è€Œè½¯é“¾æ¥çš„ inode æ‰€æŒ‡å‘çš„å†…å®¹å®é™…ä¸Šæ˜¯ä¿å­˜äº†ä¸€ä¸ªç»å¯¹è·¯å¾„ï¼Œå½“ç”¨æˆ·è®¿é—®è¿™ä¸ªæ–‡ä»¶æ—¶ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨å°†å…¶æ›¿æ¢æˆå…¶æ‰€æŒ‡çš„æ–‡ä»¶è·¯å¾„ï¼Œç„¶è€Œè¿™ä¸ªæ–‡ä»¶å·²ç»è¢«åˆ é™¤äº†ï¼Œæ‰€ä»¥è‡ªç„¶å°±ä¼šæ˜¾ç¤ºæ— æ³•æ‰¾åˆ°è¯¥æ–‡ä»¶äº†ã€‚<br>ä¸ºéªŒè¯è¿™ä¸€çŒœæƒ³ï¼Œæˆ‘ä»¬å†å‘è¿™ä¸ªè½¯é“¾æ¥å†™ç‚¹ä¸œè¥¿ï¼š<br>$ echo "Something" &gt;&gt; soft
$ ls
 
hard myfile soft
Copy<br>å¯ä»¥çœ‹åˆ°ï¼Œåˆšæ‰åˆ é™¤çš„ myfile æ–‡ä»¶ç«Ÿç„¶åˆå‡ºç°äº†ï¼è¿™å°±è¯´æ˜ï¼Œå½“æˆ‘ä»¬å†™å…¥è®¿é—®è½¯é“¾æ¥æ—¶ï¼Œç³»ç»Ÿè‡ªåŠ¨å°†å…¶è·¯å¾„æ›¿æ¢ä¸ºå…¶æ‰€ä»£è¡¨çš„ç»å¯¹è·¯å¾„ï¼Œå¹¶ç›´æ¥è®¿é—®é‚£ä¸ªè·¯å¾„äº†ã€‚<br>
<br>ç¡¬é“¾æ¥ï¼š ä¸æ™®é€šæ–‡ä»¶æ²¡ä»€ä¹ˆä¸åŒï¼Œinode éƒ½æŒ‡å‘åŒä¸€ä¸ªæ–‡ä»¶åœ¨ç¡¬ç›˜ä¸­çš„åŒºå—
<br>è½¯é“¾æ¥ï¼š ä¿å­˜äº†å…¶ä»£è¡¨çš„æ–‡ä»¶çš„ç»å¯¹è·¯å¾„ï¼Œæ˜¯å¦å¤–ä¸€ç§æ–‡ä»¶ï¼Œåœ¨ç¡¬ç›˜ä¸Šæœ‰ç‹¬ç«‹çš„åŒºå—ï¼Œè®¿é—®æ—¶æ›¿æ¢è‡ªèº«è·¯å¾„ã€‚<br>
<img alt="Linuxä¸­çš„ç¡¬é“¾æ¥å’Œè½¯é“¾æ¥.png" src="https://muqiuhan.github.io/wiki/computer-science/operating-system/linux/linuxä¸­çš„ç¡¬è¿æ¥å’Œè½¯è¿æ¥/linuxä¸­çš„ç¡¬é“¾æ¥å’Œè½¯é“¾æ¥.png">
<br><br><br>å½“æŠŠåŸæ–‡ä»¶myfileåˆ é™¤ä¹‹åï¼Œé€šè¿‡é“¾æ¥æ˜¯æ— æ³•è®¿é—®ï¼Œé€šè¿‡ç¡¬é“¾æ¥è¿˜æ˜¯å¯ä»¥è®¿é—®çš„  <br>
<br>è½¯è¿æ¥å…¶å®ä¿å­˜çš„æ˜¯åŸæ–‡ä»¶çš„è·¯å¾„ï¼Œè®¿é—®è½¯è¿æ¥å°±æ˜¯é€šè¿‡ç»å¯¹è·¯å¾„è¿›è¡Œè®¿é—®çš„ã€‚è®¿é—®ä¸åˆ°åŸæ–‡ä»¶è¯´æ˜--æ–‡ä»¶æ¶ˆå¤±äº†æˆ–è€…æ–‡ä»¶ç§»åŠ¨åˆ°å…¶ä»–ç›®å½•ä¸‹é¢äº†  
<br>æŠŠåŸmyfileæ–‡ä»¶åˆ é™¤ä¹‹åï¼Œä½†æ˜¯é€šè¿‡ç¡¬é“¾æ¥è¿˜æ˜¯å¯ä»¥è®¿é—®çš„
<br>åœ¨è¿™ä¸ªåœºæ™¯ä¸‹ï¼Œæ–‡ä»¶å¹¶æ²¡æœ‰ç§»åŠ¨æˆ–è€…ä¸ç§»åŠ¨ä¹‹è¯´ã€‚æ–‡ä»¶å°±æ˜¯ä¸€å—ç‰©ç†å­˜å‚¨åŒºåŸŸçš„å†…å®¹ã€‚åªæœ‰å½“æŒ‡å‘å­˜å‚¨åŒºçš„æŒ‡é’ˆå…¨éƒ¨æ¶ˆå¤±ï¼Œå­˜å‚¨åŒºæ‰ä¼šè¢«å›æ”¶ï¼ˆå†…å®¹ä¹Ÿå°±æ²¡äº†ï¼‰ã€‚æ‰€è°“çš„æ–‡ä»¶åï¼Œåªæ˜¯æŒ‡å‘å­˜å‚¨åŒºçš„ä¸€ä¸ªflagã€‚è½¯é“¾æ¥æ˜¯è¿™ä¸ªflagçš„è·¯å¾„ï¼Œå…ˆæ‰¾åˆ°è¿™ä¸ªflagï¼Œå†è®¿é—®å­˜å‚¨åŒºã€‚ç¡¬é“¾æ¥æ˜¯æ–°å»ºäº†ä¸€ä¸ªä¸åŒæ–‡ä»¶åä½†æŒ‡å‘åŒä¸€ä¸ªå­˜å‚¨åŒºçš„flagã€‚]]></description><link>https://muqiuhan.github.io/wiki/computer-science/operating-system/linux/linuxä¸­çš„ç¡¬è¿æ¥å’Œè½¯è¿æ¥/linuxä¸­çš„ç¡¬è¿æ¥å’Œè½¯è¿æ¥.html</link><guid isPermaLink="false">Computer Science/Operating System/Linux/Linuxä¸­çš„ç¡¬è¿æ¥å’Œè½¯è¿æ¥/Linuxä¸­çš„ç¡¬è¿æ¥å’Œè½¯è¿æ¥.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:38 GMT</pubDate><enclosure url="https://muqiuhan.github.io/wiki/computer-science/operating-system/linux/linuxä¸­çš„ç¡¬è¿æ¥å’Œè½¯è¿æ¥/linuxä¸­çš„ç¡¬é“¾æ¥å’Œè½¯é“¾æ¥.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://muqiuhan.github.io/wiki/computer-science/operating-system/linux/linuxä¸­çš„ç¡¬è¿æ¥å’Œè½¯è¿æ¥/linuxä¸­çš„ç¡¬é“¾æ¥å’Œè½¯é“¾æ¥.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Inter-process communication in Linux -- Shared storage]]></title><description><![CDATA[ 
 <br>This is the first article in a series&nbsp;about <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Inter-process_communication" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Inter-process_communication" target="_blank">interprocess communication</a> (IPC) in Linux. The series uses code examples in C to clarify the following IPC mechanisms:<br>
<br>Shared files
<br>Shared memory (with semaphores)
<br>Pipes (named and unnamed)
<br>Message queues
<br>Sockets
<br>Signals
<br>This article reviews some core concepts before moving on to the first two of these mechanisms: shared files and shared memory.<br><br>A process is a program in execution, and each process has its own address space, which comprises the memory locations that the process is allowed to access. A process has one or more threads of execution, which are sequences of executable instructions: a single-threaded process has just one thread, whereas a multi-threaded process has more than one thread. Threads within a process share various resources, in particular, address space. Accordingly, threads within a process can communicate straightforwardly through shared memory, although some modern languages (e.g., Go) encourage a more disciplined approach such as the use of thread-safe channels. Of interest here is that different processes, by default, do not share memory.<br>There are various ways to launch processes that then communicate, and two ways dominate in the examples that follow:<br>
<br>A terminal is used to start one process, and perhaps a different terminal is used to start another.
<br>The system function fork is called within one process (the parent) to spawn another process (the child).
<br>The first examples take the terminal approach. The <a data-tooltip-position="top" aria-label="http://condor.depaul.edu/mkalin" rel="noopener" class="external-link" href="http://condor.depaul.edu/mkalin" target="_blank">code examples</a> are available in a ZIP file on my website.<br><br>Programmers are all too familiar with file access, including the many pitfalls (non-existent files, bad file permissions, and so on) that beset the use of files in programs. Nonetheless, shared files may be the most basic IPC mechanism. Consider the relatively simple case in which one process (producer) creates and writes to a file, and another process (consumer) reads from this same file:<br>         writes  +-----------+  reads
producer--------&gt;| disk file |&lt;-------consumer
                 +-----------+
Copy<br>The obvious challenge in using this IPC mechanism is that a race condition might arise: the producer and the consumer might access the file at exactly the same time, thereby making the outcome indeterminate. To avoid a race condition, the file must be locked in a way that prevents a conflict between a write operation and any another operation, whether a read or a write. The locking API in the standard system library can be summarized as follows:<br>
<br>A producer should gain an exclusive lock on the file before writing to the file. An exclusive lock can be held by one process at most, which rules out a race condition because no other process can access the file until the lock is released.
<br>A consumer should gain at least a shared lock on the file before reading from the file. Multiple readers can hold a shared lock at the same time, but no writer can access a file when even a single reader holds a shared lock.
<br>A shared lock promotes efficiency. If one process is just reading a file and not changing its contents, there is no reason to prevent other processes from doing the same. Writing, however, clearly demands exclusive access to a file.<br>The standard I/O library includes a utility function named fcntl that can be used to inspect and manipulate both exclusive and shared locks on a file. The function works through a file descriptor, a non-negative integer value that, within a process, identifies a file. (Different file descriptors in different processes may identify the same physical file.) For file locking, Linux provides the library function flock, which is a thin wrapper around fcntl. The first example uses the fcntl function to expose API details.<br><br>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

#define FileName "data.dat"
#define DataString "Now is the winter of our discontent\nMade glorious summer by this sun of York\n"

void report_and_exit(const char* msg) {
  perror(msg);
  exit(-1); /* EXIT_FAILURE */
}

int main() {
  struct flock lock;
  lock.l_type = F_WRLCK;    /* read/write (exclusive versus shared) lock */
  lock.l_whence = SEEK_SET; /* base for seek offsets */
  lock.l_start = 0;         /* 1st byte in file */
  lock.l_len = 0;           /* 0 here means 'until EOF' */
  lock.l_pid = getpid();    /* process id */

  int fd; /* file descriptor to identify a file within a process */
  if ((fd = open(FileName, O_RDWR | O_CREAT, 0666)) &lt; 0)  /* -1 signals an error */
    report_and_exit("open failed...");

  if (fcntl(fd, F_SETLK, &amp;lock) &lt; 0) /** F_SETLK doesn't block, F_SETLKW does **/
    report_and_exit("fcntl failed to get lock...");
  else {
    write(fd, DataString, strlen(DataString)); /* populate data file */
    fprintf(stderr, "Process %d has written to data file...\n", lock.l_pid);
  }

  /* Now release the lock explicitly. */
  lock.l_type = F_UNLCK;
  if (fcntl(fd, F_SETLK, &amp;lock) &lt; 0)
    report_and_exit("explicit unlocking failed...");

  close(fd); /* close the file: would unlock if needed */
  return 0;  /* terminating the process would unlock as well */
}
Copy<br>The main steps in the producer program above can be summarized as follows:<br>
<br>The program declares a variable of type struct flock, which represents a lock, and initializes the structure's five fields. The first initialization:  
lock.l_type = F_WRLCK; /* exclusive lock */
Copy
  makes the lock an exclusive (read-write) rather than a shared (read-only) lock. If the producer gains the lock, then no other process will be able to write or read the file until the producer releases the lock, either explicitly with the appropriate call to fcntl or implicitly by closing the file. (When the process terminates, any opened files would be closed automatically, thereby releasing the lock.)<br>

<br>The program then initializes the remaining fields. The chief effect is that the entire file is to be locked. However, the locking API allows only designated bytes to be locked. For example, if the file contains multiple text records, then a single record (or even part of a record) could be locked and the rest left unlocked.
<br>The first call to fcntl:  
if (fcntl(fd, F_SETLK, &amp;lock) &lt; 0)
Copy
  tries to lock the file exclusively, checking whether the call succeeded. In general, the fcntl function returns -1 (hence, less than zero) to indicate failure. The second argument F_SETLK means that the call to fcntl does not block: the function returns immediately, either granting the lock or indicating failure. If the flag F_SETLKW (the W at the end is for wait) were used instead, the call to fcntl would block until gaining the lock was possible. In the calls to fcntl, the first argument fd is the file descriptor, the second argument specifies the action to be taken (in this case,&nbsp;F_SETLK for setting the lock), and the third argument is the address of the lock structure (in this case,&nbsp;&amp;lock).<br>

<br>If the producer gains the lock, the program writes two text records to the file.
<br>After writing to the file, the producer changes the lock structure's l_type field to the unlock value:  
lock.l_type = F_UNLCK;
Copy
  and calls fcntl to perform the unlocking operation. The program finishes up by closing the file and exiting.<br>

<br><br>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;

#define FileName "data.dat"

void report_and_exit(const char* msg) {
  perror(msg);
  exit(-1); /* EXIT_FAILURE */
}

int main() {
  struct flock lock;
  lock.l_type = F_WRLCK;    /* read/write (exclusive) lock */
  lock.l_whence = SEEK_SET; /* base for seek offsets */
  lock.l_start = 0;         /* 1st byte in file */
  lock.l_len = 0;           /* 0 here means 'until EOF' */
  lock.l_pid = getpid();    /* process id */

  int fd; /* file descriptor to identify a file within a process */
  if ((fd = open(FileName, O_RDONLY)) &lt; 0)  /* -1 signals an error */
    report_and_exit("open to read failed...");

  /* If the file is write-locked, we can't continue. */
  fcntl(fd, F_GETLK, &amp;lock); /* sets lock.l_type to F_UNLCK if no write lock */
  if (lock.l_type != F_UNLCK)
    report_and_exit("file is still write locked...");

  lock.l_type = F_RDLCK; /* prevents any writing during the reading */
  if (fcntl(fd, F_SETLK, &amp;lock) &lt; 0)
    report_and_exit("can't get a read-only lock...");

  /* Read the bytes (they happen to be ASCII codes) one at a time. */
  int c; /* buffer for read bytes */
  while (read(fd, &amp;c, 1) &gt; 0)    /* 0 signals EOF */
    write(STDOUT_FILENO, &amp;c, 1); /* write one byte to the standard output */

  /* Release the lock explicitly. */
  lock.l_type = F_UNLCK;
  if (fcntl(fd, F_SETLK, &amp;lock) &lt; 0)
    report_and_exit("explicit unlocking failed...");

  close(fd);
  return 0;
}
Copy<br>The consumer program is more complicated than necessary to highlight features of the locking API. In particular, the consumer program first checks whether the file is exclusively locked and only then tries to gain a shared lock. The relevant code is:<br>lock.l_type = F_WRLCK;
...
fcntl(fd, F_GETLK, &amp;lock); /* sets lock.l_type to F_UNLCK if no write lock */
if (lock.l_type != F_UNLCK)
  report_and_exit("file is still write locked...");
Copy<br>The F_GETLK operation specified in the fcntl call checks for a lock, in this case, an exclusive lock given as F_WRLCK in the first statement above. If the specified lock does not exist, then the fcntl call automatically changes the lock type field to F_UNLCK to indicate this fact. If the file is exclusively locked, the consumer terminates. (A more robust version of the program might have the consumer sleep a bit and try again several times.)<br>If the file is not currently locked, then the consumer tries to gain a shared (read-only) lock (F_RDLCK). To shorten the program, the F_GETLK call to fcntl could be dropped because the F_RDLCK call would fail if a read-write lock already were held by some other process. Recall that a read-only lock does prevent any other process from writing to the file, but allows other processes to read from the file. In short, a shared lock can be held by multiple processes. After gaining a shared lock, the consumer program reads the bytes one at a time from the file, prints the bytes to the standard output, releases the lock, closes the file, and terminates.<br>Here is the output from the two programs launched from the same terminal with % as the command line prompt:<br>% ./producer
Process 29255 has written to data file...

% ./consumer
Now is the winter of our discontent
Made glorious summer by this sun of York
Copy<br>In this first code example, the data shared through IPC is text: two lines from Shakespeare's play Richard III. Yet, the shared file's contents could be voluminous, arbitrary bytes (e.g., a digitized movie), which makes file sharing an impressively flexible IPC mechanism. The downside is that file access is relatively slow, whether the access involves reading or writing. As always, programming comes with tradeoffs. The next example has the upside of IPC through shared memory, rather than shared files, with a corresponding boost in performance.<br><br>Linux systems provide two separate APIs for shared memory: the legacy System V API and the more recent POSIX one. These APIs should never be mixed in a single application, however. A downside of the POSIX approach is that features are still in development and dependent upon the installed kernel version, which impacts code portability. For example, the POSIX API, by default, implements shared memory as a memory-mapped file: for a shared memory segment, the system maintains a backing file with corresponding contents. Shared memory under POSIX can be configured without a backing file, but this may impact portability. My example uses the POSIX API with a backing file, which combines the benefits of memory access (speed) and file storage (persistence).<br>The shared-memory example has two programs, named memwriter and memreader, and uses a semaphore to coordinate their access to the shared memory. Whenever shared memory comes into the picture with a writer, whether in multi-processing or multi-threading, so does the risk of a memory-based race condition; hence, the semaphore is used to coordinate (synchronize) access to the shared memory.<br>The memwriter program should be started first in its own terminal. The memreader program then can be started (within a dozen seconds) in its own terminal. The output from the memreader is:<br>This is the way the world ends...
Copy<br>Each source file has documentation at the top explaining the link flags to be included during compilation.<br>Let's start with a review of how semaphores work as a synchronization mechanism. A general semaphore also is called a counting semaphore, as it has a value (typically initialized to zero) that can be incremented. Consider a shop that rents bicycles, with a hundred of them in stock, with a program that clerks use to do the rentals. Every time a bike is rented, the semaphore is incremented by one; when a bike is returned, the semaphore is decremented by one. Rentals can continue until the value hits 100 but then must halt until at least one bike is returned, thereby decrementing the semaphore to 99.<br>A binary semaphore is a special case requiring only two values: 0 and 1. In this situation, a semaphore acts as a mutex: a mutual exclusion construct. The shared-memory example uses a semaphore as a mutex. When the semaphore's value is 0, the memwriter alone can access the shared memory. After writing, this process increments the semaphore's value, thereby allowing the memreader to read the shared memory.<br><br>/** Compilation: gcc -o memwriter memwriter.c -lrt -lpthread **/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;semaphore.h&gt;
#include &lt;string.h&gt;
#include "shmem.h"

void report_and_exit(const char* msg) {
  perror(msg);
  exit(-1);
}

int main() {
  int fd = shm_open(BackingFile,      /* name from smem.h */
                    O_RDWR | O_CREAT, /* read/write, create if needed */
                    AccessPerms);     /* access permissions (0644) */
  if (fd &lt; 0) report_and_exit("Can't open shared mem segment...");

  ftruncate(fd, ByteSize); /* get the bytes */

  caddr_t memptr = mmap(NULL,       /* let system pick where to put segment */
                        ByteSize,   /* how many bytes */
                        PROT_READ | PROT_WRITE, /* access protections */
                        MAP_SHARED, /* mapping visible to other processes */
                        fd,         /* file descriptor */
                        0);         /* offset: start at 1st byte */
  if ((caddr_t) -1  == memptr) report_and_exit("Can't get segment...");

  fprintf(stderr, "shared mem address: %p [0..%d]\n", memptr, ByteSize - 1);
  fprintf(stderr, "backing file:       /dev/shm%s\n", BackingFile );

  /* semaphore code to lock the shared mem */
  sem_t* semptr = sem_open(SemaphoreName, /* name */
                           O_CREAT,       /* create the semaphore */
                           AccessPerms,   /* protection perms */
                           0);            /* initial value */
  if (semptr == (void*) -1) report_and_exit("sem_open");

  strcpy(memptr, MemContents); /* copy some ASCII bytes to the segment */

  /* increment the semaphore so that memreader can read */
  if (sem_post(semptr) &lt; 0) report_and_exit("sem_post");

  sleep(12); /* give reader a chance */

  /* clean up */
  munmap(memptr, ByteSize); /* unmap the storage */
  close(fd);
  sem_close(semptr);
  shm_unlink(BackingFile); /* unlink from the backing file */
  return 0;
}
Copy<br>Here's an overview of how the memwriter and memreader programs communicate through shared memory:<br>
<br>The memwriter program, shown above, calls the shm_open function to get a file descriptor for the backing file that the system coordinates with the shared memory. At this point, no memory has been allocated. The subsequent call to the misleadingly named function ftruncate:  
ftruncate(fd, ByteSize); /* get the bytes */
Copy
  allocates ByteSize bytes, in this case, a modest 512 bytes. The memwriter and memreader programs access the shared memory only, not the backing file. The system is responsible for synchronizing the shared memory and the backing file.<br>

<br>The memwriter then calls the mmap function:  
caddr_t memptr = mmap(NULL,       /* let system pick where to put segment */
                      ByteSize,   /* how many bytes */
                      PROT_READ | PROT_WRITE, /* access protections */
                      MAP_SHARED, /* mapping visible to other processes */
                      fd,         /* file descriptor */
                      0);         /* offset: start at 1st byte */
Copy
  to get a pointer to the shared memory. (The memreader makes a similar call.) The pointer type caddr_t starts with a c for calloc, a system function that initializes dynamically allocated storage to zeroes. The memwriter uses the memptr for the later write operation, using the library strcpy (string copy) function.<br>

<br>At this point, the memwriter is ready for writing, but it first creates a semaphore to ensure exclusive access to the shared memory. A race condition would occur if the memwriter were writing while the memreader was reading. If the call to sem_open succeeds:  
sem_t* semptr = sem_open(SemaphoreName, /* name */
                         O_CREAT,       /* create the semaphore */
                         AccessPerms,   /* protection perms */
                         0);            /* initial value */
Copy
  then the writing can proceed. The SemaphoreName (any unique non-empty name will do) identifies the semaphore in both the memwriter and the memreader. The initial value of zero gives the semaphore's creator, in this case,&nbsp;the memwriter, the right to proceed, in this case, to the write operation.<br>

<br>After writing, the memwriter increments the semaphore value to 1:  
if (sem_post(semptr) &lt; 0) ..
Copy
  with a call to the sem_post function. Incrementing the semaphore releases the mutex lock and enables the memreader to perform its read operation. For good measure, the memwriter also unmaps the shared memory from the memwriter address space:
munmap(memptr, ByteSize); /* unmap the storage *
Copy
  This bars the memwriter from further access to the shared memory.<br>

<br><br>/** Compilation: gcc -o memreader memreader.c -lrt -lpthread **/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;semaphore.h&gt;
#include &lt;string.h&gt;
#include "shmem.h"

void report_and_exit(const char* msg) {
  perror(msg);
  exit(-1);
}

int main() {
  int fd = shm_open(BackingFile, O_RDWR, AccessPerms);  /* empty to begin */
  if (fd &lt; 0) report_and_exit("Can't get file descriptor...");

  /* get a pointer to memory */
  caddr_t memptr = mmap(NULL,       /* let system pick where to put segment */
                        ByteSize,   /* how many bytes */
                        PROT_READ | PROT_WRITE, /* access protections */
                        MAP_SHARED, /* mapping visible to other processes */
                        fd,         /* file descriptor */
                        0);         /* offset: start at 1st byte */
  if ((caddr_t) -1 == memptr) report_and_exit("Can't access segment...");

  /* create a semaphore for mutual exclusion */
  sem_t* semptr = sem_open(SemaphoreName, /* name */
                           O_CREAT,       /* create the semaphore */
                           AccessPerms,   /* protection perms */
                           0);            /* initial value */
  if (semptr == (void*) -1) report_and_exit("sem_open");

  /* use semaphore as a mutex (lock) by waiting for writer to increment it */
  if (!sem_wait(semptr)) { /* wait until semaphore != 0 */
    int i;
    for (i = 0; i &lt; strlen(MemContents); i++)
      write(STDOUT_FILENO, memptr + i, 1); /* one byte at a time */
    sem_post(semptr);
  }

  /* cleanup */
  munmap(memptr, ByteSize);
  close(fd);
  sem_close(semptr);
  unlink(BackingFile);
  return 0;
}
Copy<br>In both the memwriter and memreader programs, the shared-memory functions of main interest are shm_open and mmap: on success, the first call returns a file descriptor for the backing file, which the second call then uses to get a pointer to the shared memory segment. The calls to shm_open are similar in the two programs except that the memwriter program creates the shared memory, whereas the memreader only accesses this already created memory:<br>int fd = shm_open(BackingFile, O_RDWR | O_CREAT, AccessPerms); /* memwriter */
int fd = shm_open(BackingFile, O_RDWR, AccessPerms);           /* memreader */
Copy<br>With a file descriptor in hand, the calls to mmap are the same:<br>caddr_t memptr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
Copy<br>The first argument to mmap is NULL, which means that the system determines where to allocate the memory in virtual address space. It's possible (but tricky) to specify an address instead. The MAP_SHARED flag indicates that the allocated memory is shareable among processes, and the last argument (in this case, zero) means that the offset for the shared memory should be the first byte. The size argument specifies the number of bytes to be allocated (in this case, 512), and the protection argument indicates that the shared memory can be written and read.<br>When the memwriter program executes successfully, the system creates and maintains the backing file; on my system, the file is /dev/shm/shMemEx, with shMemEx as my name (given in the header file shmem.h) for the shared storage. In the current version of the memwriter and memreader programs, the statement:<br>shm_unlink(BackingFile); /* removes backing file */
Copy<br>removes the backing file. If the unlink statement is omitted, then the backing file persists after the program terminates.<br>The memreader, like the memwriter, accesses the semaphore through its name in a call to sem_open. But the memreader then goes into a wait state until the memwriter increments the semaphore, whose initial value is 0:<br>if (!sem_wait(semptr)) { /* wait until semaphore != 0 */
Copy<br>Once the wait is over, the memreader reads the ASCII bytes from the shared memory, cleans up, and terminates.<br>The shared-memory API includes operations explicitly to synchronize the shared memory segment and the backing file. These operations have been omitted from the example to reduce clutter and&nbsp;keep the&nbsp;focus on the memory-sharing and semaphore code.<br>The memwriter and memreader programs are likely to execute without inducing a race condition even if the semaphore code is removed: the memwriter creates the shared memory segment and writes immediately to it; the memreader cannot even access the shared memory until this has been created. However, best practice requires that shared-memory access is synchronized whenever a write operation is in the mix, and the semaphore API is important enough to be highlighted in a code example.<br><br>The shared-file and shared-memory examples show how processes can communicate through shared storage, files in one case and memory segments in the other. The APIs for both approaches are relatively straightforward. Do these approaches have a common downside? Modern applications often deal with streaming data, indeed, with massively large streams of data. Neither the shared-file nor the shared-memory approaches are well suited for massive data streams. Channels of one type or another are better suited. Part 2 thus introduces channels and message queues, again with code examples in C.<br>[<a data-tooltip-position="top" aria-label="https://opensource.com/downloads/guide-inter-process-communication-linux" rel="noopener" class="external-link" href="https://opensource.com/downloads/guide-inter-process-communication-linux" target="_blank">Download</a> the complete guide to inter-process communication in Linux]<br><br>More Linux resources<br>
<br><a data-tooltip-position="top" aria-label="https://developers.redhat.com/cheat-sheets/linux-commands-cheat-sheet/?intcmp=70160000000h1jYAAQ&amp;utm_source=intcallout&amp;utm_campaign=linuxcontent" rel="noopener" class="external-link" href="https://developers.redhat.com/cheat-sheets/linux-commands-cheat-sheet/?intcmp=70160000000h1jYAAQ&amp;utm_source=intcallout&amp;utm_campaign=linuxcontent" target="_blank">Linux commands cheat sheet</a>
<br><a data-tooltip-position="top" aria-label="https://developers.redhat.com/cheat-sheets/advanced-linux-commands/?intcmp=70160000000h1jYAAQ&amp;utm_source=intcallout&amp;utm_campaign=linuxcontent" rel="noopener" class="external-link" href="https://developers.redhat.com/cheat-sheets/advanced-linux-commands/?intcmp=70160000000h1jYAAQ&amp;utm_source=intcallout&amp;utm_campaign=linuxcontent" target="_blank">Advanced Linux commands cheat sheet</a>
<br><a data-tooltip-position="top" aria-label="https://www.redhat.com/en/services/training/rh024-red-hat-linux-technical-overview?intcmp=70160000000h1jYAAQ&amp;utm_source=intcallout&amp;utm_campaign=linuxcontent" rel="noopener" class="external-link" href="https://www.redhat.com/en/services/training/rh024-red-hat-linux-technical-overview?intcmp=70160000000h1jYAAQ&amp;utm_source=intcallout&amp;utm_campaign=linuxcontent" target="_blank">Free online course: RHEL Technical Overview</a>
<br><a data-tooltip-position="top" aria-label="https://opensource.com/downloads/cheat-sheet-networking?intcmp=70160000000h1jYAAQ&amp;utm_source=intcallout&amp;utm_campaign=linuxcontent" rel="noopener" class="external-link" href="https://opensource.com/downloads/cheat-sheet-networking?intcmp=70160000000h1jYAAQ&amp;utm_source=intcallout&amp;utm_campaign=linuxcontent" target="_blank">Linux networking cheat sheet</a>
<br><a data-tooltip-position="top" aria-label="https://opensource.com/downloads/cheat-sheet-selinux?intcmp=70160000000h1jYAAQ&amp;utm_source=intcallout&amp;utm_campaign=linuxcontent" rel="noopener" class="external-link" href="https://opensource.com/downloads/cheat-sheet-selinux?intcmp=70160000000h1jYAAQ&amp;utm_source=intcallout&amp;utm_campaign=linuxcontent" target="_blank">SELinux cheat sheet</a>
<br><a data-tooltip-position="top" aria-label="https://opensource.com/downloads/linux-common-commands-cheat-sheet?intcmp=70160000000h1jYAAQ&amp;utm_source=intcallout&amp;utm_campaign=linuxcontent" rel="noopener" class="external-link" href="https://opensource.com/downloads/linux-common-commands-cheat-sheet?intcmp=70160000000h1jYAAQ&amp;utm_source=intcallout&amp;utm_campaign=linuxcontent" target="_blank">Linux common commands cheat sheet</a>
<br><a data-tooltip-position="top" aria-label="https://opensource.com/resources/what-are-linux-containers?intcmp=70160000000h1jYAAQ&amp;utm_source=intcallout&amp;utm_campaign=linuxcontent" rel="noopener" class="external-link" href="https://opensource.com/resources/what-are-linux-containers?intcmp=70160000000h1jYAAQ&amp;utm_source=intcallout&amp;utm_campaign=linuxcontent" target="_blank">What are Linux containers?</a>
<br><a data-tooltip-position="top" aria-label="https://opensource.com/tags/linux?intcmp=70160000000h1jYAAQ&amp;utm_source=intcallout&amp;utm_campaign=linuxcontent" rel="noopener" class="external-link" href="https://opensource.com/tags/linux?intcmp=70160000000h1jYAAQ&amp;utm_source=intcallout&amp;utm_campaign=linuxcontent" target="_blank">Our latest Linux articles</a>
]]></description><link>https://muqiuhan.github.io/wiki/computer-science/operating-system/linux/inter-process-communication-in-linux-shared-storage.html</link><guid isPermaLink="false">Computer Science/Operating System/Linux/Inter-process communication in Linux -- Shared storage.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:31 GMT</pubDate></item><item><title><![CDATA[udevd Operation and Configuration]]></title><description><![CDATA[ 
 <br>The udevd daemon operates as follows:<br>
<br>The kernel sends udevd a notification event, called a uevent, through an internal network link.
<br>udevd loads all of the attributes in the uevent.
<br>udevd parses its rules, filters and updates the uevent based on<br>
those rules, and takes actions or sets more attributes accordingly. An incoming uevent that udevd receives from the kernel might look like this:
<br>ACTION=change
DEVNAME=sde
DEVPATH=/devices/pci0000:00/0000:00:1a.0/usb1/1-1/1-1.2/1-1.2:1.0/host4/
target4:0:0/4:0:0:3/block/sde
DEVTYPE=disk
DISK_MEDIA_CHANGE=1
MAJOR=8
MINOR=64
SEQNUM=2752
SUBSYSTEM=block
UDEV_LOG=3
Copy<br>This particular event is a change to a device. After receiving the uevent, udevd knows the name of the device, the sysfs device path, and a number of other attributes associated with the properties; it is now ready to start processing rules.<br>
The rules files are in the /lib/udev/rules.d and /etc/udev/rules.d directories. The rules in /lib are the defaults, and the rules in /etc are overrides. A full explanation of the rules would be tedious, and you can learn much more from the udev(7) manual page, but here is some basic information about how udevd reads them:<br>
<br>udevd reads rules from start to finish of a rules file.
<br>After reading a rule and possibly executing its action, udevd<br>
continues reading the current rules file for more applicable rules.
<br>There are directives (such as GOTO) to skip over parts of rules files<br>
if necessary. These are usually placed at the top of a rules file to skip over the entire file if itâ€™s irrelevant to a particular device that udevd is configuring.
<br>Letâ€™s look at the symbolic links from the /dev/sda example. Those links were defined by rules in /lib/udev/rules.d/60-persistent-storage.rules. Inside, youâ€™ll see the following lines:<br># ATA
KERNEL=="sd*[!0-9]|sr*", ENV{ID_SERIAL}!="?*", SUBSYSTEMS=="scsi",
ATTRS{vendor}=="ATA", IMPORT{program}="ata_id --export $devnode"
# ATAPI devices (SPC-3 or later)
KERNEL=="sd*[!0-9]|sr*", ENV{ID_SERIAL}!="?*", SUBSYSTEMS=="scsi",
ATTRS{type}=="5",ATTRS{scsi_level}=="[6-9]*", IMPORT{program}="ata_id --
export $devnode"
Copy<br>These rules match ATA disks and optical media presented through the kernelâ€™s SCSI subsystem. You can see that there are a few rules to catch different ways the devices may be represented, but the idea is that udevd will try to match a device starting with sd or sr but without a number (with the KERNEL =="sd*[!0-9]|sr*" expression), as well as a subsystem (SUBSYSTEMS=="scsi"), and, finally, some other attributes, depending on the type of device. If all of those conditional expressions are true in either of the rules, udevd moves to the next and final expression:<br>IMPORT{program}="ata_id --export $tempnode"
Copy<br>This is not a conditional. Instead, itâ€™s a directive to import variables from the /lib/udev/ata_id command. If you have such a disk, try it yourself on the command line. It will look like this:<br># /lib/udev/ata_id --export /dev/sda
ID_ATA=1
ID_TYPE=disk
ID_BUS=ata
ID_MODEL=WDC_WD3200AAJS-22L7A0
ID_MODEL_ENC=WDC\x20WD3200AAJS22L7A0\x20\x20\x20\x20\x20\x20\x20\x20\x20
\x20
\x20\x20\x20\x20\x20\x20\x20\x20\x20
ID_REVISION=01.03E10
ID_SERIAL=WDC_WD3200AAJS-22L7A0_WD-WMAV2FU80671
--snip--
Copy<br>The import now sets the environment so that all of the variable names in this output are set to the values shown. For example, any rule that follows will now recognize ENV{ID_TYPE} as disk. In the two rules weâ€™ve seen so far, of particular note is ID_SERIAL. In each rule, this conditional appears second:<br>ENV{ID_SERIAL}!="?*"
Copy<br>This expression evaluates to true if ID_SERIAL is not set. Therefore, if ID_SERIAL is set, the conditional is false, the entire current rule does not apply, and udevd moves to the next rule.<br>
Why is this here? The purpose of these two rules is to run ata_id to find the serial number of the disk device and then add these attributes to the current working copy of the uevent. Youâ€™ll find this general pattern in many udev rules. With ENV{ID_SERIAL} set, udevd can now evaluate this rule later on in the rules file, which looks for any attached SCSI disks:<br>KERNEL=="sd*|sr*|cciss*", ENV{DEVTYPE}=="disk", ENV{ID_SERIAL}=="?
*",SYMLINK+="disk/by-id/$env{ID_BUS}-$env{ID_SERIAL}"
Copy<br>You can see that this rule requires ENV{ID_SERIAL} to be set, and it has one directive:<br>SYMLINK+="disk/by-id/$env{ID_BUS}-$env{ID_SERIAL}"
Copy<br>This directive tells udevd to add a symbolic link for the incoming device. So now you know where the device symbolic links came from! You may be wondering how to tell a conditional expression from a directive.]]></description><link>https://muqiuhan.github.io/wiki/computer-science/operating-system/linux/udevd-operation-and-configuration.html</link><guid isPermaLink="false">Computer Science/Operating System/Linux/udevd Operation and Configuration.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Fri, 22 Mar 2024 08:42:15 GMT</pubDate></item><item><title><![CDATA[FreeBSD å…è®¸é Root ç”¨æˆ·ä½¿ç”¨ 80 ç«¯å£]]></title><description><![CDATA[ 
 <br>In experimenting with FreeNAS jails I wanted to allow a web service to use port 80. Normally 80 is a high order port reserved for root-level processes for security reasons. Since this is a FreeBSD jail and not a full on system Iâ€™m not worried about this.<br>The command to do so is fairly simple (thanks to <a data-tooltip-position="top" aria-label="http://hyber.org/privbind.yaws" rel="noopener" class="external-link" href="http://hyber.org/privbind.yaws" target="_blank">this page</a> for information)<br>sysctl net.inet.ip.portrange.reservedhigh=0<br>The above command is not permanent; to make it so add it to /etc/sysctl.conf:<br>echo "net.inet.ip.portrange.reservedhigh=0" &gt;&gt; /etc/sysctl.conf]]></description><link>https://muqiuhan.github.io/wiki/computer-science/operating-system/freebsd-å…è®¸é-root-ç”¨æˆ·ä½¿ç”¨-80-ç«¯å£.html</link><guid isPermaLink="false">Computer Science/Operating System/FreeBSD å…è®¸é Root ç”¨æˆ·ä½¿ç”¨ 80 ç«¯å£.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Wed, 15 May 2024 05:54:22 GMT</pubDate></item><item><title><![CDATA[å¹¶è¡Œå¤„ç†çš„å†å²]]></title><description><![CDATA[ 
 <br>
åŸæ–‡ã€ŠParallel Processing, 1980 to 2020ã€‹Robert Kuhn, David Padua
]]></description><link>https://muqiuhan.github.io/wiki/computer-science/other/å¹¶è¡Œå¤„ç†çš„å†å²/å¹¶è¡Œå¤„ç†çš„å†å².html</link><guid isPermaLink="false">Computer Science/OTHER/å¹¶è¡Œå¤„ç†çš„å†å²/å¹¶è¡Œå¤„ç†çš„å†å².md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Fri, 22 Mar 2024 09:03:11 GMT</pubDate></item><item><title><![CDATA[å¤šçº¿ç¨‹ï¼Œçš„ä¸€ç‚¹å°æƒ³æ³•]]></title><description><![CDATA[ 
 <br>æ ‡å‡†çš„åšæ³•æ˜¯ï¼šå¦‚æœè®¡ç®—æœºæœ‰ 32 ä¸ªæ ¸å¿ƒï¼Œé‚£ä¹ˆå¼€ä¸€ä¸ª FIFO é˜Ÿåˆ—ï¼ŒæŠŠè¦è®¡ç®—çš„æ•°æ®æ‰”åˆ°è¿™ä¸ªé˜Ÿåˆ—é‡Œï¼Œç„¶åå¼€ 36 ä¸ªçº¿ç¨‹ï¼Œæ¯ä¸ªçº¿ç¨‹å»é˜Ÿåˆ—ä¸­å–æ•°æ®ï¼Œç®—å®Œä¸€ä¸ªå†å»é˜Ÿåˆ—ä¸­å–ä¸€ä¸‹ä¸ªæ•°æ®....ç›´åˆ°é˜Ÿåˆ—ä¸­æ²¡æ•°æ®ã€‚<br>CPU å¯†é›†å‹ä»»åŠ¡æ¯” CPU æ ¸å¿ƒæ•° (å¦‚æœ CPU æœ‰è¶…çº¿ç¨‹æŠ€æœ¯ï¼Œå¯ä»¥æŒ‰ç®—ä¸Šè¶…çº¿ç¨‹çš„æ ¸å¿ƒæ•°) ç•¥å¤šå‡ ä¸ªæ˜¯æœ€å¿«çš„ï¼Œè¿‡å¤šçš„çº¿ç¨‹åè€Œä¼šæ›´æ…¢ï¼Œæ²¡æœ‰ç©ºé—²çš„æ ¸å¿ƒï¼Œè¿‡å¤šçš„çº¿ç¨‹åªèƒ½ç­‰å¾…ï¼Œå¹¶æ²¡æœ‰å¹¶è¡Œè¿ç®—æ•ˆæœï¼Œåè€Œçº¿ç¨‹ä¸åœçš„åˆ‡æ¥åˆ‡å»ï¼Œæµªè´¹æ€§èƒ½ï¼Œé€šå¸¸æ¯æ¬¡åˆ‡æ¢è¿‡ç¨‹éœ€è¦è€—è´¹å¤§çº¦ 1000 ä¸ª CPU æ—¶é’Ÿå‘¨æœŸã€‚<br>ç•¥å¤šå‡ ä¸ªçš„åŸå› æ˜¯ï¼ŒCPU åœ¨çœŸæ­£è¿ç®—å¼€å§‹å‰ï¼Œéœ€è¦ç­‰å¾…æ•°æ®è¢«è£…å…¥å¯„å­˜å™¨ï¼Œè€Œæ•°æ®ä»å†…å­˜è£…å…¥å¯„å­˜å™¨ï¼Œä¹Ÿéœ€è¦ä¸€äº›æ—¶é—´ï¼Œç•¥å¤šå‡ ä¸ªï¼Œå¯ä»¥è®© CPU åœ¨ç­‰å¾…æ•°æ®å°±ç»ªæ—¶ï¼Œåˆ‡æ¢åˆ°æ•°æ®å·²ç»å°±ç»ªçš„çº¿ç¨‹ä¸Šå¼€å§‹è¿ç®—ã€‚ (å¤šå‘å°„çš„ä¹±åºæ‰§è¡Œä¹Ÿæ˜¯è§£å†³å†…å­˜é€Ÿåº¦è·Ÿä¸ä¸Šcpuçš„ä¸€ç§æœ‰æ•ˆæ‰‹æ®µï¼Œä½†æ˜¯å¹¶ä¸æ˜¯åˆ‡æ¢åˆ°å¦ä¸€ä¸ªçº¿ç¨‹)<br>å¦‚æœæ•°æ®åœ¨å†…å­˜ä¸­è¿ç»­ï¼Œæ•°æ®é‡ä¸å¤§ (ç›¸å¯¹CPUé«˜é€Ÿç¼“å­˜) ï¼Œé‚£ä¹ˆè£…è½½æ•°æ®åˆ°å¯„å­˜å™¨çš„å¼€é”€å°±ä¼šæ¯”è¾ƒå°ï¼Œå°±å¯ä»¥é™„åŠ å°‘ä¸€ç‚¹çš„çº¿ç¨‹ï¼Œæ¯”å¦‚ 1~2 ä¸ªå°±å¤Ÿäº†ï¼Œåä¹‹ï¼Œæ•°æ®åˆ†æ•£ï¼Œç¼“å­˜å‘½ä¸­ç‡ä½ï¼Œå°±éœ€è¦å¤šå‡ ä¸ªçº¿ç¨‹ï¼Œæ¯”å¦‚ 6~8 ä¸ªã€‚<br>å¦å¤–ï¼Œè¿˜å¯ä»¥è€ƒè™‘ä½¿ç”¨ SIMD åŠ é€Ÿè®¡ç®—ï¼Œå¦‚æœæ•°æ®é‡å†å¤šï¼Œè¿˜å¯ä»¥è€ƒè™‘CUDA-GPUåŠ é€Ÿã€‚]]></description><link>https://muqiuhan.github.io/wiki/computer-science/other/å¤šçº¿ç¨‹ï¼Œçš„ä¸€ç‚¹å°æƒ³æ³•.html</link><guid isPermaLink="false">Computer Science/OTHER/å¤šçº¿ç¨‹ï¼Œçš„ä¸€ç‚¹å°æƒ³æ³•.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Mon, 13 May 2024 00:50:32 GMT</pubDate></item><item><title><![CDATA[C++ 20 å®ç° string split]]></title><description><![CDATA[ 
 <br>C++20å¼•å…¥äº†èŒƒå›´åº“rangesï¼Œå…¶ä¸­æä¾›çš„ä¸¤ä¸ªèŒƒå›´é€‚é…å™¨std::splitã€std::lazy_splitå¯ä»¥ä½¿æˆ‘ä»¬ä»¥ä¸€ç§æ›´ä¸ºä¼˜é›…çš„å½¢å¼å®ç°split:<br>#include &lt;concept&gt;
#include &lt;ranges&gt;
#include &lt;algorithm&gt;
#include &lt;format&gt;
#include &lt;iostream&gt;

#define stdr  std::ranges
#define stdrv std::ranges::views

template&lt;template&lt;typename&gt; typename Container = std::vector, typename Arg = std::string_view&gt;
auto Split(std::string_view str, std::string_view delimiter)
{
	Container&lt;Arg&gt; myCont;
	auto temp = str 
		| stdrv::split(delimiter)
		| stdrv::transform([](auto&amp;&amp; r)
			{
				return Arg(std::addressof(*r.begin()), stdr::distance(r));
			});
	auto iter = std::inserter(myCont, myCont.end());
	stdr::for_each(temp, [&amp;](auto&amp;&amp; x) { iter = {x.begin(), x.end()}; });
	return myCont;
}
int main()
{
	std::string str = "Hello233C++20233and233New233Spilt";
	std::string delimiter = "233";
	auto&amp;&amp; strCont = Split&lt;std::list, std::string&gt;(str, delimiter);
	stdr::for_each(strCont, [](auto&amp;&amp; x) { std::cout &lt;&lt; std::format("{} ", x); });
}
//output: Hello C++20 and New Spilt
Copy<br>C++20æ²¡æœ‰æä¾›å…³é”®çš„ ranges::to&lt;container&gt;å‡½æ•°ï¼Œå¯¼è‡´demoä¸­è¿˜éœ€è¦é¢å¤–å°è£…å¹¶æ‰‹å†™for_eachæ¥å†™å…¥æ•°æ®ï¼Œç­‰åˆ°C++23å®è£…äº†è¯¥å‡½æ•°ï¼Œsplitçš„å®ç°ä¼šæ¯”ç°åœ¨ç®€æ´ä¼˜é›…çš„å¤šï¼ŒçœŸæ­£åšåˆ°æ–¹ä¾¿æ³›ç”¨ã€æ— éœ€å°è£…ï¼š<br>auto&amp;&amp; strCont = str
	| stdrv::lazy_split(delimiter)
	| stdr ::to&lt;std::vector&lt;std::string&gt;&gt;;
Copy]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/c++/c++-20-å®ç°-string-split.html</link><guid isPermaLink="false">Computer Science/Programming Language/C++/C++ 20 å®ç° string split.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Fri, 22 Mar 2024 09:03:04 GMT</pubDate></item><item><title><![CDATA[C++ vector çš„ push_back å’Œ emplace_back]]></title><description><![CDATA[ 
 <br>/// Inserts a new element at the end of the vector, right after its current last element. This new element is constructed in place using args as the arguments for its constructor.
/// This effectively increases the container size by one, which causes an automatic reallocation of the allocated storage space if -and only if- the new vector size surpasses the current vector capacity.
/// The element is constructed in-place by calling allocator_traits::construct with args forwarded.
///A similar member function exists, push_back, which either copies or moves an existing object into the container.
template &lt;class... Args&gt;
void emplace_back (Args&amp;&amp;... args);
Copy<br>push_back ä¼šæ„é€ ä¸€ä¸ªä¸´æ—¶å¯¹è±¡ï¼Œè¿™ä¸ªä¸´æ—¶å¯¹è±¡ä¼šè¢«æ‹·è´æˆ–è€…ç§»å…¥åˆ°å®¹å™¨ä¸­ï¼Œç„¶è€Œ emplace_back ä¼šç›´æ¥æ ¹æ®ä¼ å…¥çš„å‚æ•°åœ¨å®¹å™¨çš„é€‚å½“ä½ç½®è¿›è¡Œæ„é€ è€Œé¿å…æ‹·è´æˆ–è€…ç§»åŠ¨ã€‚<br>ä¼ ç»Ÿè§‚ç‚¹è®¤ä¸º push_back ä¼šæ„é€ ä¸€ä¸ªä¸´æ—¶å¯¹è±¡ï¼Œè¿™ä¸ªä¸´æ—¶å¯¹è±¡ä¼šè¢«ç§»å…¥åˆ° v ä¸­ï¼Œç„¶è€Œ emplace_back ä¼šç›´æ¥æ ¹æ®ä¼ å…¥çš„å‚æ•°åœ¨é€‚å½“ä½ç½®è¿›è¡Œæ„é€ è€Œé¿å…æ‹·è´æˆ–è€…ç§»åŠ¨ã€‚ä»æ ‡å‡†åº“ä»£ç çš„å®ç°è§’åº¦æ¥è¯´è¿™æ˜¯å¯¹çš„ï¼Œä½†æ˜¯å¯¹äºæä¾›äº†ä¼˜åŒ–çš„ç¼–è¯‘å™¨æ¥è®²ï¼Œä¸Šé¢ç¤ºä¾‹ä¸­æœ€åä¸¤è¡Œè¡¨è¾¾å¼ç”Ÿæˆçš„ä»£ç å…¶å®æ²¡æœ‰åŒºåˆ«ã€‚<br>çœŸæ­£çš„åŒºåˆ«åœ¨äºï¼Œemplace_back æ›´åŠ å¼ºå¤§ï¼Œå®ƒå¯ä»¥è°ƒç”¨ä»»ä½•ç±»å‹çš„ï¼ˆåªè¦å­˜åœ¨ï¼‰æ„é€ å‡½æ•°ã€‚è€Œ push_back ä¼šæ›´åŠ ä¸¥è°¨ï¼Œå®ƒåªè°ƒç”¨éšå¼æ„é€ å‡½æ•°ã€‚éšå¼æ„é€ å‡½æ•°è¢«è®¤ä¸ºæ˜¯å®‰å…¨çš„ã€‚å¦‚æœèƒ½å¤Ÿé€šè¿‡å¯¹è±¡ T éšå¼æ„é€ å¯¹è±¡ Uï¼Œå°±è®¤ä¸º U èƒ½å¤Ÿå®Œæ•´åŒ…å« T çš„æ‰€æœ‰å†…å®¹ï¼Œè¿™æ ·å°† T ä¼ é€’ç»™ U é€šå¸¸æ˜¯å®‰å…¨çš„ã€‚æ­£ç¡®ä½¿ç”¨éšå¼æ„é€ çš„ä¾‹å­æ˜¯ç”¨ std::uint32_t å¯¹è±¡æ„é€  std::uint64_t å¯¹è±¡ï¼Œé”™è¯¯ä½¿ç”¨éšå¼æ„é€ çš„ä¾‹å­æ˜¯ç”¨ double æ„é€  std::uint8_tã€‚<br>å¦‚æœæƒ³è¦è°ƒç”¨æ˜¾ç¤ºæ„é€ å‡½æ•°ï¼Œé‚£ä¹ˆå°±è°ƒç”¨ emplace_backã€‚å¦‚æœåªå¸Œæœ›è°ƒç”¨éšå¼æ„é€ å‡½æ•°ï¼Œé‚£ä¹ˆè¯·ä½¿ç”¨æ›´åŠ å®‰å…¨çš„ push_back:<br>std::vector&lt;std::unique_ptr&lt;T&gt;&gt; v;
T a;
v.emplace_back(std::addressof(a)); // compiles
v.push_back(std::addressof(a)); // fails to compile
Copy<br>std::unique_ptr&lt;T&gt; åŒ…å«äº†æ˜¾ç¤ºæ„é€ å‡½æ•°é€šè¿‡ T* è¿›è¡Œæ„é€ ã€‚å› ä¸º emplace_back èƒ½å¤Ÿè°ƒç”¨æ˜¾ç¤ºæ„é€ å‡½æ•°ï¼Œæ‰€ä»¥ä¼ é€’ä¸€ä¸ªè£¸æŒ‡é’ˆå¹¶ä¸ä¼šäº§ç”Ÿç¼–è¯‘é”™è¯¯ã€‚ç„¶è€Œï¼Œå½“ v è¶…å‡ºäº†ä½œç”¨åŸŸï¼Œstd::unique_ptr&lt;T&gt; çš„ææ„å‡½æ•°ä¼šå°è¯• delete ç±»å‹ T* çš„æŒ‡é’ˆï¼Œè€Œç±»å‹ T* çš„æŒ‡é’ˆå¹¶ä¸æ˜¯é€šè¿‡ new æ¥åˆ†é…çš„ï¼Œå› ä¸ºå®ƒä¿å­˜çš„æ˜¯æ ˆå¯¹è±¡çš„åœ°å€ï¼Œå› æ­¤ delete è¡Œä¸ºæ˜¯æœªå®šä¹‰çš„ã€‚]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/c++/c++-vector-çš„-push_back-å’Œ-emplace_back.html</link><guid isPermaLink="false">Computer Science/Programming Language/C++/C++ vector çš„ push_back å’Œ emplace_back.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Mon, 13 May 2024 03:10:10 GMT</pubDate></item><item><title><![CDATA[C++ çš„ Trait]]></title><description><![CDATA[ 
 <br>
C++ çš„ traits æŠ€æœ¯ï¼Œæ˜¯ä¸€ç§çº¦å®šä¿—ç§°çš„æŠ€æœ¯æ–¹æ¡ˆï¼Œç”¨æ¥ä¸ºåŒä¸€ç±»æ•°æ®ï¼ˆåŒ…æ‹¬è‡ªå®šä¹‰æ•°æ®ç±»å‹å’Œå†…ç½®æ•°æ®ç±»å‹ï¼‰æä¾›ç»Ÿä¸€çš„ç±»å‹åï¼ˆtraitsï¼‰ï¼Œè¿™æ ·å¯ä»¥ç»Ÿä¸€çš„æ“ä½œå‡½æ•°ï¼Œä¾‹å¦‚ advance(), swap(), encode()/decode() ç­‰ã€‚
<br>ä¾‹å¦‚ï¼Œæ‹¥æœ‰ä¹‰ç±»å‹Foo, Barï¼Œä»¥åŠç¼–è¯‘å™¨è‡ªå¸¦ç±»å‹ int, double, stringï¼Œæˆ‘ä»¬æƒ³è¦ä¸ºè¿™äº›ä¸åŒçš„ç±»å‹æä¾›ç»Ÿä¸€çš„ç¼–ç å‡½æ•° decode() ã€‚<br>é™¤äº†ä½¿ç”¨ trait æŠ€æœ¯ä¹‹å¤–ï¼Œå‡½æ•°é‡è½½å’Œæ¨¡æ¿å‡½æ•° + å†…ç½®å­—æ®µä¹Ÿå¯ä»¥å®ç°ï¼Œå‰è€…æ¯å¢åŠ ä¸€ç§æ•°æ®ç±»å‹å°±éœ€è¦é‡æ–°å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œè€ŒåŒä¸€ç±»æ•°æ®ï¼ˆint, unsinged intï¼‰å¯ä»¥ä½¿ç”¨åŒæ ·çš„ç¼–ç æ–¹æ³•ã€‚æˆ‘ä»¬æƒ³è¦çš„æ˜¯é’ˆå¯¹åŒä¸€ç§æ•°æ®ç±»å‹ï¼Œåªç¼–å†™ä¸€ä¸ªå‡½æ•°ã€‚åè€…å¯¹äºç³»ç»Ÿè‡ªå®šä¹‰å˜é‡ int, double è€Œè¨€ï¼Œæ˜¯æ— æ³•åœ¨å…¶å†…éƒ¨å®šä¹‰ type çš„ã€‚<br>traits æŠ€æœ¯çš„å…³é”®åœ¨äºï¼Œä½¿ç”¨å¦å¤–çš„æ¨¡æ¿ç±» type_traits æ¥ä¿å­˜ä¸åŒæ•°æ®ç±»å‹çš„ typeï¼Œè¿™æ ·å°±å¯ä»¥å…¼å®¹è‡ªå®šä¹‰æ•°æ®ç±»å‹å’Œå†…ç½®æ•°æ®ç±»å‹:<br>// å®šä¹‰æ•°æ® type ç±»
enum Type {
  TYPE_1,
  TYPE_2,
  TYPE_3
}
Copy<br>å¯¹äºè‡ªå®šä¹‰ç±»å‹ï¼Œåœ¨ç±»å†…éƒ¨å®šä¹‰ typeï¼Œç„¶ååœ¨ traits ç±»ä¸­å®šä¹‰åŒæ ·çš„ type:<br>// è‡ªå®šä¹‰æ•°æ®ç±»å‹
class Foo {
public:
  Type type = TYPE_1;
};
class Bar {
public:
  Type type = TYPE_2;
};
template&lt;typename T&gt;
struct type_traits {
  Type type = T::type;
}
Copy<br>å¯¹äºå†…ç½®æ•°æ®ç±»å‹ï¼Œä½¿ç”¨æ¨¡æ¿ç±»çš„ç‰¹åŒ–ä¸ºè‡ªå®šä¹‰ç±»å‹ç”Ÿæˆç‹¬æœ‰çš„ type_traits:<br>// å†…ç½®æ•°æ®ç±»å‹
template&lt;typename int&gt;
struct type_traits {
  Type type = Type::TYPE_1;
}
template&lt;typename double&gt;
struct type_traits {
  Type type = Type::TYPE_3;
}
Copy<br>è¿™æ ·å°±å¯ä»¥ä¸ºä¸åŒæ•°æ®ç±»å‹ç”Ÿæˆç»Ÿä¸€çš„æ¨¡æ¿å‡½æ•°<br>// ç»Ÿä¸€çš„ç¼–ç å‡½æ•°
template&lt;typename T&gt;
void decode&lt;const T&amp; data, char* buf) {
  if(type_traits&lt;T&gt;::type == Type::TYPE_1) {
    ...
  }
  else if(type_traits&lt;T&gt;::type == Type::TYPE_2) {
    ...
  }
}
Copy<br>æ€»ç»“<br>
<br>traits æŠ€æœ¯çš„å…³é”®åœ¨äºä½¿ç”¨ç¬¬ä¸‰æ–¹æ¨¡æ¿ç±» traitsï¼Œåˆ©ç”¨æ¨¡æ¿ç‰¹åŒ–çš„åŠŸèƒ½, å®ç°å¯¹è‡ªå®šä¹‰æ•°æ®å’Œç¼–è¯‘å™¨å†…ç½®æ•°æ®çš„ç»Ÿä¸€
<br>è¿™ä¸ªä¾‹å­ä½¿ç”¨äº†æšä¸¾å˜é‡æ¥è¡¨ç¤ºæ•°æ®ç±»å‹ï¼Œè€Œå®é™…æ“ä½œä¸­é€šå¸¸ä½¿ç”¨ä¸åŒçš„ç±»æ¥è¡¨ç¤ºä¸åŒçš„ç±»å‹ï¼Œè¿™æ ·å¯ä»¥åœ¨ç¼–å†™æ¨¡æ¿å‡½æ•°æ—¶æ›´å¥½çš„ä¼˜åŒ–ã€‚
<br>tratis æŠ€æœ¯å¸¸è§äºæ ‡å‡†åº“çš„å®ç°ä¸­ï¼Œä½†å¯¹æ—¥å¸¸å¼€å‘ä¸­é™ä½ä»£ç å†—ä½™ä¹Ÿæœ‰å¾ˆå¥½çš„å€Ÿé‰´æ„ä¹‰
<br>C++20 æä¾›äº†Concept çš„ç‰¹æ€§ï¼Œä½¿ç”¨Concept å¯ä»¥ä½¿å¾—å®ç°ç±»ä¼¼çš„åŠŸèƒ½æ›´åŠ æ–¹ä¾¿
]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/c++/c++-çš„-trait.html</link><guid isPermaLink="false">Computer Science/Programming Language/C++/C++ çš„ Trait.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 12 May 2024 12:49:46 GMT</pubDate></item><item><title><![CDATA[My fading frustration with ClojureScript]]></title><description><![CDATA[ 
 <br>Iâ€™ve talked about <a data-tooltip-position="top" aria-label="https://mauricio.szabo.link/blog/2018/04/05/my-frustration-with-clojurescript/" rel="noopener" class="external-link" href="https://mauricio.szabo.link/blog/2018/04/05/my-frustration-with-clojurescript/" target="_blank">at another post</a> on how ClojureScript frustrates me, mostly because I was doing some Node.JS work and Figwheel simply wasnâ€™t working correctly. Now, itâ€™s time to revisit these points:<br>A little update: I talked a little with Thomas Heller, Shadow-CLJS creator, and he pointed me some issues with this article, so Iâ€™ll update it acordingly<br><br>Figwheel and Lein are not the best tools to work with ClojureScript. Since I discovered shadow-cljs, things are working way better than before: I can reload ClojureScript code from any target, and Iâ€™m even experimenting with Hubot (and it works really fine too). The only thing Iâ€™m missing is my profiles.clj file, but I can live with that (and I can always use Shadow with Lein if I need profiles.clj).<br>Also, Iâ€™m working on a new package for Atom (and in the future, for another editors too) called <a data-tooltip-position="top" aria-label="http://github.com/mauricioszabo/atom-chlorine/" rel="noopener" class="external-link" href="http://github.com/mauricioszabo/atom-chlorine/" target="_blank">Chlorine</a>. One of the ideas is to offer better ClojureScript support (we have Autocomplete now!), using Socket REPL for solutions (even self-hosted REPLs like Lumo and Plank) and even wrap UNREPL protocol in Clojure. So far, is still in the very beginning but things are looking promising!<br><br>Forget Figwheel at all: Shadow-CLJS is probably the best tooling for ClojureScript ever. It auto-reloads ClojureScript code for the browser, for node.js, for node modules, and it integrates with almost everything that you want. It controls release optimizations, have sensible defaults, and even have post-compile hooks (so you can hook Clojure code to do something after some compilation phases). Also, it integrates with node-modules (no more maven-wrappers for JS libraries!) and have some warnings when you use some kind of ClojureScript code that would break :advanced compilation. And, letâ€™s not forget that you can control the refresh reload phase, it adds a userful :include-macros in ns form (that will include all macros from the namespace being required), and controls exports in a sane manner. But first letâ€™s begin with the feature that I found most useful: :before-load-async.  <br>When youâ€™re developing ClojureScript code, one of the killer features is the abilty to reload your code after save, so at any moment you have the most recent version of your code running. Letâ€™s see how it works in practice: imagine youâ€™re developing a simple static website (no react, no vue.js, nothing â€“ just a simple site thatâ€™ll calculate the sum of two input boxes). You already have the HTML file with two input boxes (IDs â€œn1â€ and â€œn2â€) and a â€œresultsâ€ div. Youâ€™ll want to add Shadow-CLJS in this project.<br>Simple: just npm install shadow-cljs, then npx shadow-cljs init, and edit the shadow-cljs.edn file. Youâ€™ll want to add a build targeting browser, so the file will look like this:<br><br>Most of the keys should be self-explanatory. The ones that are not are:<br>
<br>:asset-path mostly says that, relative to the root of your webserver, where assets will be put â€“ for instance, suppose that your webserver will load static assets from the public directory. Then, your config will be :output-dir "public/js", so that the compiler will generate code in a folder that your webserver will be able to serve, and :asset-path "js", so the compiler will generate â€œrequiresâ€ relative to â€œjsâ€ folder, not â€œpublic/jsâ€
<br>:devtools registers a â€œhook functionâ€ thatâ€™ll be called when Shadow-CLJS have compiled the source paths, and it is ready to reload our code. This â€œreload functionâ€ will receive a parameter (letâ€™s call it done) that, when called, it informs shadow-cljs that itâ€™s time to use the new versions of our functions. So, letâ€™s first look at the main function:
<br><br>You can start our compiler with npx shadow-cljs watch app, and yes, weâ€™re using jQuery. Also, thereâ€™s a prn function thatâ€™ll be used to debug. If you include js/main.js as a script in your webpage, this code will work â€“ but itâ€™ll not reload. So, after these functions, we can add our reload function thatâ€™ll just call our main function after informing shadow that we did our cleanup:<br><br>If you change your code in any way â€“ maybe change the math operation to multiplication â€“ youâ€™ll see that our page changes correctly. Youâ€™ll also see, in the console, that weâ€™re printing our numbers twice per change. This is because jQueryâ€™s .on method stacks callbacks: this means that weâ€™re still listening to our old code. What we have to do is to clean our callbacks before reloading our code, and this is quite simple with Shadow:<br><br>UPDATE: As Thomas Heller told me, :before-load-async is used do signal my application that a reload is due, so I can control what to happen before the reload, and also to inform shadow that it can continue reloading our code. If we do any async stuff to reload code â€“ letâ€™s say, resolve a promise (something like (-&gt; clear-things (.then done)) â€“ or if the reload uses some async code, this will not work. In this case, itâ€™s better to register another callback, :after-load, and use it to re-activate our code, something like:<br><br><br>Now, this probably misses some points about why this is completely awesome. So, letâ€™s imagine a different use-case: a reload function for an Atom editorâ€™s package. In Atom, almost every side-effect function that you can call will return an Disposable object: one that you can dispose and nullify the effect (for instance, if you listen to changes in an editor, you can .dispose() those changes and un-listen to changes).<br>What you can do is to create a CompositeDisposable, and when you refresh, you .dispose everything, re-creates the CompositeDisposable, then re-adds your effects. This means that while youâ€™re developing your plug-in, you can stop subscriptions, delete your commands, add new commands to editor, re-load subscriptions, all just saving your code. If this is not awesome, I donâ€™t really know what it is. The code to do it is surprisingly simple:<br><br>For projects like Atom or other editorsâ€™ plug-ins (like VSCode, NeoVim, Oni) this give a temendous power. Also, this can be used while developing extensions for browsers, or projects when itâ€™s tedious to unload everything, reload everything, just to see you have called a function with the arguments swappedâ€¦<br><br>With a simple npx shadow-cljs release app, Shadow will try to compile your code with :advanced optimizations. But sometimes, this wonâ€™t work: imagine that in our jQuery example, :advanced will rename jQuery to something else, so things will not work. There are two options you can use: inside your build id (in our case, :app) you can add the key :compiler-options {:infer-externs :auto}. This will throw an warning when youâ€™re using code that Shadow-CLJS canâ€™t infer. Also, you can use npx shadow-cljs release --debug app to compile with :advanced features, but will pretty-print files and will make meaningful names (so you can debug where things went wrong).<br>This is not exclusive of Shadow-CLJS, but the compiler just make easier to access these options. Now, what is exclusive from Shadow-CLJS is an extension to ns form (UPDATE: it is not. As Thomas told me, it uses a different implementation and have more checks, but it works in CLJS too):<br><br>This means no more :refer-macros or :require-macros. This magically finds the macros in that required namespace, and allows then to be used in the current ns. Simpler code, less things to remember, and cleaner. Also, I never had the compiler problems that I had with figwheel â€“ that it compiles a version, then sometime later you clean things and it didnâ€™t compile anymore. Or, that it compiles a version, and thereâ€™s a runtime exception with a compiler error.<br>Yet, for now, there are still problems with .cljc files that have macros, and some toolings that I was unable to make it work (cljs-complete being one of the most critical for me). Even with these limitations, developing with ClojureScript is now my primary choice for JS projects (when I can choose), even if thereâ€™s already JS code in production (because it integrates with existing code like a breeze too). It wasnâ€™t before, and this was all thanks to a better tooling.<br>So yes, tools make all the difference!]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/clojure/my-fading-frustration-with-clojurescript.html</link><guid isPermaLink="false">Computer Science/Programming Language/Clojure/My fading frustration with ClojureScript.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Mon, 15 Jan 2024 12:10:29 GMT</pubDate></item><item><title><![CDATA[Building a self-contained game in CSharp under 8 kilobytes]]></title><description><![CDATA[ 
 <br><br>Jan 03, 2020<br>28 minute read<br>
NOTE: This article captures a point in time in the past. While the general information is still correct, the CoreRT project got folded into <a data-tooltip-position="top" aria-label="https://learn.microsoft.com/dotnet/core/deploying/native-aot/" rel="noopener" class="external-link" href="https://learn.microsoft.com/dotnet/core/deploying/native-aot/" target="_blank">Native AOT publishing</a> in .NET 7 and is now a supported part of .NET. The information about sizes is no longer accurate (and much better), neither is the information about support for dynamic code (both interpreter and JIT are unsupported).
<br>As someone who grew up in the times of 1.44 MB floppy disks and 56 kbit modems, Iâ€™ve always liked small programs. I could fit many small programs on a floppy disk I carried with me. If a program couldnâ€™t fit on my floppy disk, I started thinking about whyâ€Š-â€Šdoes it have a lot of graphics? Is there music? Can the program do many complex things? Or is it simply bloated?<br><a data-tooltip-position="top" aria-label="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/01-floppies.jpg" rel="noopener" class="external-link" href="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/01-floppies.jpg" target="_blank"></a><img alt="3.5&quot; floppies, photo by Brett Jordan on Unsplash" src="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/01-floppies.jpg" referrerpolicy="no-referrer"><br>3.5" floppies, photo by Brett Jordan on Unsplash<br>These days, disk space became so cheap (and huge flashdrives so ubiquitous) that people gave up on optimizing for size.<br>One place where size still matters is transfers: when transferring a program over a wire, megabytes equate to seconds. A fast 100 MBit connection can only push through 12 megabytes per second in the best case. If on the other end of the wire is a person waiting for a download to finish, the difference between five seconds and one second can have meaningful impact on their experience.<br>The person could be exposed to the transfer times either directly (user is downloading a program over network), or indirectly (a serverless service is getting deployed to respond to a web request).<br>People typically perceive anything faster than 0.1 seconds as instant, 3.0 seconds is about the limit for userâ€™s flow to stay uninterrupted, and you would have a hard time to keep the user engaged after 10 seconds.<br>
While smaller is not essential anymore, itâ€™s still better.
<br>This article came out as an experiment to find out just how small a useful self-contained C# executable can be. Can C# apps hit the sizes where users would consider the download times instant? Would it enable C# to be used in places where it isnâ€™t used right now?<br><br>A self-contained application is an application that includes everything thatâ€™s necessary for it to run on a vanilla installation of the operating system.<br>The C# compiler belongs to a group of compilers targeting a virtual machine (Java and Kotlin being another notable members of the group): the output of the C# compiler is an executable that requires some sort of virtual machine (VM) to execute. One canâ€™t just install a barebone operating system and expect to be able to run programs produced by the C# compiler on it.<br>At least on Windows, it used to be the case that one could rely on a machine-wide installation of the .NET Framework to run the outputs of the C# compiler. Nowadays there are many Windows SKUs that no longer carry the framework with it (IoT, Nano Server, ARM64,â€¦). .NET Framework also doesnâ€™t support the latest enhancements to the C# language. Itâ€™s kind of on its way out.<br>For a C# app to be self-contained, it needs to include the runtime and all the class libraries it uses. Itâ€™s a lot of stuff to fit into the 8 kB that we budget for!<br><br>Weâ€™re going to build a clone of the Snake game. Hereâ€™s the finished product:<br><a data-tooltip-position="top" aria-label="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/02-snake.gif" rel="noopener" class="external-link" href="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/02-snake.gif" target="_blank"></a><img alt="Snake game" src="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/02-snake.gif" referrerpolicy="no-referrer"><br>Snake game<br>If youâ€™re not interested in the game mechanics, feel free to skip over to the interesting parts where we shrink the game from 65 megabytes to 8 kilobytes in 9 steps (scroll down to where you see graphs).<br>The game will run in text mode and weâ€™ll use the box drawing characters to draw the snake. Iâ€™m sure Vulcan or DirectX would be a lot more fun, but weâ€™ll get by with System.Console.<br><br>Weâ€™re going to build a no-allocation gameâ€Š-â€Šand by no-allocation I donâ€™t mean the â€œdonâ€™t allocate in the game loopâ€ that is common among C# game devs. I mean â€œthe new keyword with reference types is forbidden in the entire codebaseâ€. The reasons for that will become apparent at the final stretch of shrinking the game.<br>With such restriction in place, one might wonder if thereâ€™s any point in using C# after all: without the new keyword, we wonâ€™t be using the garbage collector, we canâ€™t throw exceptions, etc.â€Š-â€Ša language like C would work just as well.<br>One reason to use C# is â€œbecause we canâ€. The other reason is testability and code sharingâ€Š-â€Šwhile the game as a whole is no-allocation, it doesnâ€™t mean that parts of it couldnâ€™t be reused in a different project that doesnâ€™t have such constrains. For example, parts of the game could be included from an xUnit project to get unit test coverage. If one chooses C to build the game, things have to stay constrained by what C can do even when the code is reused from elsewhere. But since C# provides a good mix of high level and low level constructs, we can follow the â€œhigh level by default, low level when necessaryâ€ philosophy.<br>To reach the 8 kB deployment size, the low level part will be necessary.<br><br>Letâ€™s start with a struct that represents the frame buffer. Frame buffer is a component that holds the pixels (or in this case characters) to be drawn to the screen.<br>unsafe struct FrameBuffer
{
    public const int Width = 40;
    public const int Height = 20;
    public const int Area = Width * Height;

    fixed char _chars[Area];

    public void SetPixel(int x, int y, char character)
    {
        _chars[y * Width + x] = character;
    }

    public void Clear()
    {
        for (int i = 0; i &lt; Area; i++)
            _chars[i] = ' ';
    }

    public readonly void Render()
    {
        Console.SetCursorPosition(0, 0);

        const ConsoleColor snakeColor = ConsoleColor.Green;

        Console.ForegroundColor = snakeColor;

        for (int i = 1; i &lt;= Area; i++)
        {
            char c = _chars[i - 1];

            if (c == '*' || (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= 'a' &amp;&amp; c &lt;= 'z'))
            {
                Console.ForegroundColor = c == '*' ? ConsoleColor.Red : ConsoleColor.White;
                Console.Write(c);
                Console.ForegroundColor = snakeColor;
            }
            else
                Console.Write(c);

            if (i % Width == 0)
            {
                Console.SetCursorPosition(0, i / Width - 1);
            }
        }
    }
}
Copy<br>We provide methods to set individual pixels, clear the frame buffer, and to render the contents of the frame buffer into System.Console. The rendering step special cases a couple characters so that we get colorful output without having to keep track of color for each pixel of the frame buffer.<br>One interesting thing to call out is the fixed char _chars[Area] field: this is the C# syntax to declare a <a data-tooltip-position="top" aria-label="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/unsafe-code-pointers/fixed-size-buffers" rel="noopener" class="external-link" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/unsafe-code-pointers/fixed-size-buffers" target="_blank">fixed array</a>. A fixed array is an array whose individual elements are a part of the struct. You can think of it as a shortcut for a set of fields char _char_0, _char_1, _char_2, _char_3,... _char_Area that one can access as an array. The size of this array needs to be a compile time constant so that the size of the entire struct is fixed.<br>We canâ€™t go overboard with the size of a fixed array because being a part of a struct, the array needs to live on the stack and stacks tend to be limited to a small number of bytes (1 MB per thread, typically). But 40  20  2 bytes (width  height  sizeof(char)) should be fine.<br>Next thing we need is a random number generator. The one that comes with .NET is a reference type (for good reasons!) and we forbid ourselves the new keywordâ€Š-â€Šwe canâ€™t use it. A simple struct will do:<br>struct Random
{
    private uint _val;

    public Random(uint seed)
    {
        _val = seed;
    }

    public uint Next() =&gt; _val = (1103515245 * _val + 12345) % 2147483648;
}
Copy<br>This random number generator is not great, but we donâ€™t need anything sophisticated.<br>Now we only need something that wraps the snake logic. Time for a Snake struct:<br>struct Snake
{
    public const int MaxLength = 30;

    private int _length;

    // Body is a packed integer that packs the X coordinate, Y coordinate, and the character
    // for the snake's body.
    // Only primitive types can be used with C# `fixed`, hence this is an `int`.
    private unsafe fixed int _body[MaxLength];

    private Direction _direction;
    private Direction _oldDirection;

    public Direction Course
    {
        set
        {
            if (_oldDirection != _direction)
                _oldDirection = _direction;

            if (_direction - value != 2 &amp;&amp; value - _direction != 2)
                _direction = value;
        }
    }

    public unsafe Snake(byte x, byte y, Direction direction)
    {
        _body[0] = new Part(x, y, DirectionToChar(direction, direction)).Pack();
        _direction = direction;
        _oldDirection = direction;
        _length = 1;
    }

    public unsafe bool Update()
    {
        Part oldHead = Part.Unpack(_body[0]);
        Part newHead = new Part(
            (byte)(_direction switch
            {
                Direction.Left =&gt; oldHead.X == 0 ? FrameBuffer.Width - 1 : oldHead.X - 1,
                Direction.Right =&gt; (oldHead.X + 1) % FrameBuffer.Width,
                _ =&gt; oldHead.X,
            }),
            (byte)(_direction switch
            {
                Direction.Up =&gt; oldHead.Y == 0 ? FrameBuffer.Height - 1 : oldHead.Y - 1,
                Direction.Down =&gt; (oldHead.Y + 1) % FrameBuffer.Height,
                _ =&gt; oldHead.Y,
            }),
            DirectionToChar(_direction, _direction)
            );

        oldHead = new Part(oldHead.X, oldHead.Y, DirectionToChar(_oldDirection, _direction));

        bool result = true;

        for (int i = 0; i &lt; _length - 1; i++)
        {
            Part current = Part.Unpack(_body[i]);
            if (current.X == newHead.X &amp;&amp; current.Y == newHead.Y)
                result = false;
        }

        _body[0] = oldHead.Pack();

        for (int i = _length - 2; i &gt;= 0; i--)
        {
            _body[i + 1] = _body[i];
        }

        _body[0] = newHead.Pack();

        _oldDirection = _direction;

        return result;
    }

    public unsafe readonly void Draw(ref FrameBuffer fb)
    {
        for (int i = 0; i &lt; _length; i++)
        {
            Part p = Part.Unpack(_body[i]);
            fb.SetPixel(p.X, p.Y, p.Character);
        }
    }

    public bool Extend()
    {
        if (_length &lt; MaxLength)
        {
            _length += 1;
            return true;
        }
        return false;
    }

    public unsafe readonly bool HitTest(int x, int y)
    {
        for (int i = 0; i &lt; _length; i++)
        {
            Part current = Part.Unpack(_body[i]);
            if (current.X == x &amp;&amp; current.Y == y)
                return true;
        }

        return false;
    }

    private static char DirectionToChar(Direction oldDirection, Direction newDirection)
    {
        const string DirectionChangeToChar = "â”‚â”Œ?â”â”˜â”€â”??â””â”‚â”˜â””?â”Œâ”€";
        return DirectionChangeToChar[(int)oldDirection * 4 + (int)newDirection];
    }

    // Helper struct to pack and unpack the packed integer in _body.
    readonly struct Part
    {
        public readonly byte X, Y;
        public readonly char Character;

        public Part(byte x, byte y, char c)
        {
            X = x;
            Y = y;
            Character = c;
        }

        public int Pack() =&gt; X &lt;&lt; 24 | Y &lt;&lt; 16 | Character;
        public static Part Unpack(int packed) =&gt; new Part((byte)(packed &gt;&gt; 24), (byte)(packed &gt;&gt; 16), (char)packed);
    }

    public enum Direction
    {
        Up, Right, Down, Left
    }
}
Copy<br>The state that a snake needs to track is:<br>
<br>the coordinates of each pixel that represents the snakeâ€™s body,
<br>the current length of the snake,
<br>the current direction of the snake,
<br>past direction of the snake (in case we need to draw the â€œbendâ€ character instead of a straight line)
<br>The snake provides methods to Extend the length of snake by one (returns false if the snake is already at full length), to HitTest a pixel with the snakeâ€™s body, to Draw the snake into a FrameBuffer and to Update the snakeâ€™s position as a response to a game tick (returns false if the snake ate itself). Thereâ€™s also a property to set the current Course of the snake.<br>We use the same fixed array trick that we used in the frame buffer to keep the snake no-allocation. It means the maximum length of the snake has to be a compile time constant.<br>The last thing we need is the game loop:<br>struct Game
{
    enum Result
    {
        Win, Loss
    }

    private Random _random;

    private Game(uint randomSeed)
    {
        _random = new Random(randomSeed);
    }

    private Result Run(ref FrameBuffer fb)
    {
        Snake s = new Snake(
            (byte)(_random.Next() % FrameBuffer.Width),
            (byte)(_random.Next() % FrameBuffer.Height),
            (Snake.Direction)(_random.Next() % 4));

        MakeFood(s, out byte foodX, out byte foodY);

        long gameTime = Environment.TickCount64;

        while (true)
        {
            fb.Clear();

            if (!s.Update())
            {
                s.Draw(ref fb);
                return Result.Loss;
            }

            s.Draw(ref fb);

            if (Console.KeyAvailable)
            {
                ConsoleKeyInfo ki = Console.ReadKey(intercept: true);
                switch (ki.Key)
                {
                    case ConsoleKey.UpArrow:
                        s.Course = Snake.Direction.Up; break;
                    case ConsoleKey.DownArrow:
                        s.Course = Snake.Direction.Down; break;
                    case ConsoleKey.LeftArrow:
                        s.Course = Snake.Direction.Left; break;
                    case ConsoleKey.RightArrow:
                        s.Course = Snake.Direction.Right; break;
                }
            }

            if (s.HitTest(foodX, foodY))
            {
                if (s.Extend())
                    MakeFood(s, out foodX, out foodY);
                else
                    return Result.Win;
            }

            fb.SetPixel(foodX, foodY, '*');

            fb.Render();

            gameTime += 100;

            long delay = gameTime - Environment.TickCount64;
            if (delay &gt;= 0)
                Thread.Sleep((int)delay);
            else
                gameTime = Environment.TickCount64;
        }
    }

    void MakeFood(in Snake snake, out byte foodX, out byte foodY)
    {
        do
        {
            foodX = (byte)(_random.Next() % FrameBuffer.Width);
            foodY = (byte)(_random.Next() % FrameBuffer.Height);
        }
        while (snake.HitTest(foodX, foodY));
    }

    static void Main()
    {
        Console.SetWindowSize(FrameBuffer.Width, FrameBuffer.Height);
        Console.SetBufferSize(FrameBuffer.Width, FrameBuffer.Height);
        Console.Title = "See Sharp Snake";
        Console.CursorVisible = false;

        FrameBuffer fb = new FrameBuffer();

        while (true)
        {
            Game g = new Game((uint)Environment.TickCount64);
            Result result = g.Run(ref fb);

            string message = result == Result.Win ? "You win" : "You lose";

            int position = (FrameBuffer.Width - message.Length) / 2;
            for (int i = 0; i &lt; message.Length; i++)
            {
                fb.SetPixel(position + i, FrameBuffer.Height / 2, message[i]);
            }

            fb.Render();

            Console.ReadKey(intercept: true);
        }
    }
}
Copy<br>We use the random number generator to generate a random position and direction of the snake, we randomly place the food on the game surface, making sure it doesnâ€™t overlap the snake, and start the game loop.<br>Within the game loop we ask the snake to update its position and check whether it ate itself. We then draw the snake, check the keyboard for input, hit-test the snake with the food, and render everything to the console.<br>Thatâ€™s pretty much it. Letâ€™s see where we are in terms of size.<br><br>Iâ€™ve placed the game in <a data-tooltip-position="top" aria-label="https://github.com/MichalStrehovsky/SeeSharpSnake" rel="noopener" class="external-link" href="https://github.com/MichalStrehovsky/SeeSharpSnake" target="_blank">a GitHub repo</a> so that you can follow along. The project file will produce the game in different configurations depending on the Mode property passed to publish. To produce the default configuration with CoreCLR, run:<br>$ dotnet publish -r win-x64 -c Release
Copy<br>This will produce a single EXE file that has whopping 65 MB. The produced EXE includes the game, the .NET Runtime, and the base class libraries that are the standard part of .NET. You might say â€œstill better than Electronâ€ and call it good, but letâ€™s see if we can do better.<br><a data-tooltip-position="top" aria-label="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/03-graph1.png" rel="noopener" class="external-link" href="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/03-graph1.png" target="_blank"></a><img alt="Starting point" src="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/03-graph1.png" referrerpolicy="no-referrer"><br>Starting point<br><br>IL trimming shipped with .NET Core 3.0â€Š-â€Štrimming removes unused code from your app by scanning the entire program and removing assemblies that are unreferenced. To use it with the project, pass a PublishTrimmed property to publish. Like so:<br>$ dotnet publish -r win-x64 -c Release /p:PublishTrimmed=true
Copy<br>With this setting, the game shrinks to 25 MB. Itâ€™s a nice 60% reduction, but far from our 8 kB goal.<br>Trimming has more aggressive settings that are not publicly exposed and they could bring this down further, but in the end, weâ€™re going to be limited by the size of the CoreCLR runtime itselfâ€Š-â€Šcoreclr.dllâ€Š-â€Šat 5.3 MB. We might have reached a dead end on the road to a 8 kB game.<br><a data-tooltip-position="top" aria-label="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/04-graph2.png" rel="noopener" class="external-link" href="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/04-graph2.png" target="_blank"></a><img alt="After trimming" src="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/04-graph2.png" referrerpolicy="no-referrer"><br>After trimming<br><br><a data-tooltip-position="top" aria-label="https://www.mono-project.com/" rel="noopener" class="external-link" href="https://www.mono-project.com/" target="_blank">Mono</a> is another .NET runtime that for many is the synonym for Xamarin. To build a single executable with the C# snake, we can use the mkbundle tool that comes with Mono:<br>$ mkbundle SeeSharpSnake.dll --simple -o SeeSharpSnake.exe
Copy<br>This will produce a 12.3 MB executable that depends on mono-2.0-sgen.dll that itself has 5.9 MBâ€Š-â€Šso weâ€™re looking at 18.2 MB in total. When trying to launch it, I hit â€œError mapping file: mono_file_map_error failedâ€, but Iâ€™m going to trust that except for this bug, things would work with Mono and the result would be 18.2 MB.<br>Unlike CoreCLR, Mono also depends on the Visual C++ runtime redistributable library that is not available in a default Windows installation: to keep the goal of the app being self-contained, we need to carry this library with the app. This increases the footprint of the application by another megabyte or so.<br>We would likely be able to make things smaller by adding trimming to the mix, but weâ€™re going to hit the same problem as with CoreCLRâ€Š-â€Šthe size of the runtime (mono-2.0-sgen.dll) is 5.9 MB (plus the size of the C++ runtime libraries on top of it), and represents the floor of where any possible IL-level optimization could bring us.<br><a data-tooltip-position="top" aria-label="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/05-graph3.png" rel="noopener" class="external-link" href="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/05-graph3.png" target="_blank"></a><img alt="With Mono" src="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/05-graph3.png" referrerpolicy="no-referrer"><br>With Mono<br><br>It is clear that to get anywhere near the 8 kB goal, we need to take the runtime out of the app. The only .NET runtime where this is possible is <a data-tooltip-position="top" aria-label="https://github.com/dotnet/corert" rel="noopener" class="external-link" href="https://github.com/dotnet/corert" target="_blank">CoreRT</a>. While itâ€™s common to call CoreRT a â€œruntimeâ€, itâ€™s closer to being a â€œruntime libraryâ€. Itâ€™s not a virtual machine like CoreCLR or Monoâ€Š-â€Šthe CoreRTâ€™s runtime is just a set of functions that support ahead of time generated native code produced by CoreRTâ€™s ahead of time compiler.<br>CoreRT comes with libraries that make CoreRT look like any other .NET runtime: thereâ€™s a library that adds GC, library that adds support for reflection, library that adds a JIT, library that adds an interpreter, etc. But all of those libraries are optional (and that includes the GC).<br>More on how CoreRT differs from CoreCLR and Mono is in <a data-tooltip-position="top" aria-label="https://migeel.sk/blog/2019/05/01/fight-the-global-warming-compile-your-csharp-apps-ahead-of-time/" rel="noopener" class="external-link" href="https://migeel.sk/blog/2019/05/01/fight-the-global-warming-compile-your-csharp-apps-ahead-of-time/" target="_blank">this article</a>. When I was reading about the runtime of the <a data-tooltip-position="top" aria-label="https://theartofmachinery.com/2017/06/04/what_is_the_d_runtime.html" rel="noopener" class="external-link" href="https://theartofmachinery.com/2017/06/04/what_is_the_d_runtime.html" target="_blank">D language</a>, it reminded me of CoreRT a lot. The article is an interesting read too.<br>Letâ€™s see where weâ€™re with the default CoreRT configuration:<br>$ dotnet publish -r win-x64 -c Release /p:Mode=CoreRT
Copy<br>This comes down to 4.7 MB. Itâ€™s the smallest so far, but still not good enough.<br><a data-tooltip-position="top" aria-label="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/06-graph4.png" rel="noopener" class="external-link" href="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/06-graph4.png" target="_blank"></a><img alt="With CoreRT" src="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/06-graph4.png" referrerpolicy="no-referrer"><br>With CoreRT<br>The CoreRT ahead of time compiler offers a <a data-tooltip-position="top" aria-label="http://aka.ms/OptimizeCoreRT" rel="noopener" class="external-link" href="http://aka.ms/OptimizeCoreRT" target="_blank">vast number</a> of settings that affect code generation. By default, the compiler tries to maximize the generated code speed and compatibility with other .NET runtimes at the expense of the size of the generated executable.<br>The compiler has a built-in trimmer that removes unused code. The â€œCoreRT-Moderateâ€ setting that we define in the Snake project relaxes one of the restrictions on removing unused code that allows more removal. We also ask the compiler to trade program speed for some extra bytes. Most .NET programs would work just fine in this mode.<br>$ dotnet publish -r win-x64 -c Release /p:Mode=CoreRT-Moderate
Copy<br>Weâ€™re now at 4.3 MB.<br><a data-tooltip-position="top" aria-label="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/07-graph5.png" rel="noopener" class="external-link" href="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/07-graph5.png" target="_blank"></a><img alt="With stuff removed" src="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/07-graph5.png" referrerpolicy="no-referrer"><br>With stuff removed<br><br>Iâ€™ve grouped a couple more compilation options into a â€œhigh savingsâ€ mode. This mode is going to remove support for things that many apps would notice, but Snake (being the low level thing that it is) wonâ€™t.<br>We are going to remove:<br>
<br>Stack trace data for framework implementation details
<br>Exception messages in framework-thrown exceptions
<br>Support for non-English locales
<br>EventSource instrumentation
<br>$ dotnet publish -r win-x64 -c Release /p:Mode=CoreRT-High
Copy<br>Weâ€™ve reached 3.0 MB. This is 5% of what we started with, but CoreRT has one more trick up its sleeve.<br><a data-tooltip-position="top" aria-label="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/08-graph6.png" rel="noopener" class="external-link" href="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/08-graph6.png" target="_blank"></a><img alt="With more stuff removed" src="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/08-graph6.png" referrerpolicy="no-referrer"><br>With more stuff removed<br><br>Substantial part of the CoreRT runtime libraries is dedicated to the implementation of the .NET reflection surface area. Because CoreRT is an ahead-of-time-compiled runtime-library-based .NET implementation, it doesnâ€™t need most of the data structures a typical VM-based runtime (like CoreCLR and Mono) needs. This data includes things like names of types, methods, signatures, base types, etc. CoreRT embeds this data because programs using .NET reflection need it, but not because itâ€™s needed for the runtime to operate. I call this data â€œthe reflection taxâ€, because thatâ€™s what it is for the runtime.<br>CoreRT supports a <a data-tooltip-position="top" aria-label="https://github.com/dotnet/corert/blob/master/Documentation/using-corert/reflection-free-mode.md" rel="noopener" class="external-link" href="https://github.com/dotnet/corert/blob/master/Documentation/using-corert/reflection-free-mode.md" target="_blank">reflection-free mode</a> that avoids this tax. You might feel that a lot of .NET code wouldnâ€™t work without reflection and you might be right, but a surprising amount of things do work: Gui.cs, System.IO.Pipelines, or even a basic WinForms app. Snake will definitely work, so letâ€™s turn this mode on:<br>$ dotnet publish -r win-x64 -c Release /p:Mode=CoreRT-ReflectionFree
Copy<br>Weâ€™re now at 1.2 MB. The reflection tax is a pretty heavy tax!<br><a data-tooltip-position="top" aria-label="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/09-graph7.png" rel="noopener" class="external-link" href="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/09-graph7.png" target="_blank"></a><img alt="With more stuff removed" src="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/09-graph7.png" referrerpolicy="no-referrer"><br>With more stuff removed<br><br>Now weâ€™ve reached the end of whatâ€™s possible with the .NET SDK and we need to get our hands dirty. What weâ€™re going to do now is starting to be ridiculous and I wouldnâ€™t expect anyone else to do this. Weâ€™re going to rely on the implementation details of the CoreRT compiler and runtime.<br>As we saw earlier, CoreRT is a set of runtime libraries coupled with an ahead of time compiler. What if we replace the runtime libraries with a minimal reimplementation? Weâ€™ve decided not to use the garbage collector and that makes this job much more feasible.<br>Letâ€™s start with the easy things:<br>namespace System.Threading
{
    static class Thread
    {
        [DllImport("api-ms-win-core-synch-l1-2-0")]
        public static extern void Sleep(int delayMs);
    }
}

namespace System
{
    static class Environment
    {
        [DllImport("api-ms-win-core-sysinfo-l1-1-0")]
        private static extern long GetTickCount64();

        public static long TickCount64 =&gt; GetTickCount64();
    }
}
Copy<br>Thereâ€Š-â€Šwe just reimplemented Thread.Sleep and Environment.TickCount64 (for Windows) while avoiding all dependencies on the existing runtime library.<br>Letâ€™s do the same for the subset of System.Console that the game uses:<br>namespace System
{
    static class Console
    {
        private enum BOOL : int
        {
            FALSE = 0,
            TRUE = 1,
        }

        [DllImport("api-ms-win-core-processenvironment-l1-1-0")]
        private static unsafe extern IntPtr GetStdHandle(int c);

        private readonly static IntPtr s_outputHandle = GetStdHandle(-11);

        private readonly static IntPtr s_inputHandle = GetStdHandle(-10);

        [DllImport("api-ms-win-core-console-l2-1-0.dll", EntryPoint = "SetConsoleTitleW")]
        private static unsafe extern BOOL SetConsoleTitle(char* c);
        public static unsafe string Title
        {
            set
            {
                fixed (char* c = value)
                    SetConsoleTitle(c);
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        struct CONSOLE_CURSOR_INFO
        {
            public uint Size;
            public BOOL Visible;
        }

        [DllImport("api-ms-win-core-console-l2-1-0")]
        private static unsafe extern BOOL SetConsoleCursorInfo(IntPtr handle, CONSOLE_CURSOR_INFO* cursorInfo);

        public static unsafe bool CursorVisible
        {
            set
            {
                CONSOLE_CURSOR_INFO cursorInfo = new CONSOLE_CURSOR_INFO
                {
                    Size = 1,
                    Visible = value ? BOOL.TRUE : BOOL.FALSE
                };
                SetConsoleCursorInfo(s_outputHandle, &amp;cursorInfo);
            }
        }

        [DllImport("api-ms-win-core-console-l2-1-0")]
        private static unsafe extern BOOL SetConsoleTextAttribute(IntPtr handle, ushort attribute);

        public static ConsoleColor ForegroundColor
        {
            set
            {
                SetConsoleTextAttribute(s_outputHandle, (ushort)value);
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct KEY_EVENT_RECORD
        {
            public BOOL KeyDown;
            public short RepeatCount;
            public short VirtualKeyCode;
            public short VirtualScanCode;
            public short UChar;
            public int ControlKeyState;
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct INPUT_RECORD
        {
            public short EventType;
            public KEY_EVENT_RECORD KeyEvent;
        }

        [DllImport("api-ms-win-core-console-l1-2-0", EntryPoint = "PeekConsoleInputW", CharSet = CharSet.Unicode)]
        private static unsafe extern BOOL PeekConsoleInput(IntPtr hConsoleInput, INPUT_RECORD* lpBuffer, uint nLength, uint* lpNumberOfEventsRead);

        public static unsafe bool KeyAvailable
        {
            get
            {
                uint nRead;
                INPUT_RECORD buffer;
                while (true)
                {
                    PeekConsoleInput(s_inputHandle, &amp;buffer, 1, &amp;nRead);

                    if (nRead == 0)
                        return false;

                    if (buffer.EventType == 1 &amp;&amp; buffer.KeyEvent.KeyDown != BOOL.FALSE)
                        return true;

                    ReadConsoleInput(s_inputHandle, &amp;buffer, 1, &amp;nRead);
                }
            }
        }

        [DllImport("api-ms-win-core-console-l1-2-0", EntryPoint = "ReadConsoleInputW", CharSet = CharSet.Unicode)]
        private static unsafe extern BOOL ReadConsoleInput(IntPtr hConsoleInput, INPUT_RECORD* lpBuffer, uint nLength, uint* lpNumberOfEventsRead);

        public static unsafe ConsoleKeyInfo ReadKey(bool intercept)
        {
            uint nRead;
            INPUT_RECORD buffer;
            do
            {
                ReadConsoleInput(s_inputHandle, &amp;buffer, 1, &amp;nRead);
            }
            while (buffer.EventType != 1 || buffer.KeyEvent.KeyDown == BOOL.FALSE);

            return new ConsoleKeyInfo((char)buffer.KeyEvent.UChar, (ConsoleKey)buffer.KeyEvent.VirtualKeyCode, false, false, false);
        }

        struct SMALL_RECT
        {
            public short Left, Top, Right, Bottom;
        }

        [DllImport("api-ms-win-core-console-l2-1-0")]
        private static unsafe extern BOOL SetConsoleWindowInfo(IntPtr handle, BOOL absolute, SMALL_RECT* consoleWindow);

        public static unsafe void SetWindowSize(int x, int y)
        {
            SMALL_RECT rect = new SMALL_RECT
            {
                Left = 0,
                Top = 0,
                Right = (short)(x - 1),
                Bottom = (short)(y - 1),
            };
            SetConsoleWindowInfo(s_outputHandle, BOOL.TRUE, &amp;rect);
        }

        [StructLayout(LayoutKind.Sequential)]
        struct COORD
        {
            public short X, Y;
        }

        [DllImport("api-ms-win-core-console-l2-1-0")]
        private static unsafe extern BOOL SetConsoleScreenBufferSize(IntPtr handle, COORD size);

        public static void SetBufferSize(int x, int y)
        {
            SetConsoleScreenBufferSize(s_outputHandle, new COORD { X = (short)x, Y = (short)y });
        }

        [DllImport("api-ms-win-core-console-l2-1-0")]
        private static unsafe extern BOOL SetConsoleCursorPosition(IntPtr handle, COORD position);

        public static void SetCursorPosition(int x, int y)
        {
            SetConsoleCursorPosition(s_outputHandle, new COORD { X = (short)x, Y = (short)y });
        }

        [DllImport("api-ms-win-core-console-l1-2-0", EntryPoint = "WriteConsoleW")]
        private static unsafe extern BOOL WriteConsole(IntPtr handle, void* buffer, int numChars, int* charsWritten, void* reserved);

        public static unsafe void Write(char c)
        {
            int dummy;
            WriteConsole(s_outputHandle, &amp;c, 1, &amp;dummy, null);
        }
    }
}
Copy<br>Letâ€™s rebuild the game with this replacement framework:<br>$ dotnet publish -r win-x64 -c Release /p:Mode=CoreRT-ReflectionFree /p:IncludePal=true
Copy<br>Unsurprisingly, this didnâ€™t save us much. The APIs weâ€™re replacing are already relatively lightweight, and rewriting them only gains a couple kilobytes that are not worth mentioning. But this is an important stepping stone to the last step in our journey.<br><br>The remaining 1.2 MB of code and data in the Snake game is there to support things we donâ€™t see, but are thereâ€Š-â€Šready in case we need them. Thereâ€™s the garbage collector, support for exception handling, the code to format and print stack traces to the console when an unhandled exception happens, and many other things that are â€œunder the hoodâ€.<br>The compiler could detect that none of this is needed and avoid generating them, but what weâ€™re trying to do is so weird that itâ€™s not worth adding compiler features to support it. The way to avoid it is to simply provide an alternative runtime library.<br>Letâ€™s start with redefining a minimal version of the base types:<br>namespace System
{
    public class Object
    {
        // The layout of object is a contract with the compiler.
        public IntPtr m_pEEType;
    }
    public struct Void { }

    // The layout of primitive types is special cased because it would be recursive.
    // These really don't need any fields to work.
    public struct Boolean { }
    public struct Char { }
    public struct SByte { }
    public struct Byte { }
    public struct Int16 { }
    public struct UInt16 { }
    public struct Int32 { }
    public struct UInt32 { }
    public struct Int64 { }
    public struct UInt64 { }
    public struct IntPtr { }
    public struct UIntPtr { }
    public struct Single { }
    public struct Double { }

    public abstract class ValueType { }
    public abstract class Enum : ValueType { }

    public struct Nullable&lt;T&gt; where T : struct { }
    
    public sealed class String
    {
        // The layout of the string type is a contract with the compiler.
        public readonly int Length;
        public char _firstChar;

        public unsafe char this[int index]
        {
            [System.Runtime.CompilerServices.Intrinsic]
            get
            {
                return Internal.Runtime.CompilerServices.Unsafe.Add(ref _firstChar, index);
            }
        }
    }
    public abstract class Array { }
    public abstract class Delegate { }
    public abstract class MulticastDelegate : Delegate { }

    public struct RuntimeTypeHandle { }
    public struct RuntimeMethodHandle { }
    public struct RuntimeFieldHandle { }

    public class Attribute { }
}

namespace System.Runtime.CompilerServices
{
    internal sealed class IntrinsicAttribute : Attribute { }

    public class RuntimeHelpers
    {
        public static unsafe int OffsetToStringData =&gt; sizeof(IntPtr) + sizeof(int);
    }
}

namespace System.Runtime.InteropServices
{
    public enum CharSet
    {
        None = 1,
        Ansi = 2,
        Unicode = 3,
        Auto = 4,
    }

    public sealed class DllImportAttribute : Attribute
    {
        public string EntryPoint;
        public CharSet CharSet;
        public DllImportAttribute(string dllName) { }
    }

    public enum LayoutKind
    {
        Sequential = 0,
        Explicit = 2,
        Auto = 3,
    }

    public sealed class StructLayoutAttribute : Attribute
    {
        public StructLayoutAttribute(LayoutKind layoutKind) { }
    }
}
namespace Internal.Runtime.CompilerServices
{
    public static unsafe partial class Unsafe
    {
        // The body of this method is generated by the compiler.
        // It will do what Unsafe.Add is expected to do. It's just not possible to express it in C#.
        [System.Runtime.CompilerServices.Intrinsic]
        public static extern ref T Add&lt;T&gt;(ref T source, int elementOffset);
    }
}
Copy<br>At this point letâ€™s forgo the project file and dotnet CLI and launch the individual tools directly. We start by launching the C# compiler (CSC). I recommend launching these commands from the â€œx64 Native Tools Command Prompt for VS 2019â€â€Š-â€Šitâ€™s in your Start menu if you have Visual Studio installed. The right version of tools is on the PATH in that window.<br>The /noconfig, /nostdlib, and /runtimemetadataversion are the magic switches needed to compile something that defines System.Object. I chose the .ilexe file extension instead of .exe because .exe will be used for the finished product.<br>$ csc.exe /debug /O /noconfig /nostdlib /runtimemetadataversion:v4.0.30319 MiniBCL.cs Game\FrameBuffer.cs Game\Random.cs Game\Game.cs Game\Snake.cs Pal\Thread.Windows.cs Pal\Environment.Windows.cs Pal\Console.Windows.cs /out:zerosnake.ilexe /langversion:latest /unsafe
Copy<br>This will successfully compile the IL bytecode version of the game with the C# compiler. We still need some sort of runtime to execute it.<br>Letâ€™s try to feed this to the CoreRT ahead of time compiler to generate native code from the IL. If you followed the steps above, youâ€™ll find ilc.exe, the CoreRT ahead of time compiler, in your NuGet package cache (somewhere like %USERPROFILE%.nuget\packages\runtime.win-x64.microsoft.dotnet.ilcompiler\1.0.0-alpha-27402â€“01\Tools).<br>$ ilc.exe zerosnake.ilexe -o zerosnake.obj --systemmodule zerosnake --Os -g
Copy<br>This is going to crash with â€œExpected type â€˜Internal.Runtime.CompilerHelpers.StartupCodeHelpersâ€™ not found in module â€˜zerosnakeâ€™â€. Turns out that besides the obvious minimum that a managed developer would expect, thereâ€™s also a minimum that the CoreRT compiler needs to compile the input.<br>Letâ€™s skip to the chase and add whatâ€™s needed:<br>namespace Internal.Runtime.CompilerHelpers
{
    // A class that the compiler looks for that has helpers to initialize the
    // process. The compiler can gracefully handle the helpers not being present,
    // but the class itself being absent is unhandled. Let's add an empty class.
    class StartupCodeHelpers
    {
    }
}

namespace System
{
    // A special type that the compiler uses to implement generic interfaces
    // (e.g. IEnumerable&lt;T&gt;) on arrays. Our arrays won't implement any generic interfaces.
    class Array&lt;T&gt; : Array { }
}

namespace System.Runtime.InteropServices
{
    // Custom attribute that marks a class as having special "Call" intrinsics.
    // The compiler has special logic handling types with this attribute.
    internal class McgIntrinsicsAttribute : Attribute { }
}

namespace System.Runtime.CompilerServices
{
    // A class responsible for running static constructors. The compiler will call into this
    // code to ensure static constructors run and that they only run once.
    [System.Runtime.InteropServices.McgIntrinsics]
    internal static class ClassConstructorRunner
    {
        private static unsafe IntPtr CheckStaticClassConstructionReturnNonGCStaticBase(ref StaticClassConstructionContext context, IntPtr nonGcStaticBase)
        {
            CheckStaticClassConstruction(ref context);
            return nonGcStaticBase;
        }

        private static unsafe void CheckStaticClassConstruction(ref StaticClassConstructionContext context)
        {
            // Very simplified class constructor runner. In real world, the class constructor runner
            // would need to be able to deal with potentially multiple threads racing to initialize
            // a single class, and would need to be able to deal with potential deadlocks
            // between class constructors.

            // If the class is already initialized, we're done.
            if (context.initialized == 1)
                return;

            // Mark the class as initialized.
            context.initialized = 1;

            // Run the class constructor.
            Call&lt;int&gt;(context.cctorMethodAddress);
        }

        // This is a special compiler intrinsic that calls the method pointed to by pfn.
        // The compiler generates code for this and we can just mark it `extern`.
        // Once C# gets proper function pointer support (planned for C# 9), this won't be needed.
        [System.Runtime.CompilerServices.Intrinsic]
        private static extern T Call&lt;T&gt;(System.IntPtr pfn);
    }

    // This data structure is a contract with the compiler. It holds the address of a static
    // constructor and a flag that specifies whether the constructor already executed.
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public struct StaticClassConstructionContext
    {
        // Pointer to the code for the static class constructor method. This is initialized by the
        // binder/runtime.
        public IntPtr cctorMethodAddress;

        // Initialization state of the class. This is initialized to 0. Every time managed code checks the
        // cctor state the runtime will call the classlibrary's CheckStaticClassConstruction with this context
        // structure unless initialized == 1. This check is specific to allow the classlibrary to store more
        // than a binary state for each cctor if it so desires.
        public int initialized;
    }
}
Copy<br>Letâ€™s rebuild the IL bytecode with this newly added code and re-rerun ILC.<br>$ csc.exe /debug /O /noconfig /nostdlib /runtimemetadataversion:v4.0.30319 MiniRuntime.cs MiniBCL.cs Game\FrameBuffer.cs Game\Random.cs Game\Game.cs Game\Snake.cs Pal\Thread.Windows.cs Pal\Environment.Windows.cs Pal\Console.Windows.cs /out:zerosnake.ilexe /langversion:latest /unsafe
$ ilc.exe zerosnake.ilexe -o zerosnake.obj --systemmodule zerosnake --Os -g
Copy<br>Now we have zerosnake.objâ€Š-â€Ša standard object file that is no different from object files produced by other native compilers such as C or C++. The last step is linking it. Weâ€™ll use the link.exe tool that should be on the PATH of our â€œx64 Native Tools Command Promptâ€ (you might need to install the C/C++ development tools in Visual Studio).<br>link.exe /debug:full /subsystem:console zerosnake.obj /entry:__managed__Main
Copy<br>The __managed__Main symbol name is a contract with the compilerâ€Š-â€Šitâ€™s the name of the managed entrypoint of the program that ILC created.<br>But it doesnâ€™t work:<br>error LNK2001: unresolved external symbol RhpPInvoke
error LNK2001: unresolved external symbol SetConsoleTextAttribute
error LNK2001: unresolved external symbol WriteConsoleW
error LNK2001: unresolved external symbol GetStdHandle
...
fatal error LNK1120: 17 unresolved externals
Copy<br>Some of these symbols look familiarâ€Š-â€Šthe linker doesnâ€™t know where to look for the Windows APIs we call. Letâ€™s add the import libraries for those:<br>$ link.exe /debug:full /subsystem:console zerosnake.obj /entry:__managed__Main kernel32.lib ucrt.lib
Copy<br>This looks betterâ€Š-â€Šonly 4 unresolved symbols:<br>error LNK2001: unresolved external symbol RhpPInvoke
error LNK2001: unresolved external symbol RhpPInvokeReturn
error LNK2001: unresolved external symbol RhpReversePInvoke2
error LNK2001: unresolved external symbol RhpReversePInvokeReturn2
fatal error LNK1120: 4 unresolved externals
Copy<br>The remaining missing symbols are helpers that the compiler expects to find in the runtime library. The fact theyâ€™re missing is only discovered at the time of linking because these helpers are typically implemented in assembly and the compiler only refers to them by their symbolic name (as opposed to other compiler-required types and methods we provided above).<br>The helpers set up and tear down the stack frames when native code calls into managed code, and managed code calls into native code. This is necessary for the GC to operate. Since we donâ€™t have a GC, letâ€™s stub them out with a piece of C# and another magical attribute that the compiler understands.<br>namespace System.Runtime
{
    // Custom attribute that the compiler understands that instructs it
    // to export the method under the given symbolic name.
    internal sealed class RuntimeExportAttribute : Attribute
    {
        public RuntimeExportAttribute(string entry) { }
    }
}

namespace Internal.Runtime.CompilerHelpers
{
    class StartupCodeHelpers
    {
        // The containing type for these methods doesn't matter.
        // Let's park them in StarupCodeHelpers.
        
        [System.Runtime.RuntimeExport("RhpReversePInvoke2")]
        static void RhpReversePInvoke2(System.IntPtr frame) { }
        [System.Runtime.RuntimeExport("RhpReversePInvokeReturn2")]
        static void RhpReversePInvokeReturn2(System.IntPtr frame) { }
        [System.Runtime.RuntimeExport("RhpPInvoke")]
        static void RhpPinvoke(System.IntPtr frame) { }
        [System.Runtime.RuntimeExport("RhpPInvokeReturn")]
        static void RhpPinvokeReturn(System.IntPtr frame) { }
    }
}
Copy<br>After rebuilding the C# source code with these modifications and re-running ILC, the linking will finally succeed.<br>Weâ€™re now at 27 kilobytes and the game still works!<br><a data-tooltip-position="top" aria-label="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/10-graph8.png" rel="noopener" class="external-link" href="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/10-graph8.png" target="_blank"></a><img alt="With runtime removed" src="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/10-graph8.png" referrerpolicy="no-referrer"><br>With runtime removed<br><br>The remaining kilobytes can be shaved off by using tricks native developers use to shrink their native apps.<br>Weâ€™re going to:<br>
<br>Disable incremental linking
<br>Strip relocation information
<br>Merge similar sections within the executable
<br>Set internal alignment within the executable to a small value
<br>$ link.exe /debug:full /subsystem:console zerosnake.obj /entry:__managed__Main kernel32.lib ucrt.lib /merge:.modules=.rdata /merge:.pdata=.rdata /incremental:no /DYNAMICBASE:NO /filealign:16 /align:16
Copy<br>Success! 8176 bytes!<br>The game still works, and interestingly, itâ€™s still fully debuggableâ€Š-â€Šfeel free to open the EXE in Visual Studio (File -&gt; Open Solution), open one of the C# files that are part of the game, set a breakpoint in it, hit F5 to launch the EXE, and see the breakpoint getting hit. You can disable optimizations in ILC to make the executable even more debuggableâ€Š-â€Šjust drop the â€“Os argument.<br><a data-tooltip-position="top" aria-label="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/11-graph9.png" rel="noopener" class="external-link" href="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/11-graph9.png" target="_blank"></a><img alt="After messing with linker" src="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/11-graph9.png" referrerpolicy="no-referrer"><br>After messing with linker<br><br>The executable still carries some data that is not essentialâ€Š-â€Šthe ILC compiler just doesnâ€™t expose command line options to disable their generation.<br>One of those data structures that gets generated but we donâ€™t need is GC information for the individual methods. CoreRT has a precise garbage collector that requires each method to describe where references to GC heap are at each instruction of the method body. Since we donâ€™t have a garbage collector in the Snake game, this data is unnecessary. Other runtimes (e.g. Mono) use a conservative garbage collector that doesnâ€™t require this data (it simply assumes any piece of the stack and CPU registers could be a GC reference)â€Š-â€Ša conservative garbage collector trades GC performance for extra size savings. The precise garbage collector used in CoreRT can operate in conservative mode too, but it hasnâ€™t been hooked up yet. Itâ€™s a potential future addition that we could then leverage to make things even smaller.<br>Maybe one day we can make a simplified version of our game fit into a 512 byte boot sector. Until then, happy hacking!]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/csharp/building-a-self-contained-game-in-csharp-under-8-kilobytes.html</link><guid isPermaLink="false">Computer Science/Programming Language/CSharp/Building a self-contained game in CSharp under 8 kilobytes.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:28 GMT</pubDate><enclosure url="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/01-floppies.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://migeel.sk/blog/2020/01/03/building-a-self-contained-game-in-csharp-under-8-kilobytes/01-floppies.jpg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Isomorphic .NET Support in Extism]]></title><description><![CDATA[ 
 <br>In the early days of computing, software was pretty much locked into specific hardware setups. Then came operating systems, providing a layer of abstraction over the hardware. However, that still didnâ€™t quite cut it. Businesses wanted to write their apps once and have them work on all sorts of platforms. This demand gave birth to higher-level languages that brought along their own runtimes, making it possible for software to run seamlessly on different operating systems.<br>Today, many organizations manage a multitude of programming languages for distinct tasks. While several runtimes, such as .NETâ€™s Common Language Runtime (â€œCLRâ€) and Oracleâ€™s Java Virtual Machine (â€œJVMâ€), support multiple languages, they still operate within isolated ecosystems. Each ecosystem has its package managers and libraries, often leading to unnecessary code duplication and duplicated efforts.<br>WebAssembly (Wasm) to the rescue! Wasm allows developers to create applications and libraries in their language of choice, meaning you can build a library in one language and smoothly integrate it with others.<br>Microsoft has long recognized Wasmâ€™s potential and has heavily invested in <a data-tooltip-position="top" aria-label="https://dotnet.microsoft.com/en-us/apps/aspnet/web-apps/blazor" rel="noopener" class="external-link" href="https://dotnet.microsoft.com/en-us/apps/aspnet/web-apps/blazor" target="_blank">Blazor</a>. Blazor runs .NET code in the browser. This way, C# and F# programmers can reuse their existing skills to write interactive apps for the web. In .NET 8, Microsoft is adding experimental support for WASI too. Which means .NET apps compiled to Wasm can now run on the server, computers, and mobile phones!<br>Thatâ€™s where Extism steps in. Languages have varying levels of support for running and compiling to Wasm, and capabilities may change depending on what runtime is being used. Extism ensures that your plugins will run consistently across languages and platforms. Weâ€™ve <a data-tooltip-position="top" aria-label="https://dylibso.com/blog/why-extism/" rel="noopener" class="external-link" href="https://dylibso.com/blog/why-extism/" target="_blank">previously talked about the added value of Extism</a>, but in a nutshell, Extism offers a set of unified and user-friendly Plugin Development Kits (PDKs) and Software Development Kits (SDKs) that make it easy for you to develop and run plugins in your preferred programming language.<br><br>Extism makes it all the more convenient to build Wasm plugins. For example, consider this scenario: you have a messaging bot platform, and you want to empower your users to create their own bots. Typically, messaging platforms provide webhooks that users can use to write bots. But we want to invert the situation: we run the users code on our own infrastructure! Hereâ€™s a glimpse of how it could look when you use the <a data-tooltip-position="top" aria-label="https://github.com/extism/dotnet-pdk" rel="noopener" class="external-link" href="https://github.com/extism/dotnet-pdk" target="_blank">.NET Extism PDK</a>:<br>  static class Plugin
{
    [UnmanagedCallersOnly(EntryPoint = "bot_name")]
    public static void BotName()
    {
        Pdk.SetOutput("weather bot");
    }

    [UnmanagedCallersOnly(EntryPoint = "respond")]
    public static void Respond()
    {
        var message = Pdk.GetInputString();

        if (message.Contains("hi", StringComparison.OrdinalIgnoreCase))
        {
            Reply("Hello :-)");
        }
        else if (message.Contains("weather", StringComparison.OrdinalIgnoreCase))
        {
            // Get secrets and configuration from the Host
            if (!Pdk.TryGetConfig("weather-api-key", out var apiKey))
            {
                throw new Exception("Beep boop malfunction detected: API Key is not configured!");
            }

            var block = MemoryBlock.Find(Env.GetUserInfo());
            var json = block.ReadString();
            var userInfo = JsonSerializer.Deserialize&lt;UserInfo&gt;(json);

            // Call HTTP APIs
            var query = $"https://api.weatherapi.com/v1/current.json?key={apiKey}&amp;q={userInfo.City}&amp;aqi=no";
            var response = Pdk.SendRequest(new HttpRequest(query));
            var responseJson = response.Body.ReadString();
            var apiResponse = JsonSerializer.Deserialize&lt;ApiResponse&gt;(responseJson);

            Reply($"The current temparature in {userInfo.City} is {apiResponse.current.temp_c}Â°C");
        }
        else
        {
            Reply("""
                Hi, I am the weather bot. Commands:
                1. Hi
                2. How's the weather?
                """);
        }
    }

    static void Reply(string message)
    {
        var block = Pdk.Allocate(message);
        Env.SendMessage(block.Offset);
    }
}

// Import functions from the host
static class Env
{
    [DllImport("extism", EntryPoint = "send_message")]
    public static extern void SendMessage(ulong offset);

    [DllImport("extism", EntryPoint = "user_info")]
    public static extern ulong GetUserInfo();
}
Copy<br>This small example demonstrates how we can easily import functions from the host, share data between the host and the plugin, and make HTTP requests. The host has full control over which HTTP hosts the plugin can make requests to and which files the plugin has access to.<br>We have also exported two functions for the host: bot_name provides the name of the bot and respond can process a message sent by the user. The .NET Extism PDK add the following capabilities on top of the .NET WASI SDK:<br>
<br>Support for DllImport for importing functions from the host.
<br>Support for UnmanagedCallersOnly for exporting C# and F# functions.
<br>A global exception handler that propagates the exceptions back to the host.
<br>Easily share data between the plugin and the host.<br>
Extism has PDKs for <a data-tooltip-position="top" aria-label="https://extism.org/docs/category/write-a-plug-in" rel="noopener" class="external-link" href="https://extism.org/docs/category/write-a-plug-in" target="_blank">many popular programming languages</a>, so your users can write plugins in their favorite programming language and it would still work the same way!
<br><br>Running plugins is equally easy thanks to our <a data-tooltip-position="top" aria-label="https://extism.org/docs/category/integrate-into-your-codebase" rel="noopener" class="external-link" href="https://extism.org/docs/category/integrate-into-your-codebase" target="_blank">Host SDKs</a>, here is how youâ€™d call the plugin above using our <a data-tooltip-position="top" aria-label="https://github.com/extism/dotnet-sdk" rel="noopener" class="external-link" href="https://github.com/extism/dotnet-sdk" target="_blank">.NET SDK</a>:<br>var manifest = new Manifest(new PathWasmSource("Plugin.wasm"))
{
	// Provide configurations and secrets for the plugins
	Config = new Dictionary&lt;string, string&gt;
	{
		{ "weather-api-key", Environment.GetEnvironmentVariable("weather-api-key") }
	},

 	// Control which HTTP hosts the plugins can call
 	AllowedHosts = ["api.weatherapi.com"]
};

// Provide custom host functions
var functions = new[]
{
    HostFunction.FromMethod("send_message", IntPtr.Zero, (CurrentPlugin plugin, long offset) =&gt;
    {
        var message = plugin.ReadString(offset);
        Console.WriteLine($"bot says: {message}");
    }),

    HostFunction.FromMethod("user_info", IntPtr.Zero, (CurrentPlugin plugin) =&gt;
    {
        var json = JsonSerializer.Serialize(new UserInfo
        {
            FullName = "John Smith",
            City = "New York"
        });

        return plugin.WriteString(json);
    })
};

var plugin = new Plugin(manifest, functions, withWasi: true);

// Call functions exported by the plugin
var botName = plugin.Call("bot_name", "");
Console.WriteLine($"Bot Name: {botName}");

// Call respond with an empty input
plugin.Call("respond", "");

while (true)
{
    Console.Write("&gt; ");
    var message = Console.ReadLine();

    // Easily cancel plugin calls
    var cts = new CancellationTokenSource();
    cts.CancelAfter(TimeSpan.FromSeconds(1));

    plugin.Call("respond", message, cts.Token);
}
Copy<br>And here is the result of running the host:<br>PS D:\x\dotnet\isomophic-dotnet-demo\Host&gt; dotnet run
Bot Name: weather bot
bot says: Hi, I am the weather bot. Commands:
1. Hi
2. How's the weather?
&gt; hi
bot says: Hello :-)
&gt; weather?
bot says: The current temparature in New York is 10.6Â°C
&gt;
Copy<br>While this example is very simple, it serves as the foundation for a robust and highly extensible bot framework. Utilizing Wasm for this scenario offers a host of advantages:<br>
<br>Sandboxed Plugins: Wasm ensures that plugins operate within a secure sandbox. They can only access resources such as memory, files, and sockets if explicitly allowed by the Host.
<br>Language Flexibility: Your users can develop plugins in their preferred programming language.
<br>Resource Management: You can set precise limits on memory usage and execution timeouts, enhancing control over your bot framework.
<br>Less network traffic: Since youâ€™re running the plugins on your own server, there is no need for webhooks which can improve the responsiveness of the bots.<br>
The complete code for this sample is <a data-tooltip-position="top" aria-label="https://github.com/dylibso/isomorphic-dotnet-demo" rel="noopener" class="external-link" href="https://github.com/dylibso/isomorphic-dotnet-demo" target="_blank">available on GitHub</a>.
<br>Finally, we want to thank the incredible .NET team for their invaluable support and guidance through the WASI SDK challenges. Weâ€™re excited about the future of .NET in Wasm.<br><a data-tooltip-position="top" aria-label="https://twitter.com/mhmd_azeez" rel="noopener" class="external-link" href="https://twitter.com/mhmd_azeez" target="_blank">Muhammad Azeez</a>, Senior Software Engineer]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/csharp/isomorphic-.net-support-in-extism.html</link><guid isPermaLink="false">Computer Science/Programming Language/CSharp/Isomorphic .NET Support in Extism.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:32 GMT</pubDate></item><item><title><![CDATA[10 Tips for Productive FSharp Scripting]]></title><description><![CDATA[<a class="tag" href="https://muqiuhan.github.io/wiki/?query=tag:I" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#I</a> <a class="tag" href="https://muqiuhan.github.io/wiki/?query=tag:time" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#time</a> <a class="tag" href="https://muqiuhan.github.io/wiki/?query=tag:fsharp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#fsharp</a> <a class="tag" href="https://muqiuhan.github.io/wiki/?query=tag:ndclondon" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#ndclondon</a> 
 <br>Scott Hanselman recently had a <a data-tooltip-position="top" aria-label="http://www.hanselman.com/blog/InteractiveCodingWithCAndFREPLsScriptCSOrTheVisualStudioInteractiveWindow.aspx" rel="noopener" class="external-link" href="http://www.hanselman.com/blog/InteractiveCodingWithCAndFREPLsScriptCSOrTheVisualStudioInteractiveWindow.aspx" target="_blank">nice post on C# and F# REPLs</a>, which reminded me of the time I started using F# scripts. Over time, I found out a couple of small tricks, which helped make the experience productive. I found about them mainly by accident, so I figured, letâ€™s see if I can list them in one place! Some of these are super simple, some probably a bit obscure, but hopefully, one of them at least will make your path towards scripting nirvana an easier oneâ€¦<br>
Note: these tips are not necessarily ordered by usefulness. For that matter, there might or might not be exactly 10 of them :)
<br><br>You can use the F# Interactive 2 ways: you can directly type code into FSI, the F# Interactive window, or you can write code in an .fsx file, and select pieces of the code you want to execute. I recommend the second approach, for at least two reasons. First, FSI is a very primitive environment, .fsx files provide a much richer experience (IntelliSense). Then this encourages writing clean scripts you can reuse later.<br>
This is not specific to scripts, butâ€¦ if you are on Visual Studio, do yourself a service and install the <a data-tooltip-position="top" aria-label="http://fsprojects.github.io/VisualFSharpPowerTools/" rel="noopener" class="external-link" href="http://fsprojects.github.io/VisualFSharpPowerTools/" target="_blank">Visual F# Power Tools</a> - youâ€™ll get nice things such as better code highlighting, refactoring, and more.
<br>To execute code interactively, simply type code in an .fsx file, select a block of code, and hit Alt + Enter. The selected code will be evaluated, and the result will show up in the FSI window. In Visual Studio, you can also select code and right-click â€œExecute in Interactiveâ€, but shortcuts are way faster.<br>
You can also execute a single-line with Alt + '. I rarely use this option, but this can save you time because you donâ€™t need to select the entire line of code.
<br>
In case the keyboard shortcuts to send code to FSI do not work anymore (ReSharper used to over-write them in the past), you can reset them in Visual Studio, by going to Tools / Options / Environment / Keyboard. The 2 commands you need to map are EditorContextMenus.CodeWindow.ExecuteInInteractive and EditorContextMenus.CodeWindow.ExecuteLineInInteractive.
<br>You can also use these shortcuts from a regular .fs file, which can be handy if you want to validate that a piece of code is behaving the way you want.<br>
Interactive coding is by far my main usage for scripts - I use it extensively to prototype designs, run dumb tasks, or explore data or libraries. I realized recently that a few of my C# friends use LinqPad for the same purpose.
<br><br>While I encourage working primarily from .fsx files, the FSI window is also very helpful. I use it primarily for small verifications. For instance, I might have in my script file code like this:<br>let add x y =
  x + y
Copy<br>Once I send it for evaluation into FSI, I will see the following show up in FSI:<br>val add : x:int -&gt; y:int -&gt; int
&gt;
Copy<br>My function add is now in memory, in my FSI session; I can start typing in the FSI window and use it:<br>&gt; add 1 2;;
val it : int = 3
&gt;
Copy<br>Enter does not trigger execution in FSI. The ;; indicates to FSI â€œPlease execute everything I just typed, up to that pointâ€. This is useful if you want to type multiple lines of code in FSI, and execute them as a block.<br>
it: in our add 1 2 example, the result showed up as it. We simply ran add, but didnâ€™t assign the result to anything. it now contains the result, until we run another expression. If you want to re-use that value, you can assign it in FSI, by doing for instance let x = it;;.â€²
<br>
Once a value is loaded in your FSI session, it will remain there, available to you until you shadow it (in the example above, x will remain available, until I run for instance let x = 42;;). This is extremely convenient: for instance, you can load a data file once let data = File.ReadAllLines path, and keep using data for as long as you want, without having to reload it between code changes.
<br>
FSI often shows an abbreviated version of values for large items. For instance, [1..999] will show up as val it : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 56; 57; 58; 59; 60; 61; 62; 63; 64; 65; 66; 67; 68; 69; 70; 71; 72; 73; 74; 75; 76; 77; 78; 79; 80; 81; 82; 83; 84; 85; 86; 87; 88; 89; 90; 91; 92; 93; 94; 95; 96; 97; 98; 99; 100; ...] - note the â€¦ at the end, which indicate that there is more.
<br>What if you inadvertently started a very long computation, or an infinite loop? In Visual Studio, you can either kill the session entirely, by right-clicking over the FSI window and selecting â€œReset Interactive Sessionâ€ or Ctrl + Alt + R, or cancel the latest evaluation you requested (â€œCancel Interactive Evaluationâ€, or Ctrl + Break.).<br><br>Besides interactive scripting, you can also run a script from the command line, by using FSI.exe:<br>&gt;fsi.exe "C:\myscript.fsx"<br>
FSI.exe is typically located at C:\Program Files (x86)\Microsoft SDKs\F#\4.0\Framework\v4.0. You can also install it separately, see <a data-tooltip-position="top" aria-label="http://fsharp.org/" rel="noopener" class="external-link" href="http://fsharp.org/" target="_blank">fsharp.org/use</a> section for instructions for various platforms.
<br>You can define different behaviors in your script, depending on whether it is run interactively or from the command line, like this:<br>#if INTERACTIVE
let msg = "Interactive"
#else
let msg = "Not Interactive"
#endif

printfn "%s" msg
Copy<br>Updated, Sep 19: thanks Matt Klein for <a data-tooltip-position="top" aria-label="http://stackoverflow.com/q/39581342/114519" rel="noopener" class="external-link" href="http://stackoverflow.com/q/39581342/114519" target="_blank">pointing the issue</a>.<br>For more information on FSI from the command line, <a data-tooltip-position="top" aria-label="https://msdn.microsoft.com/en-us/library/dd233175.aspx" rel="noopener" class="external-link" href="https://msdn.microsoft.com/en-us/library/dd233175.aspx" target="_blank">check the reference page here</a>.<br>Updated, Feb 20: <a data-tooltip-position="top" aria-label="https://twitter.com/genTauro42" rel="noopener" class="external-link" href="https://twitter.com/genTauro42" target="_blank">Ramon Soto Mathiesen</a> points out that <a data-tooltip-position="top" aria-label="https://twitter.com/genTauro42/status/696407757835132928" rel="noopener" class="external-link" href="https://twitter.com/genTauro42/status/696407757835132928" target="_blank">Tip 9 also applies to the command line</a>.<br><br>Sometimes, your script will reference another resource; for instance, you need to read the contents of a .txt file somewhere. You can use absolute path, as in:<br>File.ReadAllLines @"C:/data/myfile.txt"
Copy<br>
Pre-pending a string with @ makes it a verbatim string, and ignore escape sequences, such as \.
<br>
Use / rather than \, so that path work both on Windows and Mono.
<br>However, if that resource lives in a location relative to your script, consider using relative path, so that you can move your script folder around without breaking it.<br>Relative paths can be a bit tricky; for instance, running the following code interactivelyâ€¦<br>System.Environment.CurrentDirectory
Copy<br>â€¦ produces a potentially unexpected result in FSI:<br>val it : string = "C:\Users\Mathias Brandewinder\AppData\Local\Temp"
&gt;
Copy<br>You can avoid these issues by using built-in constants, which refer respectively to the directory where the script lives, the script file name, and the current line of the script:<br>__SOURCE_DIRECTORY__
__SOURCE_FILE__
__LINE__
Copy<br>So if your folder structure was along these linesâ€¦<br>root
  /src/script.fsx
  /data/data.txt
Copy<br>â€¦ you could refer to the data file data.txt from your script like this:<br>let path = System.IO.Path.Combine(__SOURCE_DIRECTORY__,"..","data/data.txt")
System.IO.File.ReadAllText path
Copy<br><br>By default, FSI loads FSharp.Core and nothing else. If you want to use System.DateTime, you will need to first open System in your script. If you want to use an assembly that is not part of the standard .NET distribution, you will need to reference it first using #r. Imagine for instance that you installed the Nuget package fsharp.data; to use it in your script, you would do something like:<br>#r @"../packages/FSharp.Data.2.2.5/lib/net40/FSharp.Data.dll"
open FSharp.Data
Copy<br>
When you execute open System in interactive, donâ€™t worry if nothing seems to happen: the only result is a new &gt; showing up in FSI.
<br>For assemblies that are part of .NET but not referenced by default, you can use a shorter version:<br>#r @"System.Xaml"
open System.Xaml
Copy<br>
In Visual Studio, you can right-click a reference from Solution Explorer, and send to F# interactive. You can then directly open it, and start using it in FSI.
<br>Updated, Feb 20: <a data-tooltip-position="top" aria-label="https://twitter.com/sergey_tihon" rel="noopener" class="external-link" href="https://twitter.com/sergey_tihon" target="_blank">Sergey Tihon</a> shared an interesting comment, explaining where Tip 5 can sometimes go wrong. Iâ€™d say, try Tip 5 first, but be aware that this might at times not quite work:<br>
<a data-tooltip-position="top" aria-label="https://twitter.com/brandewinder" rel="noopener" class="external-link" href="https://twitter.com/brandewinder" target="_blank">@brandewinder</a> don't load assemblies like in Tip 5 ) <a rel="noopener" class="external-link" href="https://t.co/Owft1NmPoo" target="_blank">https://t.co/Owft1NmPoo</a>
â€” Sergey Tihon (@sergey_tihon) <a data-tooltip-position="top" aria-label="https://twitter.com/sergey_tihon/status/696395229285523456" rel="noopener" class="external-link" href="https://twitter.com/sergey_tihon/status/696395229285523456" target="_blank">February 7, 2016</a>
<br>Updated, Feb 20: <a data-tooltip-position="top" aria-label="https://twitter.com/dsyme" rel="noopener" class="external-link" href="https://twitter.com/dsyme" target="_blank">F# open source contributor Don Syme</a> share a related nice trick:<br>
<a data-tooltip-position="top" aria-label="https://twitter.com/jeroldhaas" rel="noopener" class="external-link" href="https://twitter.com/jeroldhaas" target="_blank">@jeroldhaas</a> <a data-tooltip-position="top" aria-label="https://twitter.com/sergey_tihon" rel="noopener" class="external-link" href="https://twitter.com/sergey_tihon" target="_blank">@sergey_tihon</a> <a data-tooltip-position="top" aria-label="https://twitter.com/brandewinder" rel="noopener" class="external-link" href="https://twitter.com/brandewinder" target="_blank">@brandewinder</a> Use <a data-tooltip-position="top" aria-label="https://twitter.com/hashtag/I?src=hash" rel="noopener" class="external-link" href="https://twitter.com/hashtag/I?src=hash" target="_blank"></a><a href="https://muqiuhan.github.io/wiki?query=tag:I" class="tag" target="_blank" rel="noopener">#I</a> SOURCE_DIRECTORY, it is wondrous, very satisfying. All relative paths then work
â€” Don Syme (@dsyme) <a data-tooltip-position="top" aria-label="https://twitter.com/dsyme/status/696429115184955393" rel="noopener" class="external-link" href="https://twitter.com/dsyme/status/696429115184955393" target="_blank">February 7, 2016</a>
<br><br>The Nuget package manager is useful to consume existing packages. However, by default, Nuget stores assemblies in a folder that includes the package version number. This is very impractical for a script. In our example above, if fsharp.data gets an update, our script reference will be broken once we update the Nuget package:<br>#r @"../packages/FSharp.Data.2.2.5/lib/net40/FSharp.Data.dll"<br>Fixing the script requires manually editing the version number in the path, which quickly becomes a pain. <a data-tooltip-position="top" aria-label="https://fsprojects.github.io/Paket/" rel="noopener" class="external-link" href="https://fsprojects.github.io/Paket/" target="_blank"><strong></strong></a>Paket provides a better experience, because it stores packages without the version number, in this case, under:<br>#r @"../packages/FSharp.Data/lib/net40/FSharp.Data.dll"<br>Your scripts will now gracefully handle version number changes.<br>If you end up consuming numerous packages, you can make your life even easier, by referencing paths where assemblies might be searched for, using #I:<br>#I @"../packages/
#r @"FSharp.Data/lib/net40/FSharp.Data.dll"
Copy<br>
If your primary goal is to â€œjust scriptâ€, consider using <a data-tooltip-position="top" aria-label="https://atom.io/" rel="noopener" class="external-link" href="https://atom.io/" target="_blank">Atom</a> or <a data-tooltip-position="top" aria-label="https://code.visualstudio.com/" rel="noopener" class="external-link" href="https://code.visualstudio.com/" target="_blank">VSCode</a>, with the <a data-tooltip-position="top" aria-label="http://ionide.io/" rel="noopener" class="external-link" href="http://ionide.io/" target="_blank">Ionide plugin</a>. You can create and run free-standing F# scripts, with beautiful <a data-tooltip-position="top" aria-label="http://ionide.io/#paket-integration" rel="noopener" class="external-link" href="http://ionide.io/#paket-integration" target="_blank">Paket integration</a>.
<br><br>You might want to use the code from an existing file in your script. Suppose that we have a code file Code.fs somewhere, looking like this:<br>namespace Mathias

module Common =
  let hello name = sprintf "Hello, %s" name
Copy<br>You can use that code from your script, by using the #load directive:<br>#load "Code.fs"
open Mathias.Common
hello "World"
Copy<br>
You might have to close and re-open the script file if you end up changing the contents of the file.
<br>
If the file you are attempting to load contains references to other assemblies or files, you might get an error on the #load statement: â€œOne or more errors in loaded files. The namespace or module â€¦ is not definedâ€. Simply reference the missing assemblies above the #load statement, so that your script uses the same dependencies as the file it refers to.
<br><br>Another handy directive, #time, turns on basic profiling. Once it is executed, for every block of code you send for execution you will see timing and garbage collection information. For instance, running this codeâ€¦<br>#time
[| 1 .. 10000000 |] |&gt; Array.map (fun x -&gt; x * x)
Copy<br>â€¦ will produce the following in FSI:<br>--&gt; Timing now on

Real: 00:00:00.887, CPU: 00:00:00.828, GC gen0: 2, gen1: 2, gen2: 2
val it : int [] =
  [|1; 4; 9; 16; 25; 36; 49; // snipped for brevity
Copy<br>We get the wall time and CPU time it took, as well as some information about garbage collection in generations 0, 1 and 2. This would not replace a full-blown profiler, but this is an awfully convenient tool to figure out quickly if there are obvious ways to improve a piece of code.<br>Note that every time you execute #time, the timer will be switched from on to off, or vice-versa. This is not always convenient; you can also explicitly set it to the desired state, like this:<br>#time "on"
// everything now is timed
#time "off"
Copy<br>
If you are interested in profiling, you should take a look at <a data-tooltip-position="top" aria-label="http://www.privateeye.io/" rel="noopener" class="external-link" href="http://www.privateeye.io/" target="_blank">PrivateEye</a>; check out <a data-tooltip-position="top" aria-label="https://twitter.com/gregyoung" rel="noopener" class="external-link" href="https://twitter.com/gregyoung" target="_blank">Greg Young</a>â€™s <a data-tooltip-position="top" aria-label="https://vimeo.com/131637366" rel="noopener" class="external-link" href="https://vimeo.com/131637366" target="_blank">talk at NDC Oslo 2015</a> to get a feel for what it does.
<br><br>Hat tip to <a data-tooltip-position="top" aria-label="https://twitter.com/rickasaurus" rel="noopener" class="external-link" href="https://twitter.com/rickasaurus" target="_blank">Rick Minerich</a> for that one. Iâ€™ll refer you to his blog post to see how to <a data-tooltip-position="top" aria-label="http://richardminerich.com/2013/03/setting-up-fsharp-interactive-for-machine-learning-with-large-datasets/" rel="noopener" class="external-link" href="http://richardminerich.com/2013/03/setting-up-fsharp-interactive-for-machine-learning-with-large-datasets/" target="_blank">set FSI to 64 bits to handle large datasets</a>.<br><br>Did you know that you couldâ€¦<br>
<br><a data-tooltip-position="top" aria-label="https://channel9.msdn.com/Events/Visual-Studio/Visual-Studio-2015-Final-Release-Event/Six-Quick-Picks-from-Visual-F-40" rel="noopener" class="external-link" href="https://channel9.msdn.com/Events/Visual-Studio/Visual-Studio-2015-Final-Release-Event/Six-Quick-Picks-from-Visual-F-40" target="_blank">debug an F# script? (around 0:12:35 in)</a>
<br><a data-tooltip-position="top" aria-label="http://www.swensensoftware.com/fseye" rel="noopener" class="external-link" href="http://www.swensensoftware.com/fseye" target="_blank">inspect the objects in your FSI session with <strong></strong>?</a>FsEye
<br>change the FSI font size in Tools/Options/Environment/Fonts and Colors/Show Settings for/F# Interactive?
<br>add your own pretty-printer to FSI, <a data-tooltip-position="top" aria-label="https://github.com/mathnet/mathnet-numerics/blob/master/src/FSharp/MathNet.Numerics.fsx" rel="noopener" class="external-link" href="https://github.com/mathnet/mathnet-numerics/blob/master/src/FSharp/MathNet.Numerics.fsx" target="_blank">like this</a>?
<br>mess with your coworkersâ€™ mental sanity, by executing (* (opening a multiline comment) in FSI? (credit: <a data-tooltip-position="top" aria-label="https://twitter.com/tomaspetricek" rel="noopener" class="external-link" href="https://twitter.com/tomaspetricek" target="_blank">Tomas</a>)
<br>simplify loading references with Visual Studio and Power Tools? (credit: <a data-tooltip-position="top" aria-label="https://twitter.com/kitlovesfsharp" rel="noopener" class="external-link" href="https://twitter.com/kitlovesfsharp" target="_blank">Kit Eason</a>, see details in comments section).
<br>And againâ€¦ if you are not using the <a data-tooltip-position="top" aria-label="http://fsprojects.github.io/VisualFSharpPowerTools/" rel="noopener" class="external-link" href="http://fsprojects.github.io/VisualFSharpPowerTools/" target="_blank">Visual F# Power Tools</a>, you are missing out:<br>
"Don't let your friends try <a data-tooltip-position="top" aria-label="https://twitter.com/hashtag/fsharp?src=hash" rel="noopener" class="external-link" href="https://twitter.com/hashtag/fsharp?src=hash" target="_blank"></a><a href="https://muqiuhan.github.io/wiki?query=tag:fsharp" class="tag" target="_blank" rel="noopener">#fsharp</a> without installing <a data-tooltip-position="top" aria-label="https://twitter.com/FSPowerTools" rel="noopener" class="external-link" href="https://twitter.com/FSPowerTools" target="_blank">@FSPowerTools</a>." <a data-tooltip-position="top" aria-label="https://twitter.com/dsyme" rel="noopener" class="external-link" href="https://twitter.com/dsyme" target="_blank">@dsyme</a> at <a data-tooltip-position="top" aria-label="https://twitter.com/hashtag/ndclondon?src=hash" rel="noopener" class="external-link" href="https://twitter.com/hashtag/ndclondon?src=hash" target="_blank"></a><a href="https://muqiuhan.github.io/wiki?query=tag:ndclondon" class="tag" target="_blank" rel="noopener">#ndclondon</a>
â€” Tomas Petricek (@tomaspetricek) <a data-tooltip-position="top" aria-label="https://twitter.com/tomaspetricek/status/687934127627186176" rel="noopener" class="external-link" href="https://twitter.com/tomaspetricek/status/687934127627186176" target="_blank">January 15, 2016</a>
<br>Thatâ€™s what I got! I am sure I forgot some - do you have a useful or favorite trick to share?]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/fsharp/10-tips-for-productive-fsharp-scripting.html</link><guid isPermaLink="false">Computer Science/Programming Language/FSharp/10 Tips for Productive FSharp Scripting.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sat, 11 May 2024 13:23:17 GMT</pubDate></item><item><title><![CDATA[Amoeba optimization method using FSharp]]></title><description><![CDATA[ 
 <br>My favorite column in MSDN Magazine is Test Run; it was originally focused on testing, but the author, James McCaffrey, has been focusing lately on topics revolving around numeric optimization and machine learning, presenting a variety of methods and approaches. I quite enjoy his work, with one minor gripe â€“his examples are all coded in C#, which in my opinion is really too bad, because the algorithms would gain much clarity if written in F# instead.<br>Back in June 2013, he published a piece on <a data-tooltip-position="top" aria-label="http://msdn.microsoft.com/en-us/magazine/dn201752.aspx" rel="noopener" class="external-link" href="http://msdn.microsoft.com/en-us/magazine/dn201752.aspx" target="_blank">Amoeba Method Optimization using C#</a>. I hadnâ€™t seen that approach before, and found it intriguing. I also found the C# code a bit too hairy for my feeble brain to follow, so I decided to rewrite it in F#.<br>In a nutshell, the Amoeba approach is a heuristic to find the minimum of a function. Its proper respectable name is the <a data-tooltip-position="top" aria-label="http://en.wikipedia.org/wiki/Nelder%E2%80%93Mead_method" rel="noopener" class="external-link" href="http://en.wikipedia.org/wiki/Nelder%E2%80%93Mead_method" target="_blank">Nelder-Nead method</a>. The reason it is also called the Amoeba method is because of the way the algorithm works: in its simple form, it starts from a triangle, the â€œAmoebaâ€; at each step, the Amoeba â€œprobesâ€ the value of 3 points in its neighborhood, and moves based on how much better the new points are. As a result, the triangle is iteratively updated, and behaves a bit like an Amoeba moving on a surface.<br>Before going into the actual details of the algorithm, here is how my final result looks like. You can find the entire code <a data-tooltip-position="top" aria-label="https://github.com/mathias-brandewinder/Amoeba" rel="noopener" class="external-link" href="https://github.com/mathias-brandewinder/Amoeba" target="_blank">here on GitHub</a>, with some usage examples in the Sample.fsx script file. Letâ€™s demo the code in action: in a script file, we load the Amoeba code, and use the same function the article does, the <a data-tooltip-position="top" aria-label="http://mathworld.wolfram.com/RosenbrockFunction.html" rel="noopener" class="external-link" href="http://mathworld.wolfram.com/RosenbrockFunction.html" target="_blank">Rosenbrock function</a>. We transform the function a bit, so that it takes a Point (an alias for an Array of floats, essentially a vector) as an input, and pass it to the solve function, with the domain where we want to search, in that case, [ â€“10.0; 10.0 ] for both x and y:<br>#load "Amoeba.fs"
 
open Amoeba
open Amoeba.Solver
 
let g (x:float) y =
100. * pown (y - x * x) 2 + pown (1. - x) 2
 
let testFunction (x:Point) =
g x.[0] x.[1]
 
solve Default [| (-10.,10.); (-10.,10.) |] testFunction 1000
Copy<br>Running this in the F# interactive window should produce the following:<br>val it : Solution = (0.0, [|1.0; 1.0|]) 
&gt;
Copy<br>The algorithm properly identified that the minimum is 0, for a value of x = 1.0 and y = 1.0. Note that results may vary: this is a heuristic, which starts with a random initial amoeba, so each run could produce slightly different results, and might at times epically fail.<br>So how does the algorithm work?<br>I wonâ€™t go into full detail on the implementation, but here are some points of interest. At each iteration, the Amoeba has a collection of candidate solutions, Points that could be a Solution, with their value (the value of the function to be minimized at that point). These points can be ordered by value, and as such, always have a best and worst point. The following picture, which I lifted from the article, shows what points the Amoeba is probing:<br><img alt="Amoeba" src="https://mathias-brandewinder.github.io//assets/amoeba.png" referrerpolicy="no-referrer"><br>Source: <a data-tooltip-position="top" aria-label="http://msdn.microsoft.com/en-us/magazine/dn201752.aspx" rel="noopener" class="external-link" href="http://msdn.microsoft.com/en-us/magazine/dn201752.aspx" target="_blank">â€œAmoeba Optimization Method in C#â€</a><br>The algorithm constructs a Centroid, the average of all current solutions except the worst one, and attempts to replace the Worst with 3 candidates: a Contracted, Reflected and Expanded solution. If none of these is satisfactory (the rules are pretty straightforward in the code), the Amoeba shrinks towards the Best solution. In other words, first the Amoeba searches for new directions to explore by trying to replace its current Worst solution, and if no good change is found, it shrinks on itself, narrowing down around its current search zone towards its current Best candidate.<br>If you consider the diagram, clearly all transformations are a variation on the same theme: take the Worst solution and the Centroid, and compute a new point by stretching it by different values: â€“50% for contraction, +100% for reflection, and +200% for expansion. For that matter, the shrinkage can also be represented as a stretch of â€“50% towards the Best point.<br>This is what I ended up with:<br>type Point = float []
type Settings = { Alpha:float; Sigma:float; Gamma:float; Rho:float; Size:int }
 
let stretch ((X,Y):Point*Point) (s:float) =
Array.map2 (fun x y -&gt; x + s * (x - y)) X Y
 
let reflected V s = stretch V s.Alpha
let expanded V s = stretch V s.Gamma
let contracted V s = stretch V s.Rho
Copy<br>I defined Point as an alias for an array of floats, and a Record type Settings to hold the parameters that describe the transformation. The function stretch takes a pair of points and a float (by how much to stretch), and computes the resulting Point by taking every coordinate, and going by a ratio s from x towards y. From then on, defining the 3 transforms is trivial; they just use different values from the settings.<br>Now that we have the Points represented, the other part of the algorithm requires evaluating a function at each of these points. That part was done with a couple types:<br>type Solution = float * Point
type Objective = Point -&gt; float
 
type Amoeba =
{ Dim:int; Solutions:Solution [] } // assumed to be sorted by fst value
member this.Size = this.Solutions.Length
member this.Best = this.Solutions.[0]
member this.Worst = this.Solutions.[this.Size - 1]
 
let evaluate (f:Objective) (x:Point) = f x, x
let valueOf (s:Solution) = fst s
Copy<br>A Solution is a tuple, a pair associating a Point and the value of the function at that point. The function we are trying to minimize, the Objective, takes in a point, and returns a float. We can then define an Amoeba as an array of Solutions, which is assumed to be sorted. Nothing guarantees that the Solutions are ordered, which bugged me for a while; I was tempted to make that type private or internal, but this would have caused some extra hassle for testing, so I decided not to bother with it. I added a few convenience methods on the Amoeba, to directly extract the Best and Worst solutions, and two utility functions, evaluate, which associates a Point with its value, and its counter-part, valueOf, which extracts the value part of a Solution.<br>The rest of the code is really mechanics; I followed the algorithm notation from the Wikipedia page, rather than the MSDN article, because it was actually a bit easier to transcribe, built the search as a recursion (of course), which iteratively transforms an Amoeba for a given number of iterations. For good measure, I introduced another type, Domain, describing where the Amoeba should begin searching, and voila! We are done. In 91 lines of F#, we got a full implementation.<br><br>What I find nice about the algorithm is its relative simplicity. One nice benefit is that it doesnâ€™t require a derivative. Quite often, search algorithms use a gradient to evaluate the slope and decide what direction to explore. The drawback is that first, computing gradients is not always fun, and second, there might not even be a properly defined gradient in the first place. By contrast, the Amoeba doesnâ€™t require anything â€“ just give it a function, and let it probe. In some respects, the algorithm looks to me like a very simple genetic algorithm, maintaining a population of solutions, breeding new ones and letting a form of natural selection operate.<br>Of course, the price to pay for this simplicity is that it is a heuristic, that is, there is no guarantee that the algorithm will find a good solution. From my limited experimentations with it, even in simple cases, failures were not that unusual. If I get time for this, I think it would be fun to try launching multiple searches, and stopping when, say, the algorithm has found the same Best solution a given number of times.<br>Also, note that in this implementation, 2 cases are not covered: the case where the function is not defined everywhere (some Points might throw an exception), and the case where the function doesnâ€™t have a minimum. I will let the enterprising reader think about how that could be handled!]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/fsharp/amoeba-optimization-method-using-fsharp.html</link><guid isPermaLink="false">Computer Science/Programming Language/FSharp/Amoeba optimization method using FSharp.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:31 GMT</pubDate><enclosure url="https://mathias-brandewinder.github.io//assets/amoeba.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://mathias-brandewinder.github.io//assets/amoeba.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Baby steps with CNTK and FSharp]]></title><description><![CDATA[ 
 <br>So what have I been up to lately? Obsessing over <a data-tooltip-position="top" aria-label="https://www.microsoft.com/en-us/cognitive-toolkit/" rel="noopener" class="external-link" href="https://www.microsoft.com/en-us/cognitive-toolkit/" target="_blank">CNTK, the Microsoft deep-learning library</a>. Specifically, the team released a <a data-tooltip-position="top" aria-label="https://docs.microsoft.com/en-us/cognitive-toolkit/cntk-library-managed-api" rel="noopener" class="external-link" href="https://docs.microsoft.com/en-us/cognitive-toolkit/cntk-library-managed-api" target="_blank">.NET API</a>, which got me interested in exploring how usable this would be from the F# scripting environment. I started a <a data-tooltip-position="top" aria-label="https://github.com/mathias-brandewinder/CNTK.FSharp" rel="noopener" class="external-link" href="https://github.com/mathias-brandewinder/CNTK.FSharp" target="_blank">repository to try out some ideas already</a>, but, before diving into that in later posts, I figure I could start by a simple introduction, to set some context.<br>First, what problem does CNTK solve?<br>Imagine that you are interested in predicting something, and that you have data available, both inputs you can observe (the features), and the values you are trying to predict (the labels). Imagine now that you have an idea of the type of relationship between the input and the output, something along the lines of:<br>labels â‰ˆ function(features, parameters).<br>To make this more concrete, that function could be quite complex, and involve multiple layers of input transformation into the final output (â€œdeep learningâ€), or it could be quite simple, for instance a traditional linear regression, something along the lines of:<br>car price â‰ˆ car years * coefficient1 + car engine size * coefficient2 + constant.<br>In this particular case, we have 2 features (car years and car engine size), 1 label (car price), and 3 parameters (coefficient1, coefficient2 and constant) - and we would like to find â€œgoodâ€ values for the 3 parameters so that the predicted value is in general close to the correct value.<br>The purpose of CNTK is to:<br>
<br>let you specify a function connecting input and output,
<br>let you specify how to read example data to learn from,
<br>learn good parameter values from the example data,
<br>let you learn parameters on CPU or GPU, for large datasets and complex functions.
<br>With that in mind, letâ€™s take a look at a very basic example, a simple linear regression. Using CNTK here is complete overkill, and not worth the overhead; I would not use it for something that simple. Our goal here is simply to illustrate the basics of how CNTK works, from F#. In future posts, we will look into scenarios where CNTK is actually useful. As a secondary goal, I want to discuss some of the aspects that make building a nice F# API on top of the current .NET one tricky.<br><br>First order of business: letâ€™s load this thing into VS Code.<br>CNTK has a few packages on Nuget, based on what environment you want to run on. In our case, we will focus on a <a data-tooltip-position="top" aria-label="https://www.nuget.org/packages/CNTK.CPUOnly/" rel="noopener" class="external-link" href="https://www.nuget.org/packages/CNTK.CPUOnly/" target="_blank">CPU-only scenario, using the CNTK.CPUOnly 2.3.1 package</a>.<br>We assume that the <a data-tooltip-position="top" aria-label="https://marketplace.visualstudio.com/items?itemName=Ionide.Ionide-fsharp" rel="noopener" class="external-link" href="https://marketplace.visualstudio.com/items?itemName=Ionide.Ionide-fsharp" target="_blank">Ionide-fsharp</a> and <a data-tooltip-position="top" aria-label="https://marketplace.visualstudio.com/items?itemName=Ionide.Ionide-Paket" rel="noopener" class="external-link" href="https://marketplace.visualstudio.com/items?itemName=Ionide.Ionide-Paket" target="_blank">Ionide-Paket</a> extensions are installed in VS Code. Open the Folder where you want to work, and run the Paket: Init command (CTRL+SHIFT+P reveals the available commands). This will create a paket.dependencies file in the folder, where you can now specify what packages are needed, like this:<br>framework:net46
source https://www.nuget.org/api/v2
nuget CNTK.CPUOnly
Copy<br>Run Paket: Install next, and let Paket do its magic, and download the required packages. Once the operation completes, you should see a new folder, packages, with the following structure:<br>packages
  CNTK.CPUOnly
    lib
      net45
        x64
          Cntk.Core.Managed-2.3.1.dll
    support
      x64
        Debug
        Dependency
        Release
Copy<br>Letâ€™s start creating the script we will be working with now, by adding an F# script file CNTK.fsx to our folder. Unfortunately, CNTK depends on a few native libraries to run properly. As a result, the setup is a bit more involved than the usual #r "path/to/library.dll. Weâ€™ll follow <a data-tooltip-position="top" aria-label="https://twitter.com/cdrnet" rel="noopener" class="external-link" href="https://twitter.com/cdrnet" target="_blank">@cdrnet</a> <a data-tooltip-position="top" aria-label="http://christoph.ruegg.name/blog/loading-native-dlls-in-fsharp-interactive.html" rel="noopener" class="external-link" href="http://christoph.ruegg.name/blog/loading-native-dlls-in-fsharp-interactive.html" target="_blank">approach to load native libraries described here</a>, and add to the PATH every folder that contains the dlls we need, so Cntk.Core.Managed-2.3.1.dll can find them:<br>
Note: I put the <a data-tooltip-position="top" aria-label="https://gist.github.com/mathias-brandewinder/d48abe4a571c53a4a70c709c3121a566" rel="noopener" class="external-link" href="https://gist.github.com/mathias-brandewinder/d48abe4a571c53a4a70c709c3121a566" target="_blank">full code used in the post on a gist here</a>
<br>open System
open System.IO

Environment.SetEnvironmentVariable("Path",
    Environment.GetEnvironmentVariable("Path") + ";" + __SOURCE_DIRECTORY__)

let dependencies = [
        "./packages/CNTK.CPUOnly/lib/net45/x64/"
        "./packages/CNTK.CPUOnly/support/x64/Dependency/"
        "./packages/CNTK.CPUOnly/support/x64/Dependency/Release/"
        "./packages/CNTK.CPUOnly/support/x64/Release/"    
    ]

dependencies 
|&gt; Seq.iter (fun dep -&gt; 
    let path = Path.Combine(__SOURCE_DIRECTORY__,dep)
    Environment.SetEnvironmentVariable("Path",
        Environment.GetEnvironmentVariable("Path") + ";" + path)
    )    

#I "./packages/CNTK.CPUOnly/lib/net45/x64/"
#I "./packages/CNTK.CPUOnly/support/x64/Dependency/"
#I "./packages/CNTK.CPUOnly/support/x64/Dependency/Release/"
#I "./packages/CNTK.CPUOnly/support/x64/Release/"

#r "./packages/CNTK.CPUOnly/lib/net45/x64/Cntk.Core.Managed-2.3.1.dll"
open CNTK
Copy<br><br>We can now start using CNTK in our script. Letâ€™s build a function that takes 2 floats as input, and returns a float as an output, multiplying each of the inputs by a parameter.<br>A core element in CNTK is the NDShape, for n-dimensional shape. Think of an NDShape as an n-dimensional array. A vector of size 5 would be an NDShape of dimension [ 5 ] (rank 1), a 12x18 image a NDShape [ 12; 18 ] (rank 2), a 10 x 10 RGB image a NDShape [ 10; 10; 3 channels ] (rank 3), and so on. In our case, the input is an array of size 2, and the output an array of size 1:<br>let inputDim = 2
let outputDim = 1
let input = Variable.InputVariable(NDShape.CreateNDShape [inputDim], DataType.Double, "input")
let output = Variable.InputVariable(NDShape.CreateNDShape [outputDim], DataType.Double, "output")
Copy<br>Which produces the following output:<br>val inputDim : int = 2
val outputDim : int = 1
val input = Variable
val output = Variable
Copy<br>Note how the numeric type of the Variable, DataType.Double, is passed in as a argument, and not generic. Note also how the numeric types are aligned with the C# convention; that is, a DataType.Double is an F# float, and a DataType.Float is an F# single.<br>We can ask a Variable about its shape, for instance input.Shape:<br>val it : NDShape = CNTK.NDShape { Dimensions = seq [2]; (* more stuff *) Rank = 1; }
Copy<br>Letâ€™s create our Function now:<br>let device = DeviceDescriptor.CPUDevice

let predictor =
    let dim = input.Shape.[0]
    let weights = new Parameter(NDShape.CreateNDShape [dim], DataType.Double, 0.0, device, "weights")
    // create an intermediate Function
    let product = CNTKLib.TransposeTimes(input, weights)    
    let constant = new Parameter(NDShape.CreateNDShape [ outputDim ], DataType.Double, 0.0, device, "constant") 
    CNTKLib.Plus(new Variable(product), constant)
Copy<br>val device : DeviceDescriptor
val predictor : Function
Copy<br>A couple of comments here. Our predictor creates a named Parameter weights of dimension and type matching the input Variable, with values initialized at 0.0. We multiply the two shapes together, by calling CNTKLib.TransposeTimes, computing x1 * w1 + x2 * w2, which returns a Function. We then create another Parameter for our constant, and sum them up, using CNTKLib.Plus.<br>Note how we have to explicitly convert product into a Variable in the final step, using new Variable(product). CNTKLib.Plus (and the other functions built in CNTKLib) expects 2 Variable arguments. Unfortunately, a Function is not a Variable, and they do not derive from a common class or interface. The .NET API supports implicit conversion between these 2 types, which works well in C#, where you could just sum these up directly, like this: CNTKLib.Plus(product, constant). F# doesnâ€™t support implicit conversion, and as a result, this requires an annoying amount of explicit manual conversion to combine operations together.<br>Note also how we passed in device, a DeviceDescriptor, to the Parameter constructor. A CNTK Function is intended to run on a device, which must be specified. In this case, we could have omitted the device, in what case it would have picked up by default CPU.<br><br>Now that we have a Function - what can we do with it?<br>Unsuprisingly, we can pass input to a function, and compute the resulting value. We will do that next. However, before doing that, itâ€™s perhaps useful to put things in perspective, to understand why this isnâ€™t as straightforward as you might expect from something named a function. Once an F# function has been instantiated, its whole purpose is to transform an input value into an output value. The intent of a CNTK Function is subtly different: the objective here is to take a function, and modify its Parameters so that when passed in some input, the output it produces is close to some desired output, the Labels. In other words, we want a Function to be â€œtrainableâ€: we want to be able to pass it known input/output pairs, and adjust the function parameters to fit the data better.<br>With that said, letâ€™s evaluate our predictor function. To do that, we will need to do 3 things:<br>
<br>Supply values to fill in the â€œinputâ€ placeholder shape,
<br>Specify what values we want to observe - we might be interested in the output, but also the weights, for instance,
<br>Specify what device we want the function to run on.
<br>Letâ€™s do that:<br>open System.Collections.Generic

let inputValue = Value.CreateBatch(NDShape.CreateNDShape [inputDim], [| 3.0; 5.0 |], device)
let inputMap = 
    let map = Dictionary&lt;Variable,Value&gt;()
    map.Add(input, inputValue)
    map

let predictedOutput = predictor.Output
let weights = 
    predictor.Parameters () 
    |&gt; Seq.find (fun p -&gt; p.Name = "weights")
let constant = 
    predictor.Parameters () 
    |&gt; Seq.find (fun p -&gt; p.Name = "constant")
let outputMap =
    let map = Dictionary&lt;Variable,Value&gt;()
    map.Add(predictedOutput, null)
    map.Add(weights, null)
    map.Add(constant, null)
    map

predictor.Evaluate(inputMap,outputMap,device)
Copy<br>To evaluate a Function, we pass it the input we care about, a Dictionary&lt;Variable,Value&gt;, which we fill in with input, the Variable we defined earlier. We provide (completely arbitrarily) a value of [3.0;5.0] as an input value. In a similar fashion, we specify what we want to observe: the predicted value, predictor.Output, as well as the 2 named parameters we created, â€œweightsâ€ and â€œconstantâ€, which we also retrieve from the Function itself. In this case, we set the Value to null, because we have no input to supply. Finally, we run predictor.Evaluate, which will take the inputMap and fill in the missing values in the outputMap.<br>We can now review the outputs:<br>let currentPrediction = 
    outputMap.[predictedOutput].GetDenseData&lt;float&gt;(predictedOutput) 
    |&gt; Seq.map (fun x -&gt; x |&gt; Seq.toArray)
    |&gt; Seq.toArray

let currentWeights = 
    outputMap.[weights].GetDenseData&lt;float&gt;(weights) 
    |&gt; Seq.map (fun x -&gt; x |&gt; Seq.toArray)
    |&gt; Seq.toArray

let currentConstant = 
    outputMap.[constant].GetDenseData&lt;float&gt;(constant) 
    |&gt; Seq.map (fun x -&gt; x |&gt; Seq.toArray)
    |&gt; Seq.toArray
Copy<br>This is not pretty, butâ€¦ we have values.<br>val currentPrediction : float [] [] = [| [| 0.0 |] |]
val currentWeights : float [] [] = [| [| 0.0; 0.0 |] |] 
val currentConstant : float [] [] = [| [| 0.0 |] |] 
Copy<br>The values we get back are pretty unexciting, but at least they are what we would expect to see. Given that both weights and constant were initialized at 0.0, the function should produce a currentPrediction of 0.0 * 3.0 + 0.0 * 5.0 + 0.0, which is indeed 0.0.<br>Two quick notes here. First, because a value could be of any DataType, we have to manually specify a type when retrieving the values, as in GetDenseData&lt;float&gt;. Then, this is a very stateful model: when we fill in values for the input in the inputMap, we pass in the input instance we initially created to construct the Function. In a similar fashion, we are retrieving values from the instances we passed into the outputMap.<br><br>This was pretty painful. So what is our reward for that pain?<br>As I stated earlier, one defining feature of a Function is that it can be trained. What we mean by that is the following: we can take a Function, supply it batches of input and desired output pairs, and progressively adjust the internal Parameter(s) of the Function so that the values computed by the Function become close(r) to the desired output.<br>Letâ€™s start with a simple illustration. Suppose for a minute that, for our input [ 3.0; 5.0 ], we expected a result of 10.0. Currently, our weights and constant are set to 0.0. By modifying these 3 values, we should be able to tune our predictor to get an answer of 10.0.<br>This is, of course, a silly example. There are many ways I could change the parameters to produce 10.0 - I could set the constant to 10.0, or the second weight to 2.0, or infinitely many other combinations. To get something meaningful, I would need many different input/output pairs. However, weâ€™ll start with this, strictly to illustrate the mechanics involved.<br>Training a Function involves 3 elements:<br>
<br>Supplying a batch of input / output pairs (features and labels),
<br>Defining a measure of fit, that is, how to measure if a value is close to the desired value,
<br>Specifying how parameters should be adjusted to improve the function.
<br>let batchInputValue = Value.CreateBatch(NDShape.CreateNDShape [inputDim], [| 3.0; 5.0 |], device)
let batchOutputValue = Value.CreateBatch(NDShape.CreateNDShape [outputDim], [| 10.0 |], device)

let batch =
    [
        input,batchInputValue
        output,batchOutputValue
    ]
    |&gt; dict

let loss = CNTKLib.SquaredError(new Variable(predictor), output, "loss")
let evaluation = CNTKLib.SquaredError(new Variable(predictor), output, "evaluation")

let learningRatePerSample = new TrainingParameterScheduleDouble(0.01, uint32 1)
let learners = 
    ResizeArray&lt;Learner&gt;(
        [
            Learner.SGDLearner(predictor.Parameters(), learningRatePerSample)
        ]
        )

let trainer = Trainer.CreateTrainer(predictor, loss, evaluation, learners)

for i in 0 .. 10 do
    let _ = trainer.TrainMinibatch(batch, true, device)
    trainer.PreviousMinibatchLossAverage () |&gt; printfn "Loss: %f"
    trainer.PreviousMinibatchEvaluationAverage () |&gt; printfn "Eval: %f"
Copy<br>First, we create a batch of input/output values ([ 3.0; 5.0 ] and [ 10.0 ]), and link them to the input and output Variable(s) we created. Then we define what measure we want to use to determine if a prediction is close or not from the target value. In this case, we use the built-in CNTKLib.SquaredError, which computes the square difference between the predicted value (new Variable(predictor)) and the target value (output). For instance, with the initial weights and constant, the predicted value will be 0.0, and we specified that the desired value was 10.0, so the loss function will evaluate to (0.0 - 10.0)^2, that is, 100.0 - and a perfect prediction of 10.0 would result in a loss of 0.0. Finally, without going into much detail, we specify in learners which strategy to apply when updating the function parameters. In this case, we use the built-in Stochastic Gradient Descent (SGD) strategy, with a learning rate of 0.01 (how aggressively to update the parameters) and a batch size of 1, using only one input/output pair at a time when performing adjustments.<br>We feed all that into a Trainer, and perform 10 updates (trainer.TrainMinibatch), using the same example input/output each time, and writing out the current value of the loss function:<br>Loss: 100.000000
Eval: 100.000000
Loss: 9.000000
Eval: 9.000000
// omitted intermediate results for brevity 
Loss: 0.000000
Eval: 0.000000
Loss: 0.000000
Eval: 0.000000
Copy<br>As you can observe, the prediction error decreases rapidly, from 100.0 initially (as expected), to basically 0.0 after only 10 steps.<br>Letâ€™s make this a bit more interesting, by feeding different examples to the model:<br>let realModel (features:float[]) =
    3.0 * features.[0] - 2.0 * features.[1] + 5.0

let rng = Random(123456)
let batch () =        
    let batchSize = 32        
    let features = [| rng.NextDouble(); rng.NextDouble() |]
    let labels = [| realModel features |]
    let inputValues = Value.CreateBatch(NDShape.CreateNDShape [inputDim], features, device)
    let outputValues = Value.CreateBatch(NDShape.CreateNDShape [outputDim], labels, device)
    [
        input,inputValues
        output,outputValues
    ]
    |&gt; dict
Copy<br>Here we simply create a â€œtrueâ€ function, realModel, which we use to generate synthetic data. We then modify our previous example, to feed 1,000 different examples for training:<br>#time "on"

for _ in 1 .. 1000 do
    
    let example = batch ()
    trainer.TrainMinibatch(example,true,device) |&gt; ignore
    trainer.PreviousMinibatchLossAverage () |&gt; printfn "Loss: %f"
Copy<br>On my machine, extracting the weights and constant from the Function after training yields 3.0019, -1.9978 and 4.9975 - pretty close to the correct values of 3.0, -2.0 and 5.0 that we used in realModel.<br>
Note: I put the <a data-tooltip-position="top" aria-label="https://gist.github.com/mathias-brandewinder/d48abe4a571c53a4a70c709c3121a566" rel="noopener" class="external-link" href="https://gist.github.com/mathias-brandewinder/d48abe4a571c53a4a70c709c3121a566" target="_blank">full code used in the post on a gist here</a>
<br><br>First, I want to re-iterate that the example we went through is not showcasing a good example of where and how to use CNTK. It is intended primarily as an illustration of CNTKâ€™s building blocks and how they work together. For a trivial linear regression example like this one (shallow learning, if you will), you would be better served with a standard library such as <a data-tooltip-position="top" aria-label="http://accord-framework.net/" rel="noopener" class="external-link" href="http://accord-framework.net/" target="_blank">Accord.NET</a>. CNTK becomes interesting if you have a deeper, more complex model, and a larger dataset - weâ€™ll explore this in later posts.<br>
As a side-note, my initial intent was to use real batches for the final example, passing in multiple examples at once, but for reasons I couldnâ€™t figure out yet, the code kept crashing.
<br>My second goal was to explore the design of the current .NET API, as a preliminary step before trying to build an F#-scripting friendly layer on top of it.<br>In its current state, the CNTK .NET library is fairly low-level, and rather unpleasant to work with from F#. Ideally, one would like to be able to create re-usable blocks and compose them easily, along the lines of the Keras model, using a DSL to, for instance, define a network by stacking standard transformation layers on top of each other.<br>Such a DSL seems quite possible to achieve in F#, but requires taking into account a few design considerations. First, the choice to use implicit conversion between Variable and Function makes composition of functions in F# painful. This choice is reasonable for C#, but requires re-wrapping every Function into a Variable to string operations together on the F# side.<br>One aspect I am not a fan of in the library is how the DeviceDescriptor leaks all the way down. With the current model, I could create 2 parameters, one on CPU, one on GPU, and combine them together, which doesnâ€™t make a lot of sense. In an ideal world, I would like to define a Function independently of any device, and only then decide whether I want to train that model on a CPU or a GPU.<br>Finally, the fact that a Variable or a Function cannot be named after it was instantiated, as far as I can tell, introduces complications in composing blocks together. If naming was separate from instantiation, we could create a function like named : string -&gt; Function -&gt; Function, which could be inserted anywhere.<br>I havenâ€™t had much time yet to dig into the data readers; so far, most of my efforts have gone into exploring possible directions to address the questions above. If you are interested, the <a data-tooltip-position="top" aria-label="https://github.com/mathias-brandewinder/CNTK.FSharp" rel="noopener" class="external-link" href="https://github.com/mathias-brandewinder/CNTK.FSharp" target="_blank">master branch of my repository</a> contains working, straight conversions of the <a data-tooltip-position="top" aria-label="https://github.com/Microsoft/CNTK/tree/master/Examples/TrainingCSharp/Common" rel="noopener" class="external-link" href="https://github.com/Microsoft/CNTK/tree/master/Examples/TrainingCSharp/Common" target="_blank">C# examples published by the CNTK team</a>; the results of my explorations can be found in the 3 branches <a data-tooltip-position="top" aria-label="https://github.com/mathias-brandewinder/CNTK.FSharp/tree/experiment-varorfun" rel="noopener" class="external-link" href="https://github.com/mathias-brandewinder/CNTK.FSharp/tree/experiment-varorfun" target="_blank">experiment-varorfun</a>, <a data-tooltip-position="top" aria-label="https://github.com/mathias-brandewinder/CNTK.FSharp/tree/experiment-interpreter" rel="noopener" class="external-link" href="https://github.com/mathias-brandewinder/CNTK.FSharp/tree/experiment-interpreter" target="_blank">experiment-interpreter</a> and <a data-tooltip-position="top" aria-label="https://github.com/mathias-brandewinder/CNTK.FSharp/tree/experiment-stacking" rel="noopener" class="external-link" href="https://github.com/mathias-brandewinder/CNTK.FSharp/tree/experiment-stacking" target="_blank">experiment-stacking</a>.<br>I hope you found something of interest in this post! If you have feedback or suggestions, I would be quite interested to hear about them :) In the meanwhile, I will keep exploring - expect more on the topic in the near future!]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/fsharp/baby-steps-with-cntk-and-fsharp.html</link><guid isPermaLink="false">Computer Science/Programming Language/FSharp/Baby steps with CNTK and FSharp.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:32 GMT</pubDate></item><item><title><![CDATA[Basic Regression Tree]]></title><description><![CDATA[ 
 <br>In our previous installment, we <a data-tooltip-position="top" aria-label="https://mathias-brandewinder.github.io//2016/08/06/gradient-boosting-part-1/" rel="noopener" class="external-link" href="https://mathias-brandewinder.github.io//2016/08/06/gradient-boosting-part-1/" target="_blank">began exploring Gradient Boosting</a>, and outlined how by combining extremely crude regression models - stumps - we could iteratively create a decent prediction model for the quality of wine bottles, using one Feature, one of the chemical measurements we have available.<br>In and of itself, this is an interesting result: the approach allows us to aggregate mediocre indicators together into a predictor that is better than its individual parts. However, so far, we are using only a tiny subset of the information available. Why restrict ourselves to a single Feature, and not use all of them? And, if the approach works with something as weak as a stump, perhaps we can do better, by aggregating less trivial prediction models?<br>This will be our goal today: we will create a <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Decision_tree_learning#Types" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Decision_tree_learning#Types" target="_blank">Regression Tree</a>, which we will in a future installment use in place of stumps in our Boosting procedure.<br><br><a data-tooltip-position="top" aria-label="https://gist.github.com/mathias-brandewinder/05683d63bfa67c8b706ce458035c0b81#file-gradient-boosting-2-fsx" rel="noopener" class="external-link" href="https://gist.github.com/mathias-brandewinder/05683d63bfa67c8b706ce458035c0b81#file-gradient-boosting-2-fsx" target="_blank"><em></em></a>Full code for this post available here as a Gist<br>The Stump model is rather simple: we take a Feature and a split value, the threshold. If the input value is under that threshold, we predict the average output value computed across examples under the threshold, otherwise, we do the opposite:<br><img alt="Stump" src="https://mathias-brandewinder.github.io//assets/2016-08-14-stump.png" referrerpolicy="no-referrer"><br>Or, in code:<br>type Wine = CsvProvider&lt;"data/winequality-red.csv",";",InferRows=1500&gt;

type Observation = Wine.Row

type Feature = Observation -&gt; float

type Example = Observation * float

type Predictor = Observation -&gt; float

let learnStump (sample:Example seq) (feature:Feature) threshold =
    let under = 
        sample 
        |&gt; Seq.filter (fun (obs,lbl) -&gt; feature obs &lt;= threshold)
        |&gt; Seq.averageBy (fun (obs,lbl) -&gt; lbl)
    let over = 
        sample 
        |&gt; Seq.filter (fun (obs,lbl) -&gt; feature obs &gt; threshold)
        |&gt; Seq.averageBy (fun (obs,lbl) -&gt; lbl)
    fun obs -&gt;
        if (feature obs &lt;= threshold)
        then under
        else over
Copy<br>A regression tree extends the idea further. Instead of limiting ourselves to a single threshold, we can further divide each group, and create trees like this one for instance:<br><img alt="Simple Tree" src="https://mathias-brandewinder.github.io//assets/2016-08-14-simple-tree.png" referrerpolicy="no-referrer"><br>Nothing forces us to keep the tree symmetrical, or to use a single Feature, though. This would be a perfectly acceptable tree as well:<br><img alt="Complex Tree" src="https://mathias-brandewinder.github.io//assets/2016-08-14-complex-tree.png" referrerpolicy="no-referrer"><br>The nice thing about trees is, they are pretty flexible, and very easy to interpret. With a tree, we can incorporate multiple features and their interactions. In our example, we are really modelling Quality as a surface, instead of a simple line in the stump example:<br><img alt="Quality Surface" src="https://mathias-brandewinder.github.io//assets/2016-08-14-surface.png" referrerpolicy="no-referrer"><br>The resulting model can be expressed in a very understandable form:<br>
If the Alcohol Level is over 10.5, the Quality is 5.5; Otherwise, check the Volatile Acidity. If it is below 0.8, the Quality is 6.0, otherwise it is 3.0.
<br><br>How can we go about representing and learning a Tree?<br>As it turns out, the representation is fairly straightforward. A Tree can be seen as a recursive data structure: either we reached a terminal Leaf, which gives us a prediction, or we reach a Branch, where, based on a Feature and associated split value, we will find 2 new Trees, one for values under the split value, another for values above the split.<br>That is a match in heaven for a Discriminated Union:<br>type Tree =
    | Leaf of float
    | Branch of (Feature * float) * Tree * Tree
Copy<br>Creating manually the â€œcomplexâ€ tree we described above can be done along these lines:<br>let exampleTree =
    // we start with a branch
    Branch(
        // we split on Alcohol level, 10.5
        (``Alcohol Level``, 10.5),
        // if alcohol level is under 10.5, 
        // we have another branch
        Branch(
            // we split on Volatile Acidity, 0.8
            (``Volatile Acidity``, 0.8),
            // if acidity is under 0.8, 
            // we predict 6.0
            Leaf(6.0),
            // otherwise we predict 3.0
            Leaf(3.0)
        ),
        // if alcohol is over 10.5,
        // we predict 5.5
        Leaf(5.5)
    )
Copy<br>How do we go about making predictions with a Tree? We simply walk it down recursively:<br>let rec predict (tree:Tree) (obs:Observation) =
    match tree with
    | Leaf(prediction) -&gt; prediction
    | Branch((feature,split),under,over) -&gt;
        let featureValue = feature obs
        if featureValue &lt;= split
        then predict under obs
        else predict over obs
Copy<br>Letâ€™s try it out on our example:<br>predict exampleTree (reds.Rows |&gt; Seq.head)

&gt; val it : float = 6.0
Copy<br>Note that, if we use partial application:<br>let examplePredictor = predict exampleTree
Copy<br>â€¦ we get back a function, examplePredictor, which happens to have exactly the signature we defined earlier for a Predictor:<br>val examplePredictor : (Observation -&gt; float)
Copy<br>As a result, we can immediately re-use the sumOfSquares error function we wrote last time, and evaluate how good our tree is fitting the dataset:<br>let sumOfSquares (sample:Example seq) predictor = 
    sample
    |&gt; Seq.sumBy (fun (obs,lbl) -&gt; 
        pown (lbl - predictor obs) 2)

let redSample = 
    reds.Rows 
    |&gt; Seq.map (fun row -&gt; row, row.Quality |&gt; float)

sumOfSquares redSample examplePredictor 
Copy<br>val it : float = 1617.0
Copy<br>The result is pretty terrible - but then, I picked the tree values randomly. Can we automatically learn a â€œgoodâ€ Tree?<br><br>If you recall, the approach we followed to learn a â€œgoodâ€ stump was the following: for a given Feature, try out various possible split values, and pick the one that gives us the smallest error, defined as the sumOfSquares between the predicted and actual values.<br>We can use the same idea for a Tree. Instead of stopping once we found a good split, we will simply repeat the same process, and look for a good split in each of the two samples we got after the split. Also, instead of searching for a split on a single Feature, we will now consider all of them, and select the best split across all available Features.<br>That smells like recursion. As a first pass, we will re-use some of the code we wrote last time, the learnStump and evenSplits functions, and whip together a quick-and-dirty tree learning function, disregarding any performance consideration:<br>let rec learnTree (sample:Example seq) (features:Feature list) (depth:int) =
    
    if depth = 0
    then
        // we reached maximum depth, and
        // predict the sample average.
        let avg = sample |&gt; Seq.averageBy snd
        Leaf(avg)
    else
        let (bestFeature,bestSplit) = 
            // create all feature * split combinations
            seq {
                for feature in features do
                    let splits = evenSplits sample feature 10
                    for split in splits -&gt; feature,split
            }
            // find the split with the smallest error
            |&gt; Seq.minBy (fun (feature,split) -&gt; 
                let predictor = learnStump sample feature split
                sumOfSquares sample predictor)
        // split the sample following the split
        let under = 
            sample 
            |&gt; Seq.filter (fun (obs,_) -&gt; 
                bestFeature obs &lt;= bestSplit)
        let over = 
            sample 
            |&gt; Seq.filter (fun (obs,_) -&gt; 
                bestFeature obs &gt; bestSplit)
        // learn the corresponding trees
        let underTree = learnTree under features (depth - 1)
        let overTree =  learnTree over features (depth - 1)
        // and create the corresponding branch
        Branch((bestFeature,bestSplit),underTree,overTree)
Copy<br>Letâ€™s try this out, with a Tree that should be equivalent to the first stump we created last time:<br>let originalStump = learnTree redSample [ ``Alcohol Level`` ] 1
sumOfSquares redSample (predict originalStump)
Copy<br>val it : float = 864.4309287
Copy<br>Good news - we get the same result. Now letâ€™s crank it up a notch:<br>let deeperTree = learnTree redSample [``Alcohol Level``;``Volatile Acidity``] 4
sumOfSquares redSample (predict deeperTree)
Copy<br>val it : float = 680.1290569
Copy<br>This is significantly better that the best result we achieved by ensembling stumps, 811.4601191.<br><br>We have a decent-looking Tree learning algorithm. However, not everything is perfect. For instance, emboldened by our success, we could try to increase the depth a bit.<br>let explodingTree = learnTree redSample [``Alcohol Level``] 5
Copy<br>System.ArgumentException: The step of a range cannot be zero.
Parameter name: step
// long list of F# complaints follows
Copy<br>Uh-oh. What is happening here?<br>As we recurse deeper in the Tree, we split the samples further and further, and have less and less data to train our stump on. One thing which might happen for instance is that we are left only with examples sharing the same label. In that situation, generating even splits is going to cause issues, because the width in [ min + width .. width .. max - width ] (our evenly-spaced splits) will be 0.0.<br>This indicates a first problem, namely, that there might not be any good split to use for a given sample.<br>Beyond that, the design is also a bit problematic. The choice of 10 even splits is quite arbitrary; we might want to use 3, or 42 even splits, or use different strategies altogether (splits of same size, every possible distinct value, â€¦). Our evenSplits function is hard-coded deep inside the algorithm - it would be much nicer if we could inject any split function as an argument.<br>In a similar vein, assuming we are comfortable with using stumps / binary splits, the choice of our error metric is also quite arbitrary. We might want to use something else that the sum of squared prediction errors (Manhattan distance, variance reduction, â€¦). Again, that function is buried deep inside - we would like to use any reasonable cost function we think relevant to the problem.<br>Finally, we are picking the split that yields the best cost. However, that split is not guaranteed to be an improvement. As an example, every observation in the sample could have the same label, in which case no split will improve our predictions. If the resulting cost is the same as before, it is pointless to split, and we might as well spare the algorithm a useless deeper search.<br>In short,<br>
<br>we are not guaranteed to have splits for every sample,
<br>we should split only when strict cost improvements are found,
<br>we would like to decide what splits to use,
<br>we would like to decide what cost metric to use.
<br>We are probably going slightly overboard here; the only real problem we have is the first one. At the same time, why not have a bit of fun!<br>I am going to start with defining a couple of type aliases and utilities:<br>let underOver (sample:Example seq) (feat:Feature,split:float) =
    let under = sample |&gt; Seq.filter (fun (obs,_) -&gt; feat obs &lt;= split)
    let over =  sample |&gt; Seq.filter (fun (obs,_) -&gt; feat obs &gt; split)
    under,over

type Splitter = Example seq -&gt; Feature -&gt; float list

type Cost = Example seq -&gt; float
Copy<br>underOver simply takes a sample, and partitions it into 2 samples, based on a feature and a split value. Splitter is a function that, given a sample and a Feature, will produce a (potentially empty) list of values we could split on. Cost simply measures how good a sample is.<br>Given these elements, we can now rewrite our learnTree function along these lines:<br>let rec learnTree (splitter:Splitter,cost:Cost) (sample:Example seq) (features:Feature list) (depth:int) =
    
    if depth = 0
    then
        let avg = sample |&gt; Seq.averageBy snd
        Leaf(avg)
    else
        let initialCost = cost sample        
        let candidates = 
            // build up all the feature/split candidates,
            // and their associated sample splits
            seq {
                for feature in features do
                    let splits = splitter sample feature
                    for split in splits -&gt; 
                        let under,over = underOver sample (feature,split)  
                        (feature,split),(under,over)
            }
            // compute and append cost of split
            |&gt; Seq.map (fun (candidate,(under,over)) -&gt;
                candidate,(under,over), cost under + cost over)
            // retain only candidates with strict cost improvement
            |&gt; Seq.filter (fun (candidate,(under,over),splitCost) -&gt;
                splitCost &lt; initialCost)

        if (Seq.isEmpty candidates)
        then
            let avg = sample |&gt; Seq.averageBy snd
            Leaf(avg)
        else
            let ((bestFeature,bestSplit),(under,over),spliCost) = 
                candidates 
                |&gt; Seq.minBy (fun (_,_,splitCost) -&gt; splitCost)

            let underTree = learnTree (splitter,cost) under features (depth - 1)
            let overTree =  learnTree (splitter,cost) over features (depth - 1)

            Branch((bestFeature,bestSplit),underTree,overTree)
Copy<br><br>Does it work? Letâ€™s try it out:<br>let evenSplitter n (sample:Example seq) (feature:Feature) = 
    let values = sample |&gt; Seq.map (fst &gt;&gt; feature)
    let min = values |&gt; Seq.min
    let max = values |&gt; Seq.max
    if min = max 
    then []
    else
        let width = (max-min) / (float (n + 1))
        [ min + width .. width .. max - width ]

let sumOfSquaresCost (sample:Example seq) = 
    let avg = sample |&gt; Seq.averageBy snd
    sample |&gt; Seq.sumBy (fun (_,lbl) -&gt; pown (lbl - avg) 2) 

let stableTree = learnTree (evenSplitter 10,sumOfSquaresCost) redSample [``Alcohol Level``;``Volatile Acidity``] 10

sumOfSquares redSample (predict stableTree)
Copy<br>This time, nothing explodes - and the value we get is<br>val it : float = 331.1456491
Copy<br>The nice thing here is that at that point, all it takes to create and try new trees is a specification for the cost and split functions, and a list of features. We can, for instance, create a Tree using every feature we have available:<br>let features = [
    ``Alcohol Level``
    ``Chlorides``
    ``Citric Acid``
    ``Density``
    ``Fixed Acidity``
    ``Free Sulfur Dioxide``
    ``PH``
    ``Residual Sugar``
    ``Total Sulfur Dioxide``
    ``Volatile Acidity``
]

let fullTree = learnTree (evenSplitter 5,sumOfSquaresCost) redSample features 10
Copy<br>The results are pretty decent, too:<br><img alt="Actual vs Predicted" src="https://mathias-brandewinder.github.io//assets/2016-08-14-actual-vs-predicted.PNG" referrerpolicy="no-referrer"><br>Out of curiosity, I also performed a crude training vs. testing analysis, to get a feel for potential over-fitting issues.<br><img alt="Over Fitting" src="https://mathias-brandewinder.github.io//assets/2016-08-14-overfitting.PNG" referrerpolicy="no-referrer"><br>The result we observe is typical of trees: as we increase depth, the error on the training sample steadily decreases, indicating that deeper tree fit the data better and better. However, the testing sample tells a different story: for a little while, error on the training and testing samples match fairly closely, but after we reach a certain depth (here, 3), they start diverging. While our tree fit the training sample better and better, that improvement doesnâ€™t generalize to other samples, as we can see on the testing sample; at that point, we are over-fitting. In our particular case, this means that we shouldnâ€™t put much trust in trees deeper than 3.<br><br>At that point, we have a working regression tree algorithm. Itâ€™s not perfect; in particular, we largely ignored any performance consideration. Or, stated more bluntly, performance is terrible ;) Still, the result has a couple nice features, the code is fairly simple, andâ€¦ it works!<br>Trees are quite an interesting topic, which we only covered very superficially here. Still, we will leave it at that for now, and focus back on our initial goal, gradient boosting. All we needed was something a bit better than stumps to iteratively fit residuals. We have that now, with regression tree that allow us to learn a predictor using every feature we have available. In our next installments, we will look at replacing stumps with trees, and see where that leads us.]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/fsharp/basic-regression-tree.html</link><guid isPermaLink="false">Computer Science/Programming Language/FSharp/Basic Regression Tree.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:34 GMT</pubDate><enclosure url="https://mathias-brandewinder.github.io//assets/2016-08-14-stump.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://mathias-brandewinder.github.io//assets/2016-08-14-stump.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Elmish.Snabbdom]]></title><description><![CDATA[ 
 <br>I've been recently playing with <a data-tooltip-position="top" aria-label="https://github.com/alfonsogarciacaro/Feliz.Engine/tree/main/samples/Feliz.Snabbdom" rel="noopener" class="external-link" href="https://github.com/alfonsogarciacaro/Feliz.Engine/tree/main/samples/Feliz.Snabbdom" target="_blank">Feliz.Engine</a>, an attempt to take advantage of the great work done by Zaid Ajaj and contributors with <a data-tooltip-position="top" aria-label="https://zaid-ajaj.github.io/Feliz/" rel="noopener" class="external-link" href="https://zaid-ajaj.github.io/Feliz/" target="_blank">Feliz</a> when writing non-React applications. As part of this I wanted to check how easy was to adapt Feliz.Engine to an alternative Virtual-DOM implementation, and I read good things about <a data-tooltip-position="top" aria-label="https://github.com/snabbdom/snabbdom" rel="noopener" class="external-link" href="https://github.com/snabbdom/snabbdom" target="_blank">Snabbdom</a> so I gave it a go. This started just as an experiment but I've been pleasantly surprised by how simple yet powerful Snabbdom is, and more importantly, how well it fits with the <a data-tooltip-position="top" aria-label="https://elmish.github.io/" rel="noopener" class="external-link" href="https://elmish.github.io/" target="_blank">Elmish architecture</a>, so I want to share with you my findings hoping that you find them useful.<br>
æˆ‘æœ€è¿‘ä¸€ç›´åœ¨ç© Feliz.Engineï¼Œè¯•å›¾åˆ©ç”¨ Zaid Ajaj å’Œ Feliz è´¡çŒ®è€…åœ¨ç¼–å†™é React åº”ç”¨ç¨‹åºæ—¶æ‰€åšçš„å‡ºè‰²å·¥ä½œã€‚ä½œä¸ºå…¶ä¸­çš„ä¸€éƒ¨åˆ†ï¼Œæˆ‘æƒ³æ£€æŸ¥å°† Feliz.Engine é€‚åº”æ›¿ä»£ Virtual-DOM å®ç°æœ‰å¤šå®¹æ˜“ï¼Œå¹¶ä¸”æˆ‘é˜…è¯»äº†æœ‰å…³ Snabbdom çš„å¥½æ–‡ç« ï¼Œæ‰€ä»¥æˆ‘å°è¯•äº†ä¸€ä¸‹ã€‚ä¸€å¼€å§‹åªæ˜¯ä¸€ä¸ªå®éªŒï¼Œä½†æˆ‘å¯¹ Snabbdom çš„ç®€å•è€Œå¼ºå¤§æ„Ÿåˆ°æƒŠå–œï¼Œæ›´é‡è¦çš„æ˜¯ï¼Œå®ƒä¸ Elmish æ¶æ„çš„å¥‘åˆç¨‹åº¦ï¼Œæ‰€ä»¥æˆ‘æƒ³ä¸æ‚¨åˆ†äº«æˆ‘çš„å‘ç°ï¼Œå¸Œæœ›æ‚¨å‘ç°å®ƒä»¬æœ‰ç”¨ã€‚<br>There was recently a discussion in Twitter about the <a data-tooltip-position="top" aria-label="https://twitter.com/7sharp9_/status/1365270255170428928" rel="noopener" class="external-link" href="https://twitter.com/7sharp9_/status/1365270255170428928" target="_blank">problems with Fable Elmish</a>. So far, Elmish in Fable apps has always used React as the view engine, including React native for mobile (there are also Elmish implementations for non-Fable platforms like <a data-tooltip-position="top" aria-label="https://github.com/elmish/Elmish.WPF" rel="noopener" class="external-link" href="https://github.com/elmish/Elmish.WPF" target="_blank">WPF</a>, <a data-tooltip-position="top" aria-label="https://fsprojects.github.io/Fabulous/" rel="noopener" class="external-link" href="https://fsprojects.github.io/Fabulous/" target="_blank">Xamarin</a> or <a data-tooltip-position="top" aria-label="https://fsbolero.io/docs/Elmish" rel="noopener" class="external-link" href="https://fsbolero.io/docs/Elmish" target="_blank">Blazor</a>), and there's been always friction between the concept of "component" in Elmish and React. This is a bit of technical discussion and I won't go into detail here, among other reasons because I've never managed to explain the difference in an understandable manner. Probably the easiest is to consider Elm/Elmish don't really have a notion of "component" as Dave Thomas explains. It's true the Fable Elmish community tends to "componentize" apps maybe under the influence of React, which sometimes leads to an excess of boilerplate to wire everything.<br>
æœ€è¿‘ Twitter ä¸Šæœ‰ä¸€åœºå…³äºã€ŠFable Elmishã€‹é—®é¢˜çš„è®¨è®ºã€‚åˆ°ç›®å‰ä¸ºæ­¢ï¼Œã€ŠFableã€‹åº”ç”¨ä¸­çš„ Elmish ä¸€ç›´ä½¿ç”¨ React ä½œä¸ºè§†å›¾å¼•æ“ï¼ŒåŒ…æ‹¬é€‚ç”¨äºç§»åŠ¨è®¾å¤‡çš„ React Nativeï¼ˆä¹Ÿæœ‰é’ˆå¯¹ WPFã€Xamarin æˆ– Blazor ç­‰é Fable å¹³å°çš„ Elmish å®ç°ï¼‰ï¼Œå¹¶ä¸”â€œ Elmish å’Œ React ä¸­çš„ç»„ä»¶â€ã€‚è¿™æ˜¯ä¸€äº›æŠ€æœ¯è®¨è®ºï¼Œæˆ‘ä¸ä¼šåœ¨è¿™é‡Œè¯¦ç»†ä»‹ç»ï¼Œé™¤å…¶ä»–åŸå› å¤–ï¼Œå› ä¸ºæˆ‘ä»æœªè®¾æ³•ä»¥å¯ç†è§£çš„æ–¹å¼è§£é‡Šå…¶ä¸­çš„å·®å¼‚ã€‚ä¹Ÿè®¸æœ€ç®€å•çš„æ–¹æ³•æ˜¯è€ƒè™‘ Elm/Elmish å¹¶æ²¡æœ‰çœŸæ­£çš„â€œç»„ä»¶â€æ¦‚å¿µï¼Œæ­£å¦‚ Dave Thomas æ‰€è§£é‡Šçš„é‚£æ ·ã€‚ç¡®å®ï¼ŒFable Elmish ç¤¾åŒºå¯èƒ½åœ¨ React çš„å½±å“ä¸‹å€¾å‘äºâ€œç»„ä»¶åŒ–â€åº”ç”¨ç¨‹åºï¼Œè¿™æœ‰æ—¶ä¼šå¯¼è‡´è¿‡å¤šçš„æ ·æ¿æ–‡ä»¶æ¥è¿æ¥æ‰€æœ‰å†…å®¹ã€‚<br>It's possible to write an Elmish/React app with just a single view function, and some apps work well that way. But to take advantage of most of React features, like devtools, memoization or life-cycle events, you do need components, as React understands them. This is why some, myself guilty as charged, have been trying to drive towards more use of React components with Elmish. An important move for this has been the <a data-tooltip-position="top" aria-label="https://zaid-ajaj.github.io/Feliz/#/Hooks/UseElmish" rel="noopener" class="external-link" href="https://zaid-ajaj.github.io/Feliz/#/Hooks/UseElmish" target="_blank"><code></code> React hook</a>useElmish which many Fable devs have successfully adopted. But at this point Elmish gets reduced to manage the internal state of your components and your app gets eventually architected the React-way. This is not a bad thing if you already know React, but this post is about "rediscovering" the power of Elmish as I've been experiencing recently.<br>
å¯ä»¥ä»…ä½¿ç”¨å•ä¸ªè§†å›¾å‡½æ•°ç¼–å†™ Elmish/React åº”ç”¨ç¨‹åºï¼Œå¹¶ä¸”æŸäº›åº”ç”¨ç¨‹åºå¯ä»¥å¾ˆå¥½åœ°å·¥ä½œã€‚ä½†è¦åˆ©ç”¨å¤§å¤šæ•° React åŠŸèƒ½ï¼Œä¾‹å¦‚å¼€å‘å·¥å…·ã€è®°å¿†æˆ–ç”Ÿå‘½å‘¨æœŸäº‹ä»¶ï¼Œæ‚¨ç¡®å®éœ€è¦ç»„ä»¶ï¼Œæ­£å¦‚ React æ‰€ç†è§£çš„é‚£æ ·ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆä¸€äº›äººï¼ˆæˆ‘æœ¬äººä¹Ÿæœ‰ç½ªï¼‰ä¸€ç›´åœ¨å°è¯•æ¨åŠ¨æ›´å¤šåœ°ä½¿ç”¨ Elmish ä¸­çš„ React ç»„ä»¶ã€‚ä¸ºæ­¤ï¼Œä¸€ä¸ªé‡è¦çš„ä¸¾æªæ˜¯ useElmish React hookï¼Œè®¸å¤š Fable å¼€å‘äººå‘˜å·²æˆåŠŸé‡‡ç”¨ã€‚ä½†æ­¤æ—¶ Elmish è¢«ç®€åŒ–ä¸ºç®¡ç†ç»„ä»¶çš„å†…éƒ¨çŠ¶æ€ï¼Œå¹¶ä¸”æ‚¨çš„åº”ç”¨ç¨‹åºæœ€ç»ˆä»¥ React æ–¹å¼æ„å»ºã€‚å¦‚æœæ‚¨å·²ç»äº†è§£ Reactï¼Œè¿™å¹¶ä¸æ˜¯ä¸€ä»¶åäº‹ï¼Œä½†è¿™ç¯‡æ–‡ç« æ˜¯å…³äºâ€œé‡æ–°å‘ç°â€Elmish çš„åŠ›é‡ï¼Œæ­£å¦‚æˆ‘æœ€è¿‘æ‰€ç»å†çš„é‚£æ ·ã€‚<br>What if we try the other way around, that is, not worrying about "componentizing" our application? This is actually the original proposal of Elm/Elmish and what you get by using a low-level Virtual-DOM library like Snabbdom, instead of a full-fledged one like React. When I started trying to run Feliz.Engine with Snabbdom it was just about API ergonomics but being able to enjoy "pure" Elmish without giving up DOM control has been really freeing. Why I'm excited about Snabbdom? These are some of the reasons for it:<br>
å¦‚æœæˆ‘ä»¬å°è¯•ç›¸åçš„æ–¹å¼ï¼Œå³ä¸æ‹…å¿ƒâ€œç»„ä»¶åŒ–â€æˆ‘ä»¬çš„åº”ç”¨ç¨‹åºï¼Œä¼šæ€ä¹ˆæ ·ï¼Ÿè¿™å®é™…ä¸Šæ˜¯ Elm/Elmish çš„æœ€åˆæè®®ï¼Œä»¥åŠé€šè¿‡ä½¿ç”¨åƒ Snabbdom è¿™æ ·çš„ä½çº§ Virtual-DOM åº“è€Œä¸æ˜¯åƒ React è¿™æ ·çš„æˆç†Ÿåº“æ‰€å¾—åˆ°çš„ç»“æœã€‚å½“æˆ‘å¼€å§‹å°è¯•ä½¿ç”¨ Snabbdom è¿è¡Œ Feliz.Engine æ—¶ï¼Œå®ƒâ€‹â€‹åªæ˜¯å…³äº API äººä½“å·¥ç¨‹å­¦ï¼Œä½†èƒ½å¤Ÿåœ¨ä¸æ”¾å¼ƒ DOM æ§åˆ¶çš„æƒ…å†µä¸‹äº«å—â€œçº¯ç²¹çš„â€Elmish çœŸçš„å¾ˆè‡ªç”±ã€‚ä¸ºä»€ä¹ˆæˆ‘å¯¹ Snabbdom æ„Ÿåˆ°å…´å¥‹ï¼Ÿä»¥ä¸‹æ˜¯ä¸€äº›åŸå› ï¼š<br><br>There's no concept of component that clashes with Elmish, just composable functions from beginning to end. Again, you ca do the same with React but as soon as you need to deal with the DOM or some other features you need the components. This is not the case of Snabbdom, keep reading.<br>
æ²¡æœ‰ä¸ Elmish å†²çªçš„ç»„ä»¶æ¦‚å¿µï¼Œåªæœ‰ä»å¤´åˆ°å°¾çš„å¯ç»„åˆå‡½æ•°ã€‚åŒæ ·ï¼Œæ‚¨å¯ä»¥å¯¹ React æ‰§è¡Œç›¸åŒçš„æ“ä½œï¼Œä½†æ˜¯ä¸€æ—¦æ‚¨éœ€è¦å¤„ç† DOM æˆ–å…¶ä»–ä¸€äº›åŠŸèƒ½ï¼Œæ‚¨å°±éœ€è¦ç»„ä»¶ã€‚ Snabbdom çš„æƒ…å†µå¹¶éå¦‚æ­¤ï¼Œè¯·ç»§ç»­é˜…è¯»ã€‚<br><br>å†…ç½® CSS è¿‡æ¸¡#<br>Easy CSS transitions was one of biggest <a data-tooltip-position="top" aria-label="https://svelte.dev/" rel="noopener" class="external-link" href="https://svelte.dev/" target="_blank">Svelte</a> appeals for me, and I was very surprised to see Snabbdom has a similar mechanism. Together with the wonderful Feliz API (check <a data-tooltip-position="top" aria-label="https://github.com/alfonsogarciacaro/Feliz.Engine/blob/main/README.md" rel="noopener" class="external-link" href="https://github.com/alfonsogarciacaro/Feliz.Engine/blob/main/README.md" target="_blank">the differences</a> in Feliz.Engine), we can get a nice zoom-in/zoom-out effect just by attaching some styles to a node.<br>
ç®€å•çš„ CSS è½¬æ¢æ˜¯ Svelte å¯¹æˆ‘æœ€å¤§çš„å¸å¼•åŠ›ä¹‹ä¸€ï¼Œæˆ‘å¾ˆæƒŠè®¶åœ°çœ‹åˆ° Snabbdom ä¹Ÿæœ‰ç±»ä¼¼çš„æœºåˆ¶ã€‚ç»“åˆç²¾å½©çš„ Feliz APIï¼ˆæŸ¥çœ‹ Feliz.Engine ä¸­çš„å·®å¼‚ï¼‰ï¼Œæˆ‘ä»¬åªéœ€å°†ä¸€äº›æ ·å¼é™„åŠ åˆ°èŠ‚ç‚¹å³å¯è·å¾—ä¸é”™çš„æ”¾å¤§/ç¼©å°æ•ˆæœã€‚<br>Html.li [
    Attr.className "box"

    Css.opacity 0.
    Css.transformScale 1.5
    // Snabbdom doesn't support `all`, we need to list all the transitioning properties
    Css.transitionProperty(transitionProperty.opacity, transitionProperty.transform)
    Css.transitionDurationSeconds 0.5
    Css.delayed [
        Css.opacity 1.
        Css.transformScale 1.
    ]
    Css.remove [
        Css.opacity 0.
        Css.transformScale 0.1
    ]
Copy<br><img alt="Snabbdom CSS transitions" src="https://fable.io/static/img/blog/snabbdom-css-transitions.gif" referrerpolicy="no-referrer"><br>Learn more about Snabbdom CSS transitions <a data-tooltip-position="top" aria-label="https://github.com/snabbdom/snabbdom#delayed-properties" rel="noopener" class="external-link" href="https://github.com/snabbdom/snabbdom#delayed-properties" target="_blank">here</a>.<br>
åœ¨æ­¤å¤„äº†è§£æœ‰å…³ Snabbdom CSS è¿‡æ¸¡çš„æ›´å¤šä¿¡æ¯ã€‚<br><br>In theory, given that a pure Elmish app fully recreates the whole virtual DOM for every tiny change it's important to be able to skip the parts of your app that don't need to change (in reality, this usually is not a performance issue thankfully). But memoization has been one of the biggest pain-points when writing Fable/React bindings (still is). Because of nuances of how JS/F# languages work and the way React expects you to declare a memoized component. a <a data-tooltip-position="top" aria-label="https://zaid-ajaj.github.io/Feliz/#/Feliz/React/CommonPitfalls" rel="noopener" class="external-link" href="https://zaid-ajaj.github.io/Feliz/#/Feliz/React/CommonPitfalls" target="_blank">common pitfall</a> is to recreate the component for every function call rendering memoization useless. With Feliz.Snabbdom we just need to wrap a call with the memoize helper. For example, if we are displaying a list of Todos:<br>
ç†è®ºä¸Šï¼Œè€ƒè™‘åˆ°çº¯ Elmish åº”ç”¨ç¨‹åºä¼šé’ˆå¯¹æ¯ä¸€ä¸ªå¾®å°çš„æ›´æ”¹å®Œå…¨é‡æ–°åˆ›å»ºæ•´ä¸ªè™šæ‹Ÿ DOMï¼Œå› æ­¤èƒ½å¤Ÿè·³è¿‡åº”ç”¨ç¨‹åºä¸­ä¸éœ€è¦æ›´æ”¹çš„éƒ¨åˆ†éå¸¸é‡è¦ï¼ˆå®é™…ä¸Šï¼Œå¹¸è¿çš„æ˜¯ï¼Œè¿™é€šå¸¸ä¸æ˜¯æ€§èƒ½é—®é¢˜ï¼‰ ï¼‰ã€‚ä½†è®°å¿†ä¸€ç›´æ˜¯ç¼–å†™ Fable/React ç»‘å®šæ—¶æœ€å¤§çš„ç—›ç‚¹ä¹‹ä¸€ï¼ˆä»ç„¶æ˜¯ï¼‰ã€‚ç”±äº JS/F# è¯­è¨€å·¥ä½œæ–¹å¼çš„ç»†å¾®å·®åˆ«ä»¥åŠ React å¸Œæœ›æ‚¨å£°æ˜è®°å¿†ç»„ä»¶çš„æ–¹å¼ã€‚ä¸€ä¸ªå¸¸è§çš„é™·é˜±æ˜¯ä¸ºæ¯ä¸ªå‡½æ•°è°ƒç”¨é‡æ–°åˆ›å»ºç»„ä»¶ï¼Œä»è€Œä½¿è®°å¿†å˜å¾—æ— ç”¨ã€‚å¯¹äº Feliz.Snabbdomï¼Œæˆ‘ä»¬åªéœ€è¦ä½¿ç”¨ memoize å¸®åŠ©å™¨æ¥åŒ…è£…è°ƒç”¨ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬è¦æ˜¾ç¤ºå¾…åŠäº‹é¡¹åˆ—è¡¨ï¼š<br>let renderTodo dispatch (todo: Todo, editing: string option) = ...

let renderTodoList (state: State) (dispatch: Msg -&gt; unit) =
    Html.ul (
        state.TodoList |&gt; List.map (fun todo -&gt;
            todo,
            state.Editing |&gt; Option.bind (fun (i, e) -&gt; if i = todo.Id then Some e else None))
        |&gt; List.map (renderTodo dispatch)
    )
Copy<br>We just need to wrap the renderTodo call (here also provide a way to get a unique id from the arguments). Note that we don't need to check dispatch for the memoization, so we can just partially apply it before the wrapping:<br>
æˆ‘ä»¬åªéœ€è¦åŒ…è£… renderTodo è°ƒç”¨ï¼ˆè¿™é‡Œè¿˜æä¾›äº†ä¸€ç§ä»å‚æ•°ä¸­è·å–å”¯ä¸€ id çš„æ–¹æ³•ï¼‰ã€‚è¯·æ³¨æ„ï¼Œæˆ‘ä»¬ä¸éœ€è¦æ£€æŸ¥ dispatch çš„è®°å¿†åŒ–ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åœ¨åŒ…è£…ä¹‹å‰éƒ¨åˆ†åº”ç”¨å®ƒï¼š<br>let renderTodoList (state: State) (dispatch: Msg -&gt; unit) =
    Html.ul (
        state.TodoList |&gt; List.map (fun todo -&gt;
            todo,
            state.Editing |&gt; Option.bind (fun (i, e) -&gt; if i = todo.Id then Some e else None))
        |&gt; List.map (memoizeWithId (renderTodo dispatch) (fun (t, _) -&gt; t.Id))
    )
Copy<br><br>Unlike React ones, <a data-tooltip-position="top" aria-label="https://github.com/snabbdom/snabbdom#hooks" rel="noopener" class="external-link" href="https://github.com/snabbdom/snabbdom#hooks" target="_blank">hooks in Snabbdom</a> are very easy to understand. They are just events fired at different points of the lifecycle of a virtual node, as when they get inserted into or removed from the actual DOM. Very conveniently, the virtual node holding a reference to the actual DOM element is passed as argument to the event handler so it's easy for example to get the actual height of an element.<br>
ä¸ React ä¸åŒï¼ŒSnabbdom ä¸­çš„é’©å­éå¸¸å®¹æ˜“ç†è§£ã€‚å®ƒä»¬åªæ˜¯åœ¨è™šæ‹ŸèŠ‚ç‚¹ç”Ÿå‘½å‘¨æœŸçš„ä¸åŒç‚¹è§¦å‘çš„äº‹ä»¶ï¼Œå°±åƒå®ƒä»¬æ’å…¥å®é™… DOM æˆ–ä»å®é™… DOM ä¸­åˆ é™¤æ—¶ä¸€æ ·ã€‚éå¸¸æ–¹ä¾¿çš„æ˜¯ï¼Œä¿å­˜å¯¹å®é™… DOM å…ƒç´ çš„å¼•ç”¨çš„è™šæ‹ŸèŠ‚ç‚¹ä½œä¸ºå‚æ•°ä¼ é€’ç»™äº‹ä»¶å¤„ç†ç¨‹åºï¼Œå› æ­¤å¯ä»¥è½»æ¾è·å–å…ƒç´ çš„å®é™…é«˜åº¦ã€‚<br>React hooks allow you to do similar things, but they're designed in a way that forces you to translate your thinking into the React way of doing things. Let's say you want to turn some text into an input on double click, then select all the text and attach an event to the document so if you click outside the containing box you cancel the edit. For this, in React you need to (forgive me if there's a more clever way of doing this that I'm missing):<br>
React hooks å…è®¸ä½ åšç±»ä¼¼çš„äº‹æƒ…ï¼Œä½†å®ƒä»¬çš„è®¾è®¡æ–¹å¼è¿«ä½¿ä½ å°†ä½ çš„æƒ³æ³•è½¬åŒ–ä¸º React çš„åšäº‹æ–¹å¼ã€‚å‡è®¾æ‚¨æƒ³é€šè¿‡åŒå‡»å°†æŸäº›æ–‡æœ¬è½¬æ¢ä¸ºè¾“å…¥ï¼Œç„¶åé€‰æ‹©æ‰€æœ‰æ–‡æœ¬å¹¶å°†äº‹ä»¶é™„åŠ åˆ°æ–‡æ¡£ï¼Œè¿™æ ·å¦‚æœæ‚¨åœ¨åŒ…å«æ¡†ä¹‹å¤–å•å‡»ï¼Œåˆ™ä¼šå–æ¶ˆç¼–è¾‘ã€‚ä¸ºæ­¤ï¼Œåœ¨ React ä¸­ä½ éœ€è¦ï¼ˆå¦‚æœæˆ‘ç¼ºå°‘æ›´èªæ˜çš„æ–¹æ³•æ¥åšåˆ°è¿™ä¸€ç‚¹ï¼Œè¯·åŸè°…æˆ‘ï¼‰ï¼š<br>
<br>Make sure the function you are in is a component because this is required to use hooks.<br>
ç¡®ä¿æ‚¨æ‰€åœ¨çš„å‡½æ•°æ˜¯ä¸€ä¸ªç»„ä»¶ï¼Œå› ä¸ºè¿™æ˜¯ä½¿ç”¨é’©å­æ‰€å¿…éœ€çš„ã€‚
<br>Declare a reference to hold the actual input element with useRef hook (beware! you don't have the actual element yet).<br>
ä½¿ç”¨ useRef é’©å­å£°æ˜ä¸€ä¸ªå¼•ç”¨æ¥ä¿å­˜å®é™…çš„è¾“å…¥å…ƒç´ ï¼ˆæ³¨æ„ï¼æ‚¨è¿˜æ²¡æœ‰å®é™…çš„å…ƒç´ ï¼‰ã€‚
<br>Pass the value returned by useRef to a ref prop on the input element so React fills it.<br>
å°† useRef è¿”å›çš„å€¼ä¼ é€’ç»™è¾“å…¥å…ƒç´ ä¸Šçš„ ref å±æ€§ï¼Œä»¥ä¾¿ React å¡«å……å®ƒã€‚
<br>Declare an effect with useEffect hook. Because you want the effect to happen when the input appears, you need to pass an array with a flag like isEditable.<br>
ä½¿ç”¨ useEffect é’©å­å£°æ˜æ•ˆæœã€‚å› ä¸ºæ‚¨å¸Œæœ›åœ¨è¾“å…¥å‡ºç°æ—¶å‘ç”Ÿæ•ˆæœï¼Œæ‰€ä»¥æ‚¨éœ€è¦ä¼ é€’ä¸€ä¸ªå¸¦æœ‰ isEditable ç­‰æ ‡å¿—çš„æ•°ç»„ã€‚
<br>The effect will happen when isEditable changes from false to true or from true to false, so make sure isEditable is true before running the effect.<br>
å½“ isEditable ä» false å˜ä¸º true æˆ–ä» true å˜ä¸º false æ—¶ï¼Œæ•ˆæœå°±ä¼šå‘ç”Ÿï¼Œå› æ­¤åœ¨è¿è¡Œæ•ˆæœä¹‹å‰è¯·ç¡®ä¿ isEditable ä¸º trueã€‚
<br>Now get the input element from the value you declared in 2. Select the text and attach the event to the document body, return a disposable function to detach the event when isEditable changes to false.<br>
ç°åœ¨ä» 2 ä¸­å£°æ˜çš„å€¼è·å–è¾“å…¥å…ƒç´ ã€‚é€‰æ‹©æ–‡æœ¬å¹¶å°†äº‹ä»¶é™„åŠ åˆ°æ–‡æ¡£æ­£æ–‡ï¼Œè¿”å›ä¸€æ¬¡æ€§å‡½æ•°ä»¥åœ¨ isEditable æ›´æ”¹ä¸º false æ—¶åˆ†ç¦»äº‹ä»¶ã€‚
<br>On the other hand, in Snabbdom if you want to, when an input element appears, select all the text, attach an event to the html body and detach it when the input disappears you need to:<br>
å¦ä¸€æ–¹é¢ï¼Œåœ¨ Snabbdom ä¸­ï¼Œå¦‚æœæ‚¨æ„¿æ„ï¼Œå½“è¾“å…¥å…ƒç´ å‡ºç°æ—¶ï¼Œé€‰æ‹©æ‰€æœ‰æ–‡æœ¬ï¼Œå°†äº‹ä»¶é™„åŠ åˆ° html æ­£æ–‡ï¼Œå¹¶åœ¨è¾“å…¥æ¶ˆå¤±æ—¶å°†å…¶åˆ†ç¦»ï¼Œæ‚¨éœ€è¦ï¼š<br>
<br>Add an insert hook to the input, so when it appears, you can select all the text, attach an event to the html body and return a disposable to detach it when the input disappears.<br>
åœ¨è¾“å…¥ä¸­æ·»åŠ ä¸€ä¸ª insert é’©å­ï¼Œè¿™æ ·å½“å®ƒå‡ºç°æ—¶ï¼Œæ‚¨å¯ä»¥é€‰æ‹©æ‰€æœ‰æ–‡æœ¬ï¼Œå°†äº‹ä»¶é™„åŠ åˆ° html ä¸»ä½“ï¼Œå¹¶è¿”å›ä¸€ä¸ªä¸€æ¬¡æ€§äº‹ä»¶ï¼Œä»¥ä¾¿åœ¨è¾“å…¥æ¶ˆå¤±æ—¶å°†å…¶åˆ†ç¦»ã€‚
<br>Well, I'm cheating a bit here, in "raw" Snabbdom keeping a reference to the disposable and disposing it when the element is destroyed is slightly more contrived, but luckily Feliz.Snabbdom provides an overload to Hook.insert so this is automatically done for you if the callback returns a disposable:<br>
å¥½å§ï¼Œæˆ‘åœ¨è¿™é‡Œæœ‰ç‚¹ä½œå¼Šï¼Œåœ¨â€œåŸå§‹â€Snabbdom ä¸­ä¿ç•™å¯¹ä¸€æ¬¡æ€§çš„å¼•ç”¨å¹¶åœ¨å…ƒç´ è¢«é”€æ¯æ—¶å¤„ç†å®ƒï¼Œè¿™æœ‰ç‚¹åšä½œï¼Œä½†å¹¸è¿çš„æ˜¯ Feliz.Snabbdom ä¸º Hook.insert æä¾›äº†é‡è½½å› æ­¤ï¼Œå¦‚æœå›è°ƒè¿”å›ä¸€æ¬¡æ€§å€¼ï¼Œåˆ™ä¼šè‡ªåŠ¨ä¸ºæ‚¨å®Œæˆæ­¤æ“ä½œï¼š<br>Html.input [
    Attr.classes [ "input"; "is-medium" ]
    Attr.value editing
    Ev.onTextChange (SetEditedDescription &gt;&gt; dispatch)
    onEnterOrEscape dispatch ApplyEdit CancelEdit

    Hook.insert(fun vnode -&gt;
        let el = vnode.elm.AsInputEl
        el.select() // Select all text

        let parentBox = findParentWithClass "box" el
        // This function attachs the event to the body
        // and returns a disposable to detach it
        BodyEv.onMouseDown(fun ev -&gt;
            if not (parentBox.contains(ev.target :?&gt; _)) then
                CancelEdit |&gt; dispatch)
    )
]
Copy<br>
Did you notice BodyEv.onMouseDown? This is another nice use-case of <a data-tooltip-position="top" aria-label="https://github.com/alfonsogarciacaro/Feliz.Engine/blob/cbf4b90de929d7202f941ef091436a8845634b80/src/Feliz.Snabbdom/Feliz.Snabbdom.fs#L163-L168" rel="noopener" class="external-link" href="https://github.com/alfonsogarciacaro/Feliz.Engine/blob/cbf4b90de929d7202f941ef091436a8845634b80/src/Feliz.Snabbdom/Feliz.Snabbdom.fs#L163-L168" target="_blank">Feliz.Engine abstract classes</a>, it implements EventEngine by making it return a disposable.<br>
ä½ æ³¨æ„åˆ° BodyEv.onMouseDown äº†å—ï¼Ÿè¿™æ˜¯ Feliz.Engine æŠ½è±¡ç±»çš„å¦ä¸€ä¸ªå¾ˆå¥½çš„ç”¨ä¾‹ï¼Œå®ƒé€šè¿‡è¿”å›ä¸€æ¬¡æ€§å¯¹è±¡æ¥å®ç° EventEngine ã€‚
<br>So Snabbdom is great, now what? Does this mean you need to ditch React for Fable apps? Of course not! React is still a great choice, with many useful tools and a gigantic ecosystem. It's true there are frictions with Elmish but thanks to the work of Zaid, Maxime Mangel and many others, together with the ReactComponent plugin in Fable 3 they've become more bearable. So if you already know React quirks and/or rely on some of its tools and libraries you can be sure will still be well supported by Fable. Just if you're mainly interested in Elmish and don't really care for the underlying renderer you may want to give Elmish.Snabbdom a try if you're looking for less complexity. Clone the repo and try out <a data-tooltip-position="top" aria-label="https://github.com/alfonsogarciacaro/Feliz.Engine/tree/main/samples/Feliz.Snabbdom" rel="noopener" class="external-link" href="https://github.com/alfonsogarciacaro/Feliz.Engine/tree/main/samples/Feliz.Snabbdom" target="_blank">this sample</a> to see how Elmish.Snabbdom can work for you.<br>
æ‰€ä»¥ Snabbdom å¾ˆæ£’ï¼Œç°åœ¨æ€ä¹ˆåŠï¼Ÿè¿™æ˜¯å¦æ„å‘³ç€æ‚¨éœ€è¦æ”¾å¼ƒ React è€Œä½¿ç”¨ Fable åº”ç”¨ç¨‹åºï¼Ÿå½“ç„¶ä¸æ˜¯ï¼ React ä»ç„¶æ˜¯ä¸€ä¸ªä¸é”™çš„é€‰æ‹©ï¼Œæ‹¥æœ‰è®¸å¤šæœ‰ç”¨çš„å·¥å…·å’Œåºå¤§çš„ç”Ÿæ€ç³»ç»Ÿã€‚ç¡®å®ä¸ Elmish å­˜åœ¨æ‘©æ“¦ï¼Œä½†ç”±äº Zaidã€Maxime Mangel å’Œè®¸å¤šå…¶ä»–äººçš„å·¥ä½œï¼Œå†åŠ ä¸Šã€Šç¥é¬¼å¯“è¨€ 3ã€‹ä¸­çš„ ReactComponent æ’ä»¶ï¼Œè¿™äº›æ‘©æ“¦å·²ç»å˜å¾—æ›´å®¹æ˜“å¿å—ã€‚å› æ­¤ï¼Œå¦‚æœæ‚¨å·²ç»äº†è§£ React çš„æ€ªç™–å’Œ/æˆ–ä¾èµ–å®ƒçš„ä¸€äº›å·¥å…·å’Œåº“ï¼Œæ‚¨å¯ä»¥è‚¯å®š Fable ä»ç„¶ä¼šæä¾›è‰¯å¥½çš„æ”¯æŒã€‚å¦‚æœæ‚¨ä¸»è¦å¯¹ Elmish æ„Ÿå…´è¶£å¹¶ä¸”å¹¶ä¸çœŸæ­£å…³å¿ƒåº•å±‚æ¸²æŸ“å™¨ï¼Œå¦‚æœæ‚¨æ­£åœ¨å¯»æ‰¾è¾ƒä½çš„å¤æ‚æ€§ï¼Œæ‚¨å¯èƒ½æƒ³å°è¯•ä¸€ä¸‹ Elmish.Snabbdomã€‚å…‹éš†å­˜å‚¨åº“å¹¶å°è¯•æ­¤ç¤ºä¾‹ï¼Œçœ‹çœ‹ Elmish.Snabbdom å¦‚ä½•ä¸ºæ‚¨å·¥ä½œã€‚<br>And! If you are really into a purer Fable/F# experience and want more control of the DOM, take also a look at the awesome work of David Dawkins with <a data-tooltip-position="top" aria-label="https://davedawkins.github.io/Sutil" rel="noopener" class="external-link" href="https://davedawkins.github.io/Sutil" target="_blank">Sutil</a>!<br>
å’Œï¼å¦‚æœæ‚¨ç¡®å®å–œæ¬¢æ›´çº¯ç²¹çš„ Fable/F# ä½“éªŒå¹¶å¸Œæœ›æ›´å¤šåœ°æ§åˆ¶ DOMï¼Œè¿˜å¯ä»¥çœ‹çœ‹ David Dawkins ä¸ Sutil çš„ç²¾å½©ä½œå“ï¼]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/fsharp/elmish.snabbdom.html</link><guid isPermaLink="false">Computer Science/Programming Language/FSharp/Elmish.Snabbdom.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:36 GMT</pubDate><enclosure url="https://fable.io/blog/2021/2021-03-02-Announcing-Elmish-Snabbdom.html#its-just-functions" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="https://fable.io/blog/2021/2021-03-02-Announcing-Elmish-Snabbdom.html#its-just-functions"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[FSharp Native AOT çš„ JSON åº“é—®é¢˜]]></title><description><![CDATA[ 
 <br>
<br>FSharp.SystemTextJson ä¸è¡Œ
<br>FSharp.Json ä¸è¡Œ
<br>ç”¨ FSharp.Data çš„ JsonProvider 
<br>ç„¶ååœ¨ PropertyGroup ä¸­è®¾ç½® &lt;JsonSerializerIsReflectionEnabledByDefault&gt; true &lt;/JsonSerializerIsReflectionEnabledByDefault&gt;
]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/fsharp/fsharp-native-aot-çš„-json-åº“é—®é¢˜.html</link><guid isPermaLink="false">Computer Science/Programming Language/FSharp/FSharp Native AOT çš„ JSON åº“é—®é¢˜.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 26 May 2024 07:03:14 GMT</pubDate></item><item><title><![CDATA[FSharp Programming Scientific Models - A Step-By-Step Approach]]></title><description><![CDATA[ 
 <br>F Sharp programming offers unique advantages for scientific modeling, blending functional programming with .NET integration. This article delves into how F Sharp streamlines complex scientific computations, presenting practical examples and techniques.<br>F Sharp, a language well-suited for scientific modeling, offers unique features that enhance the development process. Its strong typing and functional-first approach streamline complex calculations and data manipulation. This article explores practical ways to leverage F Sharp in building robust scientific models, demonstrating its efficiency and effectiveness in tackling real-world problems.<br><img alt="F# Scientific Modeling Diagram" src="https://showme.redstarplugin.com/d/d:lgQImyCk" referrerpolicy="no-referrer"><br>
<br>[Fundamentals Of F Sharp In Scientific Modeling](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Fundamentals" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Fundamentals</a> Of F Sharp In Scientific Modeling)
<br>[Setting Up The F Sharp Environment For Scientific Computation](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Setting" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Setting</a> Up The F Sharp Environment For Scientific Computation)
<br>[Data Types And Structures In F Sharp For Modeling](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Data" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Data</a> Types And Structures In F Sharp For Modeling)
<br>[Functional Programming Concepts Applied In Scientific Models](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Functional" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Functional</a> Programming Concepts Applied In Scientific Models)
<br>[Building And Testing Simple Scientific Models With F Sharp](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Building" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Building</a> And Testing Simple Scientific Models With F Sharp)
<br>[Advanced Techniques In F Sharp For Complex Models](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Advanced" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Advanced</a> Techniques In F Sharp For Complex Models)
<br>[Performance Optimization In F Sharp For Scientific Computing](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Performance" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Performance</a> Optimization In F Sharp For Scientific Computing)
<br>[Real-World Applications Of F Sharp In Science](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Real-World" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Real-World</a> Applications Of F Sharp In Science)
<br>[Frequently Asked Questions](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Frequently" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Frequently</a> Asked Questions)
<br><br>
<br>[Type Safety And Immutability](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Type" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Type</a> Safety And Immutability)
<br>[Concise Syntax For Data Handling](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Concise" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Concise</a> Syntax For Data Handling)
<br>[Integration With .NET Libraries](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Integration" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Integration</a> With .NET Libraries)
<br>[Pattern Matching For Data Analysis](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Pattern" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Pattern</a> Matching For Data Analysis)
<br>[Interoperability With Other Languages](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Interoperability" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Interoperability</a> With Other Languages)
<br>F Sharp, a functional-first programming language, is particularly adept for scientific modeling. Its design emphasizes simplicity and expressiveness, crucial for dealing with complex scientific data and algorithms.<br><br>F Sharp's type safety and immutability are vital for scientific computations. Type safety prevents errors like mismatched data types, while immutability ensures data integrity throughout the modeling process.<br>let immutableValue = 5
// immutableValue &lt;- 10 // This line would cause a compilation error
Copy<br>ğŸ“Œ<br>In this example, attempting to change immutableValue results in an error, showcasing immutability.<br><br>The language's concise syntax is beneficial for handling large datasets. F Sharp's list and array comprehensions provide a straightforward way to manipulate data sets.<br>let squaredNumbers = [1 .. 10] |&gt; List.map (fun x -&gt; x * x)
// This creates a list of squares from 1 to 10
Copy<br>ğŸ“Œ<br>Here, we generate a list of squared numbers, demonstrating the language's ability to succinctly handle data operations.<br><br>F Sharp's seamless integration with .NET libraries extends its capabilities in scientific modeling. This allows access to a vast array of libraries for various computational tasks.<br>open System.Math
let logValue = Log(10.0) // Using Math library for logarithmic calculation
Copy<br>ğŸ“Œ<br>This code snippet uses the .NET System.Math library to perform a logarithmic calculation, illustrating the ease of integrating external libraries.<br><br>Pattern matching in F Sharp is a powerful tool for data analysis. It simplifies the process of dissecting and understanding complex data structures.<br>let analyzeData data =
    match data with
    | "Temperature" -&gt; "Analyze temperature trends"
    | "Pressure" -&gt; "Analyze atmospheric pressure"
    | _ -&gt; "Data type not recognized"
Copy<br>ğŸ“Œ<br>This function uses pattern matching to determine the type of data analysis needed, showcasing a structured approach to handling diverse data types.<br><br>F Sharp's interoperability with other programming languages, like C# and Python, is invaluable for scientific modeling, especially when integrating models or algorithms written in different languages.<br>// Example of calling a C# function from F Sharp
let result = CSharpLibrary.SomeFunction()
Copy<br>ğŸ“Œ<br>This snippet demonstrates calling a function from a C# library, highlighting F Sharp's compatibility with other languages in the .NET ecosystem.<br>By leveraging these fundamental features of F Sharp, developers can efficiently and effectively tackle scientific modeling challenges.<br><br>
<br>[Installing F Sharp](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Installing" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Installing</a> F Sharp)
<br>[Choosing An IDE](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Choosing" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Choosing</a> An IDE)
<br>[Adding Necessary Libraries](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Adding" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Adding</a> Necessary Libraries)
<br>[Configuring The Environment](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Configuring" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Configuring</a> The Environment)
<br>[Testing The Setup](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Testing" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Testing</a> The Setup)
<br>Setting up the F Sharp environment is the first step in leveraging its capabilities for scientific computation. The setup process is straightforward, ensuring a smooth start for developers.<br><br>Begin by installing F Sharp. It's typically included in the Visual Studio installation, but can also be installed separately for lighter IDEs or text editors.<br># For standalone installation, use the following command:
dotnet new console -lang "F#"
Copy<br>ğŸ“Œ<br>This command initializes a new F Sharp project, setting up the necessary environment.<br><br>Select an Integrated Development Environment (IDE) or text editor. Visual Studio, Visual Studio Code, and JetBrains Rider are popular choices, each offering F Sharp support and tools for scientific computation.<br>- Visual Studio: Full-featured, ideal for large projects.
- Visual Studio Code: Lightweight, with essential features.
- JetBrains Rider: Offers cross-platform support.
Copy<br>ğŸ“Œ<br>Each IDE has its strengths, so choose based on your project's complexity and your personal preference.<br><br>For scientific computation, add libraries like Math.NET Numerics or FSharp.Data. These libraries provide additional functions and data types useful in scientific modeling.<br>// Add Math.NET Numerics via NuGet
#r "nuget: MathNet.Numerics"
Copy<br>ğŸ“Œ<br>This code snippet demonstrates how to reference the Math.NET Numerics library in an F Sharp script, enhancing mathematical computation capabilities.<br><br>Configure your environment for optimal performance. This includes setting up the .NET runtime and adjusting project settings for efficient execution.<br>// Example: Setting target framework in the project file
&lt;TargetFramework&gt;net5.0&lt;/TargetFramework&gt;
Copy<br>ğŸ“Œ<br>In the project file, specify the .NET target framework to ensure compatibility and performance.<br><br>Finally, test your setup with a simple F Sharp script. This verifies that the environment is correctly configured and ready for more complex scientific computations.<br>// Test script: Calculate the square root of a number
let number = 16.0
let squareRoot = System.Math.Sqrt(number)
printfn "The square root of %f is %f" number squareRoot
Copy<br>ğŸ“Œ<br>This script calculates the square root of a number, providing a basic test for your F Sharp setup.<br>By following these steps, you'll establish a solid foundation for developing scientific models in F Sharp, setting the stage for more advanced computations and analyses.<br><br>
<br>[Primitive Data Types](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Primitive" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Primitive</a> Data Types)
<br>[Tuples For Grouping Data](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Tuples" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Tuples</a> For Grouping Data)
<br>[Lists And Arrays](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Lists" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Lists</a> And Arrays)
<br>[Discriminated Unions For Complex Structures](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Discriminated" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Discriminated</a> Unions For Complex Structures)
<br>[Records For Structured Data](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Records" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Records</a> For Structured Data)
<br>Understanding Data Types And Structures in F Sharp is crucial for efficient and effective scientific modeling. F Sharp offers a range of types and structures that are particularly suited for handling complex scientific data.<br><br>At the core are primitive data types like integers, floats, and booleans. These are fundamental for any computation and data manipulation.<br>let intValue = 42 // Integer
let floatValue = 3.14 // Float
let boolValue = true // Boolean
Copy<br>ğŸ“Œ<br>These examples illustrate the basic data types in F Sharp, forming the building blocks for more complex structures.<br><br>Tuples are used to group together values of possibly different types. They are particularly useful in scientific computations for representing complex data points.<br>let coordinates = (3.0, 4.0, 5.0) // A tuple representing 3D coordinates
Copy<br>ğŸ“Œ<br>This tuple represents a point in 3D space, showcasing tuples' utility in grouping diverse data.<br><br>Lists and arrays are essential for handling sequences of data, common in scientific models. Lists are immutable, while arrays offer mutability and fixed size.<br>let numberList = [1; 2; 3; 4; 5] // List of numbers
let numberArray = [| 1; 2; 3; 4; 5 |] // Array of numbers
Copy<br>ğŸ“Œ<br>These collections store sequences of numbers, illustrating their use in managing ordered data sets.<br><br>Discriminated unions provide a way to define types that can be one of several named cases, each potentially with different values and types. They are incredibly versatile for modeling complex scientific scenarios.<br>type Shape =
    | Circle of radius: float
    | Rectangle of width: float * height: float

let myShape = Circle(10.0) // Instance of a Circle
Copy<br>ğŸ“Œ<br>Here, Shape can represent different geometric forms, demonstrating discriminated unions' flexibility in modeling diverse data types.<br><br>Records in F Sharp offer a way to define types that represent structured data, akin to classes in OOP but with immutable properties by default.<br>type ScientificData = { Temperature: float; Pressure: float }
let dataPoint = { Temperature = 23.5; Pressure = 1.01 }
Copy<br>ğŸ“Œ<br>This record represents a scientific data point, highlighting records' utility in structuring and accessing data.<br>By leveraging these data types and structures, F Sharp enables developers to create sophisticated and efficient models for scientific computation, handling complex data with ease and clarity.<br><br>
<br>[Immutable Data Structures](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Immutable" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Immutable</a> Data Structures)
<br>[Pure Functions](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Pure" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Pure</a> Functions)
<br>[Higher-Order Functions](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Higher-Order" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Higher-Order</a> Functions)
<br>[Recursion For Iterative Processes](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Recursion" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Recursion</a> For Iterative Processes)
<br>[Lazy Evaluation](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Lazy" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Lazy</a> Evaluation)
<br>Incorporating Functional Programming Concepts into scientific models enhances readability, maintainability, and scalability of the code. F Sharp's functional nature makes it an ideal choice for scientific computations.<br><br>Emphasizing immutable data structures ensures data consistency and predictability. In scientific models, this aspect is crucial to maintain the integrity of data throughout computations.<br>let originalList = [1; 2; 3]
let newList = 0 :: originalList // Prepends '0' to the list
// originalList remains unchanged
Copy<br>ğŸ“Œ<br>This example shows how immutability in F Sharp preserves the original data, preventing unintended modifications.<br><br>Utilizing pure functions that donâ€™t have side effects and always produce the same output for the same input, leads to more predictable and testable code.<br>let square x = x * x // A pure function to square a number
Copy<br>ğŸ“Œ<br>This square function is a typical example of a pure function, showcasing its simplicity and predictability.<br><br>Higher-order functions that take functions as parameters or return functions, allow for more abstract and powerful ways to manipulate data.<br>let applyFunction f x = f x // Applies a function 'f' to 'x'
let result = applyFunction square 5 // Passes 'square' as a parameter
Copy<br>ğŸ“Œ<br>This demonstrates how higher-order functions can be used to apply different operations in a flexible manner.<br><br>In scientific modeling, recursive functions are often used instead of traditional loops. Recursion lends itself well to many mathematical operations and algorithms.<br>let rec factorial n = 
    if n &lt;= 1 then 1 else n * factorial (n - 1)
Copy<br>ğŸ“Œ<br>The factorial function here uses recursion to calculate the factorial of a number, a common mathematical operation.<br><br>Lazy evaluation in F Sharp can be utilized to improve performance, especially when dealing with large datasets or complex calculations.<br>let lazyValue = lazy (System.Threading.Thread.Sleep(1000); "Computed")
// The computation is not executed until 'lazyValue' is actually used
Copy<br>ğŸ“Œ<br>This lazy evaluation example defers the computation until the value is needed, enhancing efficiency in resource-intensive operations.<br>By applying these functional programming principles, scientific models in F Sharp become more robust, efficient, and easier to understand. These concepts are fundamental in handling the complexities and challenges of scientific computation.<br><br>
<br>[Creating A Basic Model](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Creating" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Creating</a> A Basic Model)
<br>[Implementing The Model](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Implementing" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Implementing</a> The Model)
<br>[Testing The Model](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Testing" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Testing</a> The Model)
<br>[Visualizing The Results](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Visualizing" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Visualizing</a> The Results)
<br>[Refining And Iterating](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Refining" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Refining</a> And Iterating)
<br>Building and testing simple scientific models in F Sharp involves creating models that are both easy to understand and effective in representing scientific concepts.<br><br>Start with defining a basic model. This could be a simple mathematical model, like a linear regression or a basic physical model representing real-world phenomena.<br>let linearRegression x = 2.0 * x + 5.0 // Simple linear regression model
Copy<br>ğŸ“Œ<br>This linear regression model represents a basic scientific model, illustrating a relationship between variables.<br><br>Next, implement the model using F Sharp's functions and data structures. Ensure that your implementation is clear and concise.<br>let calculatePrediction x = linearRegression x
let prediction = calculatePrediction 10.0 // Predicts the value for x=10.0
Copy<br>ğŸ“Œ<br>This code snippet uses the linear regression model to make a prediction, showcasing the implementation of the model.<br><br>Testing your model is crucial. Write test cases to verify the model's accuracy and reliability, especially for different input scenarios.<br>let testModel () =
    assert (calculatePrediction 0.0 = 5.0)
    assert (calculatePrediction 1.0 = 7.0)
Copy<br>ğŸ“Œ<br>These tests validate the correctness of the linear regression model for given inputs, ensuring its reliability.<br><br>For better understanding and analysis, visualize the results. Utilize libraries like FSharp.Charting for creating graphs or charts.<br>open FSharp.Charting
let data = [for x in 1 .. 10 -&gt; (x, calculatePrediction (float x))]
Chart.Line(data)
Copy<br>ğŸ“Œ<br>This visualization represents the output of the linear regression model across a range of values, aiding in analysis and interpretation.<br><br>Finally, refine and iterate your model based on test results and visualizations. Enhancing the model's accuracy and efficiency is a continuous process.<br>// Refine the model by adjusting the linear regression parameters
let refinedLinearRegression x = 2.5 * x + 4.5
Copy<br>ğŸ“Œ<br>This adjusted model represents an iteration, improving upon the initial version based on insights gained from testing and visualization.<br>Building and testing simple scientific models in F Sharp is a process of continuous refinement, leveraging the language's capabilities for accurate and efficient scientific computation.<br><br>
<br>[Parallel Processing](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Parallel" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Parallel</a> Processing)
<br>[Asynchronous Programming](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Asynchronous" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Asynchronous</a> Programming)
<br>[Type Providers](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Type" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Type</a> Providers)
<br><a data-tooltip-position="top" aria-label="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Meta-Programming" rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Meta-Programming" target="_blank">Meta-Programming</a>
<br>[Advanced Data Structures](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Advanced" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Advanced</a> Data Structures)
<br>Exploring Advanced Techniques In F Sharp can significantly enhance the capabilities of complex scientific models. These techniques allow for more intricate and efficient computation models.<br><br>Utilizing parallel processing capabilities in F Sharp can dramatically improve the performance of models that handle large datasets or complex calculations.<br>let computeInParallel data = 
    data |&gt; Array.Parallel.map (fun x -&gt; x * x)
// Processes each element in parallel
Copy<br>ğŸ“Œ<br>This code demonstrates parallel mapping, where each element of the array is processed concurrently, showcasing enhanced performance.<br><br>Asynchronous programming is key for handling long-running operations without blocking the main thread, crucial in scientific simulations and data processing tasks.<br>let asyncOperation x = 
    async { return x * x }
// An asynchronous computation
Copy<br>ğŸ“Œ<br>This asynchronous function allows for non-blocking operations, beneficial in complex models where multiple tasks run simultaneously.<br><br>F Sharp's type providers offer a way to access and manipulate different types of data seamlessly, ideal for scientific models that integrate various data sources.<br>type JsonProvider = FSharp.Data.JsonProvider&lt;Sample="sample.json"&gt;
let data = JsonProvider.GetSample()
// Parses JSON data using type provider
Copy<br>ğŸ“Œ<br>This type provider example illustrates how to easily access and work with JSON data, reducing the complexity of data parsing and manipulation.<br><br>Meta-programming techniques, such as quotations and expression trees, allow for generating and manipulating code dynamically, enhancing the flexibility and power of models.<br>let expr = &lt;@ 2 + 2 @&gt;
// Represents an F# expression as data
Copy<br>ğŸ“Œ<br>This expression tree can be analyzed or transformed at runtime, showcasing meta-programming's potential in building adaptable models.<br><br>Employing advanced data structures, such as trees and graphs, is essential for complex scientific models, especially in simulations and computational geometry.<br>type BinaryTree&lt;'T&gt; = 
    | Node of 'T * BinaryTree&lt;'T&gt; * BinaryTree&lt;'T&gt;
    | Leaf
// Represents a binary tree data structure
Copy<br>ğŸ“Œ<br>This binary tree definition in F Sharp provides a foundation for building complex data structures necessary for sophisticated modeling tasks.<br>By integrating these advanced techniques, F Sharp becomes a powerful tool for constructing and managing complex scientific models, enabling deeper analysis and more robust simulations.<br><br>
<br>[Efficient Data Structures](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Efficient" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Efficient</a> Data Structures)
<br>[Lazy Computations](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Lazy" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Lazy</a> Computations)
<br>[Profiling And Benchmarking](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Profiling" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Profiling</a> And Benchmarking)
<br>[Parallel And Asynchronous Programming](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Parallel" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Parallel</a> And Asynchronous Programming)
<br>[Algorithm Optimization](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Algorithm" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Algorithm</a> Optimization)
<br>Optimizing performance in F Sharp for Scientific Computing is essential to handle large datasets and complex calculations efficiently. Several strategies can be employed to enhance the execution speed and resource usage of F Sharp programs.<br><br>Choosing the right data structures is crucial for performance. Immutable data structures are preferred for their safety, but mutable structures can be more efficient in some scenarios.<br>let mutableArray = Array.init 100000 (fun i -&gt; i * i)
// Mutable array for efficient in-place modifications
Copy<br>ğŸ“Œ<br>This mutable array example is optimal for scenarios where in-place data modification is necessary, offering better performance than immutable structures.<br><br>Implementing lazy computations can save resources by deferring the execution of a computation until its result is actually needed.<br>let lazyValue = lazy (expensiveComputation())
// The computation is only executed when 'lazyValue' is accessed
Copy<br>ğŸ“Œ<br>This lazy computation ensures that the resource-intensive operation is only performed when necessary.<br><br>Regularly profiling and benchmarking your code is important to identify performance bottlenecks. Tools like BenchmarkDotNet or the built-in Visual Studio profiler can be used.<br>- Profile CPU usage and memory allocation
- Identify slow functions or operations
Copy<br>ğŸ“Œ<br>These practices help pinpoint inefficient code segments, allowing for targeted optimizations.<br><br>Leveraging parallel and asynchronous programming techniques can significantly improve the performance of CPU-bound and I/O-bound operations, respectively.<br>let computeInParallel data = 
    data |&gt; Array.Parallel.map expensiveComputation
// Parallel processing for CPU-bound tasks
Copy<br>ğŸ“Œ<br>Parallel processing can dramatically speed up computations on large datasets by utilizing multiple CPU cores effectively.<br><br>Optimizing algorithms and logic is often the most effective way to enhance performance. Even small improvements in algorithm efficiency can lead to significant gains in large-scale computations.<br>// Optimize algorithm by reducing unnecessary computations
let optimizedCalculation x = 
    if x &lt; 10 then simpleCalculation x else complexCalculation x
Copy<br>ğŸ“Œ<br>This example demonstrates conditional logic to choose the most efficient computation method based on the input, optimizing overall performance.<br>By employing these strategies, F Sharp's capabilities in scientific computing can be fully utilized, ensuring that models and computations are not only accurate but also efficient.<br><br>
<br><a data-tooltip-position="top" aria-label="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Bioinformatics" rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Bioinformatics" target="_blank">Bioinformatics</a>
<br>[Financial Modeling](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Financial" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Financial</a> Modeling)
<br>[Environmental Modeling](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Environmental" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Environmental</a> Modeling)
<br>[Physics Simulations](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Physics" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Physics</a> Simulations)
<br>[Astronomy And Astrophysics](<a rel="noopener" class="external-link" href="https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Astronomy" target="_blank">https://marketsplash.com/tutorials/f-sharp/f-sharp-programming-scientific-models/#Astronomy</a> And Astrophysics)
<br>F Sharp's application in science spans a wide range of fields, demonstrating its versatility and effectiveness in solving real-world problems.<br><br>In bioinformatics, F Sharp is used for processing and analyzing complex biological data. Its strong data handling capabilities make it ideal for tasks such as genome sequencing analysis.<br>let analyzeGenome sequence = 
    // Code for genome sequencing analysis
Copy<br>ğŸ“Œ<br>This pseudocode represents the type of function you might find in bioinformatics, where F Sharp's data processing strengths are a significant asset.<br><br>F Sharp also finds extensive use in financial modeling. Its robustness and precision are essential for risk analysis, predictive modeling, and algorithmic trading.<br>let calculateRisk factors = 
    // Code for financial risk calculation
Copy<br>ğŸ“Œ<br>In this financial model, F Sharp's ability to handle complex calculations and its precision are crucial.<br><br>In environmental science, F Sharp assists in creating models for climate change analysis, pollution tracking, and ecosystem simulations.<br>let simulateEcosystem conditions = 
    // Ecosystem simulation logic
Copy<br>ğŸ“Œ<br>This code snippet would be typical in environmental modeling, where F Sharp's ability to process large data sets and run complex simulations is valuable.<br><br>F Sharp is also utilized in physics for simulations and calculations in areas like quantum mechanics, fluid dynamics, and materials science.<br>let modelQuantumSystem state = 
    // Quantum mechanics modeling
Copy<br>ğŸ“Œ<br>This example represents F Sharp's application in physics, where its precision and performance are beneficial for complex simulations.<br><br>In astronomy and astrophysics, F Sharp helps in analyzing astronomical data, modeling celestial mechanics, and simulating cosmic phenomena.<br>let analyzeStarData data = 
    // Code for astronomical data analysis
Copy<br>ğŸ“Œ<br>This pseudocode illustrates F Sharp's use in astronomy, where handling and analyzing vast amounts of data is critical.<br>Through these diverse applications, F Sharp proves to be a powerful tool in scientific computing, aiding researchers and scientists in various fields to model and analyze complex phenomena efficiently and effectively.<br>ğŸ’¡<br>**Case Study: Optimizing Meteorological Data Analysis with F Sharp**  <br>A leading meteorological research institute faced challenges in processing and analyzing vast amounts of weather data. Their existing system struggled with the complexity and scale of the datasets, leading to slow analysis times and less accurate weather predictions.  <br>The primary challenge was to handle large, complex datasets efficiently while maintaining high accuracy in weather prediction models. The system needed to process diverse data types, including temperature, humidity, and atmospheric pressure, and run complex simulations for forecasting.<br>ğŸš©<br>**Solution:**  <br>The institute turned to F Sharp, a functional-first programming language known for its efficiency in handling large datasets and complex calculations. The key features of F Sharp utilized were:  <br>**Immutable Data Structures**: To maintain data integrity and facilitate safe parallel processing.<br>type WeatherData = { Temperature: float; Humidity: float; Pressure: float }
let historicalData = // Load and process historical weather data
Copy<br>ğŸš©<br>**Parallel Processing**: For efficient handling of computationally intensive tasks like weather pattern simulation.<br>let simulateWeatherPattern data = 
    data |&gt; Array.Parallel.map analyzeWeatherData
Copy<br>ğŸ˜<br>**Results:**  <br>The implementation of F Sharp led to remarkable improvements:  <br>**Increased Accuracy**: Enhanced data processing capabilities led to a 25% increase in the accuracy of weather predictions.  <br>**Reduced Processing Time**: Parallel processing decreased data analysis times by 40%, enabling faster weather forecasting.  <br>**Scalability**: The new system could scale effectively, handling larger datasets without a significant impact on performance.<br><br><br>**F Sharp** is used for a range of tasks in scientific computing, including data analysis, algorithm development, simulation, and predictive modeling. Its strong typing, functional programming features, and .NET ecosystem support make it well-suited for these applications.<br><br>**F Sharp** efficiently handles large datasets through its immutable data structures, lazy evaluation, and parallel processing capabilities. These features allow for effective management and manipulation of large volumes of data.<br><br>Yes, F Sharp can be effectively used for **machine learning and data science**. It can integrate with .NET libraries like ML.NET, and its concise syntax is suitable for data manipulation and statistical analysis.<br><br>F Sharp is highly **compatible** with other programming languages, especially those in the .NET ecosystem like C# and VB.NET. It can also interoperate with Python and other languages via libraries or APIs.]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/fsharp/fsharp-programming-scientific-models-a-step-by-step-approach.html</link><guid isPermaLink="false">Computer Science/Programming Language/FSharp/FSharp Programming Scientific Models - A Step-By-Step Approach.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:28 GMT</pubDate><enclosure url="https://showme.redstarplugin.com/d/d:lgQImyCk" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="https://showme.redstarplugin.com/d/d:lgQImyCk"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[FSharp Suave è·¨åŸŸé…ç½®]]></title><description><![CDATA[ 
 <br>
<br><a data-tooltip-position="top" aria-label="https://www.fssnip.net/mL/title/CORS-response-with-Suave" rel="noopener" class="external-link" href="https://www.fssnip.net/mL/title/CORS-response-with-Suave" target="_blank">CORS response with Suave</a>
<br><a data-tooltip-position="top" aria-label="https://stackoverflow.com/questions/44359375/allow-multiple-headers-with-cors-in-suave" rel="noopener" class="external-link" href="https://stackoverflow.com/questions/44359375/allow-multiple-headers-with-cors-in-suave" target="_blank">Allow multiple headers with CORS in Suave</a>
<br>open Suave
open Suave.Writers
open Suave.Filters
open Suave.Operators
  
let CORS =
    addHeader "Access-Control-Allow-Origin" "*"
    &gt;=&gt; setHeader "Access-Control-Allow-Headers" "token"
    &gt;=&gt; addHeader "Access-Control-Allow-Headers" "Content-Type"
    &gt;=&gt; addHeader "Access-Control-Allow-Methods" "GET"
    
let Apps: WebPart =
    GET
    &gt;=&gt; fun context -&gt;
      context
      |&gt; (Server.CORS
          &gt;=&gt; choose
            [
              (* éœ€è¦è·¨åŸŸçš„ WebPart æ”¾åœ¨è¿™é‡Œ *) 
            ])

startWebServer defaultConfig Apps
Copy]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/fsharp/fsharp-suave-è·¨åŸŸé…ç½®.html</link><guid isPermaLink="false">Computer Science/Programming Language/FSharp/FSharp Suave è·¨åŸŸé…ç½®.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 26 May 2024 07:00:34 GMT</pubDate></item><item><title><![CDATA[Fun with L-Systems]]></title><description><![CDATA[ 
 <br>I had the great pleasure to speak at <a data-tooltip-position="top" aria-label="http://www.codemash.org/" rel="noopener" class="external-link" href="http://www.codemash.org/" target="_blank">CodeMash</a> this week, and, on my way back, ended up spending a couple of hours at the Atlanta airport waiting for my connecting flight back to the warmer climate of San Francisco â€“ a perfect opportunity for some light-hearted coding fun. A couple of days earlier, I came across this really nice tweet, rendering the results of an L-system:<br>
{start:'FFPF',rules:{F:'PF++F[FF-F+PF+FPP][F]FFPF',P:''},'Î±':60} <a data-tooltip-position="top" aria-label="http://t.co/JZGDV4ghFy" rel="noopener" class="external-link" href="http://t.co/JZGDV4ghFy" target="_blank">pic.twitter.com/JZGDV4ghFy</a>
â€” LSystemBot 2.0 (@LSystemBot) <a data-tooltip-position="top" aria-label="https://twitter.com/LSystemBot/status/553954473694220288" rel="noopener" class="external-link" href="https://twitter.com/LSystemBot/status/553954473694220288" target="_blank">January 10, 2015</a>
<br>I ended up looking up <a data-tooltip-position="top" aria-label="http://en.wikipedia.org/wiki/L-system" rel="noopener" class="external-link" href="http://en.wikipedia.org/wiki/L-system" target="_blank">L-systems on Wikipedia</a>, and thought this would make for some fun coding exercise. In a nutshell, a L-system is a grammar. It starts with an alphabet of symbols, and a set of rules which govern how each symbol can be transformed into another chain of symbols. By applying these rules to a starting state (the initial axiom), one can evolve it into a succession of states, which can be seen as the growth of an organism. And by mapping each symbol to operations in a <a data-tooltip-position="top" aria-label="http://en.wikipedia.org/wiki/Logo_%28programming_language%29" rel="noopener" class="external-link" href="http://en.wikipedia.org/wiki/Logo_%28programming_language%29" target="_blank">logo/turtle like language</a>, each generation can then be rendered as a graphic.<br>So how could we go about coding this in F#? If you are impatient, you can find the final result as a <a data-tooltip-position="top" aria-label="https://gist.github.com/mathias-brandewinder/bcbac9e92901af564055" rel="noopener" class="external-link" href="https://gist.github.com/mathias-brandewinder/bcbac9e92901af564055" target="_blank">gist here</a>.<br>First, I started with representing the core elements of an L-System with a couple of types:<br>type Symbol = | Sym of char

type State = Symbol list

type Rules = Map&lt;Symbol,State&gt;

type LSystem =
  { Axiom:State
    Rules:Rules }
Copy<br>A symbol is a char, wrapped in a single-case discriminated union, and a State is simply a list of Symbols. We define the Rules that govern the transformation of Symbols by a Map, which associates a particular Symbol with a State, and an L-System is then an Axiom (the initial State), with a collection of Rules.<br>Letâ€™s illustrate this on the second example from the Wikipedia page, the Pythagoras tree. Our grammar contains 4 symbols, 0, 1, [ and ], we start with a 0, and we have 2 rules, (1 â†’ 11), and (0 â†’ 1[0]0). This can be encoded in a straightforward manner in our domain, like this:<br>let lSystem =
  { Axiom = [ Sym('0') ]
    Rules = [ Sym('1'), [ Sym('1'); Sym('1') ]
              Sym('0'), [ Sym('1'); Sym('['); Sym('0'); Sym(']'); Sym('0') ]]
            |&gt; Map.ofList }
Copy<br>Growing the organism by applying the rules is fairly straightforward: given a State, we traverse the list of Symbols, look up for each of them if there is a matching rule, and perform a substitution if it is found, leaving it unchanged otherwise:<br>(*
Growing from the original axiom
by applying the rules
*)

let applyRules (rs:Rules) (s:Symbol) =
  match (rs.TryFind s) with
  | None -&gt; [s]
  | Some(x) -&gt; x

let evolve (rs:Rules) (s:State) =
  [ for sym in s do yield! (applyRules rs sym) ]

let forward (g:LSystem) =
  let init = g.Axiom
  let gen = evolve g.Rules
  init |&gt; Seq.unfold (fun state -&gt; Some(state, gen state))

// compute nth generation of lSystem
let generation gen lSystem =
  lSystem
  |&gt; forward
  |&gt; Seq.nth gen
  |&gt; Seq.toList
Copy<br>What does this give us on the Pythagoras Tree?<br>&gt; lSystem |&gt; generation 1;;
val it : Symbol list = [Sym '1'; Sym '['; Sym '0'; Sym ']'; Sym '0']
Copy<br>Nice and crisp â€“ that part is done. Next up, rendering. The idea here is that for each Symbol in a State, we will perform a substitution with a sequence of instructions, either a Move, drawing a line of a certain length, or a Turn of a certain Angle. We will also have a Stack, where we can Push or Pop the current position of the Turtle, so that we can for instance store the current position and direction on the stack, perform a couple of moves with a Push, and then return to the previous position by a Pop, which will reset the turtle to the previous position. Again, that lends itself to a very natural model:<br>(*
Modelling the Turtle/Logo instructions
*)

type Length = | Len of float
type Angle = | Deg of float

// override operator later
let add (a1:Angle) (a2:Angle) =
  let d1 = match a1 with Deg(x) -&gt; x
  let d2 = match a2 with Deg(x) -&gt; x
  Deg(d1+d2)

type Inst =
  | Move of Length
  | Turn of Angle
  | Push
  | Pop

let Fwd x = Move(Len(x))
let Lft x = Turn(Deg(x))
let Rgt x = Turn(Deg(-x))
Copy<br>We can now transform our L-system state into a list of instructions, and convert them into a sequence of Operations, in that case Drawing lines between 2 points:<br>type Pos = { X:float; Y:float; }
type Dir = { L:Length; A:Angle }

type Turtle = { Pos:Pos; Dir:Dir }
type ProgState = { Curr:Turtle; Stack:Turtle list }

let turn angle turtle =
  let a = turtle.Dir.A |&gt; add angle
  { turtle with Dir = { turtle.Dir with A = a } }

type Translation = Map&lt;Symbol,Inst list&gt;

type Ops = | Draw of Pos * Pos

let pi = System.Math.PI

let line (pos:Pos) (len:Length) (ang:Angle) =
  let l = match len with | Len(l) -&gt; l
  let a = match ang with | Deg(a) -&gt; (a * pi / 180.)
  { X = pos.X + l * cos a ; Y = pos.Y + l * sin a }

let execute (inst:Inst) (state:ProgState) =
  match inst with
  | Push -&gt; None, { state with Stack = state.Curr :: state.Stack }
  | Pop -&gt;
    let head::tail = state.Stack // assumes more Push than Pop
    None, { state with Curr = head; Stack = tail }
  | Turn(angle) -&gt;
    None, { state with Curr =  state.Curr |&gt; turn angle }
  | Move(len) -&gt;
    let startPoint = state.Curr.Pos
    let endPoint = line startPoint len state.Curr.Dir.A
    Some(Draw(startPoint,endPoint)), { state with Curr = { state.Curr with Pos = endPoint } }

let toTurtle (T:Translation) (xs:Symbol list) =

  let startPos = { X = 400.; Y = 400. }
  let startDir = { L = Len(0.); A = Deg(0.) }
  let init =
    { Curr = { Pos = startPos; Dir = startDir }
      Stack = [] }
  xs
  |&gt; List.map (fun sym -&gt; T.[sym])
  |&gt; List.concat
  |&gt; Seq.scan (fun (op,state) inst -&gt; execute inst state) (None,init)
  |&gt; Seq.map fst
  |&gt; Seq.choose id
Copy<br>We simply map each Symbol to a List of instructions, transform the list of symbols into a list of instructions, and maintain at each step the current position and direction, as well as a Stack (represented as a list) of positions and directions. How does it play out on our Pythagoras Tree? First, we define the mapping from Symbols to Instructions:<br>let l = 1.
let T =
  [ Sym('0'), [ Fwd l; ]
    Sym('1'), [ Fwd l; ]
    Sym('['), [ Push; Lft 45.; ]
    Sym(']'), [ Pop; Rgt 45.; ] ]
  |&gt; Map.ofList
Copy<br>â€¦ and we simply send that toTurtle, which produces a list of Draw instructions:<br>&gt; lSystem |&gt; generation 1 |&gt; toTurtle T;;
val it : seq&lt;Ops&gt; =
  seq
  [ Draw ({X = 400.0; Y = 400.0;},{X = 401.0; Y = 400.0;});
    Draw ({X = 401.0; Y = 400.0;},{X = 401.7071068; Y = 400.7071068;});
    Draw ({X = 401.0; Y = 400.0;},{X = 401.7071068; Y = 399.2928932;})]
Copy<br>Last step â€“ some pretty pictures. Weâ€™ll simply generate a html document, rendering the image using SVG, by creating one SVG line per Draw instruction:<br>let header = """
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
&lt;svg height="800" width="800"&gt;"""

let footer = """
&lt;/svg&gt;
&lt;/body&gt;
&lt;/html&gt;
"""

let toSvg (ops:Ops seq) =
  let asString (op:Ops) =
    match op with
    | Draw(p1,p2) -&gt;
      sprintf """&lt;line x1="%f" y1="%f" x2="%f" y2="%f" style="stroke:rgb(0,0,0);stroke-width:1" /&gt;""" p1.X p1.Y p2.X p2.Y

  [ yield header
    for op in ops -&gt; asString op
    yield footer ]
  |&gt; String.concat "\n"

open System.IO

let path = "C:/users/mathias/desktop/lsystem.html"
let save template = File.WriteAllText(path,template)
Copy<br>And we are pretty much done:<br>&gt; lSystem |&gt; generation 8 |&gt; toTurtle T |&gt; toSvg |&gt; save;;
val it : unit = ()
Copy<br>â€¦ which produces the following graphic:<br><img alt="Pythagoras tree" src="https://mathias-brandewinder.github.io//assets/pythagoras-tree.png" referrerpolicy="no-referrer"><br>Pretty neat! Just for fun, I replicated the <a data-tooltip-position="top" aria-label="http://en.wikipedia.org/wiki/L-system#Example_5:_Sierpinski_triangle" rel="noopener" class="external-link" href="http://en.wikipedia.org/wiki/L-system#Example_5:_Sierpinski_triangle" target="_blank">Sierpinski Triangle</a> example as well:<br>let sierpinski () =

  let lSystem =
    { Axiom = [ Sym('A') ]
      Rules =
        [ Sym('A'), [ Sym('B'); Sym('&gt;'); Sym('A'); Sym('&gt;'); Sym('B') ]
          Sym('B'), [ Sym('A'); Sym('&lt;'); Sym('B'); Sym('&lt;'); Sym('A') ]]
        |&gt; Map.ofList }

  let l = 1.
  let T =
    [ Sym('A'), [ Fwd l; ]
      Sym('B'), [ Fwd l; ]
      Sym('&gt;'), [ Lft 60.; ]
      Sym('&lt;'), [ Rgt 60.; ] ]
    |&gt; Map.ofList

  lSystem
  |&gt; generation 9
  |&gt; toTurtle T
  |&gt; toSvg
  |&gt; save
Copy<br>â€¦ which results in the following picture:<br><img alt="Sierpinski triangle" src="https://mathias-brandewinder.github.io//assets/sierpinski-triangle.png" referrerpolicy="no-referrer"><br>Thatâ€™s it for tonight! I had a lot of fun coding this (it certainly made the flight less boring), and found the idea of converting code to turtle instructions, with a stack, pretty interesting. Hope you enjoyed it, and if you end up playing with this, share your creations on Twitter and ping me!]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/fsharp/fun-with-l-systems.html</link><guid isPermaLink="false">Computer Science/Programming Language/FSharp/Fun with L-Systems.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:35 GMT</pubDate><enclosure url="https://mathias-brandewinder.github.io//assets/pythagoras-tree.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://mathias-brandewinder.github.io//assets/pythagoras-tree.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Functional Reactive Programming]]></title><description><![CDATA[ 
 <br>Events are everywhere. Almost every program has to handle events, whether it be button clicks in the user interface, listening to sockets in a server, or even a system shutdown notification.<br>And events are the basis of one of the most common OO design patterns: the â€œObserverâ€ pattern.<br>But as we know, event handling, like concurrency in general, can be tricky to implement. Simple event logic is straightforward, but what about logic like â€œdo something if two events happen in a row but do something different if only one event happensâ€ or â€œdo something if two events happen at roughly the same timeâ€. And how easy is it to combine these requirements in other, more complex ways?<br>Even if you can successfully implement these requirements, the code tends to be spaghetti like and hard to understand, even with the best intentions.<br>Is there an approach that can make event handling easier?<br>We saw in the previous post on message queues that one of the advantages of that approach was that the requests were â€œserializedâ€ making it conceptually easier to deal with.<br>There is a similar approach that can be used with events. The idea is to turn a series of events into an â€œevent streamâ€. Event streams then become quite like IEnumerables, and so the obvious next step is to treat them in much the the same way that LINQ handles collections, so that they can be filtered, mapped, split and combined.<br>F# has built in support for this model, as well as for the more traditional approach.<br><br>Letâ€™s start with a simple example to compare the two approaches. Weâ€™ll implement the classic event handler approach first.<br>First, we define a utility function that will:<br>
<br>create a timer
<br>register a handler for the Elapsed event
<br>run the timer for five seconds and then stop it
<br>Hereâ€™s the code:<br>open System
open System.Threading

/// create a timer and register an event handler,
/// then run the timer for five seconds
let createTimer timerInterval eventHandler =
    // setup a timer
    let timer = new System.Timers.Timer(float timerInterval)
    timer.AutoReset &lt;- true

    // add an event handler
    timer.Elapsed.Add eventHandler

    // return an async task
    async {
        // start timer...
        timer.Start()
        // ...run for five seconds...
        do! Async.Sleep 5000
        // ... and stop
        timer.Stop()
        }
Copy<br>Now test it interactively:<br>// create a handler. The event args are ignored
let basicHandler _ = printfn "tick %A" DateTime.Now

// register the handler
let basicTimer1 = createTimer 1000 basicHandler

// run the task now
Async.RunSynchronously basicTimer1
Copy<br>Now letâ€™s create a similar utility method to create a timer, but this time it will return an â€œobservableâ€ as well, which is the stream of events.<br>let createTimerAndObservable timerInterval =
    // setup a timer
    let timer = new System.Timers.Timer(float timerInterval)
    timer.AutoReset &lt;- true

    // events are automatically IObservable
    let observable = timer.Elapsed

    // return an async task
    let task = async {
        timer.Start()
        do! Async.Sleep 5000
        timer.Stop()
        }

    // return a async task and the observable
    (task,observable)
Copy<br>And again test it interactively:<br>// create the timer and the corresponding observable
let basicTimer2 , timerEventStream = createTimerAndObservable 1000

// register that every time something happens on the
// event stream, print the time.
timerEventStream
|&gt; Observable.subscribe (fun _ -&gt; printfn "tick %A" DateTime.Now)

// run the task now
Async.RunSynchronously basicTimer2
Copy<br>The difference is that instead of registering a handler directly with an event, we are â€œsubscribingâ€ to an event stream. Subtly different, and important.<br><br>In this next example, weâ€™ll have a slightly more complex requirement:<br>Create a timer that ticks every 500ms.
At each tick, print the number of ticks so far and the current time.
Copy<br>To do this in a classic imperative way, we would probably create a class with a mutable counter, as below:<br>type ImperativeTimerCount() =

    let mutable count = 0

    // the event handler. The event args are ignored
    member this.handleEvent _ =
      count &lt;- count + 1
      printfn "timer ticked with count %i" count
Copy<br>We can reuse the utility functions we created earlier to test it:<br>// create a handler class
let handler = new ImperativeTimerCount()

// register the handler method
let timerCount1 = createTimer 500 handler.handleEvent

// run the task now
Async.RunSynchronously timerCount1
Copy<br>Letâ€™s see how we would do this same thing in a functional way:<br>// create the timer and the corresponding observable
let timerCount2, timerEventStream = createTimerAndObservable 500

// set up the transformations on the event stream
timerEventStream
|&gt; Observable.scan (fun count _ -&gt; count + 1) 0
|&gt; Observable.subscribe (fun count -&gt; printfn "timer ticked with count %i" count)

// run the task now
Async.RunSynchronously timerCount2
Copy<br>Here we see how you can build up layers of event transformations, just as you do with list transformations in LINQ.<br>The first transformation is scan, which accumulates state for each event. It is roughly equivalent to the List.fold function that we have seen used with lists. In this case, the accumulated state is just a counter.<br>And then, for each event, the count is printed out.<br>Note that in this functional approach, we didnâ€™t have any mutable state, and we didnâ€™t need to create any special classes.<br><br>For a final example, weâ€™ll look at merging multiple event streams.<br>Letâ€™s make a requirement based on the well-known â€œFizzBuzzâ€ problem:<br>Create two timers, called '3' and '5'. The '3' timer ticks every 300ms and the '5' timer ticks
every 500ms.

Handle the events as follows:
a) for all events, print the id of the time and the time
b) when a tick is simultaneous with a previous tick, print 'FizzBuzz'
otherwise:
c) when the '3' timer ticks on its own, print 'Fizz'
d) when the '5' timer ticks on its own, print 'Buzz'
Copy<br>First letâ€™s create some code that both implementations can use.<br>Weâ€™ll want a generic event type that captures the timer id and the time of the tick.<br>type FizzBuzzEvent = {label:int; time: DateTime}
Copy<br>And then we need a utility function to see if two events are simultaneous. Weâ€™ll be generous and allow a time difference of up to 50ms.<br>let areSimultaneous (earlierEvent,laterEvent) =
    let {label=_;time=t1} = earlierEvent
    let {label=_;time=t2} = laterEvent
    t2.Subtract(t1).Milliseconds &lt; 50
Copy<br>In the imperative design, weâ€™ll need to keep track of the previous event, so we can compare them. And weâ€™ll need special case code for the first time, when the previous event doesnâ€™t exist<br>type ImperativeFizzBuzzHandler() =

    let mutable previousEvent: FizzBuzzEvent option = None

    let printEvent thisEvent  =
      let {label=id; time=t} = thisEvent
      printf "[%i] %i.%03i " id t.Second t.Millisecond
      let simultaneous = previousEvent.IsSome &amp;&amp; areSimultaneous (previousEvent.Value,thisEvent)
      if simultaneous then printfn "FizzBuzz"
      elif id = 3 then printfn "Fizz"
      elif id = 5 then printfn "Buzz"

    member this.handleEvent3 eventArgs =
      let event = {label=3; time=DateTime.Now}
      printEvent event
      previousEvent &lt;- Some event

    member this.handleEvent5 eventArgs =
      let event = {label=5; time=DateTime.Now}
      printEvent event
      previousEvent &lt;- Some event
Copy<br>Now the code is beginning to get ugly fast! Already we have mutable state, complex conditional logic, and special cases, just for such a simple requirement.<br>Letâ€™s test it:<br>// create the class
let handler = new ImperativeFizzBuzzHandler()

// create the two timers and register the two handlers
let timer3 = createTimer 300 handler.handleEvent3
let timer5 = createTimer 500 handler.handleEvent5

// run the two timers at the same time
[timer3;timer5]
|&gt; Async.Parallel
|&gt; Async.RunSynchronously
Copy<br>It does work, but are you sure the code is not buggy? Are you likely to accidentally break something if you change it?<br>The problem with this imperative code is that it has a lot of noise that obscures the the requirements.<br>Can the functional version do better? Letâ€™s see!<br>First, we create two event streams, one for each timer:<br>let timer3, timerEventStream3 = createTimerAndObservable 300
let timer5, timerEventStream5 = createTimerAndObservable 500
Copy<br>Next, we convert each event on the â€œrawâ€ event streams into our FizzBuzz event type:<br>// convert the time events into FizzBuzz events with the appropriate id
let eventStream3  =
   timerEventStream3
   |&gt; Observable.map (fun _ -&gt; {label=3; time=DateTime.Now})

let eventStream5  =
   timerEventStream5
   |&gt; Observable.map (fun _ -&gt; {label=5; time=DateTime.Now})
Copy<br>Now, to see if two events are simultaneous, we need to compare them from the two different streams somehow.<br>Itâ€™s actually easier than it sounds, because we can:<br>
<br>combine the two streams into a single stream:
<br>then create pairs of sequential events
<br>then test the pairs to see if they are simultaneous
<br>then split the input stream into two new output streams based on that test
<br>Hereâ€™s the actual code to do this:<br>// combine the two streams
let combinedStream =
    Observable.merge eventStream3 eventStream5

// make pairs of events
let pairwiseStream =
   combinedStream |&gt; Observable.pairwise

// split the stream based on whether the pairs are simultaneous
let simultaneousStream, nonSimultaneousStream =
    pairwiseStream |&gt; Observable.partition areSimultaneous
Copy<br>Finally, we can split the nonSimultaneousStream again, based on the event id:<br>// split the non-simultaneous stream based on the id
let fizzStream, buzzStream  =
    nonSimultaneousStream
    // convert pair of events to the first event
    |&gt; Observable.map (fun (ev1,_) -&gt; ev1)
    // split on whether the event id is three
    |&gt; Observable.partition (fun {label=id} -&gt; id=3)
Copy<br>Letâ€™s review so far. We have started with the two original event streams and from them created four new ones:<br>
<br>combinedStream contains all the events
<br>simultaneousStream contains only the simultaneous events
<br>fizzStream contains only the non-simultaneous events with id=3
<br>buzzStream contains only the non-simultaneous events with id=5
<br>Now all we need to do is attach behavior to each stream:<br>//print events from the combinedStream
combinedStream
|&gt; Observable.subscribe (fun {label=id;time=t} -&gt;
                              printf "[%i] %i.%03i " id t.Second t.Millisecond)

//print events from the simultaneous stream
simultaneousStream
|&gt; Observable.subscribe (fun _ -&gt; printfn "FizzBuzz")

//print events from the nonSimultaneous streams
fizzStream
|&gt; Observable.subscribe (fun _ -&gt; printfn "Fizz")

buzzStream
|&gt; Observable.subscribe (fun _ -&gt; printfn "Buzz")
Copy<br>Letâ€™s test it:<br>// run the two timers at the same time
[timer3;timer5]
|&gt; Async.Parallel
|&gt; Async.RunSynchronously
Copy<br>Hereâ€™s all the code in one complete set:<br>// create the event streams and raw observables
let timer3, timerEventStream3 = createTimerAndObservable 300
let timer5, timerEventStream5 = createTimerAndObservable 500

// convert the time events into FizzBuzz events with the appropriate id
let eventStream3  = timerEventStream3
                    |&gt; Observable.map (fun _ -&gt; {label=3; time=DateTime.Now})
let eventStream5  = timerEventStream5
                    |&gt; Observable.map (fun _ -&gt; {label=5; time=DateTime.Now})

// combine the two streams
let combinedStream =
   Observable.merge eventStream3 eventStream5

// make pairs of events
let pairwiseStream =
   combinedStream |&gt; Observable.pairwise

// split the stream based on whether the pairs are simultaneous
let simultaneousStream, nonSimultaneousStream =
   pairwiseStream |&gt; Observable.partition areSimultaneous

// split the non-simultaneous stream based on the id
let fizzStream, buzzStream  =
    nonSimultaneousStream
    // convert pair of events to the first event
    |&gt; Observable.map (fun (ev1,_) -&gt; ev1)
    // split on whether the event id is three
    |&gt; Observable.partition (fun {label=id} -&gt; id=3)

//print events from the combinedStream
combinedStream
|&gt; Observable.subscribe (fun {label=id;time=t} -&gt;
                              printf "[%i] %i.%03i " id t.Second t.Millisecond)

//print events from the simultaneous stream
simultaneousStream
|&gt; Observable.subscribe (fun _ -&gt; printfn "FizzBuzz")

//print events from the nonSimultaneous streams
fizzStream
|&gt; Observable.subscribe (fun _ -&gt; printfn "Fizz")

buzzStream
|&gt; Observable.subscribe (fun _ -&gt; printfn "Buzz")

// run the two timers at the same time
[timer3;timer5]
|&gt; Async.Parallel
|&gt; Async.RunSynchronously
Copy<br>The code might seem a bit long winded, but this kind of incremental, step-wise approach is very clear and self-documenting.<br>Some of the benefits of this style are:<br>
<br>I can see that it meets the requirements just by looking at it, without even running it. Not so with the imperative version.
<br>From a design point of view, each final â€œoutputâ€ stream follows the single responsibility principle â€“ it only does one thing â€“ so it is very easy to associate behavior with it.
<br>This code has no conditionals, no mutable state, no edge cases. It would be easy to maintain or change, I hope.
<br>It is easy to debug. For example, I could easily â€œtapâ€ the output of the simultaneousStream to see if it contains what I think it contains:
<br>// debugging code
//simultaneousStream |&gt; Observable.subscribe (fun e -&gt; printfn "sim %A" e)
//nonSimultaneousStream |&gt; Observable.subscribe (fun e -&gt; printfn "non-sim %A" e)
Copy<br>This would be much harder in the imperative version.<br><br>Functional Reactive Programming (known as FRP) is a big topic, and weâ€™ve only just touched on it here. I hope this introduction has given you a glimpse of the usefulness of this way of doing things.<br>If you want to learn more, see the documentation for the F# <a data-tooltip-position="top" aria-label="https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2010/ee370313%28v=vs.100%29?redirectedfrom=MSDN" rel="noopener" class="external-link" href="https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2010/ee370313%28v=vs.100%29?redirectedfrom=MSDN" target="_blank">Observable module</a>, which has the basic transformations used above. And there is also the <a data-tooltip-position="top" aria-label="https://docs.microsoft.com/en-us/previous-versions/dotnet/reactive-extensions/hh242985%28v=vs.103%29" rel="noopener" class="external-link" href="https://docs.microsoft.com/en-us/previous-versions/dotnet/reactive-extensions/hh242985%28v=vs.103%29" target="_blank">Reactive Extensions (Rx)</a> library which shipped as part of .NET 4. That contains many other additional transformations.<br>]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/fsharp/functional-reactive-programming.html</link><guid isPermaLink="false">Computer Science/Programming Language/FSharp/Functional Reactive Programming.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:32 GMT</pubDate></item><item><title><![CDATA[K-Means clustering in FSharp]]></title><description><![CDATA[ 
 <br>Machine Learning in Action, in F#<br>Porting <a data-tooltip-position="top" aria-label="http://www.manning.com/pharrington/" rel="noopener" class="external-link" href="http://www.manning.com/pharrington/" target="_blank">Machine Learning in Action</a> from Python to F#<br>
<br><a data-tooltip-position="top" aria-label="https://mathias-brandewinder.github.io//2012/07/29/Nearest-Neighbor-Classification-part-1/" rel="noopener" class="external-link" href="https://mathias-brandewinder.github.io//2012/07/29/Nearest-Neighbor-Classification-part-1/" target="_blank">KNN classification (1)</a>
<br><a data-tooltip-position="top" aria-label="https://mathias-brandewinder.github.io//2012/08/01/Nearest-Neighbor-Classification-part-2/" rel="noopener" class="external-link" href="https://mathias-brandewinder.github.io//2012/08/01/Nearest-Neighbor-Classification-part-2/" target="_blank">KNN classification (2)</a>
<br><a data-tooltip-position="top" aria-label="https://mathias-brandewinder.github.io//2012/08/05/Decision-Tree-classification/" rel="noopener" class="external-link" href="https://mathias-brandewinder.github.io//2012/08/05/Decision-Tree-classification/" target="_blank">Decision Tree classification</a>
<br><a data-tooltip-position="top" aria-label="https://mathias-brandewinder.github.io//2012/08/18/Naive-Bayes-classification/" rel="noopener" class="external-link" href="https://mathias-brandewinder.github.io//2012/08/18/Naive-Bayes-classification/" target="_blank">Naive Bayes classification</a>
<br><a data-tooltip-position="top" aria-label="https://mathias-brandewinder.github.io//2012/09/30/Logistic-Regression/" rel="noopener" class="external-link" href="https://mathias-brandewinder.github.io//2012/09/30/Logistic-Regression/" target="_blank">Logistic Regression classification</a>
<br><a data-tooltip-position="top" aria-label="https://mathias-brandewinder.github.io//2012/11/25/Support-Vector-Machine-in-FSharp-work-in-progress/" rel="noopener" class="external-link" href="https://mathias-brandewinder.github.io//2012/11/25/Support-Vector-Machine-in-FSharp-work-in-progress/" target="_blank">SVM classification (1)</a>
<br><a data-tooltip-position="top" aria-label="https://mathias-brandewinder.github.io//2012/12/26/Support-Vector-Machine-in-FSharp/" rel="noopener" class="external-link" href="https://mathias-brandewinder.github.io//2012/12/26/Support-Vector-Machine-in-FSharp/" target="_blank">SVM classification (2)</a>
<br><a data-tooltip-position="top" aria-label="https://mathias-brandewinder.github.io//2012/12/29/AdaBoost-classifier-in-FSharp/" rel="noopener" class="external-link" href="https://mathias-brandewinder.github.io//2012/12/29/AdaBoost-classifier-in-FSharp/" target="_blank">AdaBoost classification</a>
<br><a data-tooltip-position="top" aria-label="https://mathias-brandewinder.github.io//2013/02/10/K-Means-Clustering-in-FSharp/" rel="noopener" class="external-link" href="https://mathias-brandewinder.github.io//2013/02/10/K-Means-Clustering-in-FSharp/" target="_blank">K-Means clustering</a>
<br><a data-tooltip-position="top" aria-label="https://mathias-brandewinder.github.io//2013/03/25/Simplify-data-with-SVD-and-MathNET-in-FSharp/" rel="noopener" class="external-link" href="https://mathias-brandewinder.github.io//2013/03/25/Simplify-data-with-SVD-and-MathNET-in-FSharp/" target="_blank">SVD</a>
<br><a data-tooltip-position="top" aria-label="https://mathias-brandewinder.github.io//2013/04/28/Recommendation-Engine-with-SVD-and-MathNET-in-FSharp/" rel="noopener" class="external-link" href="https://mathias-brandewinder.github.io//2013/04/28/Recommendation-Engine-with-SVD-and-MathNET-in-FSharp/" target="_blank">Recommendation engine</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/mathias-brandewinder/Machine-Learning-In-Action" rel="noopener" class="external-link" href="https://github.com/mathias-brandewinder/Machine-Learning-In-Action" target="_blank">Code on GitHub</a>
<br>And the Journey converting â€œ<a data-tooltip-position="top" aria-label="http://www.manning.com/pharrington/" rel="noopener" class="external-link" href="http://www.manning.com/pharrington/" target="_blank">Machine Learning in Action</a>â€ from Python to F# continues! Rather than following the order of the book, I decided to skip chapters 8 and 9, dedicated to regression methods (regression is something I spent a bit too much time doing in the past to be excited about it just right now), and go straight to Unsupervised Learning, which begins with the K-means clustering algorithm. So what is clustering about? In a nutshell, clustering focuses on the following question: given a set of observations, can the computer figure out a way to classify them into â€œmeaningful groupsâ€? The major difference with Classification methods is that in clustering, the Categories / Groups are initially unknown: itâ€™s the algorithmâ€™s job to figure out sensible ways to group items into Clusters, all by itself (hence the word â€œunsupervisedâ€). Chapter 10 covers 2 clustering algorithms, k-means , and bisecting k-means. Weâ€™ll discuss only the first one today. The underlying idea behind the k-means algorithm is to identify k â€œrepresentative archetypesâ€ (k being a user input), the Centroids. The algorithm proceeds iteratively:<br>
Starting from k random Centroids,<br>
Observations are assigned to the closest Centroid, and constitute a Cluster,<br>
Centroids are updated, by taking the average of their Cluster,<br>
Until the allocation of Observation to Clusters doesnâ€™t change any more.
<br>When things go well, we end up with k stable Centroids (minimal modification of Centroids do not change the Clusters), and Clusters contain Observations that are similar, because they are all close to the same Centroid (The <a data-tooltip-position="top" aria-label="http://en.wikipedia.org/wiki/K-means_clustering#Standard_algorithm" rel="noopener" class="external-link" href="http://en.wikipedia.org/wiki/K-means_clustering#Standard_algorithm" target="_blank">wikipedia page</a> for the algorithm provides a nice graphical representation).<br><br>The Python implementation proposed in the book is both very procedural and deals with Observations that are vectors. I thought it would be interesting to take a different approach, focused on functions instead. The current implementation is likely to change when I get into bisecting k-means, but should remain similar in spirit. Note also that I have given no focus to performance â€“ this is my take on the easiest thing that would work. The entire code can be found <a data-tooltip-position="top" aria-label="https://github.com/mathias-brandewinder/Machine-Learning-In-Action/blob/463cc43a5870cc8253bbf8b608800cb8380404b6/MachineLearningInAction/MachineLearningInAction/KMeansClustering.fs" rel="noopener" class="external-link" href="https://github.com/mathias-brandewinder/Machine-Learning-In-Action/blob/463cc43a5870cc8253bbf8b608800cb8380404b6/MachineLearningInAction/MachineLearningInAction/KMeansClustering.fs" target="_blank">here on GitHub</a>. Here is how I approached the problem. First, rather than restricting ourselves to vectors, suppose we want to deal with any generic type. Looking at the pseudo-code above, we need a few functions to implement the algorithm:<br>
<br>to assign Observations of type 'a to the closest Centroid 'a, we need a notion of Distance,
<br>we need to create an initial collection of k Centroids of type 'a, given a dataset of 'as,
<br>to update the Centroids based on a Cluster of 'as, we need some aggregation function.
<br>Letâ€™s create these 3 functions:<br>// the Distance between 2 observations 'a is a float
// It also better be positive - left to the implementer
type Distance&lt;'a&gt; = 'a -&gt; 'a -&gt; float
// CentroidsFactory, given a dataset, 
// should generate n Centroids
type CentroidsFactory&lt;'a&gt; = 'a seq -&gt; int -&gt; 'a seq
// Given a Centroid and observations in a Cluster,
// create an updated Centroid
type ToCentroid&lt;'a&gt; = 'a -&gt; 'a seq -&gt; 'a
Copy<br>We can now define a function which, given a set of Centroids, will return the index of the closest Centroid to an Observation, as well as the distance from the Centroid to the Observation:<br>// Returns the index of and distance to the 
// Centroid closest to observation
let closest (dist: Distance&lt;'a&gt;) centroids (obs: 'a) =
    centroids
    |&gt; Seq.mapi (fun i c -&gt; (i, dist c obs)) 
    |&gt; Seq.minBy (fun (i, d) -&gt; d)
Copy<br>Finally, weâ€™ll go for the laziest possible way to generate k initial Centroids, by picking up k random observations from our dataset:<br>// Picks k random observations as initial centroids
// (this is very lazy, even tolerates duplicates)
let randomCentroids&lt;'a&gt; (rng: System.Random) 
                        (sample: 'a seq) 
                        k =
    let size = Seq.length sample
    seq { for i in 1 .. k do 
            let pick = Seq.nth (rng.Next(size)) sample
            yield pick }
Copy<br>We have all we need â€“ we can now write the algorithm itself:<br>// Given a distance, centroid factory and
// centroid aggregation function, identify
// the k centroids of a dataset
let kmeans (dist: Distance&lt;'a&gt;) 
           (factory: CentroidsFactory&lt;'a&gt;) 
           (aggregator: ToCentroid&lt;'a&gt;)
           (dataset: 'a seq) 
           k =
    // Recursively update Centroids and
    // the assignment of observations to Centroids
    let rec update (centroids, assignment) =
        // Assign each point to the closest centroid
        let next = 
            dataset 
            |&gt; Seq.map (fun obs -&gt; closest dist centroids obs)
            |&gt; Seq.toList
        // Check if any assignment changed
        let change =
            match assignment with
            | Some(previous) -&gt; 
                Seq.zip previous next    
                |&gt; Seq.exists (fun ((i, _), (j, _)) -&gt; not (i = j))
            | None -&gt; true // initially we have no assignment
        if change 
        then 
            // Update each Centroid position:
            // extract cluster of points assigned to each Centroid
            // and compute the new Centroid by aggregating cluster
            let updatedCentroids =
                let assignedDataset = Seq.zip dataset next
                centroids 
                |&gt; Seq.mapi (fun i centroid -&gt; 
                    assignedDataset 
                    |&gt; Seq.filter (fun (_, (ci, _)) -&gt; ci = i)
                    |&gt; Seq.map (fun (obs, _) -&gt; obs)
                    |&gt; aggregator centroid)
            // Perform another round of updates
            update (updatedCentroids, Some(next))
        // No assignment changed, we are done
        else (centroids, next)

    let initialCentroids = factory dataset k
    let centroids = update (initialCentroids, None) |&gt; fst |&gt; Seq.toList        
    let classifier = fun datapoint -&gt; 
        centroids 
        |&gt; List.minBy (fun centroid -&gt; dist centroid datapoint)
    centroids, classifier
Copy<br>The meat of the algorithm is the update function. It takes in a set of current Centroids, and an optional Assignment of Observations to Centroids, represented as a list, mapping each Observation to Centroid indexes and corresponding distance. Note that we could drop the distance for the assignment â€“ itâ€™s never used afterwards, I added it prematurely because it is needed in the bissecting k-means algorithm.<br>The update function is recursive â€“ it computes what Centroid / Cluster each observation will be assigned to next, checks whether any Observation has been assigned to a different Cluster than before (or if there is an assignment at all, to cover the initial case when no assignment has been computed yet). If a change occurred, new Centroids are computed and we go for another round, and otherwise we are done.<br>The outer function calls update, and once it terminates, returns the Centroids that have been identified, as well as a Classifier function, which will return the closest Centroid to an Observation.<br><br>I created two small examples illustrating the algorithm in action: one classic, with numeric observations, and one â€œjust for kicksâ€, attempting to cluster a collection of strings. Both can be found in the file <a data-tooltip-position="top" aria-label="https://github.com/mathias-brandewinder/Machine-Learning-In-Action/blob/463cc43a5870cc8253bbf8b608800cb8380404b6/MachineLearningInAction/MachineLearningInAction/Chapter10.fsx" rel="noopener" class="external-link" href="https://github.com/mathias-brandewinder/Machine-Learning-In-Action/blob/463cc43a5870cc8253bbf8b608800cb8380404b6/MachineLearningInAction/MachineLearningInAction/Chapter10.fsx" target="_blank">Chapter10.fsx</a>.<br>The classic case operates on an artificially created dataset: we generate 3 points in 3 dimensions, and a collection of 50 points randomly generated in spheres around these 3 points:<br>let rng = new System.Random()
let centroids = [ [| 0.; 0.; 0. |]; [| 20.; 30.; 40. |]; [| -40.; -50.; -60. |] ]
// Create 50 points centered around each Centroid
let data = [ 
    for centroid in centroids do
        for i in 1 .. 50 -&gt; 
            Array.map (fun x -&gt; x + 5. * (rng.NextDouble() - 0.5)) centroid ]
Copy<br>If everything works correctly, we expect the algorithm to identify 3 Centroids close to the 3 points we used as anchor points for our data sample. We need to define 2 functions, which are included in the main module: a Distance, and a function to compute a Centroid from a Cluster of Observations:<br>// Euclidean distance between 2 points, represented as float []
let euclidean x y = 
    Array.fold2 (fun d e1 e2 -&gt; d + pown (e1 - e2) 2) 0. x y 
    |&gt; sqrt

// Recompute Centroid as average of given sample
let avgCentroid (current: float []) (sample: float [] seq) =
    let size = Seq.length sample
    match size with
    | 0 -&gt; current
    | _ -&gt;
        sample
        |&gt; Seq.reduce (fun v1 v2 -&gt; 
               Array.map2 (fun v1x v2x -&gt; v1x + v2x) v1 v2)
        |&gt; Array.map (fun e -&gt; e / (float)size)
Copy<br>Armed with this, we can run the algorithm:<br>let factory = randomCentroids&lt;float[]&gt; rng
let identifiedCentroids, classifier = kmeans euclidean factory avgCentroid data 3
printfn "Centroids identified"
identifiedCentroids 
|&gt; List.iter (fun c -&gt; 
    printfn ""
    printf "Centroid: "
    Array.iter (fun x -&gt; printf "%.2f " x) c)
Copy<br>On my machine, this produces the following:<br>Centroids identified  
Centroid: 19.93 30.32 39.89  
Centroid: -39.98 -50.10 -59.69  
Centroid: -0.28 0.43 -0.01
Copy<br>The 3 centroids are exactly what we expect â€“ 3 points close to {20; 30; 40}, {-40; â€“50; -60} and {0; 0; 0}. Things seem to be working.<br>Now I was curious to see if this would be usable on something completely different, like strings. As usual, in order to make that work, we need a Distance, and a way to reduce a Cluster to a Centroid. The most obvious choice for a Distance between strings is the <a data-tooltip-position="top" aria-label="http://en.wikipedia.org/wiki/Levenshtein_distance" rel="noopener" class="external-link" href="http://en.wikipedia.org/wiki/Levenshtein_distance" target="_blank">Levenshtein distance</a>, which measures how many edits are required to transform a string into another. Fortunately for me, someone already provided an <a data-tooltip-position="top" aria-label="http://en.wikibooks.org/wiki/Algorithm_implementation/Strings/Levenshtein_distance#F.23" rel="noopener" class="external-link" href="http://en.wikibooks.org/wiki/Algorithm_implementation/Strings/Levenshtein_distance#F.23" target="_blank">implementation in F#</a>, which I shamelessly lifted.<br>The Centroid update question required a bit of thinking. Obviously, computing the average of strings isnâ€™t going to work â€“ so how could we find a good â€œrepresentative stringâ€ from a Cluster? I decided to go for something fairly simple: pick the string in the Cluster which has the least worst-case distance to all the others (as an alternative, I also tried picking the string with the lowest sum of squares distance, which produced similar results).<br>Finally, I created a sample, using a collection of 53 words sharing three different roots: â€œGRAPHâ€, â€œSCRIPTâ€ and â€œGRAMâ€. Results vary from run to run (not surprisingly, the algorithm often struggles to separate GRAPH and GRAM words), but overall I was pleasantly surprised by the results:<br>Words identified
TELEGRAPHIC
RADIOGRAM
PRESCRIPTIVE

Classification of sample words
AUTOBIOGRAPHER -&gt; TELEGRAPHIC
AUTOBIOGRAPHICAL -&gt; TELEGRAPHIC
AUTOBIOGRAPHY -&gt; TELEGRAPHIC
AUTOGRAPH -&gt; RADIOGRAM
BIBLIOGRAPHIC -&gt; TELEGRAPHIC
BIBLIOGRAPHY -&gt; TELEGRAPHIC
CALLIGRAPHY -&gt; TELEGRAPHIC
CARTOGRAPHY -&gt; RADIOGRAM
CRYPTOGRAPHY -&gt; RADIOGRAM
GRAPH -&gt; TELEGRAPHIC
HISTORIOGRAPHY -&gt; TELEGRAPHIC
PARAGRAPH -&gt; TELEGRAPHIC
SEISMOGRAPH -&gt; TELEGRAPHIC
STENOGRAPHER -&gt; TELEGRAPHIC
TELEGRAPH -&gt; TELEGRAPHIC
TELEGRAPHIC -&gt; TELEGRAPHIC
BIBLIOGRAPHICAL -&gt; TELEGRAPHIC
STEREOGRAPH -&gt; TELEGRAPHIC
DESCRIBABLE -&gt; PRESCRIPTIVE
DESCRIBE -&gt; PRESCRIPTIVE
DESCRIBER -&gt; PRESCRIPTIVE
DESCRIPTION -&gt; PRESCRIPTIVE
DESCRIPTIVE -&gt; PRESCRIPTIVE
INDESCRIBABLE -&gt; PRESCRIPTIVE
INSCRIBE -&gt; PRESCRIPTIVE
INSCRIPTION -&gt; PRESCRIPTIVE
POSTSCRIPT -&gt; PRESCRIPTIVE
PRESCRIBE -&gt; PRESCRIPTIVE
PRESCRIPTION -&gt; PRESCRIPTIVE
PRESCRIPTIVE -&gt; PRESCRIPTIVE
SCRIBAL -&gt; RADIOGRAM
SCRIBBLE -&gt; PRESCRIPTIVE
SCRIBE -&gt; PRESCRIPTIVE
SCRIBBLER -&gt; RADIOGRAM
SCRIPT -&gt; PRESCRIPTIVE
SCRIPTURE -&gt; PRESCRIPTIVE
SCRIPTWRITER -&gt; PRESCRIPTIVE
SUPERSCRIPT -&gt; PRESCRIPTIVE
TRANSCRIBE -&gt; PRESCRIPTIVE
TYPESCRIPT -&gt; PRESCRIPTIVE
TRANSCRIPTION -&gt; PRESCRIPTIVE
DESCRIPTOR -&gt; PRESCRIPTIVE
ANAGRAM -&gt; RADIOGRAM
CABLEGRAM -&gt; RADIOGRAM
CRYPTOGRAM -&gt; RADIOGRAM
GRAMMAR -&gt; RADIOGRAM
GRAMMARIAN -&gt; RADIOGRAM
GRAMMATICAL -&gt; RADIOGRAM
MONOGRAM -&gt; RADIOGRAM
RADIOGRAM -&gt; RADIOGRAM
TELEGRAM -&gt; TELEGRAPHIC
UNGRAMMATICAL -&gt; TELEGRAPHIC
AEROGRAM -&gt; RADIOGRAM
Copy<br>Thatâ€™s it for today! In our next â€œML in Actionâ€ episode, weâ€™ll look into the bissecting k-means algorithm, which is a variation on todayâ€™s algorithm, and probably revisit the implementation. In the meanwhile, feel free to leave comments or feedback!<br><br><a data-tooltip-position="top" aria-label="https://github.com/mathias-brandewinder/Machine-Learning-In-Action/tree/463cc43a5870cc8253bbf8b608800cb8380404b6" rel="noopener" class="external-link" href="https://github.com/mathias-brandewinder/Machine-Learning-In-Action/tree/463cc43a5870cc8253bbf8b608800cb8380404b6" target="_blank">Source code on GitHub</a>: the relevant code is in the files KMeansClustering.fs and Chapter10.fsx.<br><a data-tooltip-position="top" aria-label="http://en.wikipedia.org/wiki/K-means_clustering#Standard_algorithm" rel="noopener" class="external-link" href="http://en.wikipedia.org/wiki/K-means_clustering#Standard_algorithm" target="_blank">K-means algorithm on Wikipedia</a>.<br><a data-tooltip-position="top" aria-label="http://en.wikipedia.org/wiki/Levenshtein_distance" rel="noopener" class="external-link" href="http://en.wikipedia.org/wiki/Levenshtein_distance" target="_blank">Levenshtein distance on Wikipedia</a>, and an <a data-tooltip-position="top" aria-label="http://en.wikibooks.org/wiki/Algorithm_implementation/Strings/Levenshtein_distance#F.23" rel="noopener" class="external-link" href="http://en.wikibooks.org/wiki/Algorithm_implementation/Strings/Levenshtein_distance#F.23" target="_blank">F# implementation of Levenshtein distance</a>.<br><a data-tooltip-position="top" aria-label="http://richardminerich.com/2012/09/levenshtein-distance-and-the-triangle-inequality/" rel="noopener" class="external-link" href="http://richardminerich.com/2012/09/levenshtein-distance-and-the-triangle-inequality/" target="_blank">Interesting discussion on the Levenshtein distance</a> on <a data-tooltip-position="top" aria-label="https://twitter.com/rickasaurus" rel="noopener" class="external-link" href="https://twitter.com/rickasaurus" target="_blank">@Rickasaurus</a>â€™ blog.<br>Another <a data-tooltip-position="top" aria-label="http://tech.blinemedical.com/k-means-step-by-step-in-f/" rel="noopener" class="external-link" href="http://tech.blinemedical.com/k-means-step-by-step-in-f/" target="_blank">K-means implementation in F#,</a> from <a data-tooltip-position="top" aria-label="https://twitter.com/devshorts" rel="noopener" class="external-link" href="https://twitter.com/devshorts" target="_blank">@DevShorts</a>.<br><a data-tooltip-position="top" aria-label="http://www.learnthat.org/pages/view/roots.html" rel="noopener" class="external-link" href="http://www.learnthat.org/pages/view/roots.html" target="_blank">Root Words</a>: an intriguing web page, providing help to learn words and vocabulary, which contains a list of words roots. It has one incredibly annoying feature â€“ you canâ€™t copy paste text from the page.]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/fsharp/k-means-clustering-in-fsharp.html</link><guid isPermaLink="false">Computer Science/Programming Language/FSharp/K-Means clustering in FSharp.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:33 GMT</pubDate></item><item><title><![CDATA[Learning from mistakes - Winnow algorithm in FSharp]]></title><description><![CDATA[ 
 <br>During some recent meanderings through the confines of the internet, I ended up discovering the <a data-tooltip-position="top" aria-label="http://www.cc.gatech.edu/~ninamf/ML11/lect0906.pdf" rel="noopener" class="external-link" href="http://www.cc.gatech.edu/~ninamf/ML11/lect0906.pdf" target="_blank">Winnow Algorithm</a>. The simplicity of the approach intrigued me, so I thought it would be interesting to try and implement it in F# and see how well it worked.<br>The purpose of the algorithm is to train a binary classifier, based on binary features. In other words, the goal is to predict one of two states, using a collection of features which are all binary. The prediction model assigns weights to each feature; to predict the state of an observation, it checks all the features that are â€œactiveâ€ (true), and sums up the weights assigned to these features. If the total is above a certain threshold, the result is true, otherwise itâ€™s false. Dead simple â€“ and so is the corresponding F# code:<br>type Observation = bool []
type Label = bool
type Example = Label * Observation
type Weights = float []
 
let predict (theta:float) (w:Weights) (obs:Observation) =
    (obs,w) ||&gt; Seq.zip
    |&gt; Seq.filter fst
    |&gt; Seq.sumBy snd
    |&gt; ((&lt;) theta)
Copy<br>We create some type aliases for convenience, and write a predict function which takes in theta (the threshold), weights and and observation; we zip together the features and the weights, exclude the pairs where the feature is not active, sum the weights, check whether the threshold is lower that the total, and we are done.<br>In a nutshell, the learning process feeds examples (observations with known label), and progressively updates the weights when the model makes mistakes. If the current model predicts the output correctly, donâ€™t change anything. If it predicts true but should predict false, it is over-shooting, so weights that were used in the prediction (i.e. the weights attached to active features) are reduced. Conversely, if the prediction is false but the correct result should be true, the active features are not used enough to reach the threshold, so they should be bumped up.<br>And thatâ€™s pretty much it â€“ the algorithm starts with arbitrary initial weights of 1 for every feature, and either doubles or halves them based on the mistakes. Again, the F# implementation is completely straightforward. The weights update can be written as follows:<br>let update (theta:float) (alpha:float) (w:Weights) (ex:Example) =
    let real,obs = ex
    match (real,predict theta w obs) with
    | (true,false) -&gt; w |&gt; Array.mapi (fun i x -&gt; if obs.[i] then alpha * x else x)
    | (false,true) -&gt; w |&gt; Array.mapi (fun i x -&gt; if obs.[i] then x / alpha else x)
    | _ -&gt; w
Copy<br>Letâ€™s check that the update mechanism works:<br>&gt; update 0.5 2. [|1.;1.;|] (false,[|false;true;|]);;
val it : float [] = [|1.0; 0.5|]
Copy<br>The threshold is 0.5, the adjustment multiplier is 2, and each feature is currently weighted at 1. The state of our example is [| false; true; |], so only the second feature is active, which means that the predicted value will be 1. (the weight of that feature). This is above the threshold 0.5, so the predicted value is true. However, because the correct value attached to that example is false, our prediction is incorrect, and the weight of the second feature is reduced, while the first one, which was not active, remains unchanged.<br>Letâ€™s wrap this up in a convenience function which will learn from a sequence of examples, and give us directly a function that will classify observations:<br>let learn (theta:float) (alpha:float) (fs:int) (xs:Example seq) =
    let updater = update theta alpha
    let w0 = [| for f in 1 .. fs -&gt; 1. |]   
    let w = Seq.fold (fun w x -&gt; updater w x) w0 xs
    fun (obs:Observation) -&gt; predict theta w obs
Copy<br>We pass in the number of features, fs, to initialize the weights at the correct size, and use a fold to update the weights for each example in the sequence. Finally, we create and return a function that, given an observation, will predict the label, based on the weights we just learnt.<br>And thatâ€™s it â€“ in 20 lines of code, we are done, the Winnow is implemented.<br>Butâ€¦ does it work? An example doesnâ€™t prove anything, of course, but I was curious, and cooked up the following idea. Letâ€™s use the Winnow to predict if the next character in a piece of text is going to be a letter, or something else (space, punctuationâ€¦), based on the previous characters. In other words, letâ€™s try to predict if we reached the end of a word.<br>To simplify the coding part a bit, I will ignore case, and convert every character to upper case. Obviously, whether a character is upper or lower case is relevant to where we are in a word, but my goal here is just to satisfy my curiosity, so I will ignore that and be lazy. The letters A to Z correspond to char 65 to 90 (thatâ€™s an alphabet of 26 characters), and I also want to catch everything that isnâ€™t a letter. One way we can then encode a character so that it fits our requirement of binary features is the following: create an array of 27 slots, and mark with true the slot corresponding to the letter, reserving the last slot for the case â€œnot a letterâ€.<br>I will readily admit it, the following code is a bit ugly (there is probably a cleaner way to do that), but gets the work done:<br>let letter (c:char) = int c &gt;= 65 &amp;&amp; int c &lt;= 90
 
let encode (c:char) =
    let vec = Array.create (90-65+2) false   
    let x = int c
    if (x &gt;= 65 &amp;&amp; x &lt;= 90)
    then vec.[x-65] &lt;- true
    else vec.[90-65+1] &lt;- true
vec
 
let prepare (cs:char[]) =
    cs |&gt; Seq.map encode |&gt; Array.concat
Copy<br>letter simply recognizes if a char is an uppercase letter, encode creates a vector representing a character, and prepare takes in an array of chars, and returns an array which puts side-by-side each of the encoded characters. As an example,<br>&gt; encode 'B';;
val it : bool [] =
[|false; true; false; false; false; false; false; false; false; false; false;
false; false; false; false; false; false; false; false; false; false;
false; false; false; false; false; false|]
Copy<br>This returns an array of 27 booleans â€“ all of them false, except the second position, which corresponds to Bâ€™s position in the alphabet.<br>We will try to predict the next character based not only on the previous one, but rather on the preceding sequence, the <a data-tooltip-position="top" aria-label="http://en.wikipedia.org/wiki/N-gram" rel="noopener" class="external-link" href="http://en.wikipedia.org/wiki/N-gram" target="_blank">N-gram</a>. Letâ€™s write a quick and dirty function to transform a string into N-grams, and whether the character that immediately follows is the end of a word, or any letter:<br>let ngrams n (text:string) =
text.ToUpperInvariant()
|&gt; Seq.windowed (n+1)
|&gt; Seq.map (fun x -&gt; x.[n],x.[0..(n-1)])
|&gt; Seq.map (fun (c,cs) -&gt; letter c |&gt; not, prepare cs)
Copy<br>And we are ready to go. What I am really interested in here is not that much how good or bad the classifier is, but whether it actually improves as it gets feds more data. To observe that, letâ€™s do the following: weâ€™ll use a body of text for training, and another one for validation; we will train the classifier on a larger and larger portion of the training text, and measure the quality of the various models by applying it to the validation text.<br>We will train the model on a paragraph by Borges, and validate on some Cicero, both lifted from the <a data-tooltip-position="top" aria-label="http://en.wikipedia.org/wiki/Infinite_monkey_theorem#Origins_and_.22The_Total_Library.22" rel="noopener" class="external-link" href="http://en.wikipedia.org/wiki/Infinite_monkey_theorem#Origins_and_.22The_Total_Library.22" target="_blank">Total Library section in the Infinite Monkey wikipedia page</a>.<br>Training:<br>
Everything would be in its blind volumes. Everything: the detailed history of the future, Aeschylusâ€™ The Egyptians, the exact number of times that the waters of the Ganges have reflected the flight of a falcon, the secret and true nature of Rome, the encyclopedia Novalis would have constructed, my dreams and half-dreams at dawn on August 14, 1934, the proof of Pierre Fermatâ€™s theorem, the unwritten chapters of Edwin Drood, those same chapters translated into the language spoken by the Garamantes, the paradoxes Berkeley invented concerning Time but didnâ€™t publish, Urizenâ€™s books of iron, the premature epiphanies ofStephen Dedalus, which would be meaningless before a cycle of a thousand years, the Gnostic Gospel of Basilides, the song the sirens sang, the complete catalog of the Library, the proof of the inaccuracy of that catalog. Everything: but for every sensible line or accurate fact there would be millions of meaningless cacophonies, verbal farragoes, and babblings. Everything: but all the generations of mankind could pass before the dizzying shelvesâ€”shelves that obliterate the day and on which chaos liesâ€”ever reward them with a tolerable page.
<br>Validation:<br>
He who believes this may as well believe that if a great quantity of the one-and-twenty letters, composed either of gold or any other matter, were thrown upon the ground, they would fall into such order as legibly to form the Annals of Ennius. I doubt whether fortune could make a single verse of them.
<br>Here is how one might go about coding that experiment:<br>let training = ngrams 3 borges
let validation = ngrams 3 cicero
 
let len = Seq.length training
    for l in 25 .. 25 .. (len - 1) do
    let sample = training |&gt; Seq.take l
    let model = learn 0.5 2. (3*(92-65)) sample
    validation
    |&gt; Seq.averageBy (fun (l,o) -&gt;
    if l = model o then 1. else 0.)
    |&gt; printfn "Sample: %i, correct: %.4f" l
Copy<br>Running that code will produce some rather unexciting output:<br>Sample: 25, correct: 0.2168 
Sample: 50, correct: 0.4434 
Sample: 75, correct: 0.5049 
Sample: 100, correct: 0.5955 
Sample: 125, correct: 0.5081 
Sample: 150, correct: 0.6861

// snipped because more of the same

Sample: 1125, correct: 0.7476 
Sample: 1150, correct: 0.6278 
Sample: 1175, correct: 0.6893 
Sample: 1200, correct: 0.7314
Copy<br>Visibly, the quality starts pretty low, with around 21% correct predictions for the smallest sample, climbs up as the sample increases, and ends up oscillating in the 65% â€“ 75% range. This isnâ€™t a proof of anything, of course, but it seems to indicate that the model is â€œlearningâ€, getting better and better at recognizing word endings as it is fed more 3-grams.<br>And thatâ€™s as far as Iâ€™ll go on the Winnow. I thought this was an interesting algorithm, if only for its simplicity. It is also suitable for online learning: you donâ€™t need to train your model on a dataset before using it - it can progressively learn on the fly as data is arriving, and the only state you need to maintain is the latest set of weights. The biggest limitation is that it is a linear classifier, which assumes that the data can be cleanly separated along a plane.<br>In any case, I definitely had fun playing with this â€“ I hope you did, too!]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/fsharp/learning-from-mistakes-winnow-algorithm-in-fsharp.html</link><guid isPermaLink="false">Computer Science/Programming Language/FSharp/Learning from mistakes - Winnow algorithm in FSharp.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:29 GMT</pubDate></item><item><title><![CDATA[Messages and Agents]]></title><description><![CDATA[ 
 <br>In this post, weâ€™ll look at the message-based (or actor-based) approach to concurrency.<br>In this approach, when one task wants to communicate with another, it sends it a message, rather than contacting it directly. The messages are put on a queue, and the receiving task (known as an â€œactorâ€ or â€œagentâ€) pulls the messages off the queue one at a time to process them.<br>This message-based approach has been applied to many situations, from low-level network sockets (built on TCP/IP) to enterprise wide application integration systems (for example RabbitMQ or IBM WebSphere MQ).<br>From a software design point of view, a message-based approach has a number of benefits:<br>
<br>You can manage shared data and resources without locks.
<br>You can easily follow the â€œsingle responsibility principleâ€, because each agent can be designed to do only one thing.
<br>It encourages a â€œpipelineâ€ model of programming with â€œproducersâ€ sending messages to decoupled â€œconsumersâ€, which has additional benefits:

<br>The queue acts as a buffer, eliminating waiting on the client side.
<br>It is straightforward to scale up one side or the other of the queue as needed in order to maximize throughput.
<br>Errors can be handled gracefully, because the decoupling means that agents can be created and destroyed without affecting their clients.


<br>From a practical developerâ€™s point of view, what I find most appealing about the message-based approach is that when writing the code for any given actor, you donâ€™t have to hurt your brain by thinking about concurrency. The message queue forces a â€œserializationâ€ of operations that otherwise might occur concurrently. And this in turn makes it much easier to think about (and write code for) the logic for processing a message, because you can be sure that your code will be isolated from other events that might interrupt your flow.<br>With these advantages, it is not surprising that when a team inside Ericsson wanted to design a programming language for writing highly-concurrent telephony applications, they created one with a message-based approach, namely Erlang. Erlang has now become the poster child for the whole topic, and has created a lot of interest in implementing the same approach in other languages.<br><br>F# has a built-in agent class called MailboxProcessor. These agents are very lightweight compared with threads - you can instantiate tens of thousands of them at the same time.<br>These are similar to the agents in Erlang, but unlike the Erlang ones, they do not work across process boundaries, only in the same process. And unlike a heavyweight queueing system such as RabbitMQ, the messages are not persistent. If your app crashes, the messages are lost.<br>But these are minor issues, and can be worked around. In a future series, I will go into alternative implementations of message queues. The fundamental approach is the same in all cases.<br>Letâ€™s see a simple agent implementation in F#:<br>
let printerAgent = MailboxProcessor.Start(fun inbox-&gt;

    // the message processing function
    let rec messageLoop() = async{

        // read a message
        let! msg = inbox.Receive()

        // process a message
        printfn "message is: %s" msg

        // loop to top
        return! messageLoop()
        }

    // start the loop
    messageLoop()
    )

Copy<br>The MailboxProcessor.Start function takes a simple function parameter. That function loops forever, reading messages from the queue (or â€œinboxâ€) and processing them.<br>Hereâ€™s the example in use:<br>// test it
printerAgent.Post "hello"
printerAgent.Post "hello again"
printerAgent.Post "hello a third time"
Copy<br>In the rest of this post weâ€™ll look at two slightly more useful examples:<br>
<br>Managing shared state without locks
<br>Serialized and buffered access to shared IO
<br>In both of these cases, a message based approach to concurrency is elegant, efficient, and easy to program.<br><br>Letâ€™s look at the shared state problem first.<br>A common scenario is that you have some state that needs to be accessed and changed by multiple concurrent tasks or threads. Weâ€™ll use a very simple case, and say that the requirements are:<br>
<br>A shared â€œcounterâ€ and â€œsumâ€ that can be incremented by multiple tasks concurrently.
<br>Changes to the counter and sum must be atomic â€“ we must guarantee that they will both be updated at the same time.
<br><br>Using locks or mutexes is a common solution for these requirements, so letâ€™s write some code using a lock, and see how it performs.<br>First letâ€™s write a static LockedCounter class that protects the state with locks.<br>open System
open System.Threading
open System.Diagnostics

// a utility function
type Utility() =
    static let rand = Random()

    static member RandomSleep() =
        let ms = rand.Next(1,10)
        Thread.Sleep ms

// an implementation of a shared counter using locks
type LockedCounter () =

    static let _lock = Object()

    static let mutable count = 0
    static let mutable sum = 0

    static let updateState i =
        // increment the counters and...
        sum &lt;- sum + i
        count &lt;- count + 1
        printfn "Count is: %i. Sum is: %i" count sum

        // ...emulate a short delay
        Utility.RandomSleep()


    // public interface to hide the state
    static member Add i =
        // see how long a client has to wait
        let stopwatch = Stopwatch()
        stopwatch.Start()

        // start lock. Same as C# lock{...}
        lock _lock (fun () -&gt;

            // see how long the wait was
            stopwatch.Stop()
            printfn "Client waited %i" stopwatch.ElapsedMilliseconds

            // do the core logic
            updateState i
            )
        // release lock
Copy<br>Some notes on this code:<br>
<br>This code is written using a very imperative approach, with mutable variables and locks
<br>The public Add method has explicit Monitor.Enter and Monitor.Exit expressions to get and release the lock. This is the same as the lock{...} statement in C#.
<br>Weâ€™ve also added a stopwatch to measure how long a client has to wait to get the lock.
<br>The core â€œbusiness logicâ€ is the updateState method, which not only updates the state, but adds a small random wait as well to emulate the time taken to do the processing.
<br>Letâ€™s test it in isolation:<br>// test in isolation
LockedCounter.Add 4
LockedCounter.Add 5
Copy<br>Next, weâ€™ll create a task that will try to access the counter:<br>let makeCountingTask addFunction taskId  = async {
    let name = sprintf "Task%i" taskId
    for i in [1..3] do
        addFunction i
    }

// test in isolation
let task = makeCountingTask LockedCounter.Add 1
Async.RunSynchronously task
Copy<br>In this case, when there is no contention at all, the wait times are all 0.<br>But what happens when we create 10 child tasks that all try to access the counter at once:<br>let lockedExample5 =
    [1..10]
        |&gt; List.map (fun i -&gt; makeCountingTask LockedCounter.Add i)
        |&gt; Async.Parallel
        |&gt; Async.RunSynchronously
        |&gt; ignore
Copy<br>Oh dear! Most tasks are now waiting quite a while. If two tasks want to update the state at the same time, one must wait for the otherâ€™s work to complete before it can do its own work, which affects performance.<br>And if we add more and more tasks, the contention will increase, and the tasks will spend more and more time waiting rather than working.<br><br>Letâ€™s see how a message queue might help us. Hereâ€™s the message based version:<br>type MessageBasedCounter () =

    static let updateState (count,sum) msg =

        // increment the counters and...
        let newSum = sum + msg
        let newCount = count + 1
        printfn "Count is: %i. Sum is: %i" newCount newSum

        // ...emulate a short delay
        Utility.RandomSleep()

        // return the new state
        (newCount,newSum)

    // create the agent
    static let agent = MailboxProcessor.Start(fun inbox -&gt;

        // the message processing function
        let rec messageLoop oldState = async{

            // read a message
            let! msg = inbox.Receive()

            // do the core logic
            let newState = updateState oldState msg

            // loop to top
            return! messageLoop newState
            }

        // start the loop
        messageLoop (0,0)
        )

    // public interface to hide the implementation
    static member Add i = agent.Post i
Copy<br>Some notes on this code:<br>
<br>The core â€œbusiness logicâ€ is again in the updateState method, which has almost the same implementation as the earlier example, except the state is immutable, so that a new state is created and returned to the main loop.
<br>The agent reads messages (simple ints in this case) and then calls updateState method
<br>The public method Add posts a message to the agent, rather than calling the updateState method directly
<br>This code is written in a more functional way; there are no mutable variables and no locks anywhere. In fact, there is no code dealing with concurrency at all! The code only has to focus on the business logic, and is consequently much easier to understand.
<br>Letâ€™s test it in isolation:<br>// test in isolation
MessageBasedCounter.Add 4
MessageBasedCounter.Add 5
Copy<br>Next, weâ€™ll reuse a task we defined earlier, but calling MessageBasedCounter.Add instead:<br>let task = makeCountingTask MessageBasedCounter.Add 1
Async.RunSynchronously task
Copy<br>Finally letâ€™s create 5 child tasks that try to access the counter at once.<br>let messageExample5 =
    [1..5]
        |&gt; List.map (fun i -&gt; makeCountingTask MessageBasedCounter.Add i)
        |&gt; Async.Parallel
        |&gt; Async.RunSynchronously
        |&gt; ignore
Copy<br>We canâ€™t measure the waiting time for the clients, because there is none!<br><br>A similar concurrency problem occurs when accessing a shared IO resource such as a file:<br>
<br>If the IO is slow, the clients can spend a lot of time waiting, even without locks.
<br>If multiple threads write to the resource at the same time, you can get corrupted data.
<br>Both problems can be solved by using asynchronous calls combined with buffering â€“ exactly what a message queue does.<br>In this next example, weâ€™ll consider the example of a logging service that many clients will write to concurrently. (In this trivial case, weâ€™ll just write directly to the Console.)<br>Weâ€™ll first look at an implementation without concurrency control, and then at an implementation that uses message queues to serialize all requests.<br><br>In order to make the corruption very obvious and repeatable, letâ€™s first create a â€œslowâ€ console that writes each individual character in the log message and pauses for a millisecond between each character. During that millisecond, another thread could be writing as well, causing an undesirable interleaving of messages.<br>let slowConsoleWrite msg =
    msg |&gt; String.iter (fun ch-&gt;
        System.Threading.Thread.Sleep(1)
        System.Console.Write ch
        )

// test in isolation
slowConsoleWrite "abc"
Copy<br>Next, we will create a simple task that loops a few times, writing its name each time to the logger:<br>let makeTask logger taskId = async {
    let name = sprintf "Task%i" taskId
    for i in [1..3] do
        let msg = sprintf "-%s:Loop%i-" name i
        logger msg
    }

// test in isolation
let task = makeTask slowConsoleWrite 1
Async.RunSynchronously task
Copy<br>Next, we write a logging class that encapsulates access to the slow console. It has no locking or serialization, and is basically not thread-safe:<br>type UnserializedLogger() =
    // interface
    member this.Log msg = slowConsoleWrite msg

// test in isolation
let unserializedLogger = UnserializedLogger()
unserializedLogger.Log "hello"
Copy<br>Now letâ€™s combine all these into a real example. We will create five child tasks and run them in parallel, all trying to write to the slow console.<br>let unserializedExample =
    let logger = UnserializedLogger()
    [1..5]
        |&gt; List.map (fun i -&gt; makeTask logger.Log i)
        |&gt; Async.Parallel
        |&gt; Async.RunSynchronously
        |&gt; ignore
Copy<br>Ouch! The output is very garbled!<br><br>So what happens when we replace UnserializedLogger with a SerializedLogger class that encapsulates a message queue.<br>The agent inside SerializedLogger simply reads a message from its input queue and writes it to the slow console. Again there is no code dealing with concurrency and no locks are used.<br>type SerializedLogger() =

    // create the mailbox processor
    let agent = MailboxProcessor.Start(fun inbox -&gt;

        // the message processing function
        let rec messageLoop () = async{

            // read a message
            let! msg = inbox.Receive()

            // write it to the log
            slowConsoleWrite msg

            // loop to top
            return! messageLoop ()
            }

        // start the loop
        messageLoop ()
        )

    // public interface
    member this.Log msg = agent.Post msg

// test in isolation
let serializedLogger = SerializedLogger()
serializedLogger.Log "hello"
Copy<br>So now we can repeat the earlier unserialized example but using the SerializedLogger instead. Again, we create five child tasks and run them in parallel:<br>let serializedExample =
    let logger = SerializedLogger()
    [1..5]
        |&gt; List.map (fun i -&gt; makeTask logger.Log i)
        |&gt; Async.Parallel
        |&gt; Async.RunSynchronously
        |&gt; ignore
Copy<br>What a difference! This time the output is perfect.<br><br>There is much more to say about this message based approach. In a future series, I hope to go into much more detail, including discussion of topics such as:<br>
<br>alternative implementations of message queues with RabbitMQ and TPL Dataflow.
<br>cancellation and out of band messages.
<br>error handling and retries, and handling exceptions in general.
<br>how to scale up and down by creating or removing child agents.
<br>avoiding buffer overruns and detecting starvation or inactivity.
]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/fsharp/messages-and-agents.html</link><guid isPermaLink="false">Computer Science/Programming Language/FSharp/Messages and Agents.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:35 GMT</pubDate></item><item><title><![CDATA[Tips for working with Elmish]]></title><description><![CDATA[ 
 <br>his article is intended for people who are already familiar with the MVU architecture. You can learn more about it on the <a data-tooltip-position="top" aria-label="https://elmish.github.io/elmish/" rel="noopener" class="external-link" href="https://elmish.github.io/elmish/" target="_blank"><em></em></a>Elmish website.<br>
æœ¬æ–‡é¢å‘å·²ç»ç†Ÿæ‚‰ MVU æ¶æ„çš„äººå‘˜ã€‚æ‚¨å¯ä»¥åœ¨ Elmish ç½‘ç«™ä¸Šäº†è§£æ›´å¤šç›¸å…³ä¿¡æ¯ã€‚<br>I am one of the maintainer of Elmish and I created several <a data-tooltip-position="top" aria-label="http://fable.io" rel="noopener" class="external-link" href="http://fable.io" target="_blank">Fable</a> / Elmish libraries and applications. When doing so, I needed to understand Elmish deeply and I want to take the opportunity of <a data-tooltip-position="top" aria-label="https://sergeytihon.com/2018/10/22/f-advent-calendar-in-english-2018/" rel="noopener" class="external-link" href="https://sergeytihon.com/2018/10/22/f-advent-calendar-in-english-2018/" target="_blank"><em></em></a>F# Advent Calendar to share with you my tips and knowledge.<br>
æˆ‘æ˜¯ Elmish çš„ç»´æŠ¤è€…ä¹‹ä¸€ï¼Œæˆ‘åˆ›å»ºäº†å‡ ä¸ª Fable / Elmish åº“å’Œåº”ç”¨ç¨‹åºã€‚è¿™æ ·åšæ—¶ï¼Œæˆ‘éœ€è¦æ·±å…¥äº†è§£ Elmishï¼Œæˆ‘æƒ³åˆ©ç”¨ F# Advent Calendar çš„æœºä¼šä¸å¤§å®¶åˆ†äº«æˆ‘çš„æŠ€å·§å’ŒçŸ¥è¯†ã€‚<br>I will be covering a lot in this article, so grab yourself a cup of tea ğŸµ, take a deep breath ğŸ’¨ and letâ€™s get started ğŸ.<br>
æˆ‘å°†åœ¨è¿™ç¯‡æ–‡ç« ä¸­ä»‹ç»å¾ˆå¤šå†…å®¹ï¼Œæ‰€ä»¥ç»™è‡ªå·±å–æ¯èŒ¶ğŸµï¼Œæ·±å‘¼å¸ğŸ’¨ï¼Œè®©æˆ‘ä»¬å¼€å§‹å§ğŸã€‚<br><br>A command is a container for a function that Elmish executes immediately but, may schedule dispatch of message at any time.<br>
å‘½ä»¤æ˜¯ Elmish ç«‹å³æ‰§è¡Œçš„å‡½æ•°çš„å®¹å™¨ï¼Œä½†å¯ä»¥éšæ—¶å®‰æ’æ¶ˆæ¯çš„å‘é€ã€‚<br>For example:&nbsp;ä¾‹å¦‚ï¼š<br>
<br>Issue immediately a new Message<br>
ç«‹å³å‘å‡ºæ–°æ¶ˆæ¯
<br>Make an HTTP call and then return the result in your application via a Message<br>
è¿›è¡Œ HTTP è°ƒç”¨ï¼Œç„¶åé€šè¿‡æ¶ˆæ¯å°†ç»“æœè¿”å›åˆ°æ‚¨çš„åº”ç”¨ç¨‹åºä¸­
<br>Save data in your storage<br>
å°†æ•°æ®ä¿å­˜åœ¨æ‚¨çš„å­˜å‚¨ä¸­
<br><br>In this section, I will cover all the default functions offered by Elmish and show an example of it.<br>
åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘å°†ä»‹ç» Elmish æä¾›çš„æ‰€æœ‰é»˜è®¤å‡½æ•°å¹¶å±•ç¤ºå®ƒçš„ç¤ºä¾‹ã€‚<br>Use Cmd.none to schedule no Commands.<br>
ä½¿ç”¨ Cmd.none ä¸å®‰æ’ä»»ä½•å‘½ä»¤ã€‚<br>type Model =
    { Tick : int }
    
type Msg =
    | Tick
    
let private update msg model =
    match msg with
    | Tick -&gt;
        { model with Tick = model.Tick + 1 }, Cmd.none
Copy<br>Use Cmd.ofMsg to schedules another message directly, it can be seen as a way to chain messages.<br>
ä½¿ç”¨ Cmd.ofMsg ç›´æ¥è°ƒåº¦å¦ä¸€æ¡æ¶ˆæ¯ï¼Œå¯ä»¥çœ‹ä½œæ˜¯ä¸€ç§é“¾æ¥æ¶ˆæ¯çš„æ–¹å¼ã€‚<br>type Model =
    { Value : string }

type Msg =
    | ChangeValue of string
    | ValidateData
    
let private update msg model =
    match msg with
    | ChangeValue newValue -&gt;
        { model with Value = newValue }, Cmd.ofMsg ValidateData
Copy<br>UseCmd.ofAsync to evaluate an async block and map the result into success or error (of exception).<br>
ä½¿ç”¨ Cmd.ofAsync è¯„ä¼° async å—å¹¶å°†ç»“æœæ˜ å°„ä¸ºæˆåŠŸæˆ–é”™è¯¯ï¼ˆå¼‚å¸¸ï¼‰ã€‚<br>type Model =
    { InputValue : string
      UpperValue : string }
      
type Msg =
    | ToUpper of string
    | OnUpperResult of string
    | OnUpperError of exn

let private update (msg : Msg) (model : Model) =
    match msg with
    | ToUpper txt -&gt;
        let asyncUpper (txt : string) =
            async {
                do! Async.Sleep 1000

                return txt.ToUpper()
            }

        model, Cmd.ofAsync asyncUpper txt OnUpperResult OnUpperError

    | OnUpperResult result -&gt;
        { model with UpperValue = result }, Cmd.none

    | OnUpperError error -&gt;
        Browser.console.error error
        model, Cmd.none
Copy<br>Use Cmd.ofFunc to evaluate a simple function and map the result into success or error (of exception).<br>
ä½¿ç”¨ Cmd.ofFunc è¯„ä¼°ä¸€ä¸ªç®€å•çš„å‡½æ•°å¹¶å°†ç»“æœæ˜ å°„ä¸ºæˆåŠŸæˆ–é”™è¯¯ï¼ˆå¼‚å¸¸ï¼‰ã€‚<br>type Model =
    { CurrentRoute : Route
      Value : string
      Tick : int
      UpperValue : string }

type Msg =
    | Save of string
    | OnSaveSuccess of bool
    | OnSaveError of exn
    
let private update (msg : Msg) (model : Model) =
    match msg with
    | Save txt -&gt;
        let save (txt : string) =         
            // If there is an error, an exception will be thrown and captured by Cmd.ofFunc
            Browser.localStorage.setItem("my-app.input", txt)
            true

        model, Cmd.ofFunc save txt OnSaveSuccess OnSaveError

    | OnSaveSuccess result -&gt;
        // Here we can notify the user that the save succeeded
        model, Cmd.none

    | OnSaveError error -&gt;
        // Here we can notifu the user that the save failed
        Browser.console.error error
        model, Cmd.none
Copy<br>UseCmd.performFunc to evaluate a simple function and map the success to a message discarding any possible error.<br>
ä½¿ç”¨ Cmd.performFunc è¯„ä¼°ä¸€ä¸ªç®€å•çš„å‡½æ•°ï¼Œå¹¶å°†æˆåŠŸæ˜ å°„åˆ°ä¸€æ¡æ¶ˆæ¯ï¼Œä¸¢å¼ƒä»»ä½•å¯èƒ½çš„é”™è¯¯ã€‚<br>type Model =
    { IsLoading : bool
      Value : string }

type Msg =
    | Load
    | OnLoadSuccess of bool
    
let private update (msg : Msg) (model : Model) =
    match msg with
    | Load -&gt;
        // This function can never fail so we can use Cmd.performFunc
        let load () =
            let storedValue : string = Browser.localStorage.getItem("my-app.input") :?&gt; string
            if isNull storedValue then
                ""
            else
                storedValue

        { model with IsLoading = true }, Cmd.performFunc load () OnLoadSuccess

    | OnLoadSuccess value -&gt;
        { model with IsLoading = false
                     Value = value }, Cmd.none
Copy<br>UseCmd.attemptFunc to evaluate a simple function and map the error (in case of exception)<br>
ä½¿ç”¨ Cmd.attemptFunc è®¡ç®—ä¸€ä¸ªç®€å•çš„å‡½æ•°å¹¶æ˜ å°„é”™è¯¯ï¼ˆå¦‚æœå‡ºç°å¼‚å¸¸ï¼‰<br>type Model =
    { Value : string }

type Msg =
    | ChangeValue of string
    | OnLogError of exn
    
let private update (msg : Msg) (model : Model) =
    match msg with
    | ChangeValue newValue -&gt;
        let log (msg : string) =
            // Send a msg to your logger
            // If there is an error it will throw
            Log.send msg

        let msg = sprintf "Value changed from %s to %s" model.Value newValue        

        { model with Value = newValue }, Cmd.attemptFunc log msg OnLogError

    | OnLogError value -&gt;
        // There was an error during logging, should we do something ?
        model, Cmd.none
Copy<br>Use Cmd.ofPromise to call promise block and map the results.<br>
ä½¿ç”¨ Cmd.ofPromise è°ƒç”¨ promise å—å¹¶æ˜ å°„ç»“æœã€‚<br>type Model =
    { Value : int }

type Msg =
    | Submit
    | OnPromiseSuccess of int
    | OnPromiseError of exn
    
let private update (msg : Msg) (model : Model) =
    match msg with
    | Submit -&gt;
        let myPromise () =
            promise {
                do! Promise.sleep 1000
                return 10
            }

        model, Cmd.ofPromise myPromise () OnPromiseSuccess OnPromiseError

    | OnPromiseSuccess value -&gt;
        { model with Value = value }, Cmd.none

    | OnPromiseError error -&gt;
        Browser.console.error error
        model, Cmd.none
Copy<br>Use Cmd.ofSub to call the subscriber. This is useful when you are dealing with an API which use callbacks or to listen to an event.<br>
ä½¿ç”¨ Cmd.ofSub å‘¼å«è®¢é˜…è€…ã€‚å½“æ‚¨å¤„ç†ä½¿ç”¨å›è°ƒæˆ–ä¾¦å¬äº‹ä»¶çš„ API æ—¶ï¼Œè¿™éå¸¸æœ‰ç”¨ã€‚<br>type Model =
    { Position : Browser.Position option
      ErrorMessage : string }

type Msg =
    | GetPosition
    | GetPositionSuccess of Browser.Position
    | GetPositionError of Browser.PositionError

module Sub =
    // Subscriber used to reach gealocation API
    let getPosition onSuccess onError dispatch =
        Browser.navigator.geolocation.getCurrentPosition(
          onSuccess &gt;&gt; dispatch,
          onError &gt;&gt; dispatch
        )

let update (msg:Msg) (model:Model) =
    match msg with
    | GetPosition -&gt;
        model, Cmd.ofSub (Sub.getPosition GetPositionSuccess GetPositionError)
    
    | GetPositionSuccess posision -&gt;
        { model with Position = Some position
                     ErrorMessage = "" }, Cmd.none
    
    | GetPositionError error -&gt;
        { model with Position = None
                     ErrorMessage = error.message }, Cmd.none
Copy<br>Use Cmd.batch to aggregate multiple commands. You can aggregate any of the previous commands together.<br>
ä½¿ç”¨ Cmd.batch èšåˆå¤šä¸ªå‘½ä»¤ã€‚æ‚¨å¯ä»¥å°†å‰é¢çš„ä»»ä½•å‘½ä»¤èšåˆåœ¨ä¸€èµ·ã€‚<br>type Model =
    { Data1 : int
      Data2 : int }

type Msg =
    | FetchDatas
    | OnFetchData1 of int
    | OnFetchData2 of int
    | OnPromiseError of exn
    | OnLogError of exn
    
let private update (msg : Msg) (model : Model) =
    match msg with
    | FetchDatas -&gt;
        model, Cmd.batch [ Cmd.ofPromise fetchData1 () OnFetchData1 OnPromiseError 
                           Cmd.ofPromise fetchData2 () OnFetchData2 OnPromiseError 
                           Cmd.performFunc log "FetchDatas message has been treated" OnLogError ]

    | OnFetchData1 data1 -&gt;
        { model with Data1 = data1 }, Cmd.performFunc log "FetchData1 data has been received" OnLogError

    | OnFetchData2 data2 -&gt;
        { model with Data2 = data2 }, Cmd.performFunc log "FetchData2 data has been received" OnLogError

    | OnPromiseError error -&gt;
        Browser.console.error("An error occured when fetching data", error)
        model, Cmd.none

    | OnLogError error -&gt;
        Browser.console.error("An error occured when logging", error)
        model, Cmd.none
Copy<br>The functions provided out of the box by Elmish are enough to cover most of the needs of your application. However, when working on a library or with a specific API you could want to create your own commands. We will take a look at it later.<br>
Elmish æä¾›çš„å¼€ç®±å³ç”¨çš„åŠŸèƒ½è¶³ä»¥æ»¡è¶³æ‚¨åº”ç”¨ç¨‹åºçš„å¤§éƒ¨åˆ†éœ€æ±‚ã€‚ä½†æ˜¯ï¼Œå½“ä½¿ç”¨åº“æˆ–ç‰¹å®š API æ—¶ï¼Œæ‚¨å¯èƒ½æƒ³è¦åˆ›å»ºè‡ªå·±çš„å‘½ä»¤ã€‚æˆ‘ä»¬ç¨åä¼šçœ‹ä¸€ä¸‹ã€‚<br><br>æ ¹æ®æ‚¨çš„éœ€æ±‚å¯¹æ¨¡å‹è¿›è¡Œå»ºæ¨¡<br>When working with a Single Page Application, you will have to deal with navigation and need to reflect it in your models.<br>
ä½¿ç”¨å•é¡µåº”ç”¨ç¨‹åºæ—¶ï¼Œæ‚¨å°†å¿…é¡»å¤„ç†å¯¼èˆªå¹¶éœ€è¦å°†å…¶åæ˜ åœ¨æ¨¡å‹ä¸­ã€‚<br>In general, when I am working with at a page level, I use Discrimination Union so I can store only the active page state.<br>
ä¸€èˆ¬æ¥è¯´ï¼Œå½“æˆ‘åœ¨é¡µé¢çº§åˆ«å·¥ä½œæ—¶ï¼Œæˆ‘ä½¿ç”¨æ­§è§†è”ç›Ÿï¼Œè¿™æ ·æˆ‘å°±å¯ä»¥åªå­˜å‚¨æ´»åŠ¨é¡µé¢çŠ¶æ€ã€‚<br>
For example, if in your application you have a login page you canâ€™t store your authenticated page state in your application because you canâ€™t fetch the resource to display it.<br>
ä¾‹å¦‚ï¼Œå¦‚æœæ‚¨çš„åº”ç”¨ç¨‹åºä¸­æœ‰ä¸€ä¸ªç™»å½•é¡µé¢ï¼Œæ‚¨æ— æ³•åœ¨åº”ç”¨ç¨‹åºä¸­å­˜å‚¨ç»è¿‡èº«ä»½éªŒè¯çš„é¡µé¢çŠ¶æ€ï¼Œå› ä¸ºæ‚¨æ— æ³•è·å–èµ„æºæ¥æ˜¾ç¤ºå®ƒã€‚<br>In general my main Model looks like this:<br>
ä¸€èˆ¬æ¥è¯´ï¼Œæˆ‘çš„ä¸»è¦ Model çœ‹èµ·æ¥åƒè¿™æ ·ï¼š<br>
[&lt;RequireQualifiedAccess&gt;]
type AuthPage =
    // Section for the website related to Messages management
    // For example
    // - Display the list of Messages
    // - Create a message
    | Messages of Messages.Model
    // Administration section of the website
    | Administration of Administration.Model

[&lt;RequireQualifiedAccess&gt;]
type Page =
    // The application is loading, display a loader
    | Loading
    // Login page
    | Login of Login.Model
    // From here, the user need to be authenticated
    | AuthPage of AuthPage
    // Global error page like:
    // - Generic error
    // - You need to be connected
    | Errored of Errored.Reason
    // A page that can be accessed when the user is not logged in
    // For example, to reset it's password from an URL
    | ResetAccount of ResetAccount.Model

type Model =
    { // Store the user session information
      // If Some xxx, then the user is signed-in
      // If None, the user isn't connected
      Session : User option
      // Store the active page state
      ActivePage : Page
      // Store the current route information, this is useful if your
      // route have parameters than you need to pass to child later
      CurrentRoute : Router.Route option }```

Using DUs to represent your pages state helps you isolate your logics. For me, the biggest benefit compared to storing all page states in a big record, is that you are not caching your page when navigating.  
ä½¿ç”¨ DU è¡¨ç¤ºé¡µé¢çŠ¶æ€å¯ä»¥å¸®åŠ©æ‚¨éš”ç¦»é€»è¾‘ã€‚å¯¹æˆ‘æ¥è¯´ï¼Œä¸å°†æ‰€æœ‰é¡µé¢çŠ¶æ€å­˜å‚¨åœ¨å¤§è®°å½•ä¸­ç›¸æ¯”ï¼Œæœ€å¤§çš„å¥½å¤„æ˜¯æ‚¨åœ¨å¯¼èˆªæ—¶ä¸ä¼šç¼“å­˜é¡µé¢ã€‚

Of course sometimes your application needs to maintain state between navigation. For example, if you have a form in several steps you could modelize it like this:  
å½“ç„¶ï¼Œæœ‰æ—¶æ‚¨çš„åº”ç”¨ç¨‹åºéœ€è¦åœ¨å¯¼èˆªä¹‹é—´ç»´æŠ¤çŠ¶æ€ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæ‚¨æœ‰ä¸€ä¸ªåˆ†å‡ ä¸ªæ­¥éª¤çš„è¡¨å•ï¼Œæ‚¨å¯ä»¥åƒè¿™æ ·å¯¹å…¶è¿›è¡Œå»ºæ¨¡ï¼š
```F#
type Rank =
    | One
    | Two

type Step1 =
    { Login : string
      Password : string }

type Step2 =
    { Age : int 
      Surname : string 
      Firstname : string }

type Model =
    { CurrentRank : Rank
      Step1 : Step1
      Step2 : Step2 }

let private view (model : Model) (dispatch : Msg -&gt; unit) =
    match model.CurrentRank with
    | Rank.One -&gt; // render step nÂ°1 form
    | Rank.Two -&gt; // render step nÂ°2 form
Copy<br><br>One thing we tend to forget when working with Elmish is that everything is a function. The main reason for this forgetfulness is that most of the examples only show you this code:<br>
ä½¿ç”¨ Elmish æ—¶æˆ‘ä»¬å®¹æ˜“å¿˜è®°çš„ä¸€ä»¶äº‹æ˜¯ä¸€åˆ‡éƒ½æ˜¯å‡½æ•°ã€‚é€ æˆè¿™ç§é—å¿˜çš„ä¸»è¦åŸå› æ˜¯å¤§å¤šæ•°ç¤ºä¾‹ä»…å‘æ‚¨å±•ç¤ºä»¥ä¸‹ä»£ç ï¼š<br>type Model =
    { Value : int }

type Msg =
    | SomeAction

let init =
    { Value = 0 }, Cmd.none

let update (msg : Msg) (model : Model) : Model * Cmd&lt;Msg&gt; =
    match msg with
    | SomeAction -&gt;
        model, Cmd.none

let view (model : Model) (dispatch : Msg -&gt; unit) : React.ReactElement =
    div [ ]
        [ str "This is my view" ]
Copy<br>So in our mind update takes two arguments when in fact we should think update takes at least two arguments. The same applies to view and init functions.<br>
å› æ­¤ï¼Œåœ¨æˆ‘ä»¬çœ‹æ¥ update éœ€è¦ä¸¤ä¸ªå‚æ•°ï¼Œè€Œå®é™…ä¸Šæˆ‘ä»¬åº”è¯¥è®¤ä¸º update è‡³å°‘éœ€è¦ä¸¤ä¸ªå‚æ•°ã€‚è¿™åŒæ ·é€‚ç”¨äº view å’Œ init å‡½æ•°ã€‚<br>This idea is linked to the fact that a componentâ€™s Model should have all the information needed by the component, but this is not always true.<br>
è¿™ä¸ªæƒ³æ³•ä¸ç»„ä»¶çš„ Model åº”è¯¥æ‹¥æœ‰ç»„ä»¶æ‰€éœ€çš„æ‰€æœ‰ä¿¡æ¯æœ‰å…³ï¼Œä½†è¿™å¹¶ä¸æ€»æ˜¯æ­£ç¡®çš„ã€‚<br><br>å°†æ•°æ®ä½œä¸ºå‚æ•°ä¼ é€’<br>For example, if you have a session in your application in order to make HTTP calls, should you store this session in each componentâ€™s Model ?<br>
ä¾‹å¦‚ï¼Œå¦‚æœæ‚¨çš„åº”ç”¨ç¨‹åºä¸­æœ‰ä¸€ä¸ªä¼šè¯ç”¨äºè¿›è¡Œ HTTP è°ƒç”¨ï¼Œæ‚¨æ˜¯å¦åº”è¯¥å°†æ­¤ä¼šè¯å­˜å‚¨åœ¨æ¯ä¸ªç»„ä»¶çš„ Model ä¸­ï¼Ÿ<br>
No, you should store it at one place and then pass your session to the functions that need it.<br>
ä¸ï¼Œæ‚¨åº”è¯¥å°†å…¶å­˜å‚¨åœ¨ä¸€ä¸ªä½ç½®ï¼Œç„¶åå°†ä¼šè¯ä¼ é€’ç»™éœ€è¦å®ƒçš„å‡½æ•°ã€‚<br>The next code illustrates this situation, we request a session argument in our init function because we need to make an authenticated http request using Http.Auth.* (custom module used, includes the session info in a request).<br>
ä¸‹ä¸€ä¸ªä»£ç è¯´æ˜äº†è¿™ç§æƒ…å†µï¼Œæˆ‘ä»¬åœ¨ init å‡½æ•°ä¸­è¯·æ±‚ session å‚æ•°ï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦ä½¿ç”¨ Http.Auth.* å‘å‡ºç»è¿‡èº«ä»½éªŒè¯çš„ http è¯·æ±‚ï¼ˆä½¿ç”¨çš„è‡ªå®šä¹‰æ¨¡å—ï¼ŒåŒ…æ‹¬ä¼šè¯ä¿¡æ¯è¦æ±‚ï¼‰ã€‚<br>open Elmish
open Fable.Import
open Fable.PowerPack

type Session = 
    { Token : string
      UserId : int }

type Model =
    | Loading
    | Loaded of string
    | Errored

type Msg =
    | OnFetchDataSuccess of string
    | OnFetchDataError of exn

let private fetchData (session : Session) : JS.Promise&lt;string&gt; =
    promise {
        let! res = Http.Auth.postRecord "/api/get-data" session
        return! res.text()
    }

let init (session : Session) =
    Loading, Cmd.ofPromise (fetchData session) OnFetchDataSuccess OnFetchDataError

let private update (msg : Msg) (model : Model) =
    match msg with
    | OnFetchDataSuccess value -&gt;
        Loaded value, Cmd.none

    | OnFetchDataError error -&gt;
        Browser.console.error error
        Errored, Cmd.none
Copy<br><br>å°†è®°å½•ä½œä¸ºå‚æ•°ä¼ é€’<br>If your view function takes several arguments you can use a record as an argument. It will force you to name the arguments and by doing so make your code easier to read and maintain over time.<br>
å¦‚æœæ‚¨çš„è§†å›¾å‡½æ•°é‡‡ç”¨å¤šä¸ªå‚æ•°ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨è®°å½•ä½œä¸ºå‚æ•°ã€‚å®ƒå°†è¿«ä½¿æ‚¨å‘½åå‚æ•°ï¼Œå¹¶é€šè¿‡è¿™æ ·åšä½¿æ‚¨çš„ä»£ç éšç€æ—¶é—´çš„æ¨ç§»æ›´æ˜“äºé˜…è¯»å’Œç»´æŠ¤ã€‚<br>type private SectionProps =
    { Icon : Fa.IconOption
      Count : int
      Label : string
      IsActive : bool
      ZoneColor : string }
  
let private renderSection (props : SectionProps) =
    // Render the view
    
let view (model : Model) =
    renderSection 
        { Icon = Fa.Solid.Cog
          Count = model.ZoneA.Value + model.ZoneB.Value
          Label = model.Zone.Name
          IsActive = model.IsActive
          ZoneColor = findColor model.Zone.ColorIndex }
Copy<br>It will also make it easier to optimize your code for react using memoBuilder.<br>
å®ƒè¿˜å°†ä½¿ä½¿ç”¨ memoBuilder æ›´è½»æ¾åœ°ä¼˜åŒ–ä»£ç ä»¥è¿›è¡Œååº”<br>type private SectionProps =
    { Icon : Fa.IconOption
      Count : int
      Label : string
      IsActive : bool
      ZoneColor : string }
  
let private renderSection = 
    memoBuilder "Section" (fun (props : SectionProps) -&gt;
        // Render the view
    )
        
let view (model : Model) =
    renderSection 
        { Icon = Fa.Solid.Cog
          Count = model.ZoneA.Value + model.ZoneB.Value
          Label = model.Zone.Name
          IsActive = model.IsActive
          ZoneColor = findColor model.Zone.ColorIndex }
Copy<br><br>ä½¿ç”¨è¾…åŠ©å‡½æ•°æ¥å¤„ç†æ‚¨çš„åŸŸ<br>For example, when an elmish component needs to fetch data from the server often, I like to show a loading animation. Here is how I handle it:<br>
ä¾‹å¦‚ï¼Œå½“ä¸€ä¸ªç²¾çµç»„ä»¶éœ€è¦ç»å¸¸ä»æœåŠ¡å™¨è·å–æ•°æ®æ—¶ï¼Œæˆ‘å–œæ¬¢æ˜¾ç¤ºåŠ è½½åŠ¨ç”»ã€‚æˆ‘æ˜¯è¿™æ ·å¤„ç†çš„ï¼š]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/fsharp/tips-for-working-with-elmish.html</link><guid isPermaLink="false">Computer Science/Programming Language/FSharp/Tips for working with Elmish.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:33 GMT</pubDate></item><item><title><![CDATA[UI programming with Elmish in FSharp]]></title><description><![CDATA[ 
 <br><br>The "Model View Update" (MVU) architecture was made famous by the front-end programming language <a data-tooltip-position="top" aria-label="http://elm-lang.org/" rel="noopener" class="external-link" href="http://elm-lang.org/" target="_blank">Elm</a> and can be found in many popular environments like <a data-tooltip-position="top" aria-label="http://redux.js.org/" rel="noopener" class="external-link" href="http://redux.js.org/" target="_blank">Redux</a>. Today it's probably the most famous UI pattern in functional programming. The reason for this is that it clearly separates state changes from UI controls and provides a nice and easily testable way to create modular UIs. Especially for developers that are already familiar with concepts like CQRS or event sourcing many of the things in the MVU architecture will feel natural. Here's what the MVU pattern looks like:<br>
â€œæ¨¡å‹è§†å›¾æ›´æ–°â€ï¼ˆMVUï¼‰æ¶æ„å› å‰ç«¯ç¼–ç¨‹è¯­è¨€ Elm è€Œé—»åï¼Œå¹¶ä¸”å¯ä»¥åœ¨ Redux ç­‰è®¸å¤šæµè¡Œç¯å¢ƒä¸­æ‰¾åˆ°ã€‚å¦‚ä»Šï¼Œå®ƒå¯èƒ½æ˜¯å‡½æ•°å¼ç¼–ç¨‹ä¸­æœ€è‘—åçš„ UI æ¨¡å¼ã€‚åŸå› æ˜¯å®ƒæ¸…æ¥šåœ°å°†çŠ¶æ€æ›´æ”¹ä¸ UI æ§ä»¶åˆ†å¼€ï¼Œå¹¶æä¾›äº†ä¸€ç§å¾ˆå¥½ä¸”æ˜“äºæµ‹è¯•çš„æ–¹æ³•æ¥åˆ›å»ºæ¨¡å—åŒ– UIã€‚ç‰¹åˆ«æ˜¯å¯¹äºå·²ç»ç†Ÿæ‚‰ CQRS æˆ–äº‹ä»¶æºç­‰æ¦‚å¿µçš„å¼€å‘äººå‘˜æ¥è¯´ï¼ŒMVU æ¶æ„ä¸­çš„è®¸å¤šå†…å®¹éƒ½ä¼šæ„Ÿè§‰å¾ˆè‡ªç„¶ã€‚ MVU æ¨¡å¼å¦‚ä¸‹æ‰€ç¤ºï¼š<br><img src="https://www.compositional-it.com/wp-content/uploads/2019/09/elmish-1.png" referrerpolicy="no-referrer"><br>Elmish for F# is a project that provides the capability for client-side apps written in F# to follow the MVU architecture. It comes in multiple flavors, so that you can choose between a <a data-tooltip-position="top" aria-label="https://fable-elmish.github.io/react/" rel="noopener" class="external-link" href="https://fable-elmish.github.io/react/" target="_blank">React renderer</a> for HTML, <a data-tooltip-position="top" aria-label="https://fable-elmish.github.io/react/react-native.html" rel="noopener" class="external-link" href="https://fable-elmish.github.io/react/react-native.html" target="_blank">React Native renderer</a> for mobile apps and a <a data-tooltip-position="top" aria-label="https://github.com/Prolucid/Elmish.WPF" rel="noopener" class="external-link" href="https://github.com/Prolucid/Elmish.WPF" target="_blank">WPF renderer</a> for desktop applications. In this article we will explore its power and modularity by working through a simple example.<br>
Elmish for F# æ˜¯ä¸€ä¸ªä¸ºç”¨ F# ç¼–å†™çš„å®¢æˆ·ç«¯åº”ç”¨ç¨‹åºæä¾›éµå¾ª MVU æ¶æ„çš„åŠŸèƒ½çš„é¡¹ç›®ã€‚å®ƒæœ‰å¤šç§é£æ ¼ï¼Œå› æ­¤æ‚¨å¯ä»¥åœ¨ç”¨äº HTML çš„ React æ¸²æŸ“å™¨ã€ç”¨äºç§»åŠ¨åº”ç”¨ç¨‹åºçš„ React Native æ¸²æŸ“å™¨å’Œç”¨äºæ¡Œé¢åº”ç”¨ç¨‹åºçš„ WPF æ¸²æŸ“å™¨ä¹‹é—´è¿›è¡Œé€‰æ‹©ã€‚åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬å°†é€šè¿‡ä¸€ä¸ªç®€å•çš„ç¤ºä¾‹æ¥æ¢ç´¢å®ƒçš„å¼ºå¤§åŠŸèƒ½å’Œæ¨¡å—åŒ–æ€§ã€‚<br><br>Let's start to illustrate Elmish and the MVU architecture with the very common HTML button counter sample. The following code shows a counter implemented in HTML and JavaScript.<br>
è®©æˆ‘ä»¬å¼€å§‹ç”¨éå¸¸å¸¸è§çš„ HTML æŒ‰é’®è®¡æ•°å™¨ç¤ºä¾‹æ¥è¯´æ˜ Elmish å’Œ MVU æ¶æ„ã€‚ä»¥ä¸‹ä»£ç æ˜¾ç¤ºäº†ç”¨ HTML å’Œ JavaScript å®ç°çš„è®¡æ•°å™¨ã€‚<br>&lt;html&gt;
    &lt;body&gt;
    &lt;button onclick="--counter; update();"&gt;-&lt;/button&gt;
    &lt;div id="counter"&gt;&lt;/div&gt;
    &lt;button onclick="++counter; update();"&gt;+&lt;/button&gt;
    &lt;script&gt;
        var counter = 0;

        function update() { 
        document.getElementById("counter").textContent = "" + counter;
        }

        update();
    &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
Copy<br>The code is very straight forward and works as intended, but it has a number of issues:<br>
è¯¥ä»£ç éå¸¸ç®€å•å¹¶ä¸”æŒ‰é¢„æœŸå·¥ä½œï¼Œä½†å®ƒæœ‰è®¸å¤šé—®é¢˜ï¼š<br>
<br>We are mutating the global variable counter - almost always a dangerous thing to do<br>
æˆ‘ä»¬æ­£åœ¨æ”¹å˜å…¨å±€å˜é‡ counter - å‡ ä¹æ€»æ˜¯ä¸€ä»¶å±é™©çš„äº‹æƒ…
<br>We are directly mutating a DOM element, coupling our "business logic" to the UI.<br>
æˆ‘ä»¬ç›´æ¥æ”¹å˜ DOM å…ƒç´ ï¼Œå°†æˆ‘ä»¬çš„â€œä¸šåŠ¡é€»è¾‘â€è€¦åˆåˆ° UIã€‚
<br>We are referencing the DOM element with its name via a string, which is fragile and can lead to costly knock-on effects.<br>
æˆ‘ä»¬é€šè¿‡å­—ç¬¦ä¸²å¼•ç”¨ DOM å…ƒç´ åŠå…¶åç§°ï¼Œè¿™æ˜¯è„†å¼±çš„ï¼Œå¯èƒ½ä¼šå¯¼è‡´ä»£ä»·é«˜æ˜‚çš„è¿é”ååº”ã€‚
<br>We've embedded some "domain logic" directly in the onclick event<br>
æˆ‘ä»¬ç›´æ¥åœ¨ onclick äº‹ä»¶ä¸­åµŒå…¥äº†ä¸€äº›â€œé¢†åŸŸé€»è¾‘â€
<br>These issues prevent us from using this in a modular way. For example, if we wanted to create a list with counters, we could not reuse this code. Instead, we could copy &amp; paste the code a couple of times to create a fixed number of counters, but even then we would need to be very careful that we fix all the references to the corresponding global variables. In the object-oriented world, there are number of patterns that allow you encapsulate this problem of shared mutable state - let's see how to do it in a manner that promotes some FP core practices using the three parts of the MVU pattern:<br>
è¿™äº›é—®é¢˜é˜»æ­¢æˆ‘ä»¬ä»¥æ¨¡å—åŒ–çš„æ–¹å¼ä½¿ç”¨å®ƒã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬æƒ³åˆ›å»ºä¸€ä¸ªå¸¦æœ‰è®¡æ•°å™¨çš„åˆ—è¡¨ï¼Œæˆ‘ä»¬å°±ä¸èƒ½é‡ç”¨è¿™æ®µä»£ç ã€‚ç›¸åï¼Œæˆ‘ä»¬å¯ä»¥å¤åˆ¶å¹¶ç²˜è´´ä»£ç å‡ æ¬¡æ¥åˆ›å»ºå›ºå®šæ•°é‡çš„è®¡æ•°å™¨ï¼Œä½†å³ä½¿å¦‚æ­¤ï¼Œæˆ‘ä»¬ä¹Ÿéœ€è¦éå¸¸å°å¿ƒåœ°ä¿®å¤å¯¹ç›¸åº”å…¨å±€å˜é‡çš„æ‰€æœ‰å¼•ç”¨ã€‚åœ¨é¢å‘å¯¹è±¡çš„ä¸–ç•Œä¸­ï¼Œæœ‰è®¸å¤šæ¨¡å¼å…è®¸æ‚¨å°è£…å…±äº«å¯å˜çŠ¶æ€çš„é—®é¢˜ - è®©æˆ‘ä»¬çœ‹çœ‹å¦‚ä½•ä½¿ç”¨ MVU æ¨¡å¼çš„ä¸‰ä¸ªéƒ¨åˆ†æ¥ä¿ƒè¿›ä¸€äº› FP æ ¸å¿ƒå®è·µï¼š<br><br>Let's start with the Model.<br>
è®©æˆ‘ä»¬ä»æ¨¡å‹å¼€å§‹ã€‚<br>type Model = int

type Msg =
| Increment
| Decrement

let init() : Model = 0
Copy<br>In this F# code we capture the current value of the counter in a domain type , before creating a message type which can signal that we want to increment or decrement the counter. We also implement an init function that allows us to create the initial model for our application.<br>
åœ¨æ­¤ F# ä»£ç ä¸­ï¼Œæˆ‘ä»¬åœ¨åˆ›å»ºæ¶ˆæ¯ç±»å‹ä¹‹å‰æ•è·åŸŸç±»å‹ä¸­è®¡æ•°å™¨çš„å½“å‰å€¼ï¼Œè¯¥æ¶ˆæ¯ç±»å‹å¯ä»¥è¡¨æ˜æˆ‘ä»¬æƒ³è¦é€’å¢æˆ–é€’å‡è®¡æ•°å™¨ã€‚æˆ‘ä»¬è¿˜å®ç°äº†ä¸€ä¸ª init å‡½æ•°ï¼Œå®ƒå…è®¸æˆ‘ä»¬ä¸ºåº”ç”¨ç¨‹åºåˆ›å»ºåˆå§‹æ¨¡å‹ã€‚<br><br>The View part deals with the question of displaying controls on the screen. This is where we need to decide on a UI framework; in our case we've decided to stick with HTML, and so we will use the React renderer.<br>
View éƒ¨åˆ†å¤„ç†åœ¨å±å¹•ä¸Šæ˜¾ç¤ºæ§ä»¶çš„é—®é¢˜ã€‚è¿™æ˜¯æˆ‘ä»¬éœ€è¦å†³å®š UI æ¡†æ¶çš„åœ°æ–¹ï¼›åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å†³å®šåšæŒä½¿ç”¨ HTMLï¼Œå› æ­¤æˆ‘ä»¬å°†ä½¿ç”¨ React æ¸²æŸ“å™¨ã€‚<br>let view model dispatch =
    div []
        [ button [ OnClick (fun _ -&gt; dispatch Decrement) ] [ "-" ]
          div [] [ model.ToString() ]
          button [ OnClick (fun _ -&gt; dispatch Increment) ] [ "+" ] ]
Copy<br>This is valid F# code that uses the excellent <a data-tooltip-position="top" aria-label="https://github.com/fable-compiler/fable-react" rel="noopener" class="external-link" href="https://github.com/fable-compiler/fable-react" target="_blank">Fable.React bindings</a> to convert from F# into React JS. The syntax is still similar to our HTML version from the beginning, but instead of &lt; and &gt;, we are using [ and ]. This syntax is easy to learn and IDE tools like <a data-tooltip-position="top" aria-label="http://ionide.io/" rel="noopener" class="external-link" href="http://ionide.io/" target="_blank">Ionide</a> provide code completion for it, so it's a natural fit for existing F# developers. An important observation is that we are no longer mutating state from within the OnClick handlers; instead we simply dispatch one of the earlier defined messages into the system. This decouples our model from the view.<br>
è¿™æ˜¯æœ‰æ•ˆçš„ F# ä»£ç ï¼Œå®ƒä½¿ç”¨å‡ºè‰²çš„ Fable.React ç»‘å®šä» F# è½¬æ¢ä¸º React JSã€‚è¯­æ³•ä»ä¸€å¼€å§‹ä»ç„¶ä¸æˆ‘ä»¬çš„ HTML ç‰ˆæœ¬ç±»ä¼¼ï¼Œä½†æˆ‘ä»¬ä½¿ç”¨ [ å’Œ ] ä»£æ›¿ &lt; å’Œ &gt; ã€‚ ã€‚è¿™ç§è¯­æ³•å¾ˆå®¹æ˜“å­¦ä¹ ï¼Œå¹¶ä¸” Ionide ç­‰ IDE å·¥å…·ä¸ºå…¶æä¾›äº†ä»£ç è¡¥å…¨ï¼Œå› æ­¤å®ƒéå¸¸é€‚åˆç°æœ‰çš„ F# å¼€å‘äººå‘˜ã€‚ä¸€ä¸ªé‡è¦çš„è§‚å¯Ÿç»“æœæ˜¯ï¼Œæˆ‘ä»¬ä¸å†ä» OnClick å¤„ç†ç¨‹åºå†…éƒ¨æ”¹å˜çŠ¶æ€ï¼›ç›¸åï¼Œæˆ‘ä»¬åªæ˜¯å°†å…ˆå‰å®šä¹‰çš„æ¶ˆæ¯ä¹‹ä¸€å‘é€åˆ°ç³»ç»Ÿä¸­ã€‚è¿™å°†æˆ‘ä»¬çš„æ¨¡å‹ä¸è§†å›¾åˆ†ç¦»ã€‚<br><br>In the Update part, we define a state machine that represents our domain logic (or at least hooks into it).<br>
åœ¨æ›´æ–°éƒ¨åˆ†ï¼Œæˆ‘ä»¬å®šä¹‰ä¸€ä¸ªçŠ¶æ€æœºæ¥è¡¨ç¤ºæˆ‘ä»¬çš„åŸŸé€»è¾‘ï¼ˆæˆ–è‡³å°‘æŒ‚é’©å®ƒï¼‰ã€‚<br>let update (msg:Msg) (model:Model) : Model =
    match msg with
    | Increment -&gt; model + 1
    | Decrement -&gt; model - 1
Copy<br>Here, we have defined an update function that will be called by Elmish whenever a message is received. In this very basic scenario there are only two cases to handle, and we can't really see the power of F#'s pattern matching yet. The most interesting observation is that we don't rely on any mutable state. Instead the update function takes a message and the current model, and returns a completely new version of the model. Since all the data is simply inside the model, this is very well testable - we can easily write a set of unit tests around the update function.<br>
åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ª update å‡½æ•°ï¼Œæ¯å½“æ”¶åˆ°æ¶ˆæ¯æ—¶ Elmish éƒ½ä¼šè°ƒç”¨è¯¥å‡½æ•°ã€‚åœ¨è¿™ä¸ªéå¸¸åŸºæœ¬çš„åœºæ™¯ä¸­ï¼Œåªæœ‰ä¸¤ç§æƒ…å†µéœ€è¦å¤„ç†ï¼Œè€Œä¸”æˆ‘ä»¬è¿˜ä¸èƒ½çœŸæ­£çœ‹åˆ° F# æ¨¡å¼åŒ¹é…çš„å¼ºå¤§åŠŸèƒ½ã€‚æœ€æœ‰è¶£çš„è§‚å¯Ÿæ˜¯æˆ‘ä»¬ä¸ä¾èµ–ä»»ä½•å¯å˜çŠ¶æ€ã€‚ç›¸åï¼Œæ›´æ–°å‡½æ•°æ¥å—æ¶ˆæ¯å’Œå½“å‰æ¨¡å‹ï¼Œå¹¶è¿”å›æ¨¡å‹çš„å…¨æ–°ç‰ˆæœ¬ã€‚ç”±äºæ‰€æœ‰æ•°æ®éƒ½ä½äºæ¨¡å‹å†…éƒ¨ï¼Œå› æ­¤éå¸¸å®¹æ˜“æµ‹è¯• - æˆ‘ä»¬å¯ä»¥è½»æ¾åœ°å›´ç»•æ›´æ–°å‡½æ•°ç¼–å†™ä¸€ç»„å•å…ƒæµ‹è¯•ã€‚<br><br>So far, we've not used any functionality from Elmish at all. The Model and Update parts are pure F# code, whilst the View part uses the <a data-tooltip-position="top" aria-label="https://github.com/fable-compiler/fable-react" rel="noopener" class="external-link" href="https://github.com/fable-compiler/fable-react" target="_blank">Fable.React</a> package. At this point all three parts are completely independent from each other - now Elmish will "wire" these up into an application:<br>
åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬è¿˜æ²¡æœ‰ä½¿ç”¨ Elmish çš„ä»»ä½•åŠŸèƒ½ã€‚æ¨¡å‹å’Œæ›´æ–°éƒ¨åˆ†æ˜¯çº¯ F# ä»£ç ï¼Œè€Œè§†å›¾éƒ¨åˆ†ä½¿ç”¨ Fable.React åŒ…ã€‚æ­¤æ—¶ï¼Œæ‰€æœ‰ä¸‰ä¸ªéƒ¨åˆ†å®Œå…¨ç›¸äº’ç‹¬ç«‹ - ç°åœ¨ Elmish å°†æŠŠå®ƒä»¬â€œè¿æ¥â€åˆ°ä¸€ä¸ªåº”ç”¨ç¨‹åºä¸­ï¼š<br>Program.mkSimple Counter.init Counter.update Counter.view
|&gt; Program.withConsoleTrace
|&gt; Program.withDebugger
|&gt; Program.withReact "counter-app"
|&gt; Program.run
Copy<br>Elmish's <a data-tooltip-position="top" aria-label="https://fable-elmish.github.io/elmish/program.html" rel="noopener" class="external-link" href="https://fable-elmish.github.io/elmish/program.html" target="_blank">Program</a> abstraction provides "glue" functions like mkSimple to bind the three parts together into an application. Internally, Elmish gives us a message loop and takes care of dispatching messages between the view and the update function. Since the complete state is captured in the model and every state change is explicit by processing a message, this opens a whole new world of debugging features like <a data-tooltip-position="top" aria-label="https://fable-elmish.github.io/debugger/" rel="noopener" class="external-link" href="https://fable-elmish.github.io/debugger/" target="_blank">time travelling</a>.<br>
Elmish çš„ç¨‹åºæŠ½è±¡æä¾›äº†â€œç²˜åˆâ€å‡½æ•°ï¼Œä¾‹å¦‚ mkSimple å°†è¿™ä¸‰ä¸ªéƒ¨åˆ†ç»‘å®šåˆ°ä¸€ä¸ªåº”ç”¨ç¨‹åºä¸­ã€‚åœ¨å†…éƒ¨ï¼ŒElmish ä¸ºæˆ‘ä»¬æä¾›äº†ä¸€ä¸ªæ¶ˆæ¯å¾ªç¯ï¼Œå¹¶è´Ÿè´£åœ¨è§†å›¾å’Œæ›´æ–°å‡½æ•°ä¹‹é—´è°ƒåº¦æ¶ˆæ¯ã€‚ç”±äºæ¨¡å‹ä¸­æ•è·äº†å®Œæ•´çš„çŠ¶æ€ï¼Œå¹¶ä¸”é€šè¿‡å¤„ç†æ¶ˆæ¯æ¥æ˜ç¡®æ¯ä¸ªçŠ¶æ€æ›´æ”¹ï¼Œå› æ­¤è¿™æ‰“å¼€äº†æ—¶é—´æ—…è¡Œç­‰è°ƒè¯•åŠŸèƒ½çš„å…¨æ–°ä¸–ç•Œã€‚<br><br>äº²å­ä½œæ–‡<br>In the last section we saw how to build a very basic sample app in the MVU architecture. For this minimal example it's not very clear what the benefit is compared to the original implementation that was using mutation. So, in the following example we'll use the counter as a module and create a list of counters.<br>
åœ¨ä¸Šä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬äº†è§£äº†å¦‚ä½•åœ¨ MVU æ¶æ„ä¸­æ„å»ºä¸€ä¸ªéå¸¸åŸºæœ¬çš„ç¤ºä¾‹åº”ç”¨ç¨‹åºã€‚å¯¹äºè¿™ä¸ªæœ€å°çš„ç¤ºä¾‹ï¼Œä¸ä½¿ç”¨çªå˜çš„åŸå§‹å®ç°ç›¸æ¯”ï¼Œå¹¶ä¸æ¸…æ¥šæœ‰ä»€ä¹ˆå¥½å¤„ã€‚å› æ­¤ï¼Œåœ¨ä¸‹é¢çš„ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨è®¡æ•°å™¨ä½œä¸ºæ¨¡å—å¹¶åˆ›å»ºè®¡æ•°å™¨åˆ—è¡¨ã€‚<br><br>As before let's start with the model:<br>
å’Œä¹‹å‰ä¸€æ ·ï¼Œè®©æˆ‘ä»¬â€‹â€‹ä»æ¨¡å‹å¼€å§‹ï¼š<br>module CounterList
type Model = Counter.Model list

type Msg = 
| Insert
| Remove
| Modify of int * Counter.Msg

let init() : Model =
    [ Counter.init() ]
Copy<br>In this case we have a list of counter models and a new message type. We can signal to:<br>
åœ¨æœ¬ä¾‹ä¸­ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªè®¡æ•°å™¨æ¨¡å‹åˆ—è¡¨å’Œä¸€ä¸ªæ–°æ¶ˆæ¯ç±»å‹ã€‚æˆ‘ä»¬å¯ä»¥å‘ä»¥ä¸‹äººå‘˜å‘å‡ºä¿¡å·ï¼š<br>
<br>Insert a new counter<br>
æ’å…¥æ–°è®¡æ•°å™¨
<br>Remove the latest counter<br>
åˆ é™¤æœ€æ–°çš„è®¡æ•°å™¨
<br>Dispatch a counter message to the corresponding counter in the list.<br>
å‘åˆ—è¡¨ä¸­ç›¸åº”çš„è®¡æ•°å™¨å‘é€è®¡æ•°å™¨æ¶ˆæ¯ã€‚
<br>When the application starts we will start with one counter as provided by the init function. As you can see, every part of the model refers to the corresponding part of the submodel. CounterList.Model is a collection of Counter.Model, the CounterList.Msg uses the Counter.Msg as payload and the CounterList.init function calls the Counter.init function.<br>
å½“åº”ç”¨ç¨‹åºå¯åŠ¨æ—¶ï¼Œæˆ‘ä»¬å°†ä» init å‡½æ•°æä¾›çš„ä¸€ä¸ªè®¡æ•°å™¨å¼€å§‹ã€‚æ­£å¦‚æ‚¨æ‰€çœ‹åˆ°çš„ï¼Œæ¨¡å‹çš„æ¯ä¸ªéƒ¨åˆ†éƒ½å¼•ç”¨å­æ¨¡å‹çš„ç›¸åº”éƒ¨åˆ†ã€‚ CounterList.Model æ˜¯ Counter.Model çš„é›†åˆï¼Œ CounterList.Msg ä½¿ç”¨ Counter.Msg ä½œä¸ºè´Ÿè½½ï¼Œ CounterList.init å‡½æ•°è°ƒç”¨ Counter.init å‡½æ•°ã€‚<br><br>Let's take a look at the View code:<br>
æˆ‘ä»¬çœ‹ä¸€ä¸‹ View ä»£ç ï¼š<br>let view model dispatch =
    let counters =
        model
        |&gt; List.mapi (fun pos counterModel -&gt; 
            Counter.view
                counterModel
                (fun msg -&gt; dispatch (Modify (pos, msg)))) 

    div [] [ 
        yield button [ OnClick (fun _ -&gt; dispatch Remove) ] [ "Remove" ]
        yield button [ OnClick (fun _ -&gt; dispatch Insert) ] [ "Add" ]
        yield! counters ]
Copy<br>It's not that much different to the view code of the counter itself, except now we render a list of counters and wrap the messages with position information. This code may look a bit unfamiliar at this point, but the F# compiler is helping us here. There is only one way to get it to compile - and that's the correct way! Once you've done this step a few times, it becomes second nature - just like any task that you become familiar with.<br>
å®ƒä¸è®¡æ•°å™¨æœ¬èº«çš„è§†å›¾ä»£ç æ²¡æœ‰å¤ªå¤§åŒºåˆ«ï¼Œåªæ˜¯ç°åœ¨æˆ‘ä»¬æ¸²æŸ“è®¡æ•°å™¨åˆ—è¡¨å¹¶ç”¨ä½ç½®ä¿¡æ¯åŒ…è£…æ¶ˆæ¯ã€‚è¿™æ®µä»£ç æ­¤æ—¶çœ‹èµ·æ¥å¯èƒ½æœ‰ç‚¹é™Œç”Ÿï¼Œä½† F# ç¼–è¯‘å™¨åœ¨è¿™é‡Œä¸ºæˆ‘ä»¬æä¾›äº†å¸®åŠ©ã€‚åªæœ‰ä¸€ç§æ–¹æ³•å¯ä»¥ç¼–è¯‘å®ƒ - è¿™å°±æ˜¯æ­£ç¡®çš„æ–¹æ³•ï¼ä¸€æ—¦æ‚¨å®Œæˆæ­¤æ­¥éª¤å‡ æ¬¡ï¼Œå®ƒå°±ä¼šæˆä¸ºç¬¬äºŒå¤©æ€§ - å°±åƒæ‚¨ç†Ÿæ‚‰çš„ä»»ä½•ä»»åŠ¡ä¸€æ ·ã€‚<br><br>As with the Model, we also see a nice symmetry in the Views. But what about the Update part?<br>
ä¸æ¨¡å‹ä¸€æ ·ï¼Œæˆ‘ä»¬åœ¨è§†å›¾ä¸­ä¹Ÿçœ‹åˆ°äº†å¾ˆå¥½çš„å¯¹ç§°æ€§ã€‚ä½†æ˜¯æ›´æ–°éƒ¨åˆ†å‘¢ï¼Ÿ<br>let update (msg:Msg) (model:Model) =
    match msg with
    | Insert -&gt;
        Counter.init() :: model // append to list
    | Remove -&gt;
        match model with
        | [] -&gt; []              // list is already empty
        | x :: rest -&gt; rest     // remove from list
    | Modify (pos, counterMsg) -&gt;
        model
        |&gt; List.mapi (fun i counterModel -&gt;
            if i = pos then
                Counter.update counterMsg counterModel
            else
                counterModel) }
Copy<br>Now this may come as no surprise, but we have the same situation here: CounterList.update forwards to Counter.update of the corresponding counter! We end up with something really beautiful, since now we have a CounterList component which exposes exactly the same elements as the Counter itself, namely Model, View and Update. This allows us to use the CounterList itself as a component!<br>
ç°åœ¨è¿™å¯èƒ½å¹¶ä¸å¥‡æ€ªï¼Œä½†æˆ‘ä»¬è¿™é‡Œæœ‰åŒæ ·çš„æƒ…å†µï¼š CounterList.update è½¬å‘åˆ°ç›¸åº”è®¡æ•°å™¨çš„ Counter.update ï¼æˆ‘ä»¬æœ€ç»ˆå¾—åˆ°äº†ä¸€äº›éå¸¸æ¼‚äº®çš„ä¸œè¥¿ï¼Œå› ä¸ºç°åœ¨æˆ‘ä»¬æœ‰ä¸€ä¸ª CounterList ç»„ä»¶ï¼Œå®ƒå…¬å¼€äº†ä¸ Counter æœ¬èº«å®Œå…¨ç›¸åŒçš„å…ƒç´ ï¼Œå³æ¨¡å‹ã€è§†å›¾å’Œæ›´æ–°ã€‚è¿™å…è®¸æˆ‘ä»¬ä½¿ç”¨ CounterList æœ¬èº«ä½œä¸ºç»„ä»¶ï¼<br><br>F# - éå¸¸é€‚åˆ MVU æ¶æ„<br>The MVU architecture was made famous by the Elm language, but can be used in many languages, even in vanilla <a data-tooltip-position="top" aria-label="https://github.com/ccorcos/elmish" rel="noopener" class="external-link" href="https://github.com/ccorcos/elmish" target="_blank">JavaScript</a>. F# - like Elm - is a language in the ML family of programming language, and provides features such as pattern matching that are extremely powerful and particularly useful for modelling state machines. In conjunction with F# features such as <a data-tooltip-position="top" aria-label="https://fsharpforfunandprofit.com/posts/discriminated-unions/" rel="noopener" class="external-link" href="https://fsharpforfunandprofit.com/posts/discriminated-unions/" target="_blank">Discriminated Unions</a>, this allows us to create applications in a type-safe manner that cater for all possibilities. The compiler provides us with guidance when corner cases are not dealt with, leading to quicker development time, whilst allowing F# developers to rapidly create UIs in a typesafe manner. The larger and more complex an application becomes, the greater the benefit; the F# compiler (like the Elm compiler) emits warnings for us when we forget to handle all possibilites - even for more complicated patterns - meaning less time spent debugging or writing unit tests, and more time delivering business value.<br>
MVU æ¶æ„å›  Elm è¯­è¨€è€Œé—»åï¼Œä½†å¯ä»¥åœ¨å¤šç§è¯­è¨€ä¸­ä½¿ç”¨ï¼Œç”šè‡³å¯ä»¥åœ¨æ™®é€š JavaScript ä¸­ä½¿ç”¨ã€‚ F# ä¸ Elm ä¸€æ ·ï¼Œæ˜¯ ML ç¼–ç¨‹è¯­è¨€ç³»åˆ—ä¸­çš„ä¸€ç§è¯­è¨€ï¼Œæä¾›æ¨¡å¼åŒ¹é…ç­‰åŠŸèƒ½ï¼Œè¿™äº›åŠŸèƒ½éå¸¸å¼ºå¤§ï¼Œå¯¹äºçŠ¶æ€æœºå»ºæ¨¡ç‰¹åˆ«æœ‰ç”¨ã€‚ä¸å—æ­§è§†è”åˆç­‰ F# åŠŸèƒ½ç›¸ç»“åˆï¼Œè¿™ä½¿æˆ‘ä»¬èƒ½å¤Ÿä»¥ç±»å‹å®‰å…¨çš„æ–¹å¼åˆ›å»ºåº”ç”¨ç¨‹åºï¼Œä»¥æ»¡è¶³æ‰€æœ‰å¯èƒ½æ€§ã€‚å½“æœªå¤„ç†æç«¯æƒ…å†µæ—¶ï¼Œç¼–è¯‘å™¨ä¸ºæˆ‘ä»¬æä¾›æŒ‡å¯¼ï¼Œä»è€Œç¼©çŸ­å¼€å‘æ—¶é—´ï¼ŒåŒæ—¶å…è®¸ F# å¼€å‘äººå‘˜ä»¥ç±»å‹å®‰å…¨çš„æ–¹å¼å¿«é€Ÿåˆ›å»º UIã€‚åº”ç”¨ç¨‹åºå˜å¾—è¶Šå¤§ã€è¶Šå¤æ‚ï¼Œå¥½å¤„å°±è¶Šå¤§ï¼›å½“æˆ‘ä»¬å¿˜è®°å¤„ç†æ‰€æœ‰å¯èƒ½æ€§æ—¶ï¼ˆå³ä½¿æ˜¯æ›´å¤æ‚çš„æ¨¡å¼ï¼‰ï¼ŒF# ç¼–è¯‘å™¨ï¼ˆå¦‚ Elm ç¼–è¯‘å™¨ï¼‰ä¼šå‘æˆ‘ä»¬å‘å‡ºè­¦å‘Šï¼Œè¿™æ„å‘³ç€èŠ±åœ¨è°ƒè¯•æˆ–ç¼–å†™å•å…ƒæµ‹è¯•ä¸Šçš„æ—¶é—´æ›´å°‘ï¼Œè€Œæœ‰æ›´å¤šæ—¶é—´æä¾›ä¸šåŠ¡ä»·å€¼ã€‚<br><br>For more information about Elmish and the MVU architecture please see the following resources:<br>
æœ‰å…³ Elmish å’Œ MVU æ¶æ„çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…ä»¥ä¸‹èµ„æºï¼š<br>
<br>"Modern app development with Fable and React Native" from NDC Oslo 2017 - <a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=fmaPeUBWZuM" rel="noopener" class="external-link" href="https://www.youtube.com/watch?v=fmaPeUBWZuM" target="_blank">Video</a><br>
â€œä½¿ç”¨ Fable å’Œ React Native è¿›è¡Œç°ä»£åº”ç”¨ç¨‹åºå¼€å‘â€æ¥è‡ª NDC Oslo 2017 - è§†é¢‘
<br>"The Elm Architecture" in the <a data-tooltip-position="top" aria-label="https://guide.elm-lang.org/architecture/" rel="noopener" class="external-link" href="https://guide.elm-lang.org/architecture/" target="_blank">elm docs</a><br>
elm æ–‡æ¡£ä¸­çš„â€œElm æ¶æ„â€
<br>Elmish for F# <a data-tooltip-position="top" aria-label="https://fable-elmish.github.io/" rel="noopener" class="external-link" href="https://fable-elmish.github.io/" target="_blank">docs</a>&nbsp;F# æ–‡æ¡£çš„ Elmish
<br><a data-tooltip-position="top" aria-label="https://github.com/ccorcos/elmish" rel="noopener" class="external-link" href="https://github.com/ccorcos/elmish" target="_blank">Elmish for vanilla JavaScript
ç”¨äºåŸç”Ÿ JavaScript çš„ Elmish</a><br>
<br>Fable compiler <a data-tooltip-position="top" aria-label="http://fable.io/" rel="noopener" class="external-link" href="http://fable.io/" target="_blank">docs</a>&nbsp;Fable ç¼–è¯‘å™¨æ–‡æ¡£
]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/fsharp/ui-programming-with-elmish-in-fsharp.html</link><guid isPermaLink="false">Computer Science/Programming Language/FSharp/UI programming with Elmish in FSharp.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:32 GMT</pubDate><enclosure url="https://www.compositional-it.com/wp-content/uploads/2019/09/elmish-1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://www.compositional-it.com/wp-content/uploads/2019/09/elmish-1.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Unlocking FSharp Potential -- Tips, Tricks, and Tactics]]></title><description><![CDATA[ 
 <br><a rel="noopener" class="external-link" href="https://www.youtube.com/watch?v=8aBmGUNFBQI" target="_blank">https://www.youtube.com/watch?v=8aBmGUNFBQI</a><br><a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=8aBmGUNFBQI#t=28.795104190734865" rel="noopener" class="external-link" href="https://www.youtube.com/watch?v=8aBmGUNFBQI#t=28.795104190734865" target="_blank">00:28</a>]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/fsharp/unlocking-fsharp-potential-tips,-tricks,-and-tactics.html</link><guid isPermaLink="false">Computer Science/Programming Language/FSharp/Unlocking FSharp Potential -- Tips, Tricks, and Tactics.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:29 GMT</pubDate></item><item><title><![CDATA[Writing high performance Fsharp code]]></title><description><![CDATA[ 
 <br>While this post is addressed to F# .NET developers, it introduces much wider concepts starting from hardware architecture to overall .NET runtime and JIT compiler optimizations. It shouldn't be a surprise - optimizing the application performance requires us to understand the relationships between our high level code and what actually happens on the hardware.<br>There's a popular opinion that F# code must be slower than equivalent C# code. This opinion is mostly false, however it comes with some rationale. Usually comparison doesn't use equivalent code in both languages, and F# is generally more high level and declarative in nature. "Idiomatic" F# code doesn't always play well with .NET virtual machine. Writing code that is high level, declarative and fast on .NET platform is not an easy task.<br>In the examples below we'll use some common tools that will help us get better insight into nature of F# code:<br>
<br><a data-tooltip-position="top" aria-label="https://sharplab.io/?ref=bartoszsypytkowski.com" rel="noopener" class="external-link" href="https://sharplab.io/?ref=bartoszsypytkowski.com" target="_blank">Sharplab</a> allows us to easily inspect generated JIT intermediate representation, assembly or even equivalent C# code (which sometimes is approximate, since not all IL idioms are representable in C#) for a given F# snippet. For assembly code usually some extra mangling with params may be necessary for code to be generated as SharpLab sometimes cannot introspect F# core lib code.
<br><a data-tooltip-position="top" aria-label="https://github.com/SergeyTeplyakov/ObjectLayoutInspector?ref=bartoszsypytkowski.com" rel="noopener" class="external-link" href="https://github.com/SergeyTeplyakov/ObjectLayoutInspector?ref=bartoszsypytkowski.com" target="_blank">Object Layout Inspector</a> lets us see how structs and classes will actually be represented in memory.
<br><a data-tooltip-position="top" aria-label="https://benchmarkdotnet.org/articles/overview.html?ref=bartoszsypytkowski.com" rel="noopener" class="external-link" href="https://benchmarkdotnet.org/articles/overview.html?ref=bartoszsypytkowski.com" target="_blank">BenchmarkDotNet</a> is very popular library for writing micro benchmarks. We'll use it to show heap allocations and execution times of our code.
<br>A correct profiling of the executing application is crucial before starting any work on optimizing the code - there's no sense in shaving last possible CPU cycles out of the function that's executed for 0.1% of the time.<br>Keep in mind that for most day-to-day business applications, first way to solve performance problems is to reduce obvious mistakes (eg. replacing multiple I/O requests with one, writing more efficient database query etc.). If that was not the case, next step for satisfactory solution can be simply writing more imperative code - to make it easier to reason about for the compiler rather than human - or picking better-suited data structures. This is especially prevalent in F#, where we can observe pervasive usage of types like 't list (tip: if you're looking which collection to use and want good performance, F# list is almost never a good answer). Here we're about to go deeper, into area where we're about to compete with the prefabricated data types and algorithms.<br><br>One of the big performance gains, that .NET runtime uses to take advantage over other managed virtual machines (like JVM) in race for ultimate performance, often comes from using value types. So if we're about to go fast, we first need to understand how they work.<br>.NET structs represent types, which are not allocated separately on the managed memory heap, but rather inlined within the containing scope (instance of the class in case of fields, thread stack for variables, etc.). This means that usually they are cheaper and easier to access in high-allocation scenarios.<br><img alt="class-vs-struct-layout" src="https://www.bartoszsypytkowski.com/content/images/2021/02/class-vs-struct-layout.png" referrerpolicy="no-referrer"><br>Historically, F# code was not very promising, when it comes to utilizing value types. Nowadays we got things like struct tuples - struct('a * 'b) which unfortunately are not widely used in F# even though in practice they should be preferable choice when working with tuples - and [&lt;Struct&gt;] attribute, that can be used on records and discriminated unions (we'll return to them later), making use of them became much more feasible.<br>However this doesn't necessarily mean, that replacing all reference types with value types will make our code magically go faster. In fact, this may be quite opposite. Why? Imagine what happens when we want to pass a record as a parameter. How is it done? Usually passing object to a function happens by copying reference to that object, which is either 4B or 8B depending on our OS being x86 or x64, and therefore fits perfectly into standard CPU register.<br>type A() =
  class
    [&lt;DefaultValue&gt;] val mutable x: int
    [&lt;DefaultValue&gt;] val mutable y: int
    [&lt;DefaultValue&gt;] val mutable z: int
  end

let print (value: 't) = System.Console.WriteLine(value.ToString())

let a = A() // sub rsp, 0x28
            // mov rcx, 0x7ff91b23d1a8
            // call 0x00007ff9730aade0 ; allocate A on the heap
print a     // mov rdx, rax            ; copy reference to a to the stack
            // mov rcx, 0x7ff91b23d5f8
            // call _.print[[System.__Canon, System.Private.CoreLib]](System.__Canon)
Copy<br>Now what if we're using structs? For reference types we copy object's reference on the stack - since reference is just a single address, it always can fit into register and be done within a single operation. For value types, we copy entire value instead. If they don't fit into register, we'll have to copy them over in multiple steps.<br>type B =
  struct
    [&lt;DefaultValue&gt;] val mutable x: int
    [&lt;DefaultValue&gt;] val mutable y: int
    [&lt;DefaultValue&gt;] val mutable z: int
  end

let b = B() // sub rsp, 0x38
            // xor eax, eax       ; zero field b.x
            // xor ecx, ecx       ; zero field b.y
            // xor edx, edx       ; zero field b.z
print b     // lea r8, [rsp+0x28]
            // mov [r8], ecx      ; copy field b.x to the stack
            // mov [r8+4], eax    ; copy field b.y to the stack
            // mov [r8+8], edx    ; copy field b.z to the stack
            // lea rcx, [rsp+0x28]
            // call _.print[[_+B, _]](B)
Copy<br>Each of these steps is a machine instruction that takes time to execute. However, sometimes .NET can optimize that - pointer-sized registers are not only ones available in modern machines. We also have a special purpose SIMD (Single Instruction Multiple Data) ones, that are much bigger and can be used as long as passed data fits into them perfectly.<br>type C =
  struct
    [&lt;DefaultValue&gt;] val mutable x: int
    [&lt;DefaultValue&gt;] val mutable y: int
    [&lt;DefaultValue&gt;] val mutable z: int
    [&lt;DefaultValue&gt;] val mutable zz: int
  end
  
let c = C() // sub rsp, 0x48
            // xor eax, eax             ; zero register
            // mov [rsp+0x38], rax      ; init fields b.x and b.y together with zero'ed register
            // mov [rsp+0x40], rax      ; init fields b.z and b.zz together with zero'ed register
print c     // vmovupd xmm0, [rsp+0x38] ; copy all 4 fields together on the stack using SIMD registers
            // vmovupd [rsp+0x28], xmm0
            // lea rcx, [rsp+0x28]
            // call _.print[[_+C, _]](C)
Copy<br>Another thing available in .NET, that allows us addressing inefficiencies of passing structs as arguments are so called by-ref parameters. There are 3 types of these, marked using 't inref, 't outref and 't byref:<br>let print(value: 't inref) = ...
let c = C()
print &amp;c // lea rcx, [rsp+0x28] ; copy address of the struct head onto the stack
         // call _.print[[_+C, _]](C ByRef)
Copy<br>Please, don't confuse by-ref parameters with ref data type:<br>
<br>'a ref is actually an alias for Ref&lt;'a&gt; class, therefore allocated on the heap and passed by reference. In general, using this class in F# very rarely has sense (outside of writing exemplar, idiomatic code).
<br>'a byref is equivalent to C# ref parameter tag - it means that we're passing reference (memory address) to an object or struct. It expects it to be initialized and can be used to change the contents of the underlying value. For this reason F# requires fields and variables passed as byref to be declared with mutable keyword.
<br>'a outref is equivalent to C# out parameter tag - it always must be initialized by the end of the function body. This may sound a bit tricky as F# doesn't put that requirement explicitly. If we didn't make that assignment in any of the code branches, F# compiler will simply initialize it for us with default value (just like using Unchecked.defaultof&lt;_&gt;), which sometimes may lead to null reference exceptions.
<br>'a inref is the youngest of these and is equivalent of C# in parameter - while in C# structs passed as arguments for that parameters don't have to be tagged, F# will always require to mark passing by ref (using &amp; prefix for passed argument) for any parameter marked with byref/inref/outref. inref is basically an optimization technique for what we saw above - it allows us to pass struct into a function using only its memory address, without copying entire struct contents. Additionally inref says that parameter is treated as read only, so it cannot be modified inside of function body. .NET JIT can utilize this information in some cases to reduce number of safety checks, therefore reducing number of instructions to be executed.
<br>While using by-ref parameters is usually good idea when it comes to writing code targeting complex value types, there are several limitations to it.<br>One is that arguments passed using by-ref params cannot be captured by closures/lambdas/anonymous functions, which prevents them from being used in more abstract code:<br>// WRONG!
let doSomething (a: int inref) =
  [1..10]
  |&gt; List.map (fun x -&gt; x + a) // `a` is captured by closure, which is compilation error
  
// RIGHT
let doSomething (a: int inref) =
  let mutable result = []
  for x=10 downto 1 do
    result &lt;- (x + a)::result
  result
Copy<br>This includes problems even for common inlined functions like eg. pipe operator |&gt;. That's the price, we have to pay for speed (at least for now).<br>Second issue is that, at the moment by-ref parameters cannot be involved in building nested functions (regardless if they capture the values from function in outer scope or not). This again makes very inconvenient to use them in cases like tail recursive loop pattern:<br>// WRONG!
let doSomething (a: 'a) =
  let rec loop n (x: 'a inref) = // this nested function won't compile
    if n = 0 then ()
    else loop (n-1) &amp;x
  loop 100 &amp;a

// RIGHT
let rec loop n (x: 'a inref) =
  if n = 0 then ()
  else loop (n-1) &amp;x
  
let doSomething (a: 'a) = loop 100 &amp;a
Copy<br><br>While we talked about by-ref params, .NET (and latest F#) enable us to do something more - we can define so called by-ref structs and readonly structs:<br>[&lt;Struct; IsByRefLike; IsReadOnly&gt;]
type BufWriter&lt;'a&gt; =
  // since BufWriter is by-ref struct it can have by-ref types as fields
  // otherwise it would result in compilation error
  [&lt;DefaultValue&gt;] val buffer: ReadOnlySpan&lt;'a&gt;
  
/// F# records and discriminated unions are marked with IsReadOnly by default
[&lt;Struct; IsByRefLike&gt;]
type BufWriter&lt;'a&gt; = { Buffer: ReadOnlySpan&lt;'a&gt; }
Copy<br>[&lt;IsReadOnly&gt;] attribute let's us define given structure as being readonly. For obvious reasons this also means, that corresponding data type cannot contain any mutable fields within.<br>It's used as a slight optimization technique - sometimes .NET JIT compiler must guarantee that structs contents will not be modified. To do so, it will conservatively copy that structure, even when it has been passed into function using inref parameter. If struct has been marked with [&lt;IsReadOnly&gt;] attribute, compiler can skip this step and avoid building defensive copies. You can read more about it <a data-tooltip-position="top" aria-label="https://devblogs.microsoft.com/premier-developer/avoiding-struct-and-readonly-reference-performance-pitfalls-with-errorprone-net/?ref=bartoszsypytkowski.com" rel="noopener" class="external-link" href="https://devblogs.microsoft.com/premier-developer/avoiding-struct-and-readonly-reference-performance-pitfalls-with-errorprone-net/?ref=bartoszsypytkowski.com" target="_blank">here</a>.<br>[&lt;IsByRefLike&gt;] is another attribute. We are talking a lot about passing value types using memory location addresses instead of doing deep copies. Marking struct using this attribute is basically saying "I always want to pass this value by reference". This of course comes with severe limitations: it cannot be boxed (moved to managed heap) and for this reason it can never be captured by closures, implement interfaces or be used as field in classes or other non-by-ref structs.<br>In terms of F# this basically means that this kind of structs are used mostly for code that is executed right away within the function body, with no computation expressions or other indirections. This usually qualifies them to hot paths in our code, where CPU intensive work is expected and allocations are not welcome, like:<br>
<br>for .. in loops - in fact many moderns .NET structures have special variants of GetEnumerator that doesn't allocate any memory and is implemented as by-ref struct. F# also understands that pattern - in fact you can define custom GetEnumerator(): MyEnumerator method for your collection, with MyEnumerator - which can even be a ref struct - having two methods: Current: 'item and MoveNext: unit -&gt; bool, and F# will automatically understand how to use it in loops. You can see an example implementation of it <a data-tooltip-position="top" aria-label="https://github.com/Horusiath/fsharp.core.extensions/blob/62b102e84325e89b0a6c4065b973936c11adee55/src/FSharp.Core.Extensions/Vec.fs?ref=bartoszsypytkowski.com#L147" rel="noopener" class="external-link" href="https://github.com/Horusiath/fsharp.core.extensions/blob/62b102e84325e89b0a6c4065b973936c11adee55/src/FSharp.Core.Extensions/Vec.fs?ref=bartoszsypytkowski.com#L147" target="_blank">here</a> - it's a part of implementation of persistent vector data type, similar to <a data-tooltip-position="top" aria-label="https://fsprojects.github.io/FSharpx.Collections/PersistentVector.html?ref=bartoszsypytkowski.com" rel="noopener" class="external-link" href="https://fsprojects.github.io/FSharpx.Collections/PersistentVector.html?ref=bartoszsypytkowski.com" target="_blank">FSharpX persistent vector</a>, but it's 4.5 times faster and not allocating anything on heap when executed in loops.
<br>Contextual data around byte-shaving operations. All things related to parsing/formatting can make use of that technique to optimize speed and reduce allocations. It's also used inside of all kinds of drivers working with I/O.
<br>While we're using explicit class/struct type definition here, from .NET runtime point of view memory layout for records and struct records is exactly the same (it differs for discriminated unions thou, but we'll cover that soon).<br><br>Another point worth noticing is that .NET have it's own assumptions regarding data size of classes. Let's see that on an example:<br>type A = { x: int; y: int }
type B = { x: int; y: int; z: int }
Copy<br>How do you think, what's the size of A and B? Naively, we could assume that B instance would be 4 bytes bigger than instance of type A. However that's not always true. Let's inspect memory layout of both classes:<br><img alt="padding-1" src="https://www.bartoszsypytkowski.com/content/images/2021/02/padding-1.png" referrerpolicy="no-referrer"><br>As you can see both classes start with 16 byte object header and vtable pointer: it's mandatory for every class (and boxed structs). They make things like method overriding or lock calls on objects possible. Then we have actual class content: 2 * sizeof(int) = 8 bytes in case of A and 3 * sizeof(int) = 12 bytes in case of B. However that's not the end. In case of B you can also see 4 extra bytes of padding. Where does it comes from?<br>When managing heap size, .NET GC/allocator makes some simplifications. Namely it assigns blocks of memory that are multiplications of a standard pointer size, which is 4 bytes on 32-bit OS'es and and 8 bytes on 64-bit ones. So, when instantiating objects, GC will always assign them as much space as it's necessary to encapsulate all fields and fit into 4-/8-bytes ceiling: since most servers operate on 64-bits nowadays, we're talking about buckets of 16+8 bytes, 16+16 bytes, 16+24 bytes etc.<br>What's interesting, this padding requirement doesn't concern unmanaged structs (value types consisting only of other value types). If we modify our record B to be a struct:<br>[&lt;Struct&gt;] type B = { x: int; y: int; z: int }
Copy<br>, we'll see that it takes only 12 bytes. If we take into account object header, that's over 2.5 less space than in case of class-based record, with no heap allocations and therefore no need to GC it later. Keep in mind that adding a reference type (eg. string) as struct field will cause it to add padding again. In that case the space saving comes from lack of object header/vtable pointer.<br>Now, if necessary we could also apply padding to structs manually. While in eg. Java you need to add redundant extra fields to do that, in .NET we can hint the runtime about the expected struct size:<br>[&lt;Struct; StructLayout(LayoutKind.Auto, Size=16)&gt;] 
type B = { x: int; y: int; z: int }
Copy<br>StructLayout has many useful properties i.e. it opens the door to manually define the position of each record field within the type. It also exposes the Size property, which we can use to manually say what's the expected size of our struct - in that case when creating it, runtime will explicitly add extra bytes for padding. But what would we need it for? We answer that <a data-tooltip-position="top" aria-label="https://www.bartoszsypytkowski.com/writing-high-performance-f-code/#falsesharing" rel="noopener" class="external-link" href="https://www.bartoszsypytkowski.com/writing-high-performance-f-code/#falsesharing" target="_blank">shortly</a>.<br><br>We need to go a little bit deeper and step into hardware territory. Junior programmers often are taught to think about computer memory as a single homogenous block. That's a convenient lie, especially since languages - even as low level like C - rarely expose any primitives to operate on it. From computer architecture classes, you could learn that memory is split into several layers - from RAM to L1-L3 caches.<br><img alt="CPU-architecture" src="https://www.bartoszsypytkowski.com/content/images/2021/02/CPU-architecture.svg" referrerpolicy="no-referrer"><br>Thing is that, access time to L1 can be several dozens times faster than to main memory (RAM). For this reason, when data residing in main memory is about to be used by the CPU, it's first loaded into cache. Hardware does a little bet here: it comes into assumption that most of the data used together resides in the main memory closely to each other. For that reason it doesn't just load a single object reference - it doesn't even know what is it - but instead an entire following block of data, so called cache line. On modern hardware, cache lines are usually 64 bytes long.<br>One of the reasons, why we talked about structs for so long is that collections of entities like A[] behave very differently depending on A being a class or a struct:<br>
<br>If A is a class, it means that A[] contains only references to objects, which actual contents may reside in totally different places of memory. Given nature of .NET GC, when they are created on different threads, you may be pretty sure they will not be placed together. This means that when iterating over them, you may need to load them many times from different places in memory.
<br>If A is a struct, then A[] will contain inlined values of A, with all their contents stored sequentially next to each other.
<br>There's one thing about the cache lines, that can cause misleading results during microbenchmarking of the code. Consider simple operation like sum of the list values: intList |&gt; List.sum. Let's run it twice and check the results:<br><br>In both cases we're talking about the exactly same code over preallocated lists (so list initialization is not part of the benchmark), yet second example takes almost 3 times longer to execute. What has changed then? When setting up the test case I added extra allocation of an object in between appending nodes of the list like so:<br>caseA &lt;- [1..1024] // dataset for TestA
for i = 1024 downto 1 do
    caseB &lt;- i::caseB // dataset for TestB
    unused &lt;- { x = i; y = i; z = i }::unused
Copy<br>Since F# list is implemented as a linked list, it means that its nodes are allocated on a heap and linked together. In first case, even thou suboptimal, those list nodes were still allocated in continuous space in memory, making more efficient use of cache line loads. In second case, our list was fragmented over much bigger space of memory. If elements of our list are value types, we can squash them together by using List. operations over it or just map it into an array. This however won't work for reference types, as we'll only move pointers alone, while objects themselves will stay in their old place.<br>Another way to improve performance of some operations is to revert the field order of the elements stored in collection, eg:<br>[&lt;Struct&gt;] type Point3D = { x: int; y: int; z: int}

type ContainerA(input: Point3D[]) =
  member this.SumX = input |&gt; Array.sumBy (fun a -&gt; a.x)
  member this.Item index = input.[index]

type ContainerB(input: Point3D[]) =
  let x = input |&gt; Array.map (fun a -&gt; a.x)
  let y = input |&gt; Array.map (fun a -&gt; a.y)
  let z = input |&gt; Array.map (fun a -&gt; a.z)
  member this.SumX = Array.sum x
  member this.Item index = { x = x.[index]; y = y.[index]; z = z.[index] }
Copy<br>Now, depending on which operation we care about more - accessing a single element, or computing sum of X coordinates - one or another implementation will have more sense. This approach is even more prevalent if we look into world of databases - a big contributor to performance difference between OLTP databases (oriented towards standard transactional workloads) and OLAP databases (oriented towards analytical data processing) comes exactly from laying out data on a disk by rows vs by columns.<br>PS: In case of ContainerB we can add even better optimization techniques in form of <a data-tooltip-position="top" aria-label="https://www.bartoszsypytkowski.com/writing-high-performance-f-code/#makeuseofvectorization" rel="noopener" class="external-link" href="https://www.bartoszsypytkowski.com/writing-high-performance-f-code/#makeuseofvectorization" target="_blank">vectorization</a>, which we'll cover further down the blog post.<br><br>Now the next thing is that L1-L2 caches are residing closely to CPU cores. In fact, as we've shown, every core has it's own cache. This comes with it's own problems: since every CPU has it's own copy of a value, they occasionally need to synchronize and invalidate their caches when that value is accessed from different cores. This is an expensive operation, which we want to avoid.<br>When such accidental sharing may happen? It's not easy to detect in micro benchmarks, and usually needs a dose of profiling and good old fashion trial and error of actual application code. IMO that's why optimizations in this area are not applied so often. Some tips to help build our intuition are:<br>
<br>This can happen when two adjacent fields of the same object are concurrently accessed and modified from different threads. Thing is that unless you configure your types with [&lt;StructLayout(LayoutKind.Explicit)&gt;] you won't know if two fields defined in code one after another will be placed in adjacent memory cells by .NET runtime. Using <a data-tooltip-position="top" aria-label="https://github.com/SergeyTeplyakov/ObjectLayoutInspector?ref=bartoszsypytkowski.com" rel="noopener" class="external-link" href="https://github.com/SergeyTeplyakov/ObjectLayoutInspector?ref=bartoszsypytkowski.com" target="_blank">Object Layout Inspector</a> can help you validate your assumptions here.
<br>It can also happen that two different objects/structs will be placed closely inside of collection. This is mostly common for array-backed collections (as they keep elements continuously in memory block) and with small structs (as you may fit more of them inside of single cache line).
<br>We can sometimes reduce risk of false sharing in 2nd case and making it more predictable, by defining type size explicitly to fit exactly into boundaries of cache lines eg. 64B (it's enough to have a class with 6 references/12 int fields or a struct with 8 references/16 int fields). If you know that your objects can be accessed concurrently, but don't fit nicely into into cache lines, you may add extra padding by using [&lt;StructLayout(LayoutKind.Auto, Size=64)&gt;] in your struct definition. While memory usage increases, the overall application performance may improve.<br><br>So far, we only talked about structs in terms of singular elements - when talking about collections, we got pretty much used to the fact, that we have to allocate. This however is not always the case. .NET has a long history of allowing users to allocate collections on stack rather than heap - in C# it's related with stackalloc keyword, in F# it's bit more verbose:<br>open FSharp.NativeInterop

let inline stackalloc&lt;'a when 'a: unmanaged&gt; (length: int): Span&lt;'a&gt; =
  let p = NativePtr.stackalloc&lt;'a&gt; length |&gt; NativePtr.toVoidPtr
  Span&lt;'a&gt;(p, length)
Copy<br>What we returned here is a Span&lt;'a&gt; - a by-ref struct type (meaning: it cannot be used in closures or as a field in most types), that allows us to address its elements just like they existed on the heap. In general, you should avoid allocating too much memory on the stack (in .NET stacks have fixed size that by default is limited to 1MB per thread, allocating over it will cause irrecoverable StackOverflowException). Most common case for using these are short parsing methods, that can be used on the hot paths without producing garbage to be collected later:<br>/// Parse Protocol Buffers style variable length uint32.
let readVarUInt32 (reader: Reader) : uint32 =
  // var int for 32 bit values is never encoded on more than 5 bytes
  let buffer = stackalloc&lt;byte&gt; 5 
  let read = reader.Read buffer
  if read = 0
  then failwith "trying to read var int from empty stream"
  else
    let buffer = buffer.Slice(0, read)
    let mutable decoded = 0u
    let mutable i = 0
    let mutable cont = true
    while cont &amp;&amp; i &lt; buffer.Length do
      let b: byte = buffer.[i]
      decoded &lt;- decoded ||| ((uint32 (b &amp;&amp;&amp; 0x7Fuy)) &lt;&lt;&lt; i * 7)
      i &lt;- i + 1
      if b &lt; 0x80uy then  // check if most significant bit is set
        cont &lt;- false // stop condition reached    
    reader.Advance i
    decoded
Copy<br>Even though we did create a buffer (to avoid cost of multiple virtual calls to reader.Read method), in practice we didn't allocate anything that has to be later collected by the GC.<br>Unfortunately we cannot use spans everywhere eg. as fields of ordinary classes, but there are still situations where we might want to have collections without GC. This often desirable in case of huge number of collections, that most of the time are very small (eg. <a data-tooltip-position="top" aria-label="https://www.bartoszsypytkowski.com/the-state-of-a-state-based-crdts/#noteaboutvectorclocks" rel="noopener" class="external-link" href="https://www.bartoszsypytkowski.com/the-state-of-a-state-based-crdts/#noteaboutvectorclocks" target="_blank">vector clocks</a>). We can imagine such non-allocating collection like:<br>[&lt;IsReadOnly&gt;]
type HybridMap&lt;'k, 'v&gt; =
    struct
       let count: int  // size: 4B
       // null by default, initialized once we pass over 3 entries
       // size: 8B (reference)
       let inner: Map&lt;'k,'v&gt;
       // inline first 3 entries. size: 48B = 3 * (8B+8B) (assume reference type)
       let entry0: KeyValuePair&lt;'k,'v&gt;   
       let entry1: KeyValuePair&lt;'k,'v&gt;
       let entry2: KeyValuePair&lt;'k,'v&gt;
    end
Copy<br>With map like this, adding first 3 elements produce no garbage. Why only 3? Just like mentioned previously, we prefer our structs to fit into cache lines and this way (assuming both 'k and 'v types are classes) we'll still not surpass 64B (on 64bit OS) or 32B (on 32bit one).<br><br>Discriminated unions are somewhat special citizens, in a sense they have to be represented in terms of .NET reference types (classes) or value types (structs). It means that depending on how they are defined (with or without [&lt;Struct&gt;] attribute), their in memory representation may be very different.<br><img alt="class-vs-struct-union-1" src="https://www.bartoszsypytkowski.com/content/images/2021/02/class-vs-struct-union-1.png" referrerpolicy="no-referrer"><br>A thing you can see in both situations is that fields order in both cases doesn't reflect order in which they were defined. That's because .NET runtime can reorder them in any type unless explicitly forbidden by using [&lt;StructLayout(LayoutKind.Explicit)&gt;] attribute. Moreover, using this attribute is forbidden in case of discriminated unions.<br>Another thing, that you may have noticed is how DUs are represented. A class-based discriminated union is basically equivalent to an empty abstract class with each case being a sealed class inheriting from it. Struct based DU is more complicated. Many other languages with algebraic data types optimize the size according to formula sizeof(tag field) + max([sizeof(ADT case)]). But not F# - what we see here is sizeof(int) + sum([sizeof(ADT case)]):<br><img alt="rust-vs-fsharp-adt-1" src="https://www.bartoszsypytkowski.com/content/images/2021/02/rust-vs-fsharp-adt-1.png" referrerpolicy="no-referrer"><br>The reason behind this is a limtation of .NET platform - while technically it's possible to use <a data-tooltip-position="top" aria-label="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.layoutkind?view=net-5.0&amp;ref=bartoszsypytkowski.com" rel="noopener" class="external-link" href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.layoutkind?view=net-5.0&amp;ref=bartoszsypytkowski.com" target="_blank">LayoutKind.Explicit</a> to implement F# in similar manner to i.e. Rust, it works only as long as we don't try to use it together with generics: .NET cannot make safe guesses in that situation. In result, used memory space for struct-based DU is a sum of all fields defined all cases. For this reason good candidates for struct DU's are usually the ones with very small overall number of fields. F# standard library makes good use of these in form of Result&lt;'t,'e&gt; and 't voption types.<br>Options have somewhat special treatment when it comes to F#. While value options work pretty much in ordinary way, class-based ones have some special magic in them. We could imagine them as:<br>[&lt;Struct&gt;]
type ValueOption&lt;'t&gt; =
  | ValueNone
  | ValueSome of value:'t
  
type Option&lt;'t&gt; = 
  { Value: 't }
  static member Some value = { Value = value }
  static member None = Unchecked.defaultof&lt;Option&lt;'t&gt;&gt; // null
Copy<br>This means, that value option will always have to be initialized and use sizeof(int) + sizeof('t) bytes in memory, while standard option may get optimized away into uninitialized instance (null), which size is always sizeof(IntPtr). So, while you still need to pay for allocating new object for cases where option indeed has value, in some cases where you're working with collections of mostly None values, it may turn out that using standard options is actually more effective approach.<br>A common scenario, where option types are used is when we're dealing with failable operations like trying to find element in a map (which may not be there) or parsing an int. In that case keep in mind:<br>
<br>Using option is the most expensive approach, as eventual success means allocating an extra intermediate object.
<br>Using voption is much cheaper, but at the moment .NET doesn't really know how to pass value types using registers alone, so returning voption may mean copying it through stack in multiple steps, even though we avoided GC allocations.
<br>In practice, the best performing solution is using straight old pattern - popular in C# - of try function definition ending up with 't outref -&gt; bool signature. It can be found in most .NET collections (both F# and C#), as well as parsing methods. In fact this pattern is so popular, that F# can automatically derive tuple out of it eg. let (ok, value) = map.TryGetValue(key). Under normal circumstances this tuple would mean heap allocations, however if you won't capture it and propagate further, but instead use its contents right away like i.e. in match expression, it will let F# compiler to skip allocating an object.
<br>One of the patterns sometimes used by F# programmers is to add more type info to value by wrapping it into DU:<br>type Mileage = Mileage of int 
Copy<br>Patterns like this one are generally devastating for performance - we're allocating 24B of garbage on the heap for every int used. Using units of measure or even type aliases is much better option, since both of them have only compile time representation and are erased by the compiler, they never introduce a runtime overhead.<br>[&lt;Measure&gt;] type miles
type Mileage = int&lt;miles&gt;
Copy<br><br>Did you even wonder, when function is about to call a method on interface parameter, how does it actually know, where to find the method of the underlying object implementing that interface? Runtime resolves actual method to be called by jumping to virtual table of that object (pointer to vtable is part of object header), finding the address of corresponding method (function can have pointers too!) and calling it. As you may imagine all of that indirections can take time. If you think, you're safe because you're not doing object method calls but using module functions instead, check twice - in practice many of them are being inlined as non-static methods.<br><img alt="virtual-call-dispatch-1" src="https://www.bartoszsypytkowski.com/content/images/2021/02/virtual-call-dispatch-1.png" referrerpolicy="no-referrer"><br>But how much longer does it actually take? Let's take an example code:<br>/// interface we want to test
type Stub = abstract member DoNothing: unit -&gt; unit
/// class implementing an interface
type A() =
  member _.DoNothing() = ()
  interface Stub with member this.DoNothing() = this.DoNothing()
  
/// struct implementing an interface
[&lt;Struct&gt;]
type B =
  member _.DoNothing() = ()
  interface Stub with member this.DoNothing() = this.DoNothing()

[&lt;MemoryDiagnoser&gt;]
type Benchmark() =
  [&lt;DefaultValue&gt;] val mutable a: A
  [&lt;DefaultValue&gt;] val mutable b: B
  
  static let execute (x: Stub) = x.DoNothing()
  static let executeGeneric (x: #Stub) = x.DoNothing()  
  static let executeDirect (x: A) = x.DoNothing()  
  static let executeDirect2 (x: B) = x.DoNothing()  
  
  [&lt;GlobalSetup&gt;]
  member this.Setup() =
    this.a &lt;- A()
    this.b &lt;- B()        
  [&lt;Benchmark(Baseline=true)&gt;] member this.ExecuteClassDirect() = executeDirect this.a
  [&lt;Benchmark&gt;] member this.ExecuteClass() = execute this.a
  [&lt;Benchmark&gt;] member this.ExecuteClassGeneric() = executeGeneric this.a
  [&lt;Benchmark&gt;] member this.ExecuteStructDirect() = executeDirect2 this.b
  [&lt;Benchmark&gt;] member this.ExecuteStruct() = execute this.b
  [&lt;Benchmark&gt;] member this.ExecuteStructGeneric() = executeGeneric this.b
Copy<br>Example run from BenchmarkDotNet could give us following results:<br><br>There are couple of interesting observations to be made here:<br>
<br>In both cases when either struct or class type parameter is known exactly, the call itself is almost instantaneous (in fact for ExecuteStructDirect method you should receive warning about entire call being optimized away). That's because runtime can say directly which version of the method is going to be called and skip the dispatch to type's virtual table. We call this devirtualization - a process, when runtime is able to replace virtual call dispatch with a direct function call. This is also the reason why you should not pass objects by interface parameters i.e. 't seq instead of 't[] any time when performance matters.
<br>While there exists a small difference between a class instance being called via interface or as generic argument, this is not what we're after. In both cases we can observe similar results - it's because .NET 5 runtime doesn't really specialize generic method calls for reference types. At the moment it can happen sometimes for sealed classes. This means, that usually calling by interface (either explicitly or by using generic type parameter) will require virtual table dispatch anyway.
<br>Passing struct as parameter into a function that expects interface requires boxing - it means that this structure is copied onto heap (hence we can see allocations), prefixed with a header that includes a vtable pointer. From here struct methods look very similar to classes. All of this extra work causes the entire call to be even more expensive. Sometimes when we know that we're about to pass a struct into some callback expecting a generic object (<a data-tooltip-position="top" aria-label="https://docs.microsoft.com/en-us/dotnet/api/system.threading.timer.-ctor?view=net-5.0&amp;ref=bartoszsypytkowski.com#System_Threading_Timer__ctor_System_Threading_TimerCallback_System_Object_System_Int32_System_Int32_" rel="noopener" class="external-link" href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.timer.-ctor?view=net-5.0&amp;ref=bartoszsypytkowski.com#System_Threading_Timer__ctor_System_Threading_TimerCallback_System_Object_System_Int32_System_Int32_" target="_blank">Timer</a> can be such example) multiple times, it may we worth to eagerly box it ahead and pass boxed version instead, reducing number of allocations. This may also be a sign that reference type is preferred over struct.
<br>An interesting thing happens, once we pass a struct as generic argument. As you can see, this call is several times faster than generic call on the class instance. This is because for structs, .NET JIT uses a generic code specialization - it basically emits machine code for this method call, dedicated for handling this particular type of struct when it's passed as a generic type argument. Since this is specialized branch of code, we don't need to check for vtable every time, as we already can say what function implementation is going to be called.
<br>Generic function specialization may sound a little similar to SRTP (statically resolved type parameters - generics which are erased by F# compiler at compile time), but it's performed by .NET runtime itself. Unlike SRTP, it doesn't prolong our compile times (and .NET JIT is really fast at machine code generation) and can be composed in much better way - you can pass generic functions as parameters themselves over many levels of function calls and let .NET runtime optimize them in a wider context.<br>In some cases we can leverage .NET behavior to introduce something aligned to zero-cost abstractions in our code - it's a term forged by Rust programming language, meaning that we can write abstract code that's as fast as equivalent code written by hand. While .NET and F# offer it in limited scope, we can still use it. Example:<br>type Hasher&lt;'t&gt; = abstract Hash: 't -&gt; int
let inline hash&lt;'h, 't when 'h: struct and 'h :&gt; Hasher&lt;'t&gt;&gt; (value: 't) =
  Unchecked.defaultof&lt;'h&gt;.Hash value

// we should introduce interface for equality check as well

type HashSet&lt;'t, 'h when 'h: struct and 'h :&gt; Hasher&lt;'t&gt;&gt;() =
  member this.Add(item: 't) =
    let h = hash&lt;'h, _&gt; item // 'h cannot be inferred as it has no input parameter
    // ... rest of the implementation

module StringHashers =
  
  [&lt;Struct&gt;]
  type InvariantCultureIgnoreCase =
    interface Hasher&lt;string&gt; with
      [&lt;MethodImpl(MethodImplOptions.AggressiveInlining)&gt;]
      member this.Hash(key: string) = StringComparer.InvariantCultureIgnoreCase.GetHashCode key
  
open StringHashers  
let map = HashSet&lt;string, InvariantCultureIgnoreCase&gt;()
Copy<br>Here we managed to introduce two improvements:<br>
<br>Our collection is safer that ordinary .NET HashSet&lt;'t&gt;, as we included information about what hashing method we use. Traditional HashSet&lt;'t&gt; can take IEqualityComparer&lt;'t&gt; as a parameter, but doesn't expose it at type level. That means, that a.Union(b) operation may yield different result than b.Union(a) when a and b use different comparers and we don't get any warnings.
<br>Our collection is also faster, because we provided a precise definition of what hashing method we use at the type level. As mentioned before, this allows .NET runtime to specialize HashSet&lt;'t,'h&gt; methods over 'h, since it's a struct type. Unchecked.defaultof&lt;'h&gt; used here is a pattern that we can use, as we cannot provide static classes (or F# modules) as generic type parameters. However we can provide a struct with no fields instead - it's in-memory representation is 0 bytes, and since it's not boxed (we're providing it as a generic value), .NET will elide its existence completely and compile it to the exact method call (no virtual dispatch is necessary here).
<br>If you're interested more with this approach, I can recommend <a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=UybGH0xL5ns&amp;ref=bartoszsypytkowski.com" rel="noopener" class="external-link" href="https://www.youtube.com/watch?v=UybGH0xL5ns&amp;ref=bartoszsypytkowski.com" target="_blank">this presentation</a> by Frederico Lois.<br><br>We already mentioned registers. As you may (or may not) know, modern day processors offer general purpose registers up to 64bit size. But that's not end of the story. You might have stumbled upon term SIMD (Single Instruction Multiple Data), which was already used here - it's a technique that allows to apply the same operation to multiple values at once. It's a basis for efficient graphical processing and number crunching - hence it's a core building block for GPU programs (eg. shaders).<br>However pretty much every modern day CPU also have dedicated registers - varying in size from 128, 256 to 512 bits atm. of writing this post - that can also be used for this purpose. Their API has been wrapped and exposed in .NET, and it's sometimes used for common operations i.e. finding substrings in provided text or copying structs of certain sizes (we saw that already). Sometimes we call the process of making code use these specialized registers, vectorization.<br>You can also use them on your own. Let's a simple function that's supposed to check if value can be found within given array:<br>
<br>Since vectorized operations can work only over vectors, we first need to create a vector filled in all places with value we try to find.
<br>Next, instead of checking array elements one by one, we load entire chunk of it (as much as we can fit into the vector), and compare it with a previously constructed comparator. This comparison is done over all pairwise vector elements in one instruction.
<br>Since we have to compare all vectors contents or none at all, we need to fallback to standard comparison of elements one by one, once an array remainder is smaller than vector's capacity.
<br>#r "nuget: System.Numerics.Vectors"
open System.Numerics

let inline contains (value: 't) (array: 't[]) =
  let chunkSize = Vector&lt;'t&gt;.Count
  /// ' Use SIMD registers to compare chunks of array at once
  let rec fast (cmp: Vector&lt;'t&gt;) (array: 't[]) (i: int) =
    if i &gt; array.Length - chunkSize then slow value array i
    elif Vector.EqualsAny(cmp, Vector(array, i)) then true // compare entire chunk at once
    else fast cmp array (i+chunkSize)
    
  /// if array remainer size doesn't fit into SIMD register
  /// fallback to check array items one by one
  and slow (value: 't) (array: 't[]) (i: int) =
    if i &gt;= array.Length then false
    elif array.[i] = value then true
    else slow value array (i+1)
    
  // create vector of 't filled with value copies on all positions
  let cmp = Vector(value)
  fast cmp array 0
Copy<br>Limitation here is that this operation works only on numbers - the smaller they are in size, the more of them can we compare at once. But is it fast? Let's check it and compare against standard F# Array.contains 900 [|1..1000|]:<br><br>It's 4 times performance improvement simply by using vectorized operations. There are <a data-tooltip-position="top" aria-label="https://docs.microsoft.com/en-us/dotnet/api/system.numerics.vector?view=net-5.0&amp;ref=bartoszsypytkowski.com" rel="noopener" class="external-link" href="https://docs.microsoft.com/en-us/dotnet/api/system.numerics.vector?view=net-5.0&amp;ref=bartoszsypytkowski.com" target="_blank">dozens of operations</a> defined in high-level Vector API. Knowledge on how to make an advantage of SIMD is basis for modern day design and implementation of data structures and algorithms.<br><br>Immutable data structures are prevalent technique of writing programs in functional paradigm and F# is no exception here. Thing is, that immutable structures, be it records or collections, introduce an extra overhead related to copying parts of the code in use. This can be reduced by writing structures that take advantage of <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Persistent_data_structure?ref=bartoszsypytkowski.com" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Persistent_data_structure?ref=bartoszsypytkowski.com" target="_blank">structural sharing</a> - which deserves its own blog post - but in general .NET doesn't provide optimizations that could make executing single-threaded, large scale immutable code faster than its mutable equivalent.<br>Often advantage of having immutable data types is not performance related - they just offer simpler way to analyze and debug program, which has fewer moving parts, as you can compare snapshots of previous/current/expected states with each other.<br>One of the bigger advantages - which we're also going to use soon - it's natural idempotency of such structures. Aside of being useful in testing (some of the model checkers and property-based tests make extensive use of it), we can also use it to improve performance. It's not usually visible in simple code microbenchmarking, but rather when we need to combine several different operations at once.<br>Example: imagine, that you have a dictionary, that needs to be updated concurrently, but also checked for size from time to time. In .NET we could simply implement it by using ConcurrentDictionary&lt;'k,'v&gt;, but there's a catch - have you ever wondered, how mutable concurrent dictionary ensures, that during counting process a dictionary size has not changed? Well it does it in the simplest way - it locks entire dictionary until counting completes.<br>open System
open System.Collections.Concurrent

let map = ConcurrentDictionary&lt;_,_&gt;()

// 1st set of workers tries can try to add value to a map
let write k v = map.AddOrUpdate(k, Func&lt;_,_&gt;(fun _ -&gt; v), Func&lt;_,_,_&gt;(fun _ _ -&gt; v))

// another worker performs operation over the elements of the map
let count () = map.Count
Copy<br>This issue doesn't really exists in immutable collections, since there's no risk of changing the collection as it's being iterated - we can simply iterate over old (possibly outdated) snapshot of data, but we won't stop the field/variable from being updated.<br>// shared mutable field
let map = ref Map.empty

let write k v = map := Map.add k v !map

let count () = Map.count !map
Copy<br>Now, the question would be - is it safe? Well... no. Modifying contents of F# ref cells (or even static mutable members) is not threadsafe operation. But we can make it so. How? Old school way would be to fall back to OS-level primitives like semaphores and mutexes, but we still can actually make them faster, thanks to the idempotency of immutable collections.<br><br>We'll again fallback to hardware intrinsic operations, this time exposed as part of <a data-tooltip-position="top" aria-label="https://docs.microsoft.com/en-us/dotnet/api/system.threading.volatile?view=net-5.0&amp;ref=bartoszsypytkowski.com" rel="noopener" class="external-link" href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.volatile?view=net-5.0&amp;ref=bartoszsypytkowski.com" target="_blank">Volatile</a> and <a data-tooltip-position="top" aria-label="https://docs.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-5.0&amp;ref=bartoszsypytkowski.com" rel="noopener" class="external-link" href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-5.0&amp;ref=bartoszsypytkowski.com" target="_blank">Interlocked</a> classes. We can use first to make sure that our reads and writes are invalidating field values that might be accidentally reordered or cached by other CPU cores. Just like .NET runtime feels free to reorder our fields in defined types, it - of even CPU itself - can decide to reorder our operations if it deems it to be more efficient. The latter provides a set of operations, which can be executed within single processor instruction - without worrying that OS may decide to switch threads in between leaving our shared variable in undefined state.<br>The most powerful method in that toolbox is compare-and-swap in .NET known as Interlocked.CompareExchange, which enables to atomically swap register-sized value or reference to a new one, but only if the existing reference at the moment of swap is equal to expected one. What's important here, we're doing reference-based comparison (basically comparing pointer addresses), not structural one that we know as default in F#.<br>Now, here's how can we use that operation to replace locks:<br>let mutable map = Map.empty

let rec write k v =
  let prev = Volatile.Read &amp;map // read most up-to-date value
  let next = Map.add k v prev   // update operation
  if obj.ReferenceEquals(prev, Interlocked.CompareExchange(&amp;map, next, prev)) 
  then () // we successfully updated the map
  else write k v // retry
Copy<br>What we basically try to do is to retrieve the most recent value, update it and store back using Interlocked.CompareExchange. This operation returns a previously stored value, which should be the same reference as the one, we got prior to making an update. If it's different, it means that another thread concurrently swapped it while we were making an update. It's very rare situation, even when lock contention is fairly high, but if it happens, we just retry a whole operation.<br>Here, we're using Map.add but in practice this could be any function 't -&gt; 't, as long as it satisfies few conditions:<br>
<br>A reference returned by update function must be different than the input - otherwise our if expression will never be able to reach the stop condition. It's one reason, why we prefer immutable data types here.
<br>Update must be idempotent. In case of concurrent conflict, only one of the sides will win, while other will have to repeat, and we don't want to i.e. insert the same item to our list multiple times. That's another reason for using immutable collections.
<br>Update action should be fairly fast. No I/O operations, no number crunching. The longer it takes to execute, the less useful this pattern becomes, as risk of retries grows and their cost may outweigh the cost of acquiring the lock.
<br>All of this puts some strong restrictions on the code that can be used with this pattern, nonetheless it's still used pretty often - especially in combination with standard locking mechanism, where we first try to optimistically use Interlocked primitives to acquire fast locks and on failure fallback to heavier ones. This is how "slim" locks work as well as thread safe queues and unbounded channels (eg. BlockingQueue).<br><br>Inlining is a popular optimization technique, were instead of making function call, we directly emit function body in the outer function. This allows us to avoid costs like putting invocation arguments on the stack or jumps related to returning from function. In F# and .NET, there are several situations, where that happens:<br>
<br>F# function itself can be marked using inline attribute. This will trigger F# code to literally imprint the function body at the callsite. This means that encapsulation rules of such functions must respect .NET encapsulation (eg. you cannot have public inline function calling private function in its body). Like in many other languages, F# inline is optimistic - in some cases when function cannot be inlined eg. because it has been passed as parameter to another non-inlined function, inlining won't occur.
<br>Any function can be forced to be inlined at runtime level by using [&lt;MethodImpl(MethodImplOptions.AggressiveInlining)&gt;] attribute. It will tell JIT to emit machine code directly at callsite. This option does not have limitations of F# inline keyword, however it's not always able to introduce some of the optimizations, F# compiler is capable of.
<br>Most of the time inlining happens without our precise knowledge. It can be done by the JIT compiler itself over any function not marked with [&lt;MethodImpl(MethodImplOptions.NoInlining)&gt;] attribute. It's based on a set of heuristic rules, one of which being size of the calling and called functions body - the smaller they are, the higher chance for inlining to happen. Additionally at the current moment, code that explicitly throws an exception is prevented from being inlined at JIT level, so using NoInlining option can also improve speed of your code in some cases - most popular being exception-driven input assertions inside of functions.
<br>As I mentioned, F# inline sometimes can apply optimizations outside of the scope of JIT optimizer alone. Let's take an example:<br>type AtomicRef&lt;'t when 't: not struct&gt;(initValue: 't) =
  let mutable value = initValue
  member this.Value with [&lt;MethodImpl(MethodImplOptions.AggressiveInlining)&gt;] get () = Volatile.Read &amp;value
    
  [&lt;MethodImpl(MethodImplOptions.AggressiveInlining)&gt;]
  member this.CompareAndSwap(comparand: 't, newValue: 't): bool =
    obj.ReferenceEquals(comparand, Interlocked.CompareExchange(&amp;value, newValue, comparand))
Copy<br>This type is going to present behavior similar to F# ref cell, with the difference that its operations are going to be thread safe in the same sense we described in <a data-tooltip-position="top" aria-label="https://www.bartoszsypytkowski.com/writing-high-performance-f-code/#atomiccompareandswap" rel="noopener" class="external-link" href="https://www.bartoszsypytkowski.com/writing-high-performance-f-code/#atomiccompareandswap" target="_blank">atomic compare-and-swap section</a>. Now imagine, that we'd like to have a generic updating mechanism:<br>module Atomic

let update (modify: 't -&gt; 't) (atom: AtomicRef&lt;'t&gt;) =
  let mutable old = atom.Value
  let mutable newValue = modify old
  while not (atom.CompareAndSwap(old, newValue)) do
    old &lt;- atom.Value
    newValue &lt;- modify old
  newValue
Copy<br>With this we can atomically modify a value within the cell. We could leave it like this, but if you'll benchmark an exemplar snippet like this:<br>// benchmark setup
val a = AtomicRef "hello"
val value = "world"

// benchmarked function body
a |&gt; Atomic.update (fun _ -&gt; value)
Copy<br>You'd discover that this call allocates - It's a result of passing a function argument (in .NET these are realized as objects), that captures value field. Now, we could try to mark Atomic.update function using [&lt;MethodImpl&gt;] attribute or use inline keyword. If we'd try to benchmark these however, the results would be slightly different:<br><br>You may notice, that using attribute might slightly improve speed, but didn't change anything in terms of allocations around capturing lambda parameter. However using F# inline keyword indeed helped here: a lambda argument has been erased, as its behavior was aggressively printed together with inlined function body.<br><br>It's been a long post, but we just touched a tip of an iceberg here. We're didn't really mention optimizations in the area of I/O operations, different flavors of async code execution or <a data-tooltip-position="top" aria-label="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.unsafe?view=net-5.0&amp;ref=bartoszsypytkowski.com" rel="noopener" class="external-link" href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.unsafe?view=net-5.0&amp;ref=bartoszsypytkowski.com" target="_blank">dropping .NET safety belt</a> in cases when we wish to omit safe checks even when .NET compiler alone could not. There are also many tricky situations in which one small, seemingly insignificant change in code can throw .NET runtime into pit of deoptimized code. If you're curious about these, you can follow <a data-tooltip-position="top" aria-label="https://twitter.com/badamczewski01?ref=bartoszsypytkowski.com" rel="noopener" class="external-link" href="https://twitter.com/badamczewski01?ref=bartoszsypytkowski.com" target="_blank">Bartosz Adamczewski</a> on twitter.<br>Ultimately, while many of these tips and behaviors may stay with us for years to come, remember that compilers are still actively developed and just like some of these optimizations are not applied on older runtimes like .NET Full Framework, new ones (like smarter escape analysis, new devirtualization rules etc.) may turn some of the warnings presented here obsolete and shift the optimization techniques to enable us writing code that's both fast and high-level.]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/fsharp/writing-high-performance-fsharp-code.html</link><guid isPermaLink="false">Computer Science/Programming Language/FSharp/Writing high performance Fsharp code.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sat, 11 May 2024 13:31:40 GMT</pubDate><enclosure url="https://www.bartoszsypytkowski.com/content/images/2021/02/class-vs-struct-layout.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://www.bartoszsypytkowski.com/content/images/2021/02/class-vs-struct-layout.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[OCaml News 2023 - 3]]></title><description><![CDATA[ 
 <br>o-æ–°é²œäº‹å„¿<br>
<br>
<a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/ocaml-5-1-0-released/13021" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/ocaml-5-1-0-released/13021" target="_blank">OCaml 5.1.0 released</a><br>


<br>
<a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/ann-dune-3-14/14096" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/ann-dune-3-14/14096" target="_blank">[ANN] dune 3.14</a>

<br>
<a data-tooltip-position="top" aria-label="https://ocaml.codes/search/" rel="noopener" class="external-link" href="https://ocaml.codes/search/" target="_blank">code search</a><br>


<br>
<a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/ann-ocaml-codes-code-search-for-opam-packages/14092" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/ann-ocaml-codes-code-search-for-opam-packages/14092" target="_blank">[ANN] ocaml.codes, code search for OPAM packages</a><br>


<br>
ç”¨ livegrep åŸºäº opam åŒ…çš„æºç åšçš„ä»£ç æœç´¢ï¼Œè¿˜æŒºæ–¹ä¾¿çš„ã€‚

<br>
<a data-tooltip-position="top" aria-label="https://melange.re/blog/posts/announcing-melange-3" rel="noopener" class="external-link" href="https://melange.re/blog/posts/announcing-melange-3" target="_blank">Announcing Melange 3</a><br>


<br>
<a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/ann-melange-3-0/14102" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/ann-melange-3-0/14102" target="_blank">[ANN] Melange 3.0</a>

<br>
<a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/learn-ocaml-1-0-is-out/14100" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/learn-ocaml-1-0-is-out/14100" target="_blank">Learn-OCaml 1.0 is out!</a><br>


<br>
<a rel="noopener" class="external-link" href="https://ocaml-sf.org/learn-ocaml-public/" target="_blank">https://ocaml-sf.org/learn-ocaml-public/</a>

<br>
<a data-tooltip-position="top" aria-label="https://github.com/owlbarn/owl" rel="noopener" class="external-link" href="https://github.com/owlbarn/owl" target="_blank">GitHub - owlbarn/owl: Owl - OCaml Scientific Computing @ http://ocaml.xyz</a><br>


<br>
<a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/owl-project-concluding/14117" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/owl-project-concluding/14117" target="_blank">Owl project concluding</a><br>


<br>
ç»è¿‡å…«å¹´çš„ç»´æŠ¤ï¼ŒOwlé¡¹ç›®å³å°†ç»ˆæ­¢<br>


<br><br>o-è§†é¢‘<br>
<br><a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=jvQ7fj9LlVA" rel="noopener" class="external-link" href="https://www.youtube.com/watch?v=jvQ7fj9LlVA" target="_blank">Inferring Locality in OCaml | OCaml Unboxed</a><br>

<br><a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=AGu4AO5zO8o" rel="noopener" class="external-link" href="https://www.youtube.com/watch?v=AGu4AO5zO8o" target="_blank">OCaml Locals Save Allocations | OCaml Unboxed</a><br>

<br><a data-tooltip-position="top" aria-label="https://watch.ocaml.org/w/qQzb94X9WM7zLif7FynPyN" rel="noopener" class="external-link" href="https://watch.ocaml.org/w/qQzb94X9WM7zLif7FynPyN" target="_blank">Ocsigen: Developing Web and mobile applications in OCaml â€“ JÃ©rÃ´me Vouillon &amp; Vincent Balat</a><br>

<br><a data-tooltip-position="top" aria-label="https://watch.ocaml.org/w/iQNqZzA8gVmd4RQaycAwx4" rel="noopener" class="external-link" href="https://watch.ocaml.org/w/iQNqZzA8gVmd4RQaycAwx4" target="_blank">Verifying an Effect-Based Cooperative Concurrency Scheduler in Iris by Adrian Dapprich</a><br>

<br><br>o-åšå®¢ / æ–‡ç«  / å¸–å­<br>
<br>
<a data-tooltip-position="top" aria-label="https://priver.dev/blog/dbcaml/dbcaml/" rel="noopener" class="external-link" href="https://priver.dev/blog/dbcaml/dbcaml/" target="_blank">Introducing DBCaml, Database toolkit for OCaml</a><br>


<br>
<a data-tooltip-position="top" aria-label="https://priver.dev/blog/dbcaml/building-a-connnection-pool/" rel="noopener" class="external-link" href="https://priver.dev/blog/dbcaml/building-a-connnection-pool/" target="_blank">Building a Connnection Pool for DBCaml on top of riot</a>

<br>
<a data-tooltip-position="top" aria-label="https://ocamlpro.com/blog/2021_09_02_generating_static_and_portable_executables_with_ocaml/" rel="noopener" class="external-link" href="https://ocamlpro.com/blog/2021_09_02_generating_static_and_portable_executables_with_ocaml/" target="_blank">Generating static and portable executables with OCaml</a><br>


<br>
OCamlç¼–è¯‘å™¨æ²¡æœ‰å†…ç½®ç”Ÿæˆé™æ€å¯ç§»æ¤å¯æ‰§è¡Œæ–‡ä»¶çš„ç‰¹æ€§ï¼Œè¿™é‡Œæåˆ°äº†ä¸€äº›æŠ€å·§

<br>
<a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/analog-of-promise-any-for-multicore-ocaml/14145" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/analog-of-promise-any-for-multicore-ocaml/14145" target="_blank">Analog of Promise.any() for Multicore OCaml</a><br>


<br>
<a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/printf-vs-format/14130" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/printf-vs-format/14130" target="_blank">Printf vs. Format?</a><br>


<br>
<a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/how-to-represent-tuples-in-ast/14095" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/how-to-represent-tuples-in-ast/14095" target="_blank">How to represent tuples in AST?</a><br>


<br>
<a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/how-do-i-pass-an-unsigned-char-an-array-of-bytes-representing-binary-data-from-c-to-ocaml/14074" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/how-do-i-pass-an-unsigned-char-an-array-of-bytes-representing-binary-data-from-c-to-ocaml/14074" target="_blank">How do I pass an unsigned char * (an array of bytes representing binary data) from C to OCaml?</a><br>


<br><br>o-æœªæ¥<br>
<br>
<a data-tooltip-position="top" aria-label="https://docs.google.com/forms/d/e/1FAIpQLSe1U_5KanTeKt1h9t5vjYohYXepXDhPCru4tsms4OcI5k0Fkw/viewform?pli=1" rel="noopener" class="external-link" href="https://docs.google.com/forms/d/e/1FAIpQLSe1U_5KanTeKt1h9t5vjYohYXepXDhPCru4tsms4OcI5k0Fkw/viewform?pli=1" target="_blank">How do we want to present OCaml to the World on OCaml.org?</a><br>


<br>
ä¸€ä¸ªé—®å·ï¼Œç”¨äºæ›´å¥½çš„æ”¹è¿› <a data-tooltip-position="top" aria-label="http://ocaml.org/" rel="noopener" class="external-link" href="http://ocaml.org/" target="_blank">ocaml.org</a> æœ‰å…³å­¦æœ¯å’Œå·¥ä¸šåº”ç”¨æ¿å—çš„å†…å®¹ã€‚

<br>
<a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/feedback-help-wanted-upcoming-ocaml-org-cookbook-feature/14127" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/feedback-help-wanted-upcoming-ocaml-org-cookbook-feature/14127" target="_blank">Feedback / Help Wanted: Upcoming OCaml.org Cookbook Feature</a><br>


<br>
<a data-tooltip-position="top" aria-label="http://ocaml.org/" rel="noopener" class="external-link" href="http://ocaml.org/" target="_blank">ocaml.org</a> å‡†å¤‡ä¸Šçº¿ä¸€ä¸ªcookbooké¡µé¢ï¼Œæ”¾ä¸€äº›å¦‚ä½•ç”¨OCamlçš„ç”Ÿæ€è§£å†³å¸¸è§éœ€æ±‚çš„èµ„æº

<br>
<a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/state-of-compaction-in-ocaml-5/14121/1" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/state-of-compaction-in-ocaml-5/14121/1" target="_blank">State of compaction in OCaml 5?</a><br>


<br>
OCaml 5.2 çš„ compact heap ä¼šå°†æœªä½¿ç”¨çš„å†…å­˜è¿”å›ç»™æ“ä½œç³»ç»Ÿã€‚åœ¨ OCaml 5 çš„ GC ä¸­ï¼Œå°äº 128byte çš„å—ç”¨å¤§å°éš”ç¦»æ± è¿›è¡Œç®¡ç†ï¼Œæ¯”å¦‚æœ‰ä¸€ä¸ªæ± ï¼Œå¤„ç†å¤§å°ä¸º 3byte çš„åˆ†é…ï¼Œå¦ä¸€ä¸ªæ± å¤„ç†å¤§å°ä¸º 4byte çš„åˆ†é…ç­‰ç­‰ï¼Œè¿™æ ·çš„æ± åœ¨æ¯ä¸ªDomainé‡Œéƒ½æœ‰ã€‚ç”¨è¿™ä¸ªæ–¹æ³•åˆ†é…é€Ÿåº¦å¾ˆå¿«ï¼Œå› ä¸ºä¸ç”¨æ‰¾åˆé€‚çš„å†…å­˜é—´éš™äº†ï¼Œåªè¦æ‰¾æ­£ç¡®çš„æ± å¤§å°å°±è¡Œã€‚<br>


<br><br>o-å€¼å¾—è¢«æ³¨æ„çš„é¡¹ç›®<br>
<br>
<a data-tooltip-position="top" aria-label="https://github.com/mbarbin/vcs" rel="noopener" class="external-link" href="https://github.com/mbarbin/vcs" target="_blank">GitHub - mbarbin/vcs: A versatile OCaml library for Git interaction</a><br>


<br>
<a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/a-versatile-ocaml-library-for-git-interaction-seeking-community-feedback/14155" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/a-versatile-ocaml-library-for-git-interaction-seeking-community-feedback/14155" target="_blank">A Versatile OCaml Library for Git Interaction - Seeking Community Feedback</a>

<br>
<a data-tooltip-position="top" aria-label="https://github.com/dbcaml/dbcaml" rel="noopener" class="external-link" href="https://github.com/dbcaml/dbcaml" target="_blank">GitHub - dbcaml/dbcaml: DBCaml is a database library for OCaml</a><br>


<br>
<a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/dbcaml-a-new-database-toolkit-built-on-riot/14150" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/dbcaml-a-new-database-toolkit-built-on-riot/14150" target="_blank">DBcaml, a new database toolkit built on Riot</a>

<br>
<a data-tooltip-position="top" aria-label="https://github.com/c-cube/fuseau" rel="noopener" class="external-link" href="https://github.com/c-cube/fuseau" target="_blank">GitHub - c-cube/fuseau: [alpha] lightweight fiber library for OCaml 5</a><br>


<br>
<a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/ann-fuseau-0-1/14157" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/ann-fuseau-0-1/14157" target="_blank">[ANN] fuseau 0.1</a>

<br>
<a data-tooltip-position="top" aria-label="https://github.com/issuu/ocaml-protoc-plugin" rel="noopener" class="external-link" href="https://github.com/issuu/ocaml-protoc-plugin" target="_blank">GitHub - issuu/ocaml-protoc-plugin: ocaml-protoc-plugin</a><br>


<br>
<a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/taking-over-maintanence-of-a-stale-project/14156" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/taking-over-maintanence-of-a-stale-project/14156" target="_blank">Taking over maintanence of a stale project</a>

<br>
<a data-tooltip-position="top" aria-label="https://github.com/darrenldl/docfd" rel="noopener" class="external-link" href="https://github.com/darrenldl/docfd" target="_blank">GitHub - darrenldl/docfd: TUI multiline fuzzy document finder</a><br>


<br>
<a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/ann-docfd-tui-multiline-fuzzy-document-finder-2-2-0/14109/1" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/ann-docfd-tui-multiline-fuzzy-document-finder-2-2-0/14109/1" target="_blank">[ANN] Docfd: TUI multiline fuzzy document finder 2.2.0</a>

]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/ocaml/ocaml-news/ocaml-news-2023-3.html</link><guid isPermaLink="false">Computer Science/Programming Language/OCaml/OCaml News/OCaml News 2023 - 3.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sat, 23 Mar 2024 03:28:01 GMT</pubDate></item><item><title><![CDATA[OCaml News 2024 - 1]]></title><description><![CDATA[ 
 <br><br>
<br><a data-tooltip-position="top" aria-label="https://tarides.com/blog/2023-12-20-ocaml-survey-developers-perception-interest-and-perceived-barriers/" rel="noopener" class="external-link" href="https://tarides.com/blog/2023-12-20-ocaml-survey-developers-perception-interest-and-perceived-barriers/" target="_blank">OCaml Survey: Developers' Perception, Interest, and Perceived Barriers</a>
<br><a data-tooltip-position="top" aria-label="https://tarides.com/blog/2023-12-29-announcing-the-orchide-project-powering-satellite-innovation/" rel="noopener" class="external-link" href="https://tarides.com/blog/2023-12-29-announcing-the-orchide-project-powering-satellite-innovation/" target="_blank">Announcing the ORCHIDE Project: Powering Satellite Innovation</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/ocaml/ocaml/pull/12885" rel="noopener" class="external-link" href="https://github.com/ocaml/ocaml/pull/12885" target="_blank">Dynarrays, unboxed (with local dummies) #12885</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/ocaml/ocaml/pull/12871" rel="noopener" class="external-link" href="https://github.com/ocaml/ocaml/pull/12871" target="_blank">Stdlib priority queues #12871</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/ocaml/ocaml/pull/12596" rel="noopener" class="external-link" href="https://github.com/ocaml/ocaml/pull/12596" target="_blank">Compile recursive bindings in Lambda #12596</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/ocaml/ocaml/pull/12828" rel="noopener" class="external-link" href="https://github.com/ocaml/ocaml/pull/12828" target="_blank">Add short syntax for dependent functor types #12828</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/ocaml/ocaml/pull/12508" rel="noopener" class="external-link" href="https://github.com/ocaml/ocaml/pull/12508" target="_blank">[shapes] Add support for project-wide occurrences #12508</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/ocaml/ocaml/pull/1802" rel="noopener" class="external-link" href="https://github.com/ocaml/ocaml/pull/1802" target="_blank">Make the character set for OCaml source code officially UTF-8. #1802</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/ocaml/ocaml/pull/12719" rel="noopener" class="external-link" href="https://github.com/ocaml/ocaml/pull/12719" target="_blank">Add thread local storage #12719</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=zG7JejHlQoM" rel="noopener" class="external-link" href="https://www.youtube.com/watch?v=zG7JejHlQoM" target="_blank">"Melange: The next frontier in type-safe web development" by Dillon Mulroy - RVAJS 2023</a>
<br><a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=R-XJzUrP7bQ" rel="noopener" class="external-link" href="https://www.youtube.com/watch?v=R-XJzUrP7bQ" target="_blank">Trying out OCaml TUI framework Mint Tea!</a>
<br><a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=XyDbG9FGR1o" rel="noopener" class="external-link" href="https://www.youtube.com/watch?v=XyDbG9FGR1o" target="_blank">A TUI chat in OCaml ğŸ«</a>
<br>[Building a Game Engine... with OCaml ?! [Part 1]](<a rel="noopener" class="external-link" href="https://www.youtube.com/watch?v=1XpUaTnssQE" target="_blank">https://www.youtube.com/watch?v=1XpUaTnssQE</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://sancho.dev/blog/whats-possible-with-melange" rel="noopener" class="external-link" href="https://sancho.dev/blog/whats-possible-with-melange" target="_blank">What's possible with Melange</a>
<br><a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/access-inferred-types/13805" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/access-inferred-types/13805" target="_blank">Access inferred types</a>
<br><a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/using-menhir-to-parse-into-idiomatic-js-typescript-structures/13809" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/using-menhir-to-parse-into-idiomatic-js-typescript-structures/13809" target="_blank">Using Menhir to parse into idiomatic JS (TypeScript) structures</a>
<br><a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/why-constructors-are-not-curried/13792" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/why-constructors-are-not-curried/13792" target="_blank">Why constructors are not curried?</a>
<br><a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/practical-example-of-applicative-vs-generative-functors/13777" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/practical-example-of-applicative-vs-generative-functors/13777" target="_blank">Practical example of applicative vs generative functors?</a>
<br><a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/compiler-optimization-on-flattening-adt-for-less-boxing/13764" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/compiler-optimization-on-flattening-adt-for-less-boxing/13764" target="_blank">Compiler optimization on flattening ADT for less boxing?</a>
<br><a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/how-to-express-koka-home-page-example/13748" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/how-to-express-koka-home-page-example/13748" target="_blank">How to express Koka home page example?</a>
<br><a data-tooltip-position="top" aria-label="https://practicalocaml.com/parsing-with-binary-string-pattern-matching/" rel="noopener" class="external-link" href="https://practicalocaml.com/parsing-with-binary-string-pattern-matching/" target="_blank">Parsing with Binary String Pattern Matching</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://github.com/backtracking/grid" rel="noopener" class="external-link" href="https://github.com/backtracking/grid" target="_blank">grid: A tiny library for two-dimensional arrays</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/leostera/minttea" rel="noopener" class="external-link" href="https://github.com/leostera/minttea" target="_blank">A fun little TUI framework for OCaml</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/terrateamio/ocaml-ts-mode" rel="noopener" class="external-link" href="https://github.com/terrateamio/ocaml-ts-mode" target="_blank">ocaml-ts-mode: Ocaml mode for emacs using treesitter</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/dmmulroy/create-melange-app" rel="noopener" class="external-link" href="https://github.com/dmmulroy/create-melange-app" target="_blank">create-melange-app: An example app created by create-melange-app</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/andersfugmann/ppx_protocol_conv" rel="noopener" class="external-link" href="https://github.com/andersfugmann/ppx_protocol_conv" target="_blank">ppx_protocol_conv: Pluggable serialization and deserialization of ocaml data strucures based on type_conv</a>
<br><a data-tooltip-position="top" aria-label="https://spatial-shell.app/" rel="noopener" class="external-link" href="https://spatial-shell.app/" target="_blank">spatial-shell: Spatial Shell is a daemon implementing a spatial model inspired by Material Shell, for i3 and sway. More precisely, it organizes your windows within a grid whose rows are the workspaces of your favorite WM.</a>
<br><a data-tooltip-position="top" aria-label="https://codeberg.org/marcc/fixgen" rel="noopener" class="external-link" href="https://codeberg.org/marcc/fixgen" target="_blank">Fixgen: A language agnostic fixture generator</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/tweag/opam-nix" rel="noopener" class="external-link" href="https://github.com/tweag/opam-nix" target="_blank">opam-nix: Turn opam-based OCaml projects into Nix derivations</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/leostera/blink" rel="noopener" class="external-link" href="https://github.com/leostera/blink" target="_blank">Blink: A pure OCaml HTTP client for Riot</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/leostera/colors" rel="noopener" class="external-link" href="https://github.com/leostera/colors" target="_blank">colors: A pure OCaml library for manipulating colors in different color spaces.</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/nationalarchives/miiify" rel="noopener" class="external-link" href="https://github.com/nationalarchives/miiify" target="_blank">miilfy: A web annotation server built with the same principles as Git</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://github.com/leostera/riot" rel="noopener" class="external-link" href="https://github.com/leostera/riot" target="_blank">Roit v0.0.7: An actor-model multi-core scheduler for OCaml 5 ğŸ«</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/leostera/castore" rel="noopener" class="external-link" href="https://github.com/leostera/castore" target="_blank">CAStore: A portable pure OCaml CA Store, with no dependencies, inspired by Elixir's [:castore](https://github.com/elixir-mint/castore).</a>
<br><a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/learn-ocaml-1-0-approaching-call-for-testers/13621" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/learn-ocaml-1-0-approaching-call-for-testers/13621" target="_blank">Lean-OCaml 1.0: A Web Application for Learning OCaml</a>
<br><a data-tooltip-position="top" aria-label="https://erratique.ch/software/cmarkit" rel="noopener" class="external-link" href="https://erratique.ch/software/cmarkit" target="_blank">cmarkit 0.3.0" CommonMark parser and renderer for OCaml</a>
<br><a data-tooltip-position="top" aria-label="https://ocaml.org/p/dream-html/latest" rel="noopener" class="external-link" href="https://ocaml.org/p/dream-html/latest" target="_blank">dream-html 2.0.0: A library for generating HTML</a>
<br><a data-tooltip-position="top" aria-label="https://git.frama-c.com/pub/caisar/" rel="noopener" class="external-link" href="https://git.frama-c.com/pub/caisar/" target="_blank">Caisar: A platform under active development at CEA LIST, aiming to provide a wide range of features to characterize the safety and robustness of artificial intelligence based software.</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/jserot/rfsm" rel="noopener" class="external-link" href="https://github.com/jserot/rfsm" target="_blank">RFSM 2.0: A toolset for describing and simulating StateChart-like state diagrams.</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/chshersh/zbg/tree/main" rel="noopener" class="external-link" href="https://github.com/chshersh/zbg/tree/main" target="_blank">Zbg 2.0: <code></code> (short for <strong></strong>ero <strong></strong>ullshit <strong></strong>it) is a CLI tool for using <code></code> efficiently.</a>zbgZBGgit
]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/ocaml/ocaml-news/ocaml-news-2024-1.html</link><guid isPermaLink="false">Computer Science/Programming Language/OCaml/OCaml News/OCaml News 2024 - 1.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Mon, 08 Jan 2024 10:28:31 GMT</pubDate></item><item><title><![CDATA[OCaml News 2024 - 2]]></title><description><![CDATA[ 
 <br><br>
<br><a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/ann-preview-play-with-project-wide-occurrences-for-ocaml/13814" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/ann-preview-play-with-project-wide-occurrences-for-ocaml/13814" target="_blank">[ANN][PREVIEW] Play with project-wide occurrences for OCaml!</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/ocaml/dune/pull/8784" rel="noopener" class="external-link" href="https://github.com/ocaml/dune/pull/8784" target="_blank">[Dune]: Add link flags ocamlmklib when using ctypes stubs. #8784</a>
<br><a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/ocaml-software-foundation-january-2024-update/13828" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/ocaml-software-foundation-january-2024-update/13828" target="_blank">OCaml Software Foundation: January 2024 update</a>
<br>[Apprendre Ã  programmer avec OCaml](Apprendre Ã  programmer avec OCaml)
<br><a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/call-for-speakers-for-the-2024-carolina-code-conference-is-open-until-april-15th/13827" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/call-for-speakers-for-the-2024-carolina-code-conference-is-open-until-april-15th/13827" target="_blank">[Call for Speakers for the 2024 Carolina Code Conference is open until April 15th](https://discuss.ocaml.org/t/call-for-speakers-for-the-2024-carolina-code-conference-is-open-until-april-15th/13827)</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/ocaml/ocaml/discussions/11924" rel="noopener" class="external-link" href="https://github.com/ocaml/ocaml/discussions/11924" target="_blank">[OCaml]: feature request: better errors #11924</a>
<br><a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/ocsigen-summary-of-recent-releases/13817" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/ocsigen-summary-of-recent-releases/13817" target="_blank">Ocsigen: summary of recent releases</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/benchmark-between-open-addressing-and-closed-addressing-hashtbl/13882" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/benchmark-between-open-addressing-and-closed-addressing-hashtbl/13882" target="_blank">Benchmark between open-addressing and closed-addressing hashtbl</a>
<br><a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/examples-of-caqti-infix/13878" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/examples-of-caqti-infix/13878" target="_blank">Examples of Caqti infix?</a>
<br><a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/why-can-t-i-create-a-project-with-non-ascii-characters/13865" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/why-can-t-i-create-a-project-with-non-ascii-characters/13865" target="_blank">Why canâ€™t I create a project with non-ASCII characters? </a>
<br><a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/old-self-taught-vs-uni-debate-landscape-for-former-jane-street/13851" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/old-self-taught-vs-uni-debate-landscape-for-former-jane-street/13851" target="_blank">Old self-taught vs. uni debate; Landscape for former; Jane Street</a>
<br><a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/toml-file-parser/13854" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/toml-file-parser/13854" target="_blank">Is there an easy way to read the values from a toml file?</a>
<br><a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/generate-typed-ast-fragments/13824" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/generate-typed-ast-fragments/13824" target="_blank">Generate typed AST fragments</a>
<br><a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/partially-apply-function-accepting-multiple-modules-and-keep-polymorphic-types/13823" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/partially-apply-function-accepting-multiple-modules-and-keep-polymorphic-types/13823" target="_blank">Partially apply function accepting multiple modules and keep polymorphic types</a>
<br><a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/printing-unicode-characters-on-different-platforms/13813" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/printing-unicode-characters-on-different-platforms/13813" target="_blank">Printing Unicode Characters on Different Platforms</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://watch.ocaml.org/w/iQNqZzA8gVmd4RQaycAwx4" rel="noopener" class="external-link" href="https://watch.ocaml.org/w/iQNqZzA8gVmd4RQaycAwx4" target="_blank">Verifying an Effect-Based Cooperative Concurrency Scheduler in Iris by Adrian Dapprich</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/advice-for-combining-multiple-monads/10409" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/advice-for-combining-multiple-monads/10409" target="_blank">Advice for combining multiple monads</a>
<br><a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/writing-ctypes-bindings-to-system-shared-libraries-for-bytecode-targets-via-the-dune-ctypes-stanza/13844" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/writing-ctypes-bindings-to-system-shared-libraries-for-bytecode-targets-via-the-dune-ctypes-stanza/13844" target="_blank">Writing ctypes bindings to system shared libraries for bytecode targets via the dune ctypes stanza</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://github.com/johnyob/grace" rel="noopener" class="external-link" href="https://github.com/johnyob/grace" target="_blank">Grace: A fancy diagnostics library that allows your compilers to exit with grace</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/thierry-martinez/metapp" rel="noopener" class="external-link" href="https://github.com/thierry-martinez/metapp" target="_blank">meta-pp: Meta-preprocessor for OCaml</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/stedolan/ppx_stage" rel="noopener" class="external-link" href="https://github.com/stedolan/ppx_stage" target="_blank">ppx_stage: Staged metaprogramming in stock OCaml</a>
<br><a data-tooltip-position="top" aria-label="https://erratique.ch/software/cmarkit" rel="noopener" class="external-link" href="https://erratique.ch/software/cmarkit" target="_blank">Cmarkit is an [OCaml](http://ocaml.org) libary for parsing the [CommonMark](https://spec.commonmark.org/) specification.</a>
<br><a data-tooltip-position="top" aria-label="https://erratique.ch/software/brr" rel="noopener" class="external-link" href="https://erratique.ch/software/brr" target="_blank">Brr is a toolkit for programming browsers in [OCaml](http://ocaml.org) with the [js_of_ocaml](http://ocsigen.org/js_of_ocaml/) compiler. It provides:</a>
<br><a data-tooltip-position="top" aria-label="https://erratique.ch/software/zipc" rel="noopener" class="external-link" href="https://erratique.ch/software/zipc" target="_blank">Zipc is an in-memory [ZIP](https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT) archive and [deflate](https://www.rfc-editor.org/rfc/rfc1951) compression codec for [OCaml](http://ocaml.org).</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/lukstafi/ocaml-gccjit" rel="noopener" class="external-link" href="https://github.com/lukstafi/ocaml-gccjit" target="_blank">ocaml-gccjit: OCaml bindings for libgccjit</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/whitequark/ocaml-m17n" rel="noopener" class="external-link" href="https://github.com/whitequark/ocaml-m17n" target="_blank">ocaml-m17n: Multilingualization for the OCaml source code</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/hackwaly/ocamlearlybird" rel="noopener" class="external-link" href="https://github.com/hackwaly/ocamlearlybird" target="_blank">ocamlearlybird: OCaml debug adapter</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/dmbaturin/otoml" rel="noopener" class="external-link" href="https://github.com/dmbaturin/otoml" target="_blank">otoml: TOML parsing, manipulation, and pretty-printing library for OCaml (fully 1.0.0-compliant)</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/mattjbray/ocaml-decoders" rel="noopener" class="external-link" href="https://github.com/mattjbray/ocaml-decoders" target="_blank">ocaml-decoders: Elm-inspired decoders for Ocaml</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/OCamlPro/ez_toml" rel="noopener" class="external-link" href="https://github.com/OCamlPro/ez_toml" target="_blank">ez_toml: A library to parse and print TOML files</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="http://cambium.inria.fr/~fpottier/oma/doc/oma/Oma/index.html" rel="noopener" class="external-link" href="http://cambium.inria.fr/~fpottier/oma/doc/oma/Oma/index.html" target="_blank">Oma: OCaml implementation of 'Two Simplified Algorithms for Maintaining Order in a List'</a>

<br><a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/ann-first-release-of-oma/13845" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/ann-first-release-of-oma/13845" target="_blank">[ANN] First release of oma</a>
<br><a data-tooltip-position="top" aria-label="https://erikdemaine.org/papers/DietzSleator_ESA2002/paper.pdf" rel="noopener" class="external-link" href="https://erikdemaine.org/papers/DietzSleator_ESA2002/paper.pdf" target="_blank">Two Simplified Algorithms for Maintaining Order in a List</a>


<br><a data-tooltip-position="top" aria-label="https://github.com/hackwaly/ocamlearlybird" rel="noopener" class="external-link" href="https://github.com/hackwaly/ocamlearlybird" target="_blank">ocamlearlybird: v1.3.0</a>

<br><a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/ann-ocamlearlybird-just-got-ability-to-inspect-opaque-abstract-values/13852" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/ann-ocamlearlybird-just-got-ability-to-inspect-opaque-abstract-values/13852" target="_blank">[ANN] Ocamlearlybird just got ability to inspect opaque/abstract values</a>


<br><a data-tooltip-position="top" aria-label="https://github.com/Axot017/validate" rel="noopener" class="external-link" href="https://github.com/Axot017/validate" target="_blank">validate: OCaml Data Validation library</a>

<br><a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/ann-validate-a-new-library-for-data-validation/13861" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/ann-validate-a-new-library-for-data-validation/13861" target="_blank">[ANN] Validate - A New Library for Data Validation</a>


<br><a data-tooltip-position="top" aria-label="https://github.com/gborough/sarif" rel="noopener" class="external-link" href="https://github.com/gborough/sarif" target="_blank">sarif v2.1.0: Static Analysis Results Interchange Format (SARIF) For OCaml</a>

<br><a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/ann-sarif-0-1-0-static-analysis-results-interchange-format-sarif-for-ocaml/13821" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/ann-sarif-0-1-0-static-analysis-results-interchange-format-sarif-for-ocaml/13821" target="_blank">[ANN] sarif 0.1.0 - Static Analysis Results Interchange Format (SARIF) For OCaml</a>


<br><a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/ann-new-release-of-menhir-20231231/13816" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/ann-new-release-of-menhir-20231231/13816" target="_blank">[ANN] New release of Menhir (20231231)</a>
]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/ocaml/ocaml-news/ocaml-news-2024-2.html</link><guid isPermaLink="false">Computer Science/Programming Language/OCaml/OCaml News/OCaml News 2024 - 2.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Thu, 18 Jan 2024 03:39:20 GMT</pubDate></item><item><title><![CDATA[OCaml News 2024 - 6]]></title><description><![CDATA[ 
 <br>       ^o3
~/\_/\_|)
|/=_=\|
"     "
Copy<br><br>
<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/13275" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/13275" target="_blank">Modular explicits #13275</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/12828" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/12828" target="_blank">Add short syntax for dependent functor types #12828</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/13310" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/13310" target="_blank">Add Pair module to standard library #13310</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/13272" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/13272" target="_blank">Allow maximum number of domains to be specified as a OCAMLRUNPARAM parameter #13272</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/13097" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/13097" target="_blank">Immutable arrays #13097</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/13161" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/13161" target="_blank">Restore native armv7 support for NetBSD 10.0 #13161</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/12309" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/12309" target="_blank">Add effect syntax #12309</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/12114" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/12114" target="_blank">Add ThreadSanitizer support #12114</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/13195" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/13195" target="_blank">A new abstract data type of enumerations in Set.Make(Ord).Enum #13195</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/12871" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/12871" target="_blank">Stdlib priority queues #12871</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/9080" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/9080" target="_blank">Aliasing == and != with explicit names #9080</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/12964" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/12964" target="_blank">Memory cleanup at exit #12964</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/13169" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/13169" target="_blank">A document type for error messages #13169</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/13318" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/13318" target="_blank">Fix GC alarm regression #13318</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/13326" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/13326" target="_blank">Implement O_APPEND on windows #13326</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/13296" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/13296" target="_blank">Add missing functions from Array to Dynarray #13296</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/12182%23discussion_r1678134261" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/12182%23discussion_r1678134261" target="_blank">Improve the type clash error message #12182</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/12298" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//github.com/ocaml/ocaml/pull/12298" target="_blank">Emphasize that Bigarray.int refers to the OCaml int type, and not the C int type #12298</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//discuss.ocaml.org/t/effects-with-lwt-a-dead-end-for-now/15002" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//discuss.ocaml.org/t/effects-with-lwt-a-dead-end-for-now/15002" target="_blank">Effects with Lwt, a dead end for now?</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//discuss.ocaml.org/t/changes-in-handling-of-gc-parameters-and-alarms-in-5-2-0/14986" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//discuss.ocaml.org/t/changes-in-handling-of-gc-parameters-and-alarms-in-5-2-0/14986" target="_blank">Changes in handling of Gc parameters and alarms in 5.2.0</a>

<br><br>
<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//discuss.ocaml.org/t/ann-mopsa-1-0-modular-open-platform-for-static-analysis/15013" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//discuss.ocaml.org/t/ann-mopsa-1-0-modular-open-platform-for-static-analysis/15013" target="_blank">[ANN] Mopsa 1.0 -- Modular Open Platform for Static Analysis</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//discuss.ocaml.org/t/ann-a-small-extension-of-bigarray-genarray-adding-iteration-mapping-and-folding/15005" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//discuss.ocaml.org/t/ann-a-small-extension-of-bigarray-genarray-adding-iteration-mapping-and-folding/15005" target="_blank">[ANN] A small extension of Bigarray.Genarray adding iteration, mapping and folding</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//discuss.ocaml.org/t/ann-cudajit-bindings-to-the-cuda-and-nvrtc-libraries/15010" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//discuss.ocaml.org/t/ann-cudajit-bindings-to-the-cuda-and-nvrtc-libraries/15010" target="_blank">[ANN] cudajit: Bindings to the <code></code> and <code></code> libraries</a>cudanvrtc

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//discuss.ocaml.org/t/ann-ocaml-lsp-1-18-0/14952" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//discuss.ocaml.org/t/ann-ocaml-lsp-1-18-0/14952" target="_blank">[ANN] OCaml LSP 1.18.0</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//discuss.ocaml.org/t/ann-ortac-0-3-0-dynamic-formal-verification-made-easy/14936" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//discuss.ocaml.org/t/ann-ortac-0-3-0-dynamic-formal-verification-made-easy/14936" target="_blank">[ANN] Ortac 0.3.0 Dynamic formal verification made easy</a>

<br><br>
<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//hal.sorbonne-universite.fr/hal-02890500v1/document" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//hal.sorbonne-universite.fr/hal-02890500v1/document" target="_blank">Combinations of Reusable Abstract Domains for a Multilingual Static Analyzer</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//fizzixnerd.com/blog/2024-07-21-fixing-living/" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//fizzixnerd.com/blog/2024-07-21-fixing-living/" target="_blank">Fighting Mutation with Mutation in Living</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//discuss.ocaml.org/t/type-system-and-polymorphic-lets/14990" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//discuss.ocaml.org/t/type-system-and-polymorphic-lets/14990" target="_blank">Type system and polymorphic let's</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//discuss.ocaml.org/t/using-docusaurus-to-document-an-ocaml-project/13359" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//discuss.ocaml.org/t/using-docusaurus-to-document-an-ocaml-project/13359" target="_blank">Using Docusaurus to document an OCaml project</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//discuss.ocaml.org/t/exploring-the-docusaurus-odoc-combo/15012" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//discuss.ocaml.org/t/exploring-the-docusaurus-odoc-combo/15012" target="_blank">Exploring the Docusaurus+Odoc combo</a><a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//discuss.ocaml.org/t/type-system-and-polymorphic-lets/14990" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//discuss.ocaml.org/t/type-system-and-polymorphic-lets/14990" target="_blank">Type system and polymorphic let's</a><a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//discuss.ocaml.org/t/exploring-the-docusaurus-odoc-combo/15012" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//discuss.ocaml.org/t/exploring-the-docusaurus-odoc-combo/15012" target="_blank">Exploring the Docusaurus+Odoc combo</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//fizzixnerd.com/blog/2024-07-11-a-possibly-safer-interface-to-the-ctypes-ffi/" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//fizzixnerd.com/blog/2024-07-11-a-possibly-safer-interface-to-the-ctypes-ffi/" target="_blank">A (Possibly) Safer Interface to the Ctypes FFI</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//fizzixnerd.com/blog/2024-07-09-ocaml-ffi-sharp-edges-and-how-to-avoid-them/" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//fizzixnerd.com/blog/2024-07-09-ocaml-ffi-sharp-edges-and-how-to-avoid-them/" target="_blank">OCaml FFI Sharp Edges -- and How to Avoid them!</a>

<br><br>
<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//ocaml.libvirt.org/" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//ocaml.libvirt.org/" target="_blank">ocaml-libvirt OCaml bindings for libvirt</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//gitlab.com/mopsa/mopsa-analyzer/" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//gitlab.com/mopsa/mopsa-analyzer/" target="_blank">Gitlab - MOPSA/MOPSA analyzer: stands for Modular and Open Platform for Static Analysis.</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//github.com/Heyji2/GenArrayIter" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//github.com/Heyji2/GenArrayIter" target="_blank">GitHub - Heyji2/GenArrayIter: Adding iteration, mapping and folding to the ocaml BigArray.Genarrays module which provides arrays of arbitrary dimensions</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//github.com/mbarbin/bopkit" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//github.com/mbarbin/bopkit" target="_blank">GitHub - mbarbin/bopkit: An educational project for digital circuits programming</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//github.com/dx3mod/rpmfile" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//github.com/dx3mod/rpmfile" target="_blank">GitHub - dx3mod/rpmfile: A library for reading metadata from RPM packages.</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//github.com/gildor478/ocaml-fileutils" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//github.com/gildor478/ocaml-fileutils" target="_blank">Github - gildor478/ocaml-fileutils: OCaml API to manipulate real files (POSIX like) and filenames</a>

<br>
<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//github.com/NathanReb/ocaml-api-watch" rel="noopener" class="external-link" href="https://link.zhihu.com/?target=https%3A//github.com/NathanReb/ocaml-api-watch" target="_blank">Github - NathanReb/ocaml-api-watch: Libraries and tools to keep watch on you OCaml lib's API changes</a>

]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/ocaml/ocaml-news/ocaml-news-2024-6.html</link><guid isPermaLink="false">Computer Science/Programming Language/OCaml/OCaml News/OCaml News 2024 - 6.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Tue, 23 Jul 2024 09:35:59 GMT</pubDate></item><item><title><![CDATA[A hack to implement efficient TLS (thread-local-storage)]]></title><description><![CDATA[ 
 <br>Currently OCaml 5 provides a <a data-tooltip-position="top" aria-label="https://v2.ocaml.org/api/Domain.DLS.html" rel="noopener" class="external-link" href="https://v2.ocaml.org/api/Domain.DLS.html" target="_blank"><code></code> 2</a>Domain.DLS module for domain-local storage.<br>Unfortunately,<br>
<br><a data-tooltip-position="top" aria-label="https://github.com/ocaml/ocaml/issues/11770" rel="noopener" class="external-link" href="https://github.com/ocaml/ocaml/issues/11770" target="_blank">there is no corresponding <code></code> 7</a>Thread.TLS for (sys)thread-local storage, and
<br>the current implementation of Domain.DLS is not thread-safe.
<br>I donâ€™t want to spend time to motivate this topic, but for many of the use cases of Domain.DLS, what you actually want, is to use a Thread.TLS. IOW, many of the uses of Domain.DLS are probably â€œwrongâ€ and should actually use a Thread.TLS, because, when using Domain.DLS, the implicit assumption is often that you donâ€™t have multiple threads on the domain, but that is typically decided at a higher level in the application and so making such an assumption is typically not safe.<br><br>I mentioned that the current implementation of Domain.DLS is not thread-safe. What I mean by that is that <a data-tooltip-position="top" aria-label="https://github.com/ocaml/ocaml/issues/12677" rel="noopener" class="external-link" href="https://github.com/ocaml/ocaml/issues/12677" target="_blank">the current implementation is literally not thread-safe at all</a> in the sense that unrelated concurrent Domain.DLS accesses can actually break the DLS. That is because the state updates performed by Domain.DLS contain safe-points during which the OCaml runtime may switch between (sys)threads.<br>Consider <a data-tooltip-position="top" aria-label="https://github.com/ocaml/ocaml/blob/e397ed28bcef85fdc1f0f007af481ef201fb1fd7/stdlib/domain.ml#L120-L127" rel="noopener" class="external-link" href="https://github.com/ocaml/ocaml/blob/e397ed28bcef85fdc1f0f007af481ef201fb1fd7/stdlib/domain.ml#L120-L127" target="_blank">the implementation of <code></code> 1</a>Domain.DLS.get:<br>  let get (idx, init) =
    let st = maybe_grow idx in
    let v = st.(idx) in
    if v == unique_value then
      let v' = Obj.repr (init ()) in
      st.(idx) &lt;- (Sys.opaque_identity v');
      Obj.magic v'
    else Obj.magic v
Copy<br>If there are two (or more) threads on a single domain that concurrently call get before init has been called initially, then what might happen is that init gets called twice (or more) and the threads get different values which could e.g. be pointers to two different mutable objects.<br>Consider <a data-tooltip-position="top" aria-label="https://github.com/ocaml/ocaml/blob/e397ed28bcef85fdc1f0f007af481ef201fb1fd7/stdlib/domain.ml#L98-L111" rel="noopener" class="external-link" href="https://github.com/ocaml/ocaml/blob/e397ed28bcef85fdc1f0f007af481ef201fb1fd7/stdlib/domain.ml#L98-L111" target="_blank">the implementation of <code></code></a>maybe_grow:<br>  let maybe_grow idx =
    let st = get_dls_state () in
    let sz = Array.length st in
    if idx &lt; sz then st
    else begin
      let rec compute_new_size s =
        if idx &lt; s then s else compute_new_size (2 * s)
      in
      let new_sz = compute_new_size sz in
      let new_st = Array.make new_sz unique_value in
      Array.blit st 0 new_st 0 sz;
      set_dls_state new_st;
      new_st
    end

Copy<br>Imagine calling get (which calls maybe_grow) with two different keys from two different threads concurrently. The end result might be that two different arrays are allocated and only one of them â€œwinsâ€. What this means, for example, is that effects of set calls may effectively be undone by concurrent calls of get.<br>In other words, the Domain.DLS, as it is currently implemented, is not thread-safe.<br><br>If you dig into the implementation of threads, you will notice that the opaque <a data-tooltip-position="top" aria-label="https://github.com/ocaml/ocaml/blob/e397ed28bcef85fdc1f0f007af481ef201fb1fd7/otherlibs/systhreads/thread.mli#L18" rel="noopener" class="external-link" href="https://github.com/ocaml/ocaml/blob/e397ed28bcef85fdc1f0f007af481ef201fb1fd7/otherlibs/systhreads/thread.mli#L18" target="_blank"><code></code> type</a>Thread.t is actually a heap block (record) of three fields. You can see the <a data-tooltip-position="top" aria-label="https://github.com/ocaml/ocaml/blob/e397ed28bcef85fdc1f0f007af481ef201fb1fd7/otherlibs/systhreads/st_stubs.c#L66-L68" rel="noopener" class="external-link" href="https://github.com/ocaml/ocaml/blob/e397ed28bcef85fdc1f0f007af481ef201fb1fd7/otherlibs/systhreads/st_stubs.c#L66-L68" target="_blank"><code></code> accessors</a>Thread.t:<br>#define Ident(v) Field(v, 0)
#define Start_closure(v) Field(v, 1)
#define Terminated(v) Field(v, 2)
Copy<br>and the <a data-tooltip-position="top" aria-label="https://github.com/ocaml/ocaml/blob/e397ed28bcef85fdc1f0f007af481ef201fb1fd7/otherlibs/systhreads/st_stubs.c#L335-L346" rel="noopener" class="external-link" href="https://github.com/ocaml/ocaml/blob/e397ed28bcef85fdc1f0f007af481ef201fb1fd7/otherlibs/systhreads/st_stubs.c#L335-L346" target="_blank"><code></code> allocation 1</a>Thread.t:<br>static value caml_thread_new_descriptor(value clos)
{
  CAMLparam1(clos);
  CAMLlocal1(mu);
  value descr;
  /* Create and initialize the termination semaphore */
  mu = caml_threadstatus_new();
  /* Create a descriptor for the new thread */
  descr = caml_alloc_3(0, Val_long(atomic_fetch_add(&amp;thread_next_id, +1)),
                       clos, mu);
  CAMLreturn(descr);
}
Copy<br>The second field, Start_closure, is used to pass the closure to the thread start:<br>static void * caml_thread_start(void * v)
{
  caml_thread_t th = (caml_thread_t) v;
  int dom_id = th-&gt;domain_id;
  value clos;
  void * signal_stack;

  caml_init_domain_self(dom_id);

  st_tls_set(caml_thread_key, th);

  thread_lock_acquire(dom_id);
  restore_runtime_state(th);
  signal_stack = caml_init_signal_stack();

  clos = Start_closure(Active_thread-&gt;descr);
  caml_modify(&amp;(Start_closure(Active_thread-&gt;descr)), Val_unit);
  caml_callback_exn(clos, Val_unit);
  caml_thread_stop();
  caml_free_signal_stack(signal_stack);
  return 0;
}

Copy<br>and, as seen above, <a data-tooltip-position="top" aria-label="https://github.com/ocaml/ocaml/blob/e397ed28bcef85fdc1f0f007af481ef201fb1fd7/otherlibs/systhreads/st_stubs.c#L575" rel="noopener" class="external-link" href="https://github.com/ocaml/ocaml/blob/e397ed28bcef85fdc1f0f007af481ef201fb1fd7/otherlibs/systhreads/st_stubs.c#L575" target="_blank">it is overwritten with the unit value</a> before the closure is called.<br>What this means is that when you call Thread.self () and get a reference to the current Thread.t, the Start_closure field of that heap block will be the unit value:<br>assert (Obj.field (Obj.repr (Thread.self ())) 1 = Obj.repr ())
Copy<br>Letâ€™s hijack that field for the purpose of implementing an efficient TLS!<br>Here is the full hack:<br>module TLS : sig
  type 'a key
  val new_key : (unit -&gt; 'a) -&gt; 'a key
  val get : 'a key -&gt; 'a
  val set : 'a key -&gt; 'a -&gt; unit
end = struct
  type 'a key = { index : int; compute : unit -&gt; 'a }

  let counter = Atomic.make 0
  let unique () = Obj.repr counter

  let new_key compute =
    let index = Atomic.fetch_and_add counter 1 in
    { index; compute }

  type t = { _id : int; mutable tls : Obj.t }

  let ceil_pow_2_minus_1 n =
    let n = n lor (n lsr 1) in
    let n = n lor (n lsr 2) in
    let n = n lor (n lsr 4) in
    let n = n lor (n lsr 8) in
    let n = n lor (n lsr 16) in
    if Sys.int_size &gt; 32 then n lor (n lsr 32) else n

  let[@inline never] grow_tls t before index =
    let new_length = ceil_pow_2_minus_1 (index + 1) in
    let after = Array.make new_length (unique ()) in
    Array.blit before 0 after 0 (Array.length before);
    t.tls &lt;- Obj.repr after;
    after

  let[@inline] get_tls index =
    let t = Obj.magic (Thread.self ()) in
    let tls = t.tls in
    if Obj.is_int tls then grow_tls t [||] index
    else
      let tls = (Obj.magic tls : Obj.t array) in
      if index &lt; Array.length tls then tls else grow_tls t tls index

  let get key =
    let tls = get_tls key.index in
    let value = Array.unsafe_get tls key.index in
    if value != unique () then Obj.magic value
    else
      let value = key.compute () in
      Array.unsafe_set tls key.index (Obj.repr (Sys.opaque_identity value));
      value

  let set key value =
    let tls = get_tls key.index in
    Array.unsafe_set tls key.index (Obj.repr (Sys.opaque_identity value))
end
Copy<br>The above achieves about 80% of the performance of Domain.DLS allowing roughly 241M TLS.gets/s (vs 296M Domain.DLS.gets/s) on my laptop.]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/ocaml/a-hack-to-implement-efficient-tls-(thread-local-storage).html</link><guid isPermaLink="false">Computer Science/Programming Language/OCaml/A hack to implement efficient TLS (thread-local-storage).md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:29 GMT</pubDate></item><item><title><![CDATA[Generalised signature]]></title><description><![CDATA[ 
 <br>
This post presents a technique for defining more reusable OCaml signatures, helping to maintain consistent APIs with minimal boilerplate. We'll work through a few examples, which you can check out <a data-tooltip-position="top" aria-label="https://github.com/CraigFe/generalised-signatures" rel="noopener" class="external-link" href="https://github.com/CraigFe/generalised-signatures" target="_blank">on GitHub</a>.
<br><br>Consider the following definition of an iter function for some container type t:<br>let iter f t =
  for i = 0 to length t - 1 do
    f (get t i)
  done
Copy<br>iter requires only that t comes with functions get and length. Many useful operations can be derived in terms of such indexing functions. To take advantage of this, let's move iter into a functor and provide some other useful operations too:<br>module type Indexable1 = sig
  type 'a t

  val get    : 'a t -&gt; int -&gt; 'a
  val length : _ t -&gt; int
end

module Foldable_of_indexable1 (I : Indexable1) : sig
  open I

  val iter      :        ('a -&gt; unit) -&gt; 'a t -&gt; unit
  val iteri     : (int -&gt; 'a -&gt; unit) -&gt; 'a t -&gt; unit
  val fold_left : ('acc -&gt; 'a -&gt; 'acc) -&gt; 'acc -&gt; 'a t -&gt; 'acc
  val exists    : ('a -&gt; bool) -&gt; 'a t -&gt; bool
  val for_all   : ('a -&gt; bool) -&gt; 'a t -&gt; bool
  val is_empty  : _ t -&gt; bool
  (* ... *)
end
Copy<br>For many types, including array, the get-based definitions are identical to their hand-optimised equivalents (modulo functor application). We can imagine avoiding a lot of standard-library boilerplate â€“ and potential for API inconsistency â€“ by using many such functors <a data-tooltip-position="top" aria-label="https://www.craigfe.io/posts/generalised-signatures#fn-1" rel="noopener" class="external-link" href="https://www.craigfe.io/posts/generalised-signatures#fn-1" target="_blank">1</a>. We'd end up defining exactly one iter function that suffices for all Indexable types.<br>All good so far. Now, let's consider the string type.<br>A string is also an indexable container with length and get functions, albeit one that can only contain char values. It's natural to expect to be able to re-use Foldable_of_indexable1 in some way: indeed, our definition of iter above is exactly equal to the one in Stdlib.String.iter. Unfortunately, our Indexable1 module type can only describe parametric containers:<br>module _ : (Indexable1 with type 'a t := string) = Stdlib.String
Copy<br>Error: Signature mismatch:
       ...
       Values do not match:
         val get : t -&gt; int -&gt; char
       is not included in
         val get : t -&gt; int -&gt; 'a
       File "string.mli", line 52, characters 0-57: Actual declaration
Copy<br>We're unable to tell the type system something like<br>
'a t = string &nbsp;&nbsp; implies &nbsp;&nbsp; 'a = char
<br>as part of our substitution. This means that many types â€“ including string, bytes, unboxed arrays and unboxed vectors â€“ can't benefit from our Foldable_of_iterable1 definitions, even though their own definitions will be identical!<br>When we wrapped our code in the Foldable_of_indexable1 functor, we needed to give it specific input and output module types, and the ones we picked artificially limited its usefulness. This is a hazard of functorising highly-generic code. As ever, we could solve the problem with copy-paste: a new Indexable0 module type for non-parametric containers, and a new functor Foldable_of_indexable0 with exactly the same implementations as our previous one.<br>(* Non-parametric indexable types *)
module type Indexable0 = sig
  type t
  type elt

  val get    : t -&gt; int -&gt; elt
  val length : t -&gt; int
end

module Foldable_of_indexable0 (I : Indexable0) : sig
  (* All with the same implementation as before... *)
end
Copy<br>This definition suffers from the dual problem when we try to apply it to parameterised containers like 'a array:<br>module _ : (Indexable0 with type t := 'a array) = Stdlib.Array
Copy<br>Error: The type variable 'a is unbound in this type declaration.
Copy<br>This time, we wanted to be able to say something like<br>
elt = 'a &nbsp;&nbsp; implies &nbsp;&nbsp; t = 'a array &nbsp;&nbsp; (where 'a is universally quantified),
<br>which is even more nonsensical than our previous attempt. Neither Indexable0 nor Indexable1 can be expressed in terms of the other. We need something more general.<br><br>Interestingly, it's possible to generalise Indexable0 and Indexable1 with <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Fundamental_theorem_of_software_engineering" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Fundamental_theorem_of_software_engineering" target="_blank">another layer of indirection</a> by making elt a type operator:<br>module type IndexableN = sig
  type 'a t
  type 'a elt

  val get    : 'a t -&gt; int -&gt; 'a elt
  val length : _ t -&gt; int
end
Copy<br>elt carries the type equalities needed for the Indexable1 case, without forbidding the non-parametric implementation needed for the Indexable0 case. Arrays can set 'a elt := 'a, and strings can set 'a elt := char. Indeed, we can do this in the general case:<br>(** [Indexable0] is a special-case of [IndexableN] *)
module Indexable0_to_N = functor
  (T : Indexable0) -&gt;
  (T : IndexableN with type 'a t := T.t and type 'a elt := elt)

(** [Indexable1] is a special-case of [IndexableN] *)
module Indexable1_to_N = functor
  (T : Indexable1) -&gt;
  (T : IndexableN with type 'a t := 'a T.t and type 'a elt := 'a)
Copy<br>Now we can define a single Foldable_of_indexableN functor (with exactly the same implementations as before), and it will work for polymorphic and monomorphic containers. Neat!<br><img alt="A lattice showing Indexable0 and Indexable1 being generalised by IndexableN." src="https://www.craigfe.io/posts/generalised-signatures/dag-indexable.png" referrerpolicy="no-referrer"><br>In the general case, when you notice that different signatures are sharing common functions, it's often possible to unify them under a common interface with the following two steps:<br>
<br>generalise. Convert pure type variables into type operators (as in 'a â†’ 'a elt), to support use-cases like instantiating those variables to fixed types. Add type parameters to existing types to carry type equalities between them (as in 'a t / 'a elt), to support use-cases where these types depend on each other.
<br>specialise. Use destructive substitution (:=) to eliminate those types and type parameters when they're not needed. We're taking advantage of the <a data-tooltip-position="top" aria-label="https://github.com/ocaml/ocaml/pull/792" rel="noopener" class="external-link" href="https://github.com/ocaml/ocaml/pull/792" target="_blank">more powerful destructive substitution</a> offered by OCaml 4.06, which allows us to freely undo our generalisation step.
<br>The truly magical part of this trick is that â€“ with better support for destructive type substitutions recently added to Odoc â€“ it can be made completely invisible<a data-tooltip-position="top" aria-label="https://www.craigfe.io/posts/generalised-signatures#fn-2" rel="noopener" class="external-link" href="https://www.craigfe.io/posts/generalised-signatures#fn-2" target="_blank">2</a> in documentation!<br>module type Indexable1 = sig
  type _ t

  val get : 'a t -&gt; int -&gt; 'a
  val length : _ t -&gt; int
end

(** This module gets identical documentation to the one above! *)
module type Indexable1' = sig
  include IndexableN with type 'a elt := 'a (** @inline *)
end
Copy<br><br>One unavoidable limitation is in what sort of operations we can put in the Foldable_of_indexable functor. Suppose our initial attempt at generalising containers included a sum function:<br>let sum : int t -&gt; t = fold_left ( + ) 0
Copy<br>sum requires a container that can hold int values, which is clearly not possible for strings as the type system will happily tell us:<br>   |   let sum = fold_left ( + ) 0
                           ^^^^^
Error: This expression has type int -&gt; int -&gt; int
       but an expression was expected of type int -&gt; 'a elt -&gt; int
       Type int is not compatible with type 'a elt
Copy<br>To state the obvious, we can't rely on parametricity in our container functions if we want them to work on non-parametric containers. The natural solution here would be to define such parametric-only functions in a separate functor.<br><br>Indexable containers aren't the only example of generalised signatures in the real world. Indeed, many other data-structures and design patterns have APIs that can be unified in this way. Consider the case of hashtables, which have a huge space of possible implementations:<br>
<br>key types can be left polymorphic by using a magic hash function like caml_hash (as in <a data-tooltip-position="top" aria-label="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Hashtbl.html" rel="noopener" class="external-link" href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Hashtbl.html" target="_blank"><code></code></a>Stdlib.Hashtbl), or fixed by a user-specified hash function (as in <a data-tooltip-position="top" aria-label="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Hashtbl.Make.html" rel="noopener" class="external-link" href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Hashtbl.Make.html" target="_blank"><code></code></a>Stdlib.Hashtbl.Make).<br>

<br>value types can be left polymorphic, fixed by the user (as in persistent hashtables like <a data-tooltip-position="top" aria-label="https://mirage.github.io/index/index/Index/Make/index.html" rel="noopener" class="external-link" href="https://mirage.github.io/index/index/Index/Make/index.html" target="_blank"><code></code></a>Index), or even determined by the keys used to index them (as in universal maps like <a data-tooltip-position="top" aria-label="https://erratique.ch/software/hmap/doc/Hmap" rel="noopener" class="external-link" href="https://erratique.ch/software/hmap/doc/Hmap" target="_blank"><code></code></a>Hmap).<br>

<br>Initially, it looks like these different hashtables will each require their own hand-written signature (and this is what the standard library does with its hashtables). However, with enough type parameters, these different implementations can all be unified under a single Hashtbl_generalised module type:<br>module type Hashtbl_generalised = sig
  (** We have three types ([t], [key] and [value]) and three type variables:

      - ['k]/['v] allow the hashtable to determine key/value types;
      - ['a] is carried from keys to corresponding values, allowing the key to
        determine the types of values. *)

  type ('k, 'v) t
  type ('k, 'a) key
  type ('v, 'a) value

  val create : int -&gt; (_, _) t
  val replace : ('k, 'v) t -&gt; ('k, 'a) key -&gt; ('v, 'a) value -&gt; unit
  val remove : ('k, _) t -&gt; ('k, _) key -&gt; unit
  val find_opt : ('k, 'v) t -&gt; ('k, 'a) key -&gt; ('v, 'a) value option
  (* ... *)
end
Copy<br>We can then implement our different hashtable signatures as specialisations:<br><img alt="A lattice showing four different `Hashtbl` module types being generalised by `Hashtbl_generalised`." src="https://www.craigfe.io/posts/generalised-signatures/dag-hashtables.png" referrerpolicy="no-referrer"><br>For instance, for the regular polymorphic hashtable:<br>module type Poly_hash = sig
  include Hashtbl_generalised
    with type ('k, _) key := 'k
     and type ('v, _) value := 'v (** @inline **)
end
Copy<br>The other specialisations are very similar (see <a data-tooltip-position="top" aria-label="https://github.com/CraigFe/generalised-signatures/blob/main/examples/hashtbl.ml" rel="noopener" class="external-link" href="https://github.com/CraigFe/generalised-signatures/blob/main/examples/hashtbl.ml" target="_blank">here</a> for the specifics).<br>What is it that makes Hashtable_generalised a good parent interface for these four flavours of hashtable? To get some insight, we can notice that each of the type parameters ('k, 'v, and 'a) connects its own pair of types:<br>hashtbl_generalised<br><img src="https://www.craigfe.io/posts/generalised-signatures/dep-hashtbl_generalised.png" referrerpolicy="no-referrer"><br>Framed this way, the type parameter 'k exists solely to carry type information between hashtables and their keys (using a type equality at call sites). Similarly, 'v bridges between hashtables and values, and 'a between keys and values. From here, each of our hashtable variants uses destructive subsitution (:=) to prune away unnecessary bridges and express some sort of dependency relation between the types:<br><br>In this case, it's not feasible for all these data structures to share the same implementation, but it's still valuable for them to implement a common core API: it ensures consistency of the user-facing functions, allows sharing of documentation, and may even allow these implementations to share a common test suite.<br><br>The full code for our Indexable and Hashtbl examples, including explicit definitions of each of the module types, can be found in the <a data-tooltip-position="top" aria-label="https://github.(com/CraigFe/generalised-signatures)" rel="noopener" class="external-link" href="https://github.(com/CraigFe/generalised-signatures)" target="_blank"><code></code> repository</a>generalised-signatures. This repository also contains and a <a data-tooltip-position="top" aria-label="https://github.com/CraigFe/generalised-signatures/blob/main/examples/monads.ml" rel="noopener" class="external-link" href="https://github.com/CraigFe/generalised-signatures/blob/main/examples/monads.ml" target="_blank">third demonstration</a> of this technique being used to express monad-like signatures. The auto-generated documentation for these examples can be <a data-tooltip-position="top" aria-label="https://craigfe.github.io/generalised-signatures/generalised_signatures/Generalised_signatures/index.html" rel="noopener" class="external-link" href="https://craigfe.github.io/generalised-signatures/generalised_signatures/Generalised_signatures/index.html" target="_blank">viewed online</a>.x<br>Thanks for making it to the end; I hope you picked up something useful. If you think it would help others in your network, I'd appreciate it if you <a data-tooltip-position="top" aria-label="https://twitter.com/share?url=NaN&amp;text=%E2%80%9CGeneralised%20signatures%E2%80%9D%2C%20a%20post%20by%20Craig%20Ferguson.%20&amp;via=_craigfe" rel="noopener" class="external-link" href="https://twitter.com/share?url=NaN&amp;text=%E2%80%9CGeneralised%20signatures%E2%80%9D%2C%20a%20post%20by%20Craig%20Ferguson.%20&amp;via=_craigfe" target="_blank">shared it</a> with them.<br><br><br>The typeclasses in Haskell's <a data-tooltip-position="top" aria-label="https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Foldable.html" rel="noopener" class="external-link" href="https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Foldable.html" target="_blank">base</a> have the same "polymorphic-instances-only" property as our Indexable1 signature (unsurprising, since it doesn't provide any unboxed container types).<br>class Indexable1 f where        -- Polymorphic instances only
  get    :: f a -&gt; Int -&gt; a
  length :: f a -&gt; Int
Copy<br>A similar trick can be performed there to generalise the typeclass instances for monomorphic containers like Text:<br>{-# LANGUAGE TypeFamilies #-}

type family   Elt container     -- Relate containers to their element type
type instance Elt [a]  = a
type instance Elt Text = Char

class IndexableN c where
  get    :: c -&gt; Int -&gt; Elt c
  length :: c -&gt; Int

instance IndexableN [a] where   -- Polymorphic instance
  get    = (!!)
  length = Prelude.length

instance IndexableN Text where  -- Monomorphic instance
  get    = Text.index
  length = Text.length
Copy<br>As in the OCaml version, we use an Elt type operator to carry the equality needed for the monomorphic case. This time we used type families to specify the relations explicitly, but we could have used multi-parameter type classes for something more akin to the OCaml functor implementation. See the <a data-tooltip-position="top" aria-label="https://hackage.haskell.org/package/mono-traversable" rel="noopener" class="external-link" href="https://hackage.haskell.org/package/mono-traversable" target="_blank">mono-traversable</a> package for more of this sort of trickery in Haskell.<br><br>
<br>This is the approach taken by Jane Street's <a data-tooltip-position="top" aria-label="https://github.com/janestreet/base" rel="noopener" class="external-link" href="https://github.com/janestreet/base" target="_blank">base</a>, and is very similar to the Haskell notion of building standard libraries from type-class instances.<a data-tooltip-position="top" aria-label="https://www.craigfe.io/posts/generalised-signatures#fnref-1" rel="noopener" class="external-link" href="https://www.craigfe.io/posts/generalised-signatures#fnref-1" target="_blank">â†©</a>
<br>This example uses the (** @inline *) tag to ensure that Odoc doesn't leak that Indexable1' is implemented in terms of IndexableN.<a data-tooltip-position="top" aria-label="https://www.craigfe.io/posts/generalised-signatures#fnref-2" rel="noopener" class="external-link" href="https://www.craigfe.io/posts/generalised-signatures#fnref-2" target="_blank">â†©</a>
]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/ocaml/generalised-signature.html</link><guid isPermaLink="false">Computer Science/Programming Language/OCaml/Generalised signature.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:34 GMT</pubDate><enclosure url="https://www.craigfe.io/posts/generalised-signatures/dag-indexable.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://www.craigfe.io/posts/generalised-signatures/dag-indexable.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Interfacing OCaml and PostgreSQL with Caqti]]></title><description><![CDATA[ 
 <br>
On dealing with dependencies in your Dune-powered OCaml app and interfacing with the most popular DBMS in town.
<br>This article is part of Hands-on OCaml, a series of articles that Iâ€™m working on that is focusing on doing web app development with OCaml.<br>The project we will be building throughout the series is a To-Do List app, which connects to a PostgreSQL database as its datastore. In the previous article, we have covered initializing and bootstrapping our project with Dune; if you havenâ€™t seen it, check out the link below:<br>This tutorial will build upon the foundation we have laid out in the previous article in the series. While you can of course follow along without actually doing the tutorial, it is recommended to give the article a read first to be sure that we have the required knowledge in place.<br>In this second article of Hands-on OCaml series, we will explore how to manage dependencies in OCaml project; in particular, we will bring in and use a third-party library to deal with DB operations.<br><br>Assuming you followed the previous article, you should have both opam and jbuilder installed. Verify their installation as follows:<br>$ opam --version  
1.2.2
$ jbuilder --version  
1.0+beta20
Copy<br>We would also need to have a local PostgreSQL instance up and running. Iâ€™m assuming readers have had prior experience with PostgreSQL, so Iâ€™m not going to expand about it here, but you should be able to install it via your OS package manager (e.g. apt on Ubuntu or brew on MacOS) or via a Docker container. Verify that it is running and and you can connect to it via psql. At the time of this writing, I am using locally installed PostgreSQL 10.4.<br><br>In this section weâ€™ll see how we will prepare our project. Again, this tutorial assumes that you have done the initial <a data-tooltip-position="top" aria-label="https://medium.com/@bobbypriambodo/starting-an-ocaml-app-project-using-dune-d4f74e291de8" rel="noopener" class="external-link" href="https://medium.com/@bobbypriambodo/starting-an-ocaml-app-project-using-dune-d4f74e291de8" target="_blank">Dune setup tutorial</a>. If you havenâ€™t, do check it out. You might also want to remove the previously created .mli and .ml files from bin and lib since we wonâ€™t need them anymore.<br><br>First off, we will fetch some dependencies! Unlike the previous tutorial where we install packages directly, we are going to use a different and cleaner method of installing dependencies: through opam files.<br>Make sure youâ€™re in the todolist directory, create a file named todolist.opam with the following contents:<br>opam-version: "1.2"
name: "todolist"
version: "1.0.0"
maintainer: "Your Name &lt;email@example.com&gt;"

depends: [
  "jbuilder" {build}
  "lwt"
  "lwt_ppx"
  "caqti"
  "caqti-lwt"
  "caqti-driver-postgresql"
]
Copy]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/ocaml/interfacing-ocaml-and-postgresql-with-caqti.html</link><guid isPermaLink="false">Computer Science/Programming Language/OCaml/Interfacing OCaml and PostgreSQL with Caqti.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:31 GMT</pubDate></item><item><title><![CDATA[Off to the Races Using ThreadSanitizer in OCaml]]></title><description><![CDATA[ 
 <br>OCaml Multicore opened up a new world of performance for developers, something that <a data-tooltip-position="top" aria-label="https://tarides.com/blog/2022-12-20-how-nomadic-labs-used-multicore-processing-to-create-a-faster-blockchain/" rel="noopener" class="external-link" href="https://tarides.com/blog/2022-12-20-how-nomadic-labs-used-multicore-processing-to-create-a-faster-blockchain/" target="_blank">Nomadic Labs has tested with great results.</a> Rather than relying on one core to do everything, the program can take advantage of multiple cores simultaneously for a significant performance boost.<br>With new programming possibilities come new classes of bugs, which require updated detection methods. One of these types of bugs is called a data race. A data race is a race condition that occurs when two accesses are made to the same memory location, at least one is a write, and no order is enforced between them.<br>Data races can be dangerous as they are easy to miss and capable of yielding unexpected results. Consequently, integrating a tool to detect data races has been a high priority for the teams working on OCaml 5.0 with Multicore support. Whilst data races in OCaml are less problematic than in many other languages (for example, data races in OCaml do not cause crashes and do not constitute undefined behaviour), developers still want to be made aware of possible data races so that they can remove them from their programs. More about this below.<br><br><br><a data-tooltip-position="top" aria-label="https://clang.llvm.org/docs/ThreadSanitizer.html" rel="noopener" class="external-link" href="https://clang.llvm.org/docs/ThreadSanitizer.html" target="_blank">ThreadSanitizer</a>, or TSan, is an open-source tool that reliably detects data races at runtime. It consists of instrumenting programs with calls to a dedicated runtime that performs the detection.<br>Support for TSan will officially be part of the OCaml 5.2 release, and there is already a backport for OCaml 5.1.<br>This blog post will demonstrate the benefits of using TSan, offer insight into how TSan works, and outline the challenges of integrating it with OCaml. For a more practically oriented guide on how to use TSan in your own projects, the <a data-tooltip-position="top" aria-label="https://ocaml.org/docs/multicore-transition" rel="noopener" class="external-link" href="https://ocaml.org/docs/multicore-transition" target="_blank">tutorial on using TSan with OCaml Multicore</a> is a great place to start.<br>We will begin by examining what a data race looks like, both before and after using TSan.<br><br><br>Let us consider how a data race might occur. Say an OCaml programmer writes code to populate a table of clients from several sources. They decide to make it Multicore to improve performance by using two Domains for two data sources:<br>let clients = Hashtbl.create 16
let free_id = Atomic.make 0

let clients1 = (* Some data source *)

let clients2 = (* Some data source *)

let record_clients =
  Seq.iter
    (fun c -&gt; Hashtbl.add clients (Atomic.fetch_and_add free_id 1) c)

let () =
  let d = Domain.spawn (fun () -&gt; record_clients clients1) in
  record_clients clients2;
  Domain.join d
Copy<br>As we can tell, each incoming client is bound to a unique ID. The programmer correctly used the Atomic module for ID generation, ensuring the IDs are truly unique. However, they have failed to use a domain-safe module designed for concurrency, instead opting for Hashtbl. Unfortunately, this module is unsafe for concurrent use: using Hashtbl.t in parallel can cause data races and lead to surprising results.<br>For example, when two domains add elements in parallel it may cause some elements to be silently dropped. To make matters worse, the resulting bugs would be non-deterministic and as such be hard to detect and track down. Furthermore, if the programmer's project depends on libraries that use Hashtbl, it would make them unsafe to use in parallel without it necessarily being clear from their documentation.<br>If, however, the programmer were to build their program on a special opam switch with a TSan-enabled compiler like this:<br>$ opam switch create 5.1.0+tsan
$ opam install dune
$ dune exec ./clients.exe
Copy<br>(Side note: the 5.1.0+tsan switch is the most convenient way to use TSan with OCaml at the time of writing. Once OCaml 5.2 is released, the blessed command will be opam switch create &lt;switch name&gt; ocaml-option-tsan.)<br>All memory accesses would be instrumented with calls to the TSan runtime, and TSan would detect the data race condition and output a data race report:<br>==================
WARNING: ThreadSanitizer: data race (pid=790576)
  Write of size 8 at 0x7f42b37f57e0 by main thread (mutexes: write M86):
    #0 caml_modify runtime/memory.c:166 (clients.exe+0x58b87d)
    #1 camlStdlib__Hashtbl.resize_749 stdlib/hashtbl.ml:152 (clients.exe+0x536766)
    #2 camlStdlib__Seq.iter_329 stdlib/seq.ml:76 (clients.exe+0x4c8a87)
    #3 camlDune__exe__Clients.entry /workspace_root/clients.ml:9 (clients.exe+0x4650ef)
    #4 caml_program &lt;null&gt; (clients.exe+0x45fefe)
    #5 caml_start_program &lt;null&gt; (clients.exe+0x5a0ae7)

  Previous read of size 8 at 0x7f42b37f57e0 by thread T1 (mutexes: write M90):
    #0 camlStdlib__Hashtbl.key_index_1308 stdlib/hashtbl.ml:507 (clients.exe+0x53a625)
    #1 camlStdlib__Hashtbl.add_1312 stdlib/hashtbl.ml:511 (clients.exe+0x53a6f8)
    #2 camlStdlib__Seq.iter_329 stdlib/seq.ml:76 (clients.exe+0x4c8a87)
    #3 camlStdlib__Domain.body_703 stdlib/domain.ml:202 (clients.exe+0x50bf60)
    #4 caml_start_program &lt;null&gt; (clients.exe+0x5a0ae7)
    #5 caml_callback_exn runtime/callback.c:197 (clients.exe+0x56917b)
    #6 caml_callback runtime/callback.c:293 (clients.exe+0x569cb0)
    #7 domain_thread_func runtime/domain.c:1100 (clients.exe+0x56d37f)
    [...]

SUMMARY: ThreadSanitizer: data race runtime/memory.c:166 in caml_modify
==================
[...]
ThreadSanitizer: reported 2 warnings
Copy<br>Above is a truncated view of what the TSan report, warning of a data race, looks like in this case. TSan has detected two memory accesses, a write and a read, made to one memory location. As they are also unordered, this constitutes a data race and TSan reports it along with the backtraces of both accesses.<br>In this case it would be evident that something has gone wrong with Hashtbl.add â€“ a big hint to the programmer.<br><br><br>Now that we know what TSan is used for, it's time to explore how it works. Compiling a program with TSan enabled causes the executable to be instrumented with calls to the TSan runtime library. The runtime library tracks memory accesses and ordering relations between these accesses.<br>Internally, the TSan runtime assigns a vector clock to each OCaml domain or system thread. Each thread holds a vector clock â€“ a vector clock being an array of n integers, where n is the number of threads â€“ and increments its clock upon each event (memory access, mutex operation, etc.). Certain operations like mutex locks, atomic reads, and so on, will synchronise clocks between threads.<br><a data-tooltip-position="top" aria-label="https://tarides.com/static/0bf64db362ac972b1285ab93f569b53a/798d4/vector-clocks.png" rel="noopener" class="external-link" href="https://tarides.com/static/0bf64db362ac972b1285ab93f569b53a/798d4/vector-clocks.png" target="_blank"></a><img alt="A mutex lock synchronising the clock between two threads." src="https://tarides.com/static/0bf64db362ac972b1285ab93f569b53a/c5bb3/vector-clocks.png" referrerpolicy="no-referrer"><br>Comparing vector clocks allows TSan to establish an order between events, so-called <a data-tooltip-position="top" aria-label="https://jameshfisher.com/2017/02/10/happened-before/" rel="noopener" class="external-link" href="https://jameshfisher.com/2017/02/10/happened-before/" target="_blank">happens-before relations.</a> TSan reports a data race every time two memory accesses are made to overlapping memory regions, if:<br>
<br>At least one of them is a write, and
<br>There is no established happens-before relation between them.
<br><br><br>Let us look at this process in more detail. Each word of application memory is associated with one or more 'shadow words'. Each shadow word contains information about a recent memory access to that word. This information points to the vector clock's state at the moment the access was performed.<br><a data-tooltip-position="top" aria-label="https://tarides.com/static/805211c514eae2a5f8a8410fd26f476a/d125e/shadow-state.png" rel="noopener" class="external-link" href="https://tarides.com/static/805211c514eae2a5f8a8410fd26f476a/d125e/shadow-state.png" target="_blank"></a><img alt="A box labelled application with an arrow to a box labeled shadow state." src="https://tarides.com/static/805211c514eae2a5f8a8410fd26f476a/c5bb3/shadow-state.png" referrerpolicy="no-referrer"><br>This information (called the 'shadow state') is updated at every instrumented memory access: TSan compares the accessor's clock with each existing shadow word, and checks the following:<br>
<br>Do the accesses overlap?
<br>Is one of them a write?
<br>Are the thread IDs different?
<br>Are they unordered by happens-before?
<br>If these conditions are met, TSan detects and reports a data race.<br>In addition to memory access, operations like Domain.spawn and Domain.join (as well as mutex operations) are relevant for operation ordering. As such, TSan also instruments these operations.<br><br><br>The core of TSan support is instrumentation of memory acceses with calls to the TSan runtime. The OCaml compiler performs this instrumentation in a dedicated pass.<br><br><br>For TSan to show a backtrace of past events, function entries and exits must also be instrumented. This is done as part of the instrumentation pass.<br>However, in OCaml, a function can also be exited by an <a data-tooltip-position="top" aria-label="https://github.com/fabbing/obts_exn" rel="noopener" class="external-link" href="https://github.com/fabbing/obts_exn" target="_blank">exception</a>, bypassing part of the instrumentation. When that happens, for TSanâ€™s view of the backtrace to remain up-to-date, the OCaml runtime informs TSan about every exited function.<br><br><br><a data-tooltip-position="top" aria-label="https://v2.ocaml.org/manual/effects.html" rel="noopener" class="external-link" href="https://v2.ocaml.org/manual/effects.html" target="_blank">Effect handlers</a> are a generalisation of exception handlers. Performing an effect results in a jump to the associated effect handler, and then a delimited continuation makes it possible to resume the computation. In the same way as with exceptions, the OCaml runtime must signal to TSan which functions are exited when an effect is performed and re-entered when a continuation is resumed.<br><br><br>Each language specifies how memory behaves in parallel programs using what is known as a memory model. Incidentally, what counts as a data race in a given language also depends on its memory model.<br>TSan can detect data races in programs that follow the C memory model. OCaml 5's memory model is different from the C model, however, and it offers more guarantees: data races in C and C++ cause undefined behaviour (i.e., anything can happen), which is not the case in OCaml. OCaml's semantics are â€œfully definedâ€ (see the <a data-tooltip-position="top" aria-label="https://v2.ocaml.org/manual/memorymodel.html" rel="noopener" class="external-link" href="https://v2.ocaml.org/manual/memorymodel.html" target="_blank">manual page</a> about the memory model). In particular, a program with data races in OCaml will not crash, unlike in C++. In addition, there can be no <a data-tooltip-position="top" aria-label="https://www.hboehm.info/c++mm/thin_air.html" rel="noopener" class="external-link" href="https://www.hboehm.info/c++mm/thin_air.html" target="_blank">out-of-thin-air values</a>: the only values that can be observed are values that are previously written to that location. The OCaml memory model guarantees that even for programs with data races, memory safety is preserved.<br>Data races in OCaml can still result in unexpected surprises for the OCaml programmer. A multi-threaded execution may produce behaviours that cannot be explained by the mere interleaving of actions from different threads. The only way such behaviours can be explained is through a reordering of actions in the same thread. Such reasoning is quite unintuitive for a programmer who will be more used to thinking about program behaviour as being an interleaving of actions from different threads.<br>However, if the program is data-race free, then the observed behaviour can be explained by a simple interleaving of operations from different threads (a property known as sequential consistency). Eliminating data races reduces non-determinism in the program and hence it is beneficial to remove data races whenever possible. Note that we do not completely eliminate non-determinism from a parallel program.<br>In essence, because of the differences between the C and OCaml memory models, in order for TSan to detect data races in OCaml the instrumentation of memory accesses must conceptually map OCaml programs to C programs. During development, the team took care to ensure that this mapping preserved the detection of data races (in the OCaml sense) and did not introduce false positives.<br>You can find more details about the inner workings of TSan and its OCaml support in this <a data-tooltip-position="top" aria-label="https://github.com/fabbing/ocaml_tsan_icfp/blob/master/presentation/presentation.pdf" rel="noopener" class="external-link" href="https://github.com/fabbing/ocaml_tsan_icfp/blob/master/presentation/presentation.pdf" target="_blank">OCaml Workshop 2023 talk</a>.<br><br><br>In terms of the cost of running TSan, currently, it affects memory and performance in the following ways:<br>
<br>Performance cost: about a 2-7x slowdown (compared to 5-15x for C/C++)
<br>Memory consumption: increased by about 4-7x (compared to 5-10x for C++)
<br>As with all tools, TSan has some limitations. These are due to how TSan is built and are unlikely to change. With TSan, data races are only detected on visited code paths. In addition, TSan only remembers a finite amount of memory accesses for space-saving reasons, which can in principle cause TSan to miss some races. TSan also does not currently support Windows.<br>TSan support for OCaml is currently only implemented for x86-64 Linux and macOS, but will hopefully be extended to include more architectures such as arm64.<br><br><br>Knowing the limitations, let us explore TSan's use cases. So far, TSan has helped by unearthing data races in several OCaml libraries:<br>
<br><a data-tooltip-position="top" aria-label="https://github.com/ocaml-multicore/saturn" rel="noopener" class="external-link" href="https://github.com/ocaml-multicore/saturn" target="_blank">Saturn (formerly known as Lockfree):</a> TSan <a data-tooltip-position="top" aria-label="https://github.com/ocaml-multicore/saturn/issues/39" rel="noopener" class="external-link" href="https://github.com/ocaml-multicore/saturn/issues/39" target="_blank">found a benign data race</a>, as well as a data race occuring from the use of <a data-tooltip-position="top" aria-label="https://github.com/ocaml-multicore/saturn/pull/40" rel="noopener" class="external-link" href="https://github.com/ocaml-multicore/saturn/pull/40" target="_blank">semaphores</a>.
<br><a data-tooltip-position="top" aria-label="https://github.com/ocaml-multicore/domainslib" rel="noopener" class="external-link" href="https://github.com/ocaml-multicore/domainslib" target="_blank">Domainslib:</a> TSan found benign data races in Chan, not just <a data-tooltip-position="top" aria-label="https://github.com/ocaml-multicore/domainslib/issues/72" rel="noopener" class="external-link" href="https://github.com/ocaml-multicore/domainslib/issues/72" target="_blank">once</a> but <a data-tooltip-position="top" aria-label="https://github.com/ocaml-multicore/domainslib/pull/103" rel="noopener" class="external-link" href="https://github.com/ocaml-multicore/domainslib/pull/103" target="_blank">twice</a>.
<br><a data-tooltip-position="top" aria-label="https://github.com/ocaml/ocaml" rel="noopener" class="external-link" href="https://github.com/ocaml/ocaml" target="_blank">The OCaml runtime system</a> itself: TSan warned about a <a data-tooltip-position="top" aria-label="https://github.com/ocaml/ocaml/issues/11040" rel="noopener" class="external-link" href="https://github.com/ocaml/ocaml/issues/11040" target="_blank">number of race conditions</a> in the OCaml runtime.
<br>In addition, TSan has been a great help in transitioning the effects-based I/O library <a data-tooltip-position="top" aria-label="https://github.com/ocaml-multicore/eio" rel="noopener" class="external-link" href="https://github.com/ocaml-multicore/eio" target="_blank">Eio</a> and the distributed database <a data-tooltip-position="top" aria-label="https://github.com/mirage/irmin" rel="noopener" class="external-link" href="https://github.com/mirage/irmin" target="_blank">Irmin</a> to Multicore. It allowed teams to detect potential data races and fix them as required.<br><br><br>We want to hear from you â€“ are you using TSan for your OCaml projects? Please get in touch and let us know about your experience, whether you have encountered any problems, and if you have any suggestions for how it could be improved.<br>You can share your thoughts on the <a data-tooltip-position="top" aria-label="https://discuss.ocaml.org" rel="noopener" class="external-link" href="https://discuss.ocaml.org" target="_blank">OCaml Discuss Forum</a> or contact Tarides directly <a data-tooltip-position="top" aria-label="https://tarides.com/contact/" rel="noopener" class="external-link" href="https://tarides.com/contact/" target="_blank">on our website</a>. Don't forget to check out the <a data-tooltip-position="top" aria-label="https://ocaml.org/docs/multicore-transition" rel="noopener" class="external-link" href="https://ocaml.org/docs/multicore-transition" target="_blank">TSan tutorial</a> as well. Happy hacking!]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/ocaml/off-to-the-races-using-threadsanitizer-in-ocaml.html</link><guid isPermaLink="false">Computer Science/Programming Language/OCaml/Off to the Races Using ThreadSanitizer in OCaml.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:30 GMT</pubDate><enclosure url="https://tarides.com/static/0bf64db362ac972b1285ab93f569b53a/c5bb3/vector-clocks.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://tarides.com/static/0bf64db362ac972b1285ab93f569b53a/c5bb3/vector-clocks.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pitfalls of polymorphic ignore]]></title><description><![CDATA[ 
 <br>In OCaml, we can ignore the return value of a side-effecting computation by either naming it _ or using Stdlib.ignore. These are commonly used to test functions:<br>let test_eval =
  (* we only care that [eval] doesn't raise an exception *)
  let _ = eval (`Int 5) in
  ignore (eval (`Add (`Int 1, `Int 2)))
Copy<br>There's a bug waiting to happen here. Suppose we later refactor eval to take another variable:<br>val eval : expr -&gt; context -&gt; expr
Copy<br>Suddenly, the test is ignoring partially-applied functions of type context -&gt; expr: it silently became useless! For this reason, one often sees code that explicitly asserts the type of the value being ignored:<br>let ignore_expr (_ : expr) = ()

let test_eval =
  (* require the ignored value to have type [expr] *)
  let (_ : expr) = eval (`Int 5) in
  ignore_expr (eval (`Add (`Int 1, `Int 2)))
Copy<br>The type-checker now catches our partial application bug:<br>File "test_eval.ml", line 9, characters 19-25:
9 |   let (_ : expr) = eval (`Int 5) in
                       ^^^^^^^^^^^^^
Error: This expression has type context -&gt; expr
       but an expression was expected of type expr
Copy]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/ocaml/pitfalls-of-polymorphic-ignore.html</link><guid isPermaLink="false">Computer Science/Programming Language/OCaml/Pitfalls of polymorphic ignore.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:33 GMT</pubDate></item><item><title><![CDATA[Polymorphic type constraints]]></title><description><![CDATA[ 
 <br>
In this post, I explain a common mistake when writing constraints of polymorphic functions in OCaml programs, then show how to correct it.
<br><br>One of the earliest lessons of any functional programming tutorial is how to write polymorphic functions and their signatures:<br>val id  : 'a -&gt; 'a
val fst : ('a * 'b) -&gt; 'a
val map : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list
Copy<br>A typical explanation of these type signatures goes along the lines of:<br>
Types of the form 'a, 'b, ..., known as type variables, stand for an unknown type. They allow us to describe functions that work uniformly over many possible input types. This is known as "parametric polymorphism".
â€” Hypothetical education resource<a data-tooltip-position="top" aria-label="https://www.craigfe.io/posts/polymorphic-type-constraints#fn-1" rel="noopener" class="external-link" href="https://www.craigfe.io/posts/polymorphic-type-constraints#fn-1" target="_blank">1</a>
<br>As is often the case with introductory explanations, this is just specific enough to be technically correct without introducing too many new concepts, letting us hurry on to demonstrating useful examples before the student gets bored. Unfortunately, we've laid a trap: when our reader learns about type constraints, they naturally try to combine these two "intuitive" features and get bitten:<br>á… let id1 : 'a -&gt; 'a = (fun x -&gt; x) ;;        (* Accepted. So far so good... *)
  val id1 : 'a -&gt; 'a = &lt;fun&gt;

á… let id2 : 'a -&gt; 'a = (fun x -&gt; x + 1) ;;    (* Also accepted. Uh oh... *)
  val id2 : int -&gt; int = &lt;fun&gt;
Copy<br>In this case, the student finds that 'a -&gt; 'a is a valid constraint for a function of type int -&gt; int, and their mental model is broken almost immediately. It's quite natural to expect id2 to be rejected as a non-polymorphic function, particularly given our vague explanation of what 'a actually means.<br>Our hypothetical student's mistake stems from the fact that type variables in signatures are implicitly universally-quantified â€“ that is, they stand for all types â€“ whereas type variables in constraints are not. To understand what this means, let's try to pin down a more precise idea of what type variables are. If you're already &nbsp;indoctrinated&nbsp; comfortable with type variables, you may wish to <a data-tooltip-position="top" aria-label="https://www.craigfe.io/posts/polymorphic-type-constraints#true-polymorphic-constraints" rel="noopener" class="external-link" href="https://www.craigfe.io/posts/polymorphic-type-constraints#true-polymorphic-constraints" target="_blank">cut to the chase</a>.<br><br>Type variables in constraints are referred to as being "unbound" (or "free"), meaning that they stand for some type that is not yet known to the type-checker: they are placeholders that can later be filled by a particular type. Without going into <a data-tooltip-position="top" aria-label="http://dev.stephendiehl.com/fun/006_hindley_milner.html" rel="noopener" class="external-link" href="http://dev.stephendiehl.com/fun/006_hindley_milner.html" target="_blank">the details</a>, these placeholders are gradually determined as the type-checker resolves constraints. For instance, in our id2 example, the type-checker decides that 'a equals int by first reconciling the user-supplied constraint 'a -&gt; 'a with the constraint int -&gt; int that it inferred from the implementation.<br>To a theorist (or type-system developer), who regularly has to worry about types that are not yet fully known, the notion of a "placeholder" is a sensible default meaning of an unbound type variable. Such people also tend to use explicit syntax to disambiguate the alternative case, type variables that are bound:<br>
âˆ€ a. a -&gt; a (read as: "For all a, a -&gt; a")
<br>We call "âˆ€ a" a universal quantifier because it introduces a variable a, bound inside the quantifier, that can stand for any type in the universe of OCaml types. It's this flavour of type variable that enables parametric polymorphism and â€“ although the OCaml syntax often tries to hide it from you â€“ these quantifiers exist everywhere in your programs. As I already mentioned, all unbound variables in signatures are implicitly quantified in this way:<br>
val length : 'a list -&gt; int
... secretly means ...
val length : âˆ€ a. a list -&gt; int
<br>On the implementation side of length, the compiler will check to see if there are any placeholder variables left after type-checking the definition and wrap them in universal quantifiers (if it's sure that it's safe to do so<a data-tooltip-position="top" aria-label="https://www.craigfe.io/posts/polymorphic-type-constraints#fn-2" rel="noopener" class="external-link" href="https://www.craigfe.io/posts/polymorphic-type-constraints#fn-2" target="_blank">2</a>). When this happens, we say that those type variables have been generalised. Once length has been given its polymorphic type, the user gets to pick a specific type a at each call-site by passing it a list of any element type they want. This idea of choosing the instantiation of a at each call-site is what is "parametric" about "parametric polymorphism".<br>Taking a step back, we can now see what went wrong with our hypothetical introduction to type variables above: it led our student to think of all type variables as being implicitly universally-quantified, when this is not true in constraints<a data-tooltip-position="top" aria-label="https://www.craigfe.io/posts/polymorphic-type-constraints#fn-3" rel="noopener" class="external-link" href="https://www.craigfe.io/posts/polymorphic-type-constraints#fn-3" target="_blank">3</a>. So, given that we can't rely on implicit generalisation in constraints, what can we do to declare that our code is polymorphic within the implementation itself?<br><br>The punchline is that OCaml actually does have syntax for expressing polymorphic constraints â€“ and it even involves an explicit quantifier â€“ but sadly it's not often taught to beginners:<br>let id : 'a. 'a -&gt; 'a = (fun x -&gt; x + 1)
Copy<br>The syntax 'a. 'a -&gt; 'a denotes an <a data-tooltip-position="top" aria-label="https://caml.inria.fr/pub/docs/manual-ocaml/types.html#poly-typexpr" rel="noopener" class="external-link" href="https://caml.inria.fr/pub/docs/manual-ocaml/types.html#poly-typexpr" target="_blank">explicitly-polymorphic type</a>, where 'a. corresponds directly with the âˆ€ a. quantifier we've been using so far. Applying it here gives us a satisfyingly readable error message:<br>Error: This definition has type int -&gt; int which is less general than
         'a. 'a -&gt; 'a
Copy<br>The caveat of polymorphic constraints is that we can only apply them directly to let-bindings, not to function bodies or other forms of expression:<br>let panic : 'a. unit -&gt; 'a = (fun () -&gt; raise Crisis)  (* Works fine... *)

let panic () : 'a. 'a = raise Crisis                   (* Uh oh... *)
(*               ^
 *  Error: Syntax error  *)
Copy<br>This somewhat unhelpful error message arises because OCaml will never infer a polymorphic type for a value that is not let-bound. Trying to make your type inference algorithm cleverer than this quickly runs into certain <a data-tooltip-position="top" aria-label="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/putting.pdf" rel="noopener" class="external-link" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/putting.pdf" target="_blank">undecidable problems</a>; the parser knows that the type-checker is afraid of undecidable problems, and so rejects the program straight away<a data-tooltip-position="top" aria-label="https://www.craigfe.io/posts/polymorphic-type-constraints#fn-4" rel="noopener" class="external-link" href="https://www.craigfe.io/posts/polymorphic-type-constraints#fn-4" target="_blank">4</a>.<br>In spite of their limitations, explicitly-polymorphic type constraints are a great way to express polymorphic intent in your OCaml programs, either as internal documentation or to have more productive conversations with the type-checker when debugging. I recommend using them frequently and teaching them to beginners as soon as possible.<br>At this point, if you suffered through my explanation of type variables in the previous section, you may be thinking the following:<br>
"If introducing type variables properly requires so many paragraphs of jargon, we shouldn't burden beginners with the details right away."
â€” Straw-man argument
<br>Personally, I find that introducing these terms early on in the learning process is easily worthwhile in avoiding early roadblocks, but that discussion can wait for another time. In the spirit of functional programming for the masses, let's summarise with a less jargon-heavy attempt at redrafting our hypothetical education resource:<br>
Types of the form 'a, 'b, ..., known as type variables, are placeholders for an undetermined type. When bound by for-all quantifiers (of the form 'a.), they can be used to describe values that can take on many possible types. For instance, we can write the type of (fun x -&gt; x) as 'a. 'a -&gt; 'a, meaning:

"For any type 'a, this function can take on type 'a -&gt; 'a."

The OCaml type-checker will infer polymorphic types wherever it is safe, but we can also explicitly specify a polymorphic type for a let-binding:
á… let fst : 'a 'b. ('a * 'b) -&gt; 'a = (* "For all ['a] and ['b], ..." *)
    fun (x, _) -&gt; x ;;

val fst : 'a * 'b -&gt; 'a = &lt;fun&gt;
Copy
Note that all type variables in signatures are implicitly universally-quantified: it's not necessary (or even possible) to write 'a 'b. before the type.
<br>The explanation is undeniably still longer and more technical than the one we started with, but crucially it uses the extra space to give the reader a clue as to how to debug their polymorphic functions.<br>The story doesn't end here. We haven't discussed <a data-tooltip-position="top" aria-label="https://caml.inria.fr/pub/docs/manual-ocaml/gadts.html" rel="noopener" class="external-link" href="https://caml.inria.fr/pub/docs/manual-ocaml/gadts.html" target="_blank">existential quantifiers</a>, the other type of type variable binding; or <a data-tooltip-position="top" aria-label="https://caml.inria.fr/pub/docs/manual-ocaml/polymorphism.html#s:polymorphic-recursion" rel="noopener" class="external-link" href="https://caml.inria.fr/pub/docs/manual-ocaml/polymorphism.html#s:polymorphic-recursion" target="_blank">polymorphic recursion</a>, where polymorphic annotations become compulsory; or <a data-tooltip-position="top" aria-label="https://caml.inria.fr/pub/docs/manual-ocaml/locallyabstract.html" rel="noopener" class="external-link" href="https://caml.inria.fr/pub/docs/manual-ocaml/locallyabstract.html" target="_blank">locally-abstract types</a>, which offer other useful syntaxes for constraining your OCaml programs to be polymorphic. These will all have to wait for future posts. For now, thanks for reading!<br><br>
<br>
Very similar equivalents of this explanation exist in <a data-tooltip-position="top" aria-label="http://dev.realworldocaml.org/guided-tour.html" rel="noopener" class="external-link" href="http://dev.realworldocaml.org/guided-tour.html" target="_blank">Real World OCaml</a>, <a data-tooltip-position="top" aria-label="https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook/" rel="noopener" class="external-link" href="https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook/" target="_blank">Cornell's OCaml course</a>, and <a data-tooltip-position="top" aria-label="https://www.cl.cam.ac.uk/teaching/1920/FoundsCS/focs-201920-v1.1.pdf" rel="noopener" class="external-link" href="https://www.cl.cam.ac.uk/teaching/1920/FoundsCS/focs-201920-v1.1.pdf" target="_blank">Cambridge's OCaml course</a>. Type variables are variously described as representing "any type", "an unknown type" or "a generic type"; explanations that are all as different as they are vague.<a data-tooltip-position="top" aria-label="https://www.craigfe.io/posts/polymorphic-type-constraints#fnref-1" rel="noopener" class="external-link" href="https://www.craigfe.io/posts/polymorphic-type-constraints#fnref-1" target="_blank">â†©</a>

<br>
The most famous example of a type variable that is unsafe to generalise is one that has been captured in mutable state:
á… let state = ref [] ;;
á… let sneaky_id x = (state := x :: !state); x ;;

val sneaky_id : '_weak1 -&gt; '_weak1 = &lt;fun&gt;
Copy
In this case, it's not possible to give sneaky_id the type âˆ€ a. a -&gt; a because different choices of the type a are not independent: passing a string to sneaky_id, followed by an integer, would build a list containing both strings and integers, violating type safety. Instead, sneaky_id is given a type containing a "<a data-tooltip-position="top" aria-label="https://caml.inria.fr/pub/docs/manual-ocaml/polymorphism.html#ss:weak-types" rel="noopener" class="external-link" href="https://caml.inria.fr/pub/docs/manual-ocaml/polymorphism.html#ss:weak-types" target="_blank">weak type variable</a>" which represents a single, unknown type. This meaning of type variables should be familiar to you; it's exactly the same as the "unbound" type variables we've been discussing!
In general, it's not easy to decide if it's safe to generalise a particular type variable. OCaml makes a quick under-approximation called the <a data-tooltip-position="top" aria-label="https://caml.inria.fr/pub/docs/manual-ocaml/polymorphism.html#ss:valuerestriction" rel="noopener" class="external-link" href="https://caml.inria.fr/pub/docs/manual-ocaml/polymorphism.html#ss:valuerestriction" target="_blank">(relaxed) value restriction</a>.
<a data-tooltip-position="top" aria-label="https://www.craigfe.io/posts/polymorphic-type-constraints#fnref-2" rel="noopener" class="external-link" href="https://www.craigfe.io/posts/polymorphic-type-constraints#fnref-2" target="_blank">â†©</a>

<br>
As an aside, there's no profound reason why constraints must behave differently with respect to implicit quantification. Both SML and Haskell choose to generalise variables in constraints:
val id1 : 'a -&gt; 'a = (fn x =&gt; x + 1);
(*  Error: pattern and expression in val dec do not agree

pattern:    'a -&gt; 'a
expression: 'Z[INT] -&gt; 'Z[INT] *)
Copy

(Note: val f : t = e in SML is analogous to let f : t = e in OCaml.)

I suspect that constraints having the same quantification behaviour as signatures is more intuitive, at least for simple examples. In complex cases, the exact point at which type variables are implicitly quantified can be surprising, and so SML '97 provides an explicit quantification syntax for taking control of this behaviour. See <a data-tooltip-position="top" aria-label="https://www.smlnj.org/doc/Conversion/types.html#Explicit" rel="noopener" class="external-link" href="https://www.smlnj.org/doc/Conversion/types.html#Explicit" target="_blank">the SML/NJ guide (Â§ 1.1.3)</a> for much more detail.
The advantage of OCaml's approach is that it enables constraining subcomponents of types without needing to specify the entire thing (as in (1, x) : (int * _)), which can be useful when quickly constraining types as a sanity check or for code clarity. As far as I'm aware, SML has no equivalent feature.
<a data-tooltip-position="top" aria-label="https://www.craigfe.io/posts/polymorphic-type-constraints#fnref-3" rel="noopener" class="external-link" href="https://www.craigfe.io/posts/polymorphic-type-constraints#fnref-3" target="_blank">â†©</a>

<br>
This limitation of the type-checker can artificially limit the polymorphism that can be extracted from your programs. If you want to take polymorphism to its limits â€“ as God intended â€“ it's sometimes necessary to exploit another point where explicitly-polymorphic types can appear: <a data-tooltip-position="top" aria-label="https://caml.inria.fr/pub/docs/manual-ocaml/polymorphism.html#s%3Ahigher-rank-poly" rel="noopener" class="external-link" href="https://caml.inria.fr/pub/docs/manual-ocaml/polymorphism.html#s%3Ahigher-rank-poly" target="_blank">record and object fields</a>.<a data-tooltip-position="top" aria-label="https://www.craigfe.io/posts/polymorphic-type-constraints#fnref-4" rel="noopener" class="external-link" href="https://www.craigfe.io/posts/polymorphic-type-constraints#fnref-4" target="_blank">â†©</a>

]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/ocaml/polymorphic-type-constraints.html</link><guid isPermaLink="false">Computer Science/Programming Language/OCaml/Polymorphic type constraints.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:34 GMT</pubDate></item><item><title><![CDATA[Polymorphic Variants]]></title><description><![CDATA[ 
 <br><br>This tutorial teaches you how to use polymorphic variants. This includes starting to use them, maintaining a project already using them, deciding when to use them or not, and balancing their unique benefits against their drawbacks.<br>Product types and data types such as option and list are variants and polymorphic. In this tutorial, they are called simple variants to distinguish them from the polymorphic variants presented here. Simple variants and polymorphic variants are close siblings. Their values are both introduced using labels that may carry data. Both can be recursive and have type parameters. By the way, don't trust a <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Large_language_model" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Large_language_model" target="_blank">LLM</a> chatbot if it tells you polymorphic variants are dynamically typed; it is a hallucination. Like simple variants, polymorphic variants are type-checked statically.<br>However, they are type-checked using different algorithms, which results in a different programming experience. The relationship between value and type (written with the colon symbol :) is changed with polymorphic variants. Usually, values are thought of as inhabitants of the type, which is regarded as a set-like thing. Rather, polymorphic variant values should be considered as pieces of data that several functions can accept. Polymorphic variants types are a way to express compatibility relationships between those functions. The approach in this tutorial is to build sense from experience using features of polymorphic variants.<br>Prerequisites: This is an intermediate-level tutorial. It is required to have completed tutorials on <a data-tooltip-position="top" aria-label="https://staging.ocaml.org/docs/functions-and-values" rel="noopener" class="external-link" href="https://staging.ocaml.org/docs/functions-and-values" target="_blank">Functions and Values</a>, <a data-tooltip-position="top" aria-label="https://staging.ocaml.org/docs/basic-data-types" rel="noopener" class="external-link" href="https://staging.ocaml.org/docs/basic-data-types" target="_blank">Basic Data Types</a>, and <a data-tooltip-position="top" aria-label="https://staging.ocaml.org/docs/lists" rel="noopener" class="external-link" href="https://staging.ocaml.org/docs/lists" target="_blank">Lists</a> to begin this one.<br><br>Polymorphic variants originate from Jacques Garrigue's work on Objective Label, which was <a data-tooltip-position="top" aria-label="https://caml.inria.fr/pub/old_caml_site/caml-list-ar/0533.html" rel="noopener" class="external-link" href="https://caml.inria.fr/pub/old_caml_site/caml-list-ar/0533.html" target="_blank">first published in 1996</a>. It became part of standard Objective Caml with <a data-tooltip-position="top" aria-label="https://caml.inria.fr/distrib/ocaml-3.00/" rel="noopener" class="external-link" href="https://caml.inria.fr/distrib/ocaml-3.00/" target="_blank">release 3.0</a> in 2000, along with labelled and optional function arguments. They were introduced to give more precise types in <a data-tooltip-position="top" aria-label="https://garrigue.github.io/labltk/" rel="noopener" class="external-link" href="https://garrigue.github.io/labltk/" target="_blank">LablTk</a>.<br>The core type system of OCaml follows a <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Nominal_type_system" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Nominal_type_system" target="_blank"><em></em></a>nominal discipline. Variants must be explicitly declared before being used. The typing discipline used for polymorphic variants and classes is different, as it is <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Structural_type_system" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Structural_type_system" target="_blank"><em></em></a>structural.<br>In the nominal approach of typing, types are first defined; later, when the type of an expression is inferred, three outcomes are possible:<br>
<br>If a matching type is found, it becomes the inferred type.
<br>If any type can be applied, a type parameter is created.
<br>If typing inconsistencies are found, an error is raised.
<br>This is very similar to solving an equation in mathematics. Equations accept either zero, exactly one, several, or infinitely many numbers as solutions. Nominal type-checking finds that either zero, exactly one, or any type can be used in an expression.<br>In the structural approach of typing, type definitions are optional, so they can be omitted. Type-checking an expression constructs a data structure that represents the types that are compatible with it. These data structures are displayed as type expressions sharing a resemblance with simple variants.<br><br>The type expression 'a list does not designate a single type; it designates a family of types, basically all the types that can be created by substituting an actual type to type parameter 'a. The type expressions int list, bool option list, or (float -&gt; float) list list are real types. They're actual members of the type family 'a list. Types are intended to have inhabitants, type families don't.<br>The identifiers list, option, and others are type operators. Just like functions, they take parameters. Although these parameters are not values, they are types. Their results aren't values but types, too.<br>Simple variants are polymorphic, but not in the same sense as polymorphic variants.<br>
<br>Simple variants have <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Parametric_polymorphism" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Parametric_polymorphism" target="_blank">parametric polymorphism</a>
<br>Polymorphic variants have a form of <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Structural_type_system" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Structural_type_system" target="_blank">structural polymorphism</a>
<br><br><br>The visual signature of the polymorphic variants is the back quote. Pattern matching on them looks just the same as with simple variants, except for back quotes (and capitals, which are no longer required).<br># let f = function `Broccoli -&gt; "Broccoli" | `Fruit name -&gt; name;;
val f : [&lt; `Broccoli | `Fruit of string ] -&gt; string = &lt;fun&gt;
Copy<br>Here `Broccoli and `Fruit play a role similar to the one played by the constructors Broccoli and Fruit in a variant declared as type t = Broccoli | Fruit of string. Except, and most importantly, that the definition doesn't need to be written. The tokens `Broccoli and `Fruit are called tags instead of constructors. A tag is defined by a name and a list of parameter types.<br>The expression [&lt; `Broccoli | `Fruit of string ] plays the role of a type. However, it does not represent a single type, it represents three different types.<br>
<br>The type that only has `Broccoli as an inhabitant, its translation into a simple variant is type t0 = Broccoli
<br>The type that only has `Fruit as an inhabitant, its translation into a simple variant is type t1 = Fruit of string
<br>Type type that has both `Broccoli and `Fruit inhabitants, its translation into a simple variant is type t2 = Broccoli | Fruit of string
<br>Note each of the above translations into simple variants is correct. However, entering them as-is into the environment would lead to constructor shadowing (unless type annotation is used at pattern or expression level, see section on <a data-tooltip-position="top" aria-label="https://staging.ocaml.org/docs/polymorphic-variants#Shared-Constructors" rel="noopener" class="external-link" href="https://staging.ocaml.org/docs/polymorphic-variants#Shared-Constructors" target="_blank">Shared Constructors</a>).<br>This also illustrates the other striking feature of polymorphic variants: values can be attached to several types. For instance, the tag `Broccoli inhabits [ `Broccoli ] and[ `Broccoli | `Fruit of String ], but it also inhabits any type that contains it.<br>What is displayed by the type-checker, for instance [&lt; `Broccoli | `Fruit of string ], isn't a single type. It is a type expression that designates a constrained set of types. For instance, all the types that are defined by a group of tags containing either `Broccoli or `Fruit of string and nothing more. This is the meaning of the &lt; sign in this type expression. This is a bit similar to what happens with 'a list, which isn't a single type either, but a type expression that designates the set of list types of something, i.e. the set of types where 'a has been replaced by some other type. It is also meant to indicate that the exact types are subsets of the indicated ones (this will be explained in the section on <a data-tooltip-position="top" aria-label="https://staging.ocaml.org/docs/polymorphic-variants#Subtyping-of-Polymorphic-Variants" rel="noopener" class="external-link" href="https://staging.ocaml.org/docs/polymorphic-variants#Subtyping-of-Polymorphic-Variants" target="_blank">Subtyping</a>).<br>This is the sense of the polymorphism of polymorphic variants. Polymorphic variants types are type expressions. The structural typing algorithm used for polymorphic variants creates type expressions that designate sets of types (here the three types above), which are defined by constraints on sets of tags (the inequality symbols). The polymorphism of polymorphic variants is different.<br>In the rest of this tutorial, the following terminology is used:<br>
<br>â€œsimple variantsâ€: product types and variants such as list, option
<br>polymorphic variant: type expressions displayed by the OCaml type-checker such as [&lt; `Broccoli | `Fruit of string ]
<br><br>Here is another function using pattern matching on a polymorphic variant.<br># let g = function `Edible name -&gt; name | `Broccoli -&gt; "Brassica oleracea";;
val g : [&lt; `Broccoli | `Edible of string ] -&gt; string = &lt;fun&gt;

# f `Broccoli;;
- : string = "Broccoli"

# g `Broccoli;;
- : string = "Brassica oleracea"
Copy<br>Both f and g accept the `Broccoli tag as input because they both have code for it. They do not have the same domain because f also accepts `Fruit of string whilst g also accepts `Edible of string. The domains of f and g express this. The tag `Broccoli satisfies both the constraints of the domain of f: [&lt; `Broccoli | `Fruit of string ] and the constraints of the domain of g: [&lt; `Broccoli | `Fruit of string ]. That type is [ `Broccoli ]. The value defined by a tag belongs to several types, similarly, a tag accepting functions belongs to several types.<br>Polymorphic variant tags are meant to be used as stand-alone values, wherever it makes sense. As long as used consistently, with a single implicit type per tag, the type checker will accept any combination of them in pattern-matching expressions.<br><br>Type-checking of polymorphic variants is static. No information on tag types is available at runtime.<br># [ `Fruit "Banana"; `Fruit true ];;
Error: This expression has type bool but an expression was expected of type
         string
Copy<br>When a tag is used inconsistently, the type-checker raises an error.<br><br>When building an expression from sub-expressions, the type-checker assembles types from sub-expressions to create the type of the whole expression. This is why the type discipline used for polymorphic variants is said to be structural, it follows the structure of the expressions.<br># let brocco = `Broccoli;;

# let pepe = `Peperone;;

# [ brocco; pepe; brocco ];;
- : [&gt; `Broccoli | `Peperone ] list = [`Broccoli; `Peperone; `Broccoli]
Copy<br><br>Polymorphic variant type expressions can have three forms:<br>
<br>Exact: [ `Broccoli | `Gherkin | `Fruit of string ]<br>
This only designates the type inhabited by the values introduced by these tags.
<br>Closed: [&lt; `Broccoli | `Gherkin | `Fruit of string ]<br>
This designates a set of exact types. Each exact type is inhabited by the values introduced by a subset of the tags from 1. For instance, there are 7 exact types as such:
<br>
<br>[ `Broccoli ]
<br>[ `Gherkin ]
<br>[ `Fruit of string ]
<br>[ `Broccoli | `Gherkin ]
<br>[ `Broccoli | `Fruit of string ]
<br>[ `Gherkin | `Fruit of string ]
<br>[ `Broccoli | `Gherkin | `Fruit of string ]
<br>
<br>Open: [&gt; `Broccoli | `Gherkin | `Fruit of string ]<br>
This designates a set of exact types. Each exact type is inhabited by the values introduced by supersets of the tags from 1.
<br>Note: This syntax works like if the set of natural numbers greater or equal than three was written { &gt; 3 } and the set { 0, 1, 2, 3 } was written { &lt; 3 }.<br>Tip: To distinguish closed and open type expressions, you can remember that the less-than sign &lt; is oriented the same way as a capital C letter, as in closed.<br>An exact form is inferred by the type-checker when naming a type defined by a set of tags:<br># type t = [ `Broccoli | `Gherkin | `Fruit of string ]
type t = [ `Broccoli | `Fruit of string | `Gherkin ]
Copy<br>Exact variants correspond closely to simple variants.<br>The closed form is introduced when performing pattern matching over an explicit set of tags<br># let f = function
    | `Broccoli -&gt; "Broccoli"
    | `Gherkin -&gt; "Gherkin"
    | `Fruit Fruit -&gt; Fruit;;
val upcast : [&lt; `Broccoli | `Fruit of string | `Gherkin ] -&gt; string = &lt;fun&gt;
Copy<br>The function f can be used with any exact type that has these three tags or less. When applied to a type with fewer tags, branches associated with removed tags turn safely into dead code. The type is closed because the function can't accept more than what is listed.<br>The open form can be introduced in two different ways.<br>Open polymorphic variants appear when using a catch-all pattern, either the underscore _ symbol or a name:<br># let g = function
    | `Broccoli -&gt; "Broccoli"
    | `Gherkin -&gt; "Gherkin"
    | `Fruit Fruit -&gt; Fruit
    | _ -&gt; "Edible plant";;
val g : [&gt; `Broccoli | `Fruit of string | `Gherkin ] -&gt; string = &lt;fun&gt;
Copy<br>The function g can be used with any exact type that has these three tags or more. Because of the catch-all pattern, if g is passed a value introduced by a tag that is not part of the list, it will be accepted, and "Edible plant" is returned. The type is open because it can accept more than what is listed in its expression.<br>Note: The type of g is also meant to disallow exact types with tags removed or changed in type. OCaml is a statically typed language, which means no type information is available at runtime. As a consequence pattern matching only relies on tag names. If g was assigned to a type with removed tags, such as [&gt; `Broccoli | `Gherkin ], then passing `Fruit to g would be allowed, but since dispatch is based on names, it would execute the `Fruit of string branch and crash because no string is available. Therefore, an open polymorphic variant must include all the tags from pattern matching.<br>Open polymorphic variants also appear when type-checking tags as values.<br># `Gherkin
- : [&gt; `Gherkin ] = `Gherkin

# [ `Broccoli; `Gherkin; `Broccoli ];;
- : [&gt; `Broccoli | `Gherkin ] list = [ `Broccoli; `Gherkin; `Broccoli ]
Copy<br>Setting the type of tag to the open polymorphic variant which only contains it enables:<br>
<br>To use it in all the contexts where applicable code is available.
<br>To avoid using it in contexts that can't deal with it.
<br>The build of sums of polymorphic variants. This is shown in the second example.
<br>This also applies to functions returning polymorphic variant values.<br># let f b = if b then `Up else `Down;;
val f : bool -&gt; [&gt; `Down | `Up ] = &lt;fun&gt;
Copy<br>The codomain of f is the open type [&gt; `Down | `Up ]. This makes sense when having a look at function composition.<br># let g = function
    | `Up -&gt; 1
    | `Down -&gt; 2
    | `Broken -&gt; 3;;

# fun x -&gt; x |&gt; f |&gt; g;;
- : bool -&gt; int = &lt;fun&gt;
Copy<br>Functions g and f can be composed because g accepts more than what f can return. The value `Broken will never pass from f into g, but it is safe to write it as no unexpected value can make its way through.<br>Closed and open cases are polymorphic because they do not designate a single type but families of types. An exact variant type is (structurally) monomorphic, it corresponds to a single variant type, not a set of variant types.<br><br>A closed variant type may also have an additional constraint preventing some tags from being removed.<br># let is_red = function `Clubs -&gt; false | `Diamonds -&gt; true | `Hearts -&gt; true | `Spades -&gt; false;;
val is_red : [&lt; `Clubs | `Diamonds | `Hearts | `Spades ] -&gt; bool = &lt;fun&gt;

# let h = fun u -&gt; List.map is_red (`Hearts :: u);;
val h : [&lt; `Clubs | `Diamonds | `Hearts | `Spades &gt; `Hearts ] list -&gt; bool list = &lt;fun&gt;
Copy<br>Function is_red accepts values from any subtype of [ `Clubs | `Diamonds | `Hearts | `Spades ]. However, function h excludes the exact types [ `Clubs ], [ `Diamonds ] and [ `Spades ]. The list passed to List.map includes a `Hearts tag. Types that do not include it are not allowed.<br>The domain of h is:<br>
<br>closed by [ `Clubs | `Diamonds | `Hearts | `Spades ] and,
<br>open by [ `Hearts ].
<br><br>Simple variants have a form of polymorphism called parametric polymorphism. Together with predefined types, they are type-checked using the nominal typing discipline. In this discipline, a value has a unique type.<br>In the structural type-checking discipline used for polymorphic variants, a value may have several types. Equivalently it can be said to inhabit several types:<br># let gherkin = `Gherkin;;
val Gherkin : [&gt; `Gherkin ] = `Gherkin

# let (gherkin : [ `Gherkin ]) = `Gherkin;;
val Gherkin : [ `Gherkin ] = `Gherkin

# let (gherkin : [ `Gherkin | `Avocado ]) = `Gherkin;;
val Gherkin : [ `Gherkin | `Avocado ] = `Gherkin
Copy<br>
<br>By default, the type assigned to the `Gherkin tag is [&gt; `Gherkin]. It means any variant type that includes that tag.
<br>Using an annotation, the type can be restrained to [ `Gherkin ], the exact variant type only containing `Gherkin
<br>Using another annotation allows assigning the `Gherkin value to a type containing more tags.
<br>This entails a partial ordering relation between exact variant types. The type [ `Gherkin ] is smaller than the type [ `Gherkin | `Avocado ]. The types `[ `Gherkin ] and [ `Avocado ] do not compare. The type `[ `Gherkin ] is the smallest possible type for the tag `Gherkin.<br>The order between the exact variants derives from the <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Partially_ordered_set#Partial_order" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Partially_ordered_set#Partial_order" target="_blank">partial order</a> on <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Subset" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Subset" target="_blank">subsets</a> of tags. The sets considered are the tags, with names and types. This order is said to be partial because some sets can't be compared. This order is called the subtyping order.<br>The OCaml syntax does not allow expression of the <a data-tooltip-position="top" aria-label="https://github.com/ocaml/ocaml/issues/10687" rel="noopener" class="external-link" href="https://github.com/ocaml/ocaml/issues/10687" target="_blank">empty</a> polymorphic variant type. If it was, it would be the least element in the subtyping order.<br>OCaml has a cast operator, it allows to raise the type of an expression into any larger type, with respect to the subtyping order. It is written :&gt;<br># (gherkin :&gt; [ `Avocado | `Gherkin | `Tomato ]);;
- : [ `Avocado | `Gherkin | `Tomato ] = `Gherkin
Copy<br>It means the type of gherkin is raised from [ `Gherkin | `Tomato ] into [ `Avocado | `Gherkin | `Tomato ]. It is admissible because [ `Gherkin | `Tomato ] is smaller than [ `Avocado | `Gherkin | `Tomato ] in the subtyping order.<br>When casting, it is also possible to indicate the subtype from which the value is upcast.<br># (gherkin : [ `Gherkin | `Tomato ] :&gt; [ `Avocado | `Gherkin | `Tomato ]);;
- : [ `Avocado | `Gherkin | `Tomato ] = `Gherkin
Copy<br><br><br>Exact polymorphic variant types can be given names.<br># type exotic = [ `Guayaba | `Maracuya | `Papaya ];;
Copy<br>Named polymorphic variants are always exact, thus they are equivalent to simple variants. It is not possible to give names to closed or open polymorphic variants.<br><br>Named polymorphic variants can be used to create extended types.<br># type mexican = [ exotic | `Pitahaya | `Sapodilla ];;
type mexican = [ `Guayaba | `Maracuya | `Papaya | `Pitahaya | `Sapodilla ]
Copy<br><br>Named polymorphic variants can be used as patterns.<br># let f = function
    | #exotic -&gt; "Exotic Fruit"
    | `Mango -&gt; "Mango";;
val f : [&lt; `Guayaba | `Mango | `Maracuya | `Papaya ] -&gt; string = &lt;fun&gt;
Copy<br>This is not a dynamic type check. The #exotic pattern acts like a macro, it is a shortcut to avoid writing all the corresponding patterns.<br><br><br># function `Avocado -&gt; `Cilantro | plant -&gt; plant;;
- : ([&gt; `Cilantro | `Avocado ] as 'a) -&gt; 'a = &lt;fun&gt;
Copy<br>The meaning of the type of this function is twofold.<br>
<br>Any exact variant type which is a super set of [&gt; `Cilantro | `Avocado ] is a domain
<br>The very same type is also a codomain
<br>The meaning of 'a is not the same as with simple variants. It is not a type parameter meant to be replaced by another type. The as 'a part in the type expression [&gt; `Cilantro | `Avocado ] as 'a means [&gt; `Cilantro | `Avocado ] is bound to the local name 'a in the overall expression. It allows expressing that the same variant type is used as both domain and codomain. This is a consequence of the plant -&gt; plant clause that forces domain and codomain types to be the same.<br><br>It is possible to combine polymorphic variants and parametric polymorphism. Here is a duplication of the 'a option type, translated as a polymorphic variant parametrized with a type parameter.<br># let map f = function
    | `Some x -&gt; `Some (f x)
    | `None -&gt; `None;;
val map : ('a -&gt; 'b) -&gt; [&lt; `None | `Some of 'a ] -&gt; [&gt; `None | `Some of 'b ] =
  &lt;fun&gt;
Copy<br>This map function has two type parameters: 'a and 'b. They are used to type its f parameter.<br><br>The inferred type of a polymorphic variant may be recursive.<br># let rec map f = function
    | `Nil -&gt; `Nil
    | `Cons (x, u) -&gt; `Cons (f x, map f u);;
val map :
  ('a -&gt; 'b) -&gt;
  ([&lt; `Cons of 'a * 'c | `Nil ] as 'c) -&gt; ([&gt; `Cons of 'b * 'd | `Nil ] as 'd) =
  &lt;fun&gt;
Copy<br>The aliasing mechanism is used to express type recursion. In the type expression [&lt; `Cons of 'a * 'c | `Nil ] as 'c, the local name 'c occurs inside the defined thing: [&lt; `Cons of 'a * 'c | `Nil ]. Therefore, it is a recursive type definition.<br><br>A tag `Night inhabits any type with additional tags, for instance [ `Night | `Day ] or [`Morning | `Afternoon | `Evening | `Night]. This is summarized by the subtyping order where [ `Night ] is smaller to both [ `Night | `Day ] and [`Morning | `Afternoon | `Evening | `Night ].<br>This can be seen by defining a function upcast in the following way:<br># let upcast (x : [ `Night ]) = (x :&gt; [ `Night | `Day ]);;
val upcast : [ `Night ] -&gt; [ `Night | `Day ] = &lt;fun&gt;
Copy<br>This function is an identity function it returns its parameter unchanged. It illustrates a value of type [ `Night ] can be cast into the type [ `Night | `Day ]. Casting goes from subtype to supertype.<br><br>The subtyping order extends to simple variants. Functions upcast_opt upcast_list and upcast_snd are doing the same thing as upcast except they are taking parameters from variants parametrized by polymorphic variants.<br># let upcast_opt (x : [ `Night ] option) = (x :&gt; [ `Night | `Day ] option);;
val upcast_opt : [ `Night ] option -&gt; [ `Night | `Day ] option = &lt;fun&gt;

# let upcast_list (x : [ `Night ] list) = (x :&gt; [ `Night | `Day ] list);;
val upcast_list : [ `Night ] list -&gt; [ `Night | `Day ] list = &lt;fun&gt;

let upcast_snd (x : [ `Night ] * int) = (x :&gt; [ `Night | `Day ] * int);;
val upcast_snd : [ `Night ] * int -&gt; [ `Night | `Day ] * int = &lt;fun&gt;
Copy<br>The product type and the types option, list are said to be covariant. Subtyping on parametrized variants goes â€œin the same directionâ€ as on polymorphic variants parameters:<br>
<br>[ `Night ] is a subtype of [ `Night | `Day ]
<br>[ `Night ] list is a subtype of [ `Night | `Day ] list
<br>Note that these types are covariant because of the way their type parameters appear in the type of their constructors. This is detailed in <a data-tooltip-position="top" aria-label="https://v2.ocaml.org/manual/typedecl.html#ss:typedefs" rel="noopener" class="external-link" href="https://v2.ocaml.org/manual/typedecl.html#ss:typedefs" target="_blank">Chapter 11, Section 8.1</a> of the OCaml Manual. This has nothing to do with being predefined types.<br><br>The function type is covariant on codomains. Casting a function is allowed if the target codomain is larger.<br># let upcast_dom (f : int -&gt; [ `Night ]) = (x :&gt; int -&gt; [ `Night | `Day ]);;
val f : (int -&gt; [ `Night ]) -&gt; int -&gt; [ `Night | `Day ] = &lt;fun&gt;
Copy<br>Covariance means subtyping â€œgoes in the same directionâ€:<br>
<br>On codomain: [ `Night ] is a subtype of [ `Night | `Day ]
<br>On function type: int -&gt; [ `Night ] is a subtype of int -&gt; [ `Night | `Day ]
<br>Adding tags to a polymorphic variant codomain of a function is harmless. Extending a function's codomain is pretending it can return something that is never returned. It is a false promise, and the precision of the type is reduced, but it is safe, no unexpected data will ever be returned by the function.<br><br>The function type is contravariant on domains. Casting a function is allowed if the target domain is smaller.<br># let upcast_cod (f : [ `Night | `Day ] -&gt; int) = (x :&gt; [ `Night ] -&gt; int);;
val f : ([ `Night | `Day ] -&gt; int) -&gt; [ `Night ] -&gt; int = &lt;fun&gt;
Copy<br>Contravariance means subtyping â€œis reversedâ€:<br>
<br>On domain: [ `Night ] is a subtype of [ `Night | `Day ]
<br>On function type: [ `Night | `Day ] -&gt; int is a subtype of [ `Night ] -&gt; int
<br>At first, it may seem counterintuitive. However, removing tags from a polymorphic variant domain is also harmless. The code in charge of the removed tags is turned into dead paths. Implemented generality of the function is lost, but it is safe, no data will be passed that the function can't handle.<br><br># let ingredient = function 0 -&gt; `Flour | _ -&gt; `Masa;;
val ingredient : int -&gt; [&gt; `Masa | `Flour ] = &lt;fun&gt;

# let chef = function
    | `Flour -&gt; `Bread
    | `Egg -&gt; `Tortilla
    | `Masa -&gt; `Tortilla;;
val chef : [&lt; `Masa | `Flour | `Egg ] -&gt; [&gt; `Bread | `Tortilla ] =
  &lt;fun&gt;

# let taste = function `Tortilla | `Bread -&gt; "Nutritious" | `Cake -&gt; "Yummy";;
val taste : [&lt; `Bread | `Tortilla | `Cake ] -&gt; string = &lt;fun&gt;

# fun n -&gt; n |&gt; ingredient |&gt; chef |&gt; taste;;
- : int -&gt; string = &lt;fun&gt;

# let upcasted_chef =
    (chef :&gt; [&lt; `Flour | `Masa ] -&gt; [&gt; `Bread | `Tortilla | `Cake ]);;
val upcasted_chef : [&lt; `Flour | `Masa ] -&gt; [&gt; `Bread | `Tortilla | `Cake ] =
  &lt;fun&gt;

# fun n -&gt; n |&gt; ingredient |&gt; upcasted_chef |&gt; taste;;
- : int -&gt; string = &lt;fun&gt;
Copy<br>The type of chef is a subtype of the type of upcasted_chef. The function upcasted_chef has a reduced domain and enlarged codomain. However, upcasted_chef has a domain that remains larger than the codomain of ingredient and, a codomain that remains smaller than the domain of taste. Therefore, it is safely possible to consider chef as an inhabitant of the type of upcasted_chef in the composition pipe where it is used.<br>It is also possible to refactor chef into a new function that can be used safely at the same place.<br># let refactored_chef = function
    | `Flour -&gt; `Bread
    | `Masa -&gt; (`Tortilla : [&gt; `Bread | `Tortilla | `Cake ]);;

# fun n -&gt; n |&gt; ingredient |&gt; refactored_chef |&gt; taste;;
- : int -&gt; string = &lt;fun&gt;
Copy<br><br><br>Not having to explicitly declare polymorphic variant types is beneficial in several cases.<br>
<br>When few functions use the type
<br>When many types would have to be declared
<br>When reading a pattern-matching expression using polymorphic variant tags, understanding is local. Since polymorphic variant types are anonymous or aliases, there is no need to search for the meaning of the tags somewhere else. The meaning arises from the expression itself.<br><br>When several simple variants use the same constructor name, shadowing takes place. To pattern match over a shadowed variant, type annotation must be added, either to the whole pattern-matching expression or to some patterns.<br># type a = A;;
type a = A
# type b = A;;
type b = A
# function A -&gt; true;;
- : b -&gt; bool = &lt;fun&gt;
# function (A : a) -&gt; true;;
- : a -&gt; bool = &lt;fun&gt;
# (function A -&gt; true : a -&gt; bool);;
- : a -&gt; bool = &lt;fun&gt;
Copy<br>Without this, previously entered ones are no longer reachable. This can be worked around using modules. This is explained in <a data-tooltip-position="top" aria-label="https://dev.realworldocaml.org/records.html#scrollNav-3" rel="noopener" class="external-link" href="https://dev.realworldocaml.org/records.html#scrollNav-3" target="_blank">Reusing Field Names</a> ) of the Real World OCaml book written by Yaron Minsky and Anil Madhavapeddy.<br>This problem never happens with polymorphic variants. When a tag appears several times in an expression, it must be with the same type, that's the only restriction. This makes polymorphic variants very handy when dealing with multiple sum types sharing constructors.<br><br>Using the same type in two different modules can be done in several ways:<br>
<br>Having a dependency, either direct or shared
<br>Turn the dependent module into a functor and inject the dependence as a parameter
<br>The polymorphic variants provide an additional alternative. This was proposed by Jacques Garrigue in his seminal paper â€œProgramming with Polymorphic Variantsâ€ (ACM SIGPLAN Workshop on ML, October 1998):<br>
You [...] define the same [polymorphic variant] type in both [modules], and since these are only type abbreviations, the two definitions are compatible. The type system checks the structural equality when you pass a value from one [module] to the other.
<br><br>The <a data-tooltip-position="top" aria-label="https://staging.ocaml.org/docs/error-handling" rel="noopener" class="external-link" href="https://staging.ocaml.org/docs/error-handling" target="_blank">Error Handling</a> guide details possible ways to handle errors in OCaml. Among various mechanisms, the result type, when used as a monad, provides a powerful means to handle errors. Refer to the guide and documentation on this type to learn how to use it. In this section, we discuss why using polymorphic variants to carry error values can be beneficial.<br>Let's consider this exception-raising code:<br># let f_exn m n =
    let open List in
    let u = init m Fun.id |&gt; map (fun n -&gt; n * n) in
    nth u n;;
val f_exn : int -&gt; int -&gt; int = &lt;fun&gt;
Copy<br>The following is an attempt at translating f_exn with result values instead of exceptions. It is using the Result.bind instead of |&gt;:<br># type init_error = Negative_length;;

# let init n f = try Ok (List.init n f) with
    | Invalid_argument _ -&gt; Error Negative_length;;
val init : int -&gt; (int -&gt; 'a) -&gt; ('a list, init_error) result = &lt;fun&gt;

# type nth_error = Too_short of int * int | Negative_index of int;;
type nth_error = Too_short of int * int | Negative_index of int

# let nth u i = try Ok (List.nth u i) with
    | Invalid_argument _ -&gt; Error (Negative_index i)
    | Failure _ -&gt; Error (Too_short (List.length u, i))
val nth : 'a list -&gt; int -&gt; ('a, nth_error) result = &lt;fun&gt;

# let f_res m n =
    let* u = init m Fun.id in
    let u = List.map (fun n -&gt; n * n) u in
    let* x = nth u n in
    Ok x;;
Error: This expression has type (int, nth_error) result
       but an expression was expected of type (int, init_error) result
       Type nth_error is not compatible with type init_error
Copy<br>This does not work because of the type of Result.bind.<br># Result.bind;;
- : ('a, 'e) result -&gt; ('a -&gt; ('b, 'e) result) -&gt; ('b, 'e) result = &lt;fun&gt;
Copy<br>Binding can't change the 'e type, while this code needs it to change throughout the pipe.<br>Here is an equivalent version using polymorphic variants:<br># let ( let* ) = Result.bind;;
val ( let* ) : ('a, 'b) result -&gt; ('a -&gt; ('c, 'b) result) -&gt; ('c, 'b) result =
  &lt;fun&gt;

# let init n f = try Ok (List.init n f) with
    | Invalid_argument _ -&gt; Error `Negative_length;;
val init : int -&gt; (int -&gt; 'a) -&gt; ('a list, [&gt; `Negative_length ]) result =

# let nth u i = try Ok (List.nth u i) with
    | Invalid_argument _ -&gt; Error (`Negative_index i)
    | Failure _ -&gt; Error (`Too_short (List.length u, i));;
val nth :
  'a list -&gt;
  int -&gt; ('a, [&gt; `Negative_index of int | `Too_short of int * int ]) result =
  &lt;fun&gt;

# let f_res m n =
    let* u = init m Fun.id in
    let u = List.map (fun n -&gt; n * n) u in
    let* x = nth u n in
    Ok x;;
val f_res :
  int -&gt;
  int -&gt;
  (int,
   [&gt; `Negative_index of int | `Negative_length | `Too_short of int * int ])
  result = &lt;fun&gt;

Copy<br>Using polymorphic variants, the type-checker generates a unique type for the whole pipe. The constraints coming from calling init and nth_error are merged into a single type.<br><br><br>By default, polymorphic variant types aren't declared with a name before being used. The compiler will generate type expressions corresponding to each function dealing with polymorphic variants. Some of those types are hard to read. When several such functions are composed together, inferred types can become very large and difficult to understand.<br># let rec fold_left f y = function `Nil -&gt; y | `Cons (x, u) -&gt; fold_left f (f x y) u;;
val fold_left :
  ('a -&gt; 'b -&gt; 'b) -&gt; 'b -&gt; ([&lt; `Cons of 'a * 'c | `Nil ] as 'c) -&gt; 'b = &lt;fun&gt;
Copy<br><br>In some circumstances, combining sets of constraints will artificially reduce the domain of a function. This happens when the conjunction of constraints must be taken. Functions f and g used here are those defined in the <a data-tooltip-position="top" aria-label="https://staging.ocaml.org/docs/polymorphic-variants#a-first-example" rel="noopener" class="external-link" href="https://staging.ocaml.org/docs/polymorphic-variants#a-first-example" target="_blank">first section</a>.<br># f;;
- : [&lt; `Broccoli | `Fruit of string ] -&gt; string = &lt;fun&gt;

# g;;
- : [&lt; `Broccoli | `Edible of string ] -&gt; string = &lt;fun&gt;

# let u = [f; g];;
u : ([&lt; `Broccoli ] -&gt; string) list = [&lt;fun&gt;; &lt;fun&gt;]

# f (`Fruit "Pitahaya");;
- : string = "Pitahaya"

# (List.hd u) (`Fruit "Pitahaya");;
Error: This expression has type [&gt; `Fruit of string ]
       but an expression was expected of type [&lt; `Broccoli ]
       The second variant type does not allow tag(s) `Fruit
Copy<br>Function f accepts tags `Broccoli and `Fruit whilst g accepts `Broccoli and `Edible. But if f and g are stored in a list, they must have the same type. That forces their domain to be restricted to a common subtype. Although f can handle the tag `Fruit, it no longer accepts that parameter when f is extracted from the list.<br><br>This is adapted from the section <a data-tooltip-position="top" aria-label="https://dev.realworldocaml.org/variants.html#scrollNav-4-2" rel="noopener" class="external-link" href="https://dev.realworldocaml.org/variants.html#scrollNav-4-2" target="_blank">Example: Terminal Colors Redux</a> from the â€œReal World OCamlâ€ book.<br>Tags are used to store color representations:<br>
<br>`RGB contains a <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/RGB_color_model" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/RGB_color_model" target="_blank">red, green and blue</a> triplet
<br>`Gray contains a <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Grayscale" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Grayscale" target="_blank">grayscale</a> value
<br>`RGBA contains a <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/RGBA_color_model" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/RGBA_color_model" target="_blank">red, green, blue, alpha</a> quadruplet
<br>The polymorphic variant type color groups the tags `RGB and `Gray whilst the type extended_color has three tags by extending color with `RGBA. Functions are defined to convert colors into integers.<br># type color = [ `Gray of int | `RGB of int * int * int ];;
type color = [ `Gray of int | `RGB of int * int * int ]

# type extended_color = [ color | `RGBA of int * int * int * int ];;
type extended_color =
    [ `Gray of int | `RGB of int * int * int | `RGBA of int * int * int * int ]

# let color_to_int = function
  | `RGB (r, g, b) -&gt; 36 * r + 6 * g + b + 16
  | `Gray i -&gt; i + 232;;
val color_to_int : [&lt; `Gray of int | `RGB of int * int * int ] -&gt; int = &lt;fun&gt;

# let extended_color_to_int = function
  | `RGBA (r, g, b, a) -&gt; 216 * r + 36 * g + 6 * b + a + 16
  | `Grey i -&gt; i + 2000
  | #color as color -&gt; color_to_int color;;
val extended_color_to_int :
  [&lt; `Gray of int
   | `Grey of int
   | `RGB of int * int * int
   | `RGBA of int * int * int * int ] -&gt;
  int = &lt;fun&gt;

Copy<br>The function color_to_int can convert `RGB or `Gray values. The function extended_color_to_int is intended to convert `RGB, `Gray or `RGBA values; but it is supposed to apply a different conversion formula for gray scales. However, a typo was made, it is spelled `Gray. The type-checker accepts this definition of extended_color_to_int as a function accepting four tags.<br><br>The following function was presented in the <a data-tooltip-position="top" aria-label="https://staging.ocaml.org/docs/polymorphic-variants#Inferred-Type-Aliases" rel="noopener" class="external-link" href="https://staging.ocaml.org/docs/polymorphic-variants#Inferred-Type-Aliases" target="_blank">Inferred Type Aliases</a> section.<br># function `Avocado -&gt; `Cilantro | plant -&gt; plant;;
- : ([&gt; `Cilantro | `Avocado ] as 'a) -&gt; 'a = &lt;fun&gt;
Copy<br>Because of the plant -&gt; plant pattern, the types inferred as domain and codomain are the same. As `Avocado is accepted, it must be part of the domain; and as `Cilantro is returned, it must be part of the codomain. Both end up being part of the common type. However, `Avocado should not be part of the codomain, as this function can't possibly return this value. A finer type-checker would infer more precise types. Type-checking is an approximation and a trade-off, some valid programs are rejected, and some types are too coarse.<br><br>TODO: Expand this section<br>
There is one more downside: the runtime cost. A value Pair (x, y) occupies 3 words in memory, while a value `Pair (x, y) occupies 6 words.
<br>Guillaume Melquiond<br><br>Only using polymorphic variants is over-engineering, it should be avoided. Polymorphic variants aren't an extension of simple variants. From the data perspective, polymorphic variants and simple variants are equivalent. They both are sum types in the algebraic data types sense, both with parametric polymorphism and recursion. Back quote isn't a difference that matters. The only meaningful difference is the algorithm. Therefore, deciding when to use polymorphic variants boils down to another question:<br>
Are nominally or structurally type-checked variants needed?
<br>Answering this isn't significantly easier, but it helps to narrow what to consider. The key difference lies in the way pattern matching is type-checked. Polymorphic variant induces functions that intrinsically accept more data than simple variants. This is a consequence of the subtyping relation between polymorphic variant types.<br>In a precautionary approach (inspired by <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/KISS_principle" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/KISS_principle" target="_blank">KISS</a> or <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it" target="_blank">YAGNI</a> design principles), using simple variants should be the default. However, they can feel too tight. Here are clues indicating this:<br>
<br>Many variant declarations look alike
<br>Equivalent constructor duplicated in several variants
<br>Variant declared for a single-purpose
<br>Variant declaration feeling made up or artificial
<br>Having difficulties finding names for simple variants or constructors may be smell for one of the above. When such discomfort is felt, polymorphic variants may not be the solution, but they can be considered. Keep in mind they may ease some parts but at the expense of understandability, precision and performance. Hopefully, very soon, LLM bots will be able to refactor variants of some sort into the other. This will ease experimentation.<br>To conclude, remember a simple variant that naturally encodes some data should remain a simple variant.<br><br>Although polymorphic variants share a lot with simple variants, they are substantially different. This comes from the structural type-checking algorithm used for polymorphic variants.<br>
<br>Type declaration is optional
<br>A type is a set of constraints over values
<br>A Value satisfies its type rather than inhabits it
<br>Type expression designates sets of types
<br>There is a subtyping relation between types
<br>Polymorphic variants should not be considered as an improvement over simple variants. In some regards, they are more flexible and lightweight, but they also have harder-to-read types and slightly weaker type-checking assurances. Choosing when to prefer polymorphic variants over simple variants is a subtle decision to make. It is safe to prefer simple variants as the default and go for polymorphic variants when there is a solid case for them.<br>It is important to be comfortable with polymorphic variants, many projects are using them. Most often, only a fraction of their expressive strength is used. However, refactoring code using them requires being able to understand more than what's used. Otherwise, one may quickly end up stalled by indecipherable type error messages.]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/ocaml/polymorphic-variants.html</link><guid isPermaLink="false">Computer Science/Programming Language/OCaml/Polymorphic Variants.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:35 GMT</pubDate></item><item><title><![CDATA[Rethinking OCaml abstract signatures]]></title><description><![CDATA[ 
 <br>Abstract module types are one of the less understood features of the OCaml module system. They have been one of the obstacles in the on-going effort to specify, and eventually redesign, the module system.<br>In this blog post, I (ClÃ©ment Blaudeau) present an explanation of what are those abstract module types, and propose a slightly restricted version that might be easier to understand and specify while remaining pretty expressive.<br>For the past 2 years, Iâ€™ve been working on building a new specification for the OCaml module system based on FÏ‰. The goal, besides the theoretical interest, is to eventually redo (the module part of) the typechecker with this approach, which would have several benefits:<br>
<br>fix some soundness issues and edge-cases that have appeared and built up over the years, due to unforeseen interactions between features
<br>simplify the (notoriously hard) code of the typechecker by removing ad-hoc techniques and hacks (such as the strengthening or the treatment of aliases for instance)
<br>provide a clean base to add new and awaited features. Notably, transparent ascription and modular implicits are proposals for OCaml modules stalled by the lack of specification of the module system.
<br>Yet, a key aspect in OCaml development culture is to ensure backward compatibility. Therefore, the new FÏ‰ approach Iâ€™ve been building should not only subsumes the current typechecker in normal use cases, but actually support all of the features of the module system. For long, abstract signatures (also called abstract module types) were believed to be, at least, problematic for FÏ‰. Hopefully, we found out that a slightly restricted version of the feature was encodable in FÏ‰, and, in passing, made the semantics of abstract signatures much simpler. Thus, only one question remains: does this restricted form actually covers all use cases, i.e., is the restriction backward compatible ?<br>Here, we aim at presenting the current state of abstract signatures and our proposed simplification purely from an OCaml user point of view, not from the theoretical one. We welcome any feedback, specifically, use cases or potential use cases that significantly differ from our examples.<br>We start by introducing abstract signatures through examples. Then, we present the current state of abstract signatures in OCaml: we explain the syntactic approach and the issues associated with it. We argue that it has surprising behaviors and, in its current unrestricted form, it is actually too powerful for its own good. Then, we propose a restriction to make the system predicative which, by decreasing its expressiveness, actually makes it more usable. (Our actual proposal is given in 3.3). We finish by other aspect related to usability (syntax, inference).<br><br>The art of modularity is all about controlling abstraction and interfaces. ML languages offer this control via a module system, which contains a signature language to describe interfaces. Signatures contain declarations (fields): values val x : t, types type t = int, modules module X : S, and module types module type T = S. Type and module type declarations can also be abstract type t, module type T, which serves both to hide implementation details via sealing and to have polymorphic interfaces, using functors.<br>Here, we focus on the construct module type T, called abstract module type or abstract signature. We start with examples adapted from <a data-tooltip-position="top" aria-label="https://discuss.ocaml.org/t/what-are-abstract-module-types-useful-for/10121/3" rel="noopener" class="external-link" href="https://discuss.ocaml.org/t/what-are-abstract-module-types-useful-for/10121/3" target="_blank">this forum discussion</a>.<br><br>Letâ€™s consider the following scenario. Two modules providing an implementation of UDP (UDP1 and UDP2) are developed with different design trade-offs. They both implement a signature with basic send and receive operations. Then, functors are added as layers on top: taking a udp library as input, they return another udp library as an output.<br>
<br>Reliable adds sequence numbers to the packets and re-sends missing packets;
<br>CongestionControl tracks the rate of missing packets to adapt the throughput to network congestion situations;
<br>Encryption encrypts the content of all messages.
<br>A project might need different combinations of the basic libraries and functors, while requiring that all combinations use encryption. To enforce this, the solution is to use the module-level sealing of abstract signatures. In practice, the signature of the whole library containing implementations and functors UDPLib (typically, its .mli file) is rewritten to abstract all interfaces except for the output of the Encryption functor.<br>module type UDPLib = sig<br>
module type UNSAFE<br>  module UDP1 : UNSAFE<br>
module UDP2 : UNSAFE<br>  module Reliable : UNSAFE -&gt; UNSAFE<br>
module CongestionControl : UNSAFE -&gt; UNSAFE<br>  module Encryption : UNSAFE -&gt;<br>
sig val send : string -&gt; unit ( ... ) end<br>
end<br>Just as type abstraction, signature abstraction can be used to enforce certain code patterns: users of UDPLib will only be able to use the content of modules after calling the Encryption functor, and yet they have the freedom to choose between different implementations and features:<br>module UDPKeyHandshake = Encryption(Reliable(UDP1))<br>
module UDPVideoStream  = Encryption(CongestionControl(UDP2))<br>
( etc )<br><br>Another use is to introduce polymorphism at the module level. Just as polymorphic functions can be used to factor code, module-level polymorphic functors can be used to factor module expressions. If a code happens to often feature functor applications of the form Hashtbl.Make(F(X)) or Set.Make(F(X)), one can define the MakeApply functor as follows:<br>( Factorizing common expressions )<br>
module type Type = sig module type T end<br>
module MakeApply<br>
(A:Type) (X: A.T)<br>
(B:Type) (F: A.T -&gt; B.T)<br>
(C:Type) (H: sig module Make : B.T -&gt; C.T end) = H.Make(F(X))<br>Downstream the code is rewritten into MakeApply(...)(X)(...)(F)(...)(Set) or MakeApply(...)(X)(...)(F)(...)(Hashtbl) Right now, the verbosity of such example would probably be a deal-breaker. We address this aspect at the end. Ignoring the verbosity, this can be useful for maintenance: by channeling all applications through MakeApply, only one place needs to be updated if the arity or order of arguments is changed. Similarly, if several functors expect a constant argument containing â€“ for instance â€“ global variables, a ApplyGv functor can be defined to always provide the right second argument, which can even latter be hidden away to the user of ApplyGv:<br>( Constant argument )<br>
module Gv : GlobalVars<br>
module ApplyGv (Y : sig module type A module type B end)<br>
(F : Y.A -&gt; GlobalVars -&gt; Y.B)(X : Y.A) = F(X)(Gv)<br>Downstream, code featuring F(X)(GlobalVars) is rewritten into ApplyGv(...)(F)(X) Then, the programmer can hide the GlobalVars module while letting users use ApplyGv, ensuring that global variables are not modified in uncontrolled ways by certain part of the program.<br>Finally, polymorphism can also be used by a developer to prevent unwanted dependencies on implementation details. If the body of a functor uses an argument with a submodule X, but actually does not depend on the content of S, abstracting it is a â€œgood practiceâ€.<br>module F (Arg : sig ... module X : S ... end) =<br>
... ( polymorphism is not enforced )<br>module F' (Y: sig module type S end)<br>
(Arg : sig ... module X : Y.S ... end ) =<br>
... ( polymorphism is enforced )<br><br>Fundamentally, these example are not surprising for developers that are used to rely on abstraction to protect invariants and factor code. Their specificity lies in the fact that there are at the module level, and therefore require projects with a certain size and a strong emphasis on modularity to be justified.<br><br>The challenge for understanding (and implementing) abstract signatures lies more in the meaning of the module-level polymorphism that they offer than the module level sealing, the latter being pretty straightforward. More specifically, the crux lies in the meaning of the instantiation of an abstract signature variable A by some other signature S, that happens when a polymorphic functor is applied. OCaml follows an unrestricted syntactical approach: A can be instantiated by any (well-formed) signature S. During instantiation, all occurrences of A are just replaced by S ; finally, the resulting signature is re-interpretedâ€”as if it were written as is by the user.<br>However, this syntactical rewriting interferes with the variant interpretation of signatures, which can lead to surprising behaviors. We discuss this aspect first. The unrestricted aspect leads to the (infamous) Type : Type issue which has some theoretical consequences. We finish this section by mentioning otherâ€”more technicalâ€”issues.<br><br>The first key issue of this approach comes from the fact that signatures in OCaml have a variant interpretation: abstract fields (1) have a different meaning (sealing or polymorphism) depending on whether they occur in positive or negative positions, and (2) abstract fields open new scopes, i.e.&nbsp;duplicating an abstract type field introduces two different abstract types. Overall, OCaml signatures can be thought of as having implicit quantifiers: using a signature in positive or negative position changes its implicit quantifiers (from existential to universal) while duplicating a signature duplicates the quantifiers (and therefore introduces new incompatible abstract types).<br>Therefore, when instantiating an abstract signature with a signature that has abstract fields, the user must be aware of this, and mentally infer the meaning of the resulting signature. To illustrate how it can be confusing, letâ€™s revisit the first motivating example and letâ€™s assume that the developer actually want to expose part of the interface of the raw UDP libraries. One might be tempted to instantiate UNSAFE with something along the following lines:<br>module type UDPLib_expose = sig<br>
include UDPLib with module type UNSAFE =<br>
sig<br>
module type CORE_UNSAFE<br>
module Unsafe : CORE_UNSAFE ( this part remains abstract )<br>
module Safe : sig ... end ( this part is exposed )<br>
end<br>
end<br>This returns :<br>module type UDPLib_expose =  sig<br>
module type UNSAFE =<br>
sig<br>
module type CORE_UNSAFE<br>
module Unsafe : CORE_UNSAFE<br>
module Safe : sig ... end<br>
end<br>
module UDP1 : UNSAFE<br>
module UDP2 : UNSAFE<br>
module Reliable : UNSAFE -&gt; UNSAFE<br>
module CongestionControl : UNSAFE -&gt; UNSAFE<br>
module Encryption : UNSAFE -&gt; sig val send : string -&gt; unit ( ... ) end<br>
end<br>However, the syntactical rewriting and reinterpretation of this signature in the negative positions produces a counter-intuitive result. For instance, if we expand the signature of the argument for the functor Reliable (for instance) we see:<br>module Reliable :<br>
sig<br>
module type CORE_UNSAFE<br>
module Unsafe : CORE_UNSAFE<br>
module Safe : sig ... end<br>
end -&gt; UNSAFE<br>This means that the functor actually has to be polymorphic in the underlying implementation of CORE_UNSAFE, rather than using the internal details, which has the opposite meaning as before. If the user wants to hide a shared unsafe core, accessible to the functor when they were defined and then abstracted away, the following pattern may be used instead:<br>module type UDPLib_expose' = sig<br>
module type CORE_UNSAFE<br>
include UDPLib with module type UNSAFE = sig<br>
module type CORE_UNSAFE = CORE_UNSAFE<br>
module Unsafe : CORE_UNSAFE<br>
module Safe : sig ... end<br>
end<br>
end<br>Doing so, the instantiated signature does not contain abstract fields and therefore its variant reinterpretation will not introduce unwanted polymorphism. This observation is at the core of the proposal of this post.<br><br>Abstract module types are impredicative: a signature containing an abstract signature can be instantiated by itself. One can trick the subtyping algorithm into an infinite loop of instantiating an abstract signature by itself, as shown by <a data-tooltip-position="top" aria-label="https://sympa.inria.fr/sympa/arc/caml-list/1999-07/msg00027.html" rel="noopener" class="external-link" href="https://sympa.inria.fr/sympa/arc/caml-list/1999-07/msg00027.html" target="_blank">Andreas Rosseberg</a>, adapting an example from <a data-tooltip-position="top" aria-label="https://doi.org/10.1145/174675.176927" rel="noopener" class="external-link" href="https://doi.org/10.1145/174675.176927" target="_blank">Harper and Lillibridge (POPL â€™94)</a>. This also allows type-checking of (non-terminating) programs with an absurd type, as shown by the encoding of the Girardâ€™s paradox done by <a data-tooltip-position="top" aria-label="https://github.com/lpw25/girards-paradox/tree/master" rel="noopener" class="external-link" href="https://github.com/lpw25/girards-paradox/tree/master" target="_blank">Leo White</a>.<br><br>The current implementation of the typechecker does not handle abstract signatures correctly in some scenarios. Itâ€™s unclear if they are just bugs or pose theoretical challenges.<br><br>Inside a functor, module aliases are disallowed between the parameter and the body (for soundness reasons, due to coercive subtyping). However, this check can be bypassed by using an abstract signature that is then instantiated with an alias. If we try to use it to produce a functor that exports its argument as an alias, the typechecker crashes. This is discussed in <a data-tooltip-position="top" aria-label="https://github.com/ocaml/ocaml/issues/11441" rel="noopener" class="external-link" href="https://github.com/ocaml/ocaml/issues/11441" target="_blank">#11441</a><br>( crashes the typechecker in current OCaml )<br>
module F (Type : sig module type T end)(Y : Type.T) = Y<br>module Crash (Y : sig end) =<br>
F(struct module type T = sig module X = Y end end)<br><br>The use of abstract signatures clashes with applicativity of functors, as discussed <a data-tooltip-position="top" aria-label="https://github.com/ocaml/ocaml/issues/12204" rel="noopener" class="external-link" href="https://github.com/ocaml/ocaml/issues/12204" target="_blank">in #12204</a>.<br><br>Another known issue is that the typechecker can abstract a signature when it contains unreachable type fields (types pointing to anonymous modules). This can lead to the production of invalid signatures : signatures that are refused by the typechecker when re-entered back in.<br>module F (Y: sig type t end) =<br>
struct<br>
module type A = sig<br>
type t = Y.t ( this will force the abstraction of all of A )<br>
type u<br>
end<br>
module X : A = struct type t = Y.t type u = int end<br>
type u = X.u<br>
end<br>module Test = F(struct type t end)<br>( returns )<br>
module Test : sig module type A module X : A type u = X.u end<br>Here, the type field type u = X.u is invalid as X has an abstract signature (and therefore, no fields).<br><br>In this section we explore solutions for fixing the issues of the current approach. The core criticism we make of the OCaml approach is that it is actually too expressive for its own good. Abstract signatures are impredicative: they can be instantiated by themselves. Having impredicative instantiation with variant reinterpretation is hard to track for the user and interacts in very subtle ways with other features of the module system, slowing down its developmentâ€”and breaking its theoretical properties. To address this, we take the opposite stance and propose to make the system actually predicative: we restrict the set of signatures that can be used to instantiate an abstract signature. This also indirectly addresses the complexity of the variant reinterpretation.<br>We start with the simplest solution where instantiation of abstract signatures is restricted to signatures containing no abstract fields. Then, we propose to relax this restriction and allow for signatures that contain abstract type fields (but no abstract module types), which we call simple signatures. This will requires us to briefly discuss the need for module-level sharing.<br>In this section we focus on the theoretical aspects, but present them informally with examples. The practical aspects, notably syntax and inference, are discussed in the next section.<br><br>One might wonder why abstract types and abstract signatures syntactically resembles one another and yet, the latter is much more complex than the former. The key lies in the fact that abstract types can only be instantiated by concrete type expressions, without free variables. Informally, this:<br>sig<br>
type t<br>
val x : t<br>
val f : t -&gt; t<br>
end with type t = (int * 'a)<br>is not allowed, notably because (1) the scope of the abstract type variable 'a is unclear, (2) values of type t, like x, would be ill-typed.<br>Therefore, a first solution is to require abstract signatures to be instantiated only by concrete signatures, i.e.&nbsp;signatures with no abstract fields (neither types nor module types). This circumvents the clash between the rewriting and variant reinterpretation of abstract fields (by disallowing them).<br>This is simple and sound but prevents some valid uses of abstract types: in the first example, UNSAFE could not be instantiated with abstract type fields, forcing UDP1 and UDP2 to have the same type definitions.<br><br>If we want to relax the no-abstraction proposal, some abstract fields will be allowed when instantiating signatures. Then, the question of what sharing (i.e., type equalities) should be kept between different occurrences of the abstract fields arises.<br>In OCaml signatures, sharing between two modules is usually expressed at the core-level by rewriting the fields of the signature of the second module to refer to their counterpart in the first one. This cannot be done with abstract signatures, as they have no fields. Instead, the language needs module-level sharing, which in OCaml is very restricted. Indeed, it provides a form of module aliases (only for submodules, not at the top-level of a signature), but aliasing between a functor body and its parameter is not allowedâ€”while it is typically the use-case for abstract signatures in polymorphic functors. Consider the following code:<br>( Code )<br>
module F1 (Y: sig module type A module X : A end) = Y.X<br>
module F2 (Y: sig module type A module X : A end) = (Y.X : Y.A)<br>Currently, the typechecker cannot distinguish between the two and returns the same signature, while we would expect the first one to keep the sharing between the parameter and the body.<br>( Currently, both are given the same type: )<br>
module F1 (Y: sig module type A module X : A end) : A<br>
module F2 (Y: sig module type A module X : A end) : A<br>As an example, we can consider the argument for the functors:<br>module Y = struct<br>
module type A = sig type t end<br>
module X = struct type t = int end<br>
end<br>module Test1 = F1(Y)<br>
module Test2 = F2(Y)<br>This returns :<br>module Test1 : sig type t end<br>
module Test2 : sig type t end<br>While we would expect :<br>module Test1 : sig type t = int end<br>
module Test2 : sig type t end<br>Two possible extensions would help tackle this issue.<br><br>A recently proposed experimentation, named lazy strengthening, extends the signature language with an operator S with P, where S is a signature and P a module path. It is interpreted as S strengthened by P, i.e.&nbsp;S in which all abstract fields are rewritten to point to their counterpart in P. Initially considered for performance reasons, it would allow for tracking of type equalities when using abstract signatures.<br>( Lazy strengthening would keep type equalities: )<br>
module F1 (Y: sig module type A module X : A end) = Y.A with Y.X<br><br>A more involved solution is the use of an extension of aliasing called transparent ascription, where both the alias and the signature are stored in the signature. The signature language would be extended with an operator (= P &lt; S). The technical implications of this choice are beyond the scope of this discussion.<br>( Transparent ascription would keep module equalities: )<br>
module F1 (Y: sig module type A module X : A end) : (= Y.X &lt; Y.A)<br><br>Maintaining a predicative approach, we propose to restrict instantiation only by simple signatures, i.e., signatures that may contain abstract type fields, but no abstract module types. This reintroduces the need to express module-level sharing and the mental gymnastic of variant re-interpretation of abstract type fields. However, it guarantees that all modules sharing the same abstract signature will also share the same structure (same fields) after instantiation, and can only differ in their type fields. We believe this makes for a good compromise.<br><br>One might wonder how restrictive is this proposal. Specifically, if we consider a simple polymorphic functor as:<br>module Apply (Y : sig module type A end) (F : Y.A -&gt; Y.A)(X : Y.A) = F(X)<br>The following partial application would be rejected:<br>( Rejected as A would be instantiated by sig module type B module X : B -&gt; B end )<br>
module Apply' = Apply(struct module type A = sig module type B module X : B -&gt; B end end)<br>However, this could be circumvented by eta-expanding, thus expliciting module type parameters, and instantiating only a simple signature:<br>( Accepted as A is instantiated by a signature with no abstract fields )<br>
module Apply'' = functor (Y:sig module type B end) -&gt;<br>
Apply(struct module type A = sig module type B = Y.B module X : B -&gt; B end end)<br><br>Concrete and simple signatures can be seen as the first two levels of the predicative approach for types declarations. There are no more levels for type declarations, as types cannot be partially abstract (see 3.1). Could it be useful to add even more expressivity and authorize instantiation by a signature containing again an abstract module type field (which would need to be restricted with a level system like universes)? We have found no example where this was useful. Besides, it would add a great layer of complexity.<br><br><br>A key aspect of abstract module types that reduces their usability is the verbosity of the syntax. Rather than having to pass signature as part of a module argument to a polymorphic functor, using a separate notation for module type parameters could be more concise. In practice, abstract signature arguments could be indicated by using brackets instead of parenthesis, and interleaved with normal module arguments, as in this example:<br>( At definition )<br>
module MakeApply<br>
[A] (X:A)<br>
[B] (F: A -&gt; B)<br>
[C] (H : sig module Make : B -&gt; C end)<br>
= H.Make(F(X))<br>module ApplyGv<br>
[A] [B] (F:A -&gt; GlobalVars -&gt; B) (X:A)<br>
= F(X)(Gv)<br>( At the call site )<br>
module M1 = MakeApply<br>
[T] (X)<br>
[Hashtbl.HashedType] (F)<br>
[Hashtbl.S] (Hashtbl)<br>module M2 = ApplyGv [A] [B] (F) (X)<br>Technically, this is not just syntactic sugar for anonymous parameters due to the fact that OCaml relies on names for applicativity of functors.<br><br>Following up on the previous point, usability of abstract signatures could even be improved with some form of inference at call sites. Further work is needed to understand to what extend this could be done.<br><br>We have presented the feature of abstract signatures in OCaml. After showing use cases via examples, we explained the issues associated with the unrestricted syntactical approach. Then, we propose a new specification: simple abstract signatures. In addition to making the behavior of abstract signatures much more predictable for the user, this approach can be fully formalized by translation into FÏ‰ (extended with predicative kinds).<br>As stated above, our goal here was both to sum up the current state and our proposal, but also to gather feedback from users or potential users. In particular, we want to see if it can indeed cover all use cases, and if we missed other usability problems.]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/ocaml/rethinking-ocaml-abstract-signatures.html</link><guid isPermaLink="false">Computer Science/Programming Language/OCaml/Rethinking OCaml abstract signatures.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:32 GMT</pubDate></item><item><title><![CDATA[Tail recursion modulo cons]]></title><description><![CDATA[ 
 <br>If the last action of a function ff is to call another function gg, the language run-time doesn't need to keep ff's stack frame around when calling gg:<br>let f n =
  Printf.printf "Hello, World!";
  g (n + 1)
Copy<br>Instead, the run-time may `re-purpose' ff's stack frame for gg, saving space and time in stack (de)allocations. This optimisation, known as tail call elimination, is useful in many language paradigms. It is useful in functional programming languages for which recursion is the idiomatic way to repeat actions.<br>Unfortunately, many standard uses of recursion are not tail-call optimisable:<br>let rec map f = function
  | [] -&gt; []
  | x :: xs -&gt;
     let y = f x in
     y :: map f xs
Copy<br>The x::xsx::xs case proceeds as follows:<br>
<br>Compute y:=f(x)y:=f(x);
<br>Recursively compute t1:=map&nbsp;f&nbsp;xst1â€‹:=map&nbsp;f&nbsp;xs;
<br>Allocate t2:=y::t1t2â€‹:=y::t1â€‹ on the heap;
<br>Return t2t2â€‹.
<br>Step 3 prevents the tail-call optimisation: the runtime must build the list node after computing the tail with map f xs. Our map function is almost tail-recursive: if not for the data constructor (::), it would be. We call such functions 'tail recursive modulo cons'. There are two ways to make map fully tail-recursive:<br>
<br>We could build the result list in reverse order, then reverse it in one pass at the end. This is not ideal since our intermediate list requires time to build and creates work for the garbage collector.<br>

<br>We could change the list type to allow us to build the list node first, and later fill in the correct tail. In OCaml, this needs a ref indirection.<br>

<br>Let's try the latter approach. We introduce a ref and pass the 'tail to be filled in later' as an explicit argument:<br>type 'a mutable_list = (::) of 'a * 'a mutable_list ref | []

let rec map f xs =
    let rec inner res = function
     | [] -&gt; ()
     | x :: xs -&gt;
        let y = f x in
        (* create an 'incomplete' list node *)
        let tail = ref [] in
        res := y :: tail;
        inner tail !xs (* tail call! *)
    in
    let res = ref [] in
    inner res xs; !res
Copy<br>Putting 'incomplete' values into the heap as a user requires changing the list type to contain references, but the OCaml runtime doesn't have the same restriction! It can choose to modify 'immutable' heap contents if it wants, allowing our original map to be compiled to take O(1)O(1)-space and not generate any garbage!<br>The transformation given above can be applied whenever a function is 'tail recursive modulo cons': whenever the only actions after the last function call are heap allocations. The OCaml compiler doesn't yet make this optimisation, but it could! There are interesting details to be fixed, such as what happens when a garbage collection happens in the middle of the TRMC recursion.<a data-tooltip-position="top" aria-label="https://www.craigfe.io/posts/tail-recursion-modulo-cons#fn-1" rel="noopener" class="external-link" href="https://www.craigfe.io/posts/tail-recursion-modulo-cons#fn-1" target="_blank">1</a><br>
Many thanks to <a data-tooltip-position="top" aria-label="https://discord.com/users/327286755562618891/" rel="noopener" class="external-link" href="https://discord.com/users/327286755562618891/" target="_blank">@Splingush</a> for corrections to this post.
<br><br>
<br><a rel="noopener" class="external-link" href="http://gallium.inria.fr/seminaires/transparents/20141027.Frederic.Bour.pdf" target="_blank">http://gallium.inria.fr/seminaires/transparents/20141027.Frederic.Bour.pdf</a><a data-tooltip-position="top" aria-label="https://www.craigfe.io/posts/tail-recursion-modulo-cons#fnref-1" rel="noopener" class="external-link" href="https://www.craigfe.io/posts/tail-recursion-modulo-cons#fnref-1" target="_blank">â†©</a>
]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/ocaml/tail-recursion-modulo-cons.html</link><guid isPermaLink="false">Computer Science/Programming Language/OCaml/Tail recursion modulo cons.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:33 GMT</pubDate></item><item><title><![CDATA[Testing manpages]]></title><description><![CDATA[ 
 <br>Dune supports a <a data-tooltip-position="top" aria-label="https://dune.readthedocs.io/en/stable/concepts.html#diffing-and-promotion" rel="noopener" class="external-link" href="https://dune.readthedocs.io/en/stable/concepts.html#diffing-and-promotion" target="_blank"><code></code> action</a>diff that compares two files aa and bb and fails if aa â‰  bb. The magic of this action is that it allows the user to set a:=ba:=b if aa is a source file and bb is a generated file. This is used under the hood for code formatting with dune build @fmt:<br>
<br>for each file aa, generate a formatted file bb;
<br>assert that a=ba=b;
<br>if not, the user may run dune promote to set a:=ba:=b.
<br>The diff action can also be used to write 'self-correcting' tests: write a series of tests with some expected output; run each test and diff the output with an expected output; if any of the errors are expected, run dune promote to auto-correct the test.<br>One particularly useful type of 'self-correcting' test is an assertion of the output of the --help option to a binary. Snapshot the --help output in a help.txt file and diff it against the true --help output each time you run your tests. This has two advantages:<br>
<br>you are certain of how any PR will change your program's CLI;<br>

<br>the help.txt file serves as documentation that is guaranteed to be up-to-date.<br>

<br>For example, here's how it's being done in <a data-tooltip-position="top" aria-label="https://github.com/CraigFe/oskel" rel="noopener" class="external-link" href="https://github.com/CraigFe/oskel" target="_blank">CraigFe/oskel</a>:<br>(rule
 (with-stdout-to
  oskel-help.txt.gen
  (run oskel --help=plain)))

(rule
 (alias runtest)
 (action
  (diff oskel-help.txt oskel-help.txt.gen)))
Copy]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/ocaml/testing-manpages.html</link><guid isPermaLink="false">Computer Science/Programming Language/OCaml/Testing manpages.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:36 GMT</pubDate></item><item><title><![CDATA[The _intf trick]]></title><description><![CDATA[ 
 <br>
In this post, I explain a trick for avoiding duplication of types between .ml and .mli files that will be familiar to anyone who's worked with Jane Street codebases.
<br><br>OCaml compilation units live a double life: one as source code (foo.ml) and one as header information (foo.mli).<br><img src="https://www.craigfe.io/posts/the-intf-trick/two_files.svg" referrerpolicy="no-referrer"><br>This works well in encouraging abstraction, so you'll often see less type information in the .mli than in the .ml, but any types that are not abstracted are duplicated. This is a big deal for functor-heavy projects, since large module types will end up being duplicated across the two files.<br>There's a couple of standard mitigations for this:<br>
<br>move all of your types into a single file with no corresponding .mli.
  Each foo.{ml,mli} file can now alias the types and module types from a central s.ml or types.ml file. Unfortunately, all those types are now defined separately from their point-of-use, making your codebase harder to understand and less scalable.<br>

<br>minimise the number of module types being defined.
  Since we're paying twice for each module type we define, it's natural to want to define as few of them as possible. For instance, we might avoid defining a MAKER type for our Make functor and just keep the constraints in the .mli file instead. Unfortunately, this hides the constraints from <a data-tooltip-position="top" aria-label="https://github.com/ocaml/merlin" rel="noopener" class="external-link" href="https://github.com/ocaml/merlin" target="_blank">Merlin</a>, so you won't discover any discrepancies until compile time:<br>

<br>(* --- foo.mli -------------------------------------------------------------- *)

module Make (A: Arg.S) : S with type arg = A.t

(* --- foo.ml --------------------------------------------------------------- *)

module Make (A : Arg.S) = struct

  (* We must define [type arg = A.t], but Merlin doesn't know this *)
  type arg = string

end
Copy<br>Both of these mitigations have their drawbacks. If only our foo.ml could refer to the module types defined in foo.mli. Hmm...<br><br>As with <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Fundamental_theorem_of_software_engineering" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Fundamental_theorem_of_software_engineering" target="_blank">most problems</a>, we can solve this with another layer of indirection. We add a third file, named foo_intf.ml. This file holds types and signatures, so is like our old foo.mli file, but has the distinct advantage that foo.ml can pull types from it:<br><img src="https://www.craigfe.io/posts/the-intf-trick/three_files.svg" referrerpolicy="no-referrer"><br>Now our types are defined in exactly one place, with no unnecessary duplication. The foo_intf.ml file contains all of the types required by foo.ml and also defines a special module type Intf to act as the public interface.<br>(* --- foo_intf.ml ---------------------------------------------------------- *)

(* Type definitions go here: *)

module type S = sig ... end
module type MAKER = functor (A: Arg.S) -&gt; S with type arg = A.t
type error = [ `Msg of string | `Code of int ]

(* The interface of [foo.ml]: *)

module type Intf = sig
  type error
  (** [error] is the type of errors returned by {!S}. *)

  module type S = S
  module type MAKER = MAKER

  module Make : MAKER
end

(* --- foo.ml --------------------------------------------------------------- *)

(* Fetch module types and type definitions from the [_intf] file *)
include Foo_intf

(* Implementation here as normal *)
module Make : MAKER = functor (A : Arg.S) -&gt; struct ... end

(* --- foo.mli -------------------------------------------------------------- *)

include Foo_intf.Intf (** @inline *)
Copy<br>There are some nice advantages to this approach:<br>
<br>
We've avoided duplicate definitions of foo's module types and kept them in the foo* namespace in our source tree. The code is now easier to change<a data-tooltip-position="top" aria-label="https://www.craigfe.io/posts/the-intf-trick#fn-1" rel="noopener" class="external-link" href="https://www.craigfe.io/posts/the-intf-trick#fn-1" target="_blank">1</a> and easier to understand.

<br>
Since we no longer have to minimise our use of module types, we can give the types of functors at the point of definition (module Make : MAKER = ...). This style works better with Merlin.

<br>The _intf style is commonly used in Jane Street packages (c.f. <a data-tooltip-position="top" aria-label="https://github.com/janestreet/higher_kinded/tree/master/src" rel="noopener" class="external-link" href="https://github.com/janestreet/higher_kinded/tree/master/src" target="_blank"><code></code></a>higher_kinded, <a data-tooltip-position="top" aria-label="https://github.com/janestreet/base/tree/master/src" rel="noopener" class="external-link" href="https://github.com/janestreet/base/tree/master/src" target="_blank"><code></code></a>base, <a data-tooltip-position="top" aria-label="https://github.com/janestreet/core/tree/master/src" rel="noopener" class="external-link" href="https://github.com/janestreet/core/tree/master/src" target="_blank"><code></code></a>core). Note that it's typically only used for files that export module types, for which this trick is most effective.<br>I hope you find this technique useful in making your OCaml code more concise and less frustrating to work with.<br><br><br>Use of the _intf trick is an implementation detail that (ideally) shouldn't be exposed in your documentation. At time of writing, Odoc renders all includes and type aliases with links to the source definition. In the case of included module types, you can use the @inline annotation to prevent Odoc from displaying the indirection:<br>include Foo_intf.Intf (** @inline *)
Copy<br>Unfortunately: (a) there's no equivalent trick for plain type definitions, and (b) any cross-references between module types will link to the true definition. This leaves you with rendered output like the following:<br>module Make : functor (Input : Foo__.Foo_intf.INPUT) -&gt; S
Copy<br>where INPUT is defined in the Foo_intf file but accessible to the user as Foo.INPUT (via an alias).<br>Fortunately, the <a data-tooltip-position="top" aria-label="https://github.com/ocaml/odoc/pull/439" rel="noopener" class="external-link" href="https://github.com/ocaml/odoc/pull/439" target="_blank">new Odoc model</a> solves this problem by generating links to "canonical" definitions of types, which are never taken from hidden modules (those with double underscores like Foo__). At time of writing, this new model hasn't yet been released.<br><br>An interesting side-effect of being able to reference interfaces from implementations is that you can use them to kick-start initial development on a file. If your development process begins by defining signatures, the .ml + .mli workflow requires a secondary step of "add stub implementations of everything" to sneak past the type-checker:<br>(* --- stack.mli ------------------------------------------------------------ *)

type 'a t
val empty : 'a t
val push : 'a t -&gt; 'a -&gt; 'a t
val pop : 'a t -&gt; ('a t * 'a) option

(* --- stack.ml ------------------------------------------------------------- *)

type 'a t
let empty = failwith "TODO"
let push = failwith "TODO"
let pop = failwith "TODO"
Copy<br>With an _intf file, we can provide all of these stubs in one go:<br>(* --- stack.ml ------------------------------------------------------------- *)

include (val (failwith "TODO") : Stack_intf.Intf)
Copy<br>(I learned about this trick from a <a data-tooltip-position="top" aria-label="https://blog.janestreet.com/simple-top-down-development-in-ocaml/" rel="noopener" class="external-link" href="https://blog.janestreet.com/simple-top-down-development-in-ocaml/" target="_blank">blog post</a> by Carl Eastlund.)<br><br>Emacs users with tuareg-mode can use tuareg-find-alternate-file to quickly jump between corresponding .ml and .mli files. If you use this feature (as I do), you'll want it to be aware of _intf files. This can be done by customising the tuareg-find-alternate-file variable to include the correspondence &lt;foo&gt;.ml â†” &lt;foo&gt;_intf.ml:<br>;; Add support for `foo_intf.ml' â†” `foo.ml' in tuareg-find-alternate-file
(custom-set-variables
 '(tuareg-other-file-alist
   (quote
    (("\\.mli\\'" (".ml" ".mll" ".mly"))
     ("_intf.ml\\'" (".ml"))
     ("\\.ml\\'" (".mli" "_intf.ml"))
     ("\\.mll\\'" (".mli"))
     ("\\.mly\\'" (".mli"))
     ("\\.eliomi\\'" (".eliom"))
     ("\\.eliom\\'" (".eliomi"))))))
Copy<br>If you're currently looking at some file foo.ml, tuareg-find-alternate-file will try to open foo_intf.ml and then foo.mli in that order. (If one of the two already has an open buffer, that will take priority.)<br><br>
<br>2020-06-10: changed the recommended name of the interface module type from Foo_intf.Foo to Foo_intf.Intf. In the time since I originally wrote this post, I've come to dislike the duplication of the module name using the Jane Street convention: in practice, Foo is often quite long and subjected to later renaming.
<br><br>
<br>via reducing the <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Cognitive_dimensions_of_notations" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Cognitive_dimensions_of_notations" target="_blank">repetition viscosity</a> of our notation for types.<a data-tooltip-position="top" aria-label="https://www.craigfe.io/posts/the-intf-trick#fnref-1" rel="noopener" class="external-link" href="https://www.craigfe.io/posts/the-intf-trick#fnref-1" target="_blank">â†©</a>
]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/ocaml/the-_intf-trick.html</link><guid isPermaLink="false">Computer Science/Programming Language/OCaml/The _intf trick.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:36 GMT</pubDate><enclosure url="https://www.craigfe.io/posts/the-intf-trick/two_files.svg" length="0" type="image/svg+xml"/><content:encoded>&lt;figure&gt;&lt;img src="https://www.craigfe.io/posts/the-intf-trick/two_files.svg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Transitioning to Multicore with ThreadSanitizer]]></title><description><![CDATA[ 
 <br>The 5.0 release brought Multicore, Domain-based parallelism to the OCaml language. Parallel Domains performing uncoordinated operations on shared mutable memory locations may however cause data races. Such issues will unfortunately not <a data-tooltip-position="top" aria-label="https://blog.janestreet.com/oxidizing-ocaml-parallelism/" rel="noopener" class="external-link" href="https://blog.janestreet.com/oxidizing-ocaml-parallelism/" target="_blank">(yet)</a> be caught by OCaml's strong type system, meaning they may go unnoticed when introducing parallelism into an existing OCaml code base. In this guide, we will therefore study a step-wise workflow that utilises the <a data-tooltip-position="top" aria-label="https://github.com/ocaml-multicore/ocaml-tsan" rel="noopener" class="external-link" href="https://github.com/ocaml-multicore/ocaml-tsan" target="_blank">ThreadSanitizer (TSan)</a> tool to help make your OCaml code 5.x ready.<br>Note: TSan is currently only supported under Linux with AMD/Intel cpus. It furthermore requires at least GCC 11 or Clang 11 and the libunwind library.<br><br>Consider a little bank library with the following signature in bank.mli:<br>type t
(** a collective type representing a bank *)

val init : num_accounts:int -&gt; init_balance:int -&gt; t
(** [init ~num_accounts ~init_balance] creates a bank with [num_accounts] each
    containing [init_balance]. *)

val transfer : t -&gt; src_acc:int -&gt; dst_acc:int -&gt; amount:int -&gt; unit
(** [transfer t ~src_acc ~dst_acc ~amount] moves [amount] from account
    [src_acc] to account [dst_acc].
    @raise Invalid_argument if amount is not positive,
    if [src_acc] and [dst_acc] are the same, or if [src_acc] contains
    insufficient funds. *)

val iter_accounts : t -&gt; (account:int -&gt; balance:int -&gt; unit) -&gt; unit
(** [iter_accounts t f] applies [f] to each account from [t]
    one after another. *)
Copy<br>Underneath the hood, the library may have been implemented in various ways. Consider the following thread-unsafe implementation in bank.ml:<br>type t = int array

let init ~num_accounts ~init_balance =
  Array.make num_accounts init_balance

let transfer t ~src_acc ~dst_acc ~amount =
  begin
    if amount &lt;= 0 then raise (Invalid_argument "Amount has to be positive");
    if src_acc = dst_acc then raise (Invalid_argument "Cannot transfer to yourself");
    if t.(src_acc) &lt; amount then raise (Invalid_argument "Not enough money on account");
    t.(src_acc) &lt;- t.(src_acc) - amount;
    t.(dst_acc) &lt;- t.(dst_acc) + amount;
  end

let iter_accounts t f = (* inspect the bank accounts *)
  Array.iteri (fun account balance -&gt; f ~account ~balance) t;
Copy<br><br>Now if we want to see if this code is Multicore ready for OCaml 5.x, we can utilise the following workflow:<br>
<br>Install TSan
<br>Write a parallel test runner
<br>Run tests under TSan
<br>If TSan complains about data races, address the reported issue and go to step 2.
<br><br>We will now go through the proposed workflow for our example application.<br><br>For now, convenient 5.1.0+tsan and 5.0.0+tsan opam switches are available until TSan is officially included with the forthcoming 5.2.0 OCaml release. You can install such a TSan switch as follows:<br>opam switch create 5.1.0+tsan
Copy<br><br>For a start, we can test our library under parallel usage by running two Domains in parallel. Here's a quick little test runner in bank_test.ml utilising this idea:<br>let num_accounts = 7

let money_shuffle t = (* simulate an economy *)
  for i = 1 to 10 do
    Unix.sleepf 0.1 ; (* wait for a network request *)
    let src_acc = i mod num_accounts in
    let dst_acc = (i*3+1) mod num_accounts in
    try Bank.transfer t ~src_acc ~dst_acc ~amount:1 (* transfer $1 *)
    with Invalid_argument _ -&gt; ()
  done

let print_balances t = (* inspect the bank accounts *)
  for _ = 1 to 12 do
    let sum = ref 0 in
    Bank.iter_accounts t
      (fun ~account ~balance -&gt; Format.printf "%i %3i " account balance; sum := !sum + balance);
    Format.printf "  total = %i @." !sum;
    Unix.sleepf 0.1;
  done

let _ =
  let t = Bank.init ~num_accounts ~init_balance:100 in
  (* run the simulation and the debug view in parallel *)
  [| Domain.spawn (fun () -&gt; money_shuffle t);
     Domain.spawn (fun () -&gt; print_balances t);
  |]
  |&gt; Array.iter Domain.join
Copy<br>The runner creates a bank with 7 accounts containing $100 each and then runs two loops in parallel with:<br>
<br>One transfering money with money_shuffle
<br>Another one repeatedly printing the account balances with print_balances:
<br>$ opam switch 5.1.0
$ dune runtest
0 100 1 100 2 100 3 100 4 100 5 100 6 100   total = 700
0 100 1 100 2 100 3 100 4 100 5 100 6 100   total = 700
0 100 1  99 2 100 3 100 4 101 5 100 6 100   total = 700
0 101 1  99 2  99 3 100 4 101 5 100 6 100   total = 700
0 101 1  99 2  99 3 100 4 100 5 100 6 101   total = 700
0 101 1  99 2 100 3 100 4 100 5  99 6 101   total = 700
0 101 1  99 2 100 3 100 4 100 5 100 6 100   total = 700
0 100 1 100 2 100 3 100 4 100 5 100 6 100   total = 700
0 100 1  99 2 100 3 100 4 101 5 100 6 100   total = 700
0 101 1  99 2  99 3 100 4 101 5 100 6 100   total = 700
0 101 1  99 2  99 3 100 4 101 5 100 6 100   total = 700
0 101 1  99 2  99 3 100 4 101 5 100 6 100   total = 700
Copy<br>From the above run under a regular 5.1.0 compiler, one may get the impression that everything is OK, as the balances sum to a total of $700 as expected, indicating that no money is lost.<br><br>Let us now perform the same test run under TSan. Doing so is as simple as follows and immediately complains about races:<br>$ opam switch 5.1.0+tsan
$ dune runtest
File "test/dune", line 2, characters 7-16:
2 |  (name bank_test)
           ^^^^^^^^^
0 100 1 100 2 100 3 100 4 100 5 100 6 100   total = 700
0 100 1 100 2 100 3 100 4 100 5 100 6 100   total = 700
0 100 1  99 2 100 3 100 4 101 5 100 6 100   total = 700
0 101 1  99 2  99 3 100 4 101 5 100 6 100   total = 700
0 101 1  99 2  99 3 100 4 101 5 100 6 100   total = 700
0 101 1  99 2  99 3 100 4 100 5 100 6 101   total = 700
0 101 1  99 2 100 3 100 4 100 5  99 6 101   total = 700
0 101 1  99 2 100 3 100 4 100 5 100 6 100   total = 700
0 100 1 100 2 100 3 100 4 100 5 100 6 100   total = 700
0 100 1  99 2 100 3 100 4 101 5 100 6 100   total = 700
0 101 1  99 2  99 3 100 4 101 5 100 6 100   total = 700
0 101 1  99 2  99 3 100 4 101 5 100 6 100   total = 700
==================
WARNING: ThreadSanitizer: data race (pid=26148)
  Write of size 8 at 0x7f5b0c0fd6d8 by thread T4 (mutexes: write M85):
    #0 camlBank.transfer_322 lib/bank.ml:11 (bank_test.exe+0x6de4d)
    #1 camlDune__exe__Bank_test.money_shuffle_270 test/bank_test.ml:8 (bank_test.exe+0x6d7c5)
    #2 camlStdlib__Domain.body_703 /home/opam/.opam/5.1.0+tsan/.opam-switch/build/ocaml-variants.5.1.0+tsan/stdlib/domain.ml:202 (bank_test.exe+0xb06b0)
    #3 caml_start_program &lt;null&gt; (bank_test.exe+0x13fdfb)
    #4 caml_callback_exn runtime/callback.c:197 (bank_test.exe+0x106053)
    #5 caml_callback runtime/callback.c:293 (bank_test.exe+0x106b70)
    #6 domain_thread_func runtime/domain.c:1102 (bank_test.exe+0x10a2b1)

  Previous read of size 8 at 0x7f5b0c0fd6d8 by thread T1 (mutexes: write M81):
    #0 camlStdlib__Array.iteri_367 /home/opam/.opam/5.1.0+tsan/.opam-switch/build/ocaml-variants.5.1.0+tsan/stdlib/array.ml:136 (bank_test.exe+0xa0f36)
    #1 camlDune__exe__Bank_test.print_balances_496 test/bank_test.ml:15 (bank_test.exe+0x6d8f4)
    #2 camlStdlib__Domain.body_703 /home/opam/.opam/5.1.0+tsan/.opam-switch/build/ocaml-variants.5.1.0+tsan/stdlib/domain.ml:202 (bank_test.exe+0xb06b0)
    #3 caml_start_program &lt;null&gt; (bank_test.exe+0x13fdfb)
    #4 caml_callback_exn runtime/callback.c:197 (bank_test.exe+0x106053)
    #5 caml_callback runtime/callback.c:293 (bank_test.exe+0x106b70)
    #6 domain_thread_func runtime/domain.c:1102 (bank_test.exe+0x10a2b1)

  [...]
Copy<br>Notice we obtain a back trace of the two racing accesses, with<br>
<br>A write in one Domain coming from the array assignment in Bank.transfer
<br>A read in another Domain coming from a call to Stdlib.Array.iteri to read and print the array entries in print_balances.
<br><br>One way to address the reported races is to add a Mutex, ensuring exclusive access to the underlying array. A first attempt could be to wrap transfer and iter_accounts with lock-unlock calls as follows:<br>let lock = Mutex.create () (* addition *)

let transfer t ~src_acc ~dst_acc ~amount =
  begin
    Mutex.lock lock; (* addition *)
    if amount &lt;= 0 then raise (Invalid_argument "Amount has to be positive");
    if src_acc = dst_acc then raise (Invalid_argument "Cannot transfer to yourself");
    if t.(src_acc) &lt; amount then raise (Invalid_argument "Not enough money on account");
    t.(src_acc) &lt;- t.(src_acc) - amount;
    t.(dst_acc) &lt;- t.(dst_acc) + amount;
    Mutex.unlock lock; (* addition *)
  end

let iter_accounts t f = (* inspect the bank accounts *)
  Mutex.lock lock; (* addition *)
  Array.iteri (fun account balance -&gt; f ~account ~balance) t;
  Mutex.unlock lock (* addition *)
Copy<br>Rerunning our tests, we obtain:<br>$ dune runtest
File "test/dune", line 2, characters 7-16:
2 |  (name bank_test)
           ^^^^^^^^^
0 100 1 100 2 100 3 100 4 100 5 100 6 100   total = 700
0 100 1 100 2 100 3 100 4 100 5 100 6 100   total = 700
0 100 1  99 2 100 3 100 4 101 5 100 6 100   total = 700
0 101 1  99 2  99 3 100 4 101 5 100 6 100   total = 700
Fatal error: exception Sys_error("Mutex.lock: Resource deadlock avoided")
Copy<br>How come we may hit a resource deadlock error when adding just two pairs of Mutex.lock and Mutex.unlock calls?<br><br>Oh, wait! When raising an exception in transfer, we forgot to unlock the Mutex again. Let's adapt the function to do so:<br>let transfer t ~src_acc ~dst_acc ~amount =
  begin
    if amount &lt;= 0 then raise (Invalid_argument "Amount has to be positive");
    if src_acc = dst_acc then raise (Invalid_argument "Cannot transfer to yourself");
    Mutex.lock lock; (* addition *)
    if t.(src_acc) &lt; amount
    then (Mutex.unlock lock; (* addition *)
          raise (Invalid_argument "Not enough money on account"));
    t.(src_acc) &lt;- t.(src_acc) - amount;
    t.(dst_acc) &lt;- t.(dst_acc) + amount;
    Mutex.unlock lock; (* addition *)
  end
Copy<br>We can now rerun our tests under TSan to confirm the fix:<br>$ dune runtest
0 100 1 100 2 100 3 100 4 100 5 100 6 100   total = 700
0 100 1 100 2 100 3 100 4 100 5 100 6 100   total = 700
0 100 1  99 2 100 3 100 4 101 5 100 6 100   total = 700
0 101 1  99 2  99 3 100 4 101 5 100 6 100   total = 700
0 101 1  99 2  99 3 100 4 101 5 100 6 100   total = 700
0 101 1  99 2 100 3 100 4 100 5  99 6 101   total = 700
0 101 1  99 2 100 3 100 4 100 5 100 6 100   total = 700
0 100 1 100 2 100 3 100 4 100 5 100 6 100   total = 700
0 100 1  99 2 100 3 100 4 101 5 100 6 100   total = 700
0 101 1  99 2  99 3 100 4 101 5 100 6 100   total = 700
0 101 1  99 2  99 3 100 4 101 5 100 6 100   total = 700
0 101 1  99 2  99 3 100 4 101 5 100 6 100   total = 700
Copy<br>This works well and TSan no longer complains, so our little library is ready for OCaml 5.x parallelism, hurrah!<br><br>The programming pattern of 'always-having-to-do-something-at-the-end' that we encountered with the missing Mutex.unlock is a recurring one for which OCaml offers a dedicate function:<br> Fun.protect : finally:(unit -&gt; unit) -&gt; (unit -&gt; 'a) -&gt; 'a
Copy<br>Using Fun.protect, we could have written our final fix as follows:<br>let transfer t ~src_acc ~dst_acc ~amount =
  begin
    if amount &lt;= 0 then raise (Invalid_argument "Amount has to be positive");
    if src_acc = dst_acc then raise (Invalid_argument "Cannot transfer to yourself");
    Mutex.lock lock; (* addition *)
    Fun.protect ~finally:(fun () -&gt; Mutex.unlock lock) (* addition *)
      (fun () -&gt;
         begin
           if t.(src_acc) &lt; amount
           then raise (Invalid_argument "Not enough money on account");
           t.(src_acc) &lt;- t.(src_acc) - amount;
           t.(dst_acc) &lt;- t.(dst_acc) + amount;
         end)
  end
Copy<br>Admittedly, using a Mutex to ensure exclusive access may be a bit heavy if performance is a concern. If this is the case, one option is to replace the underlying array with a lock-free data structure, such as the <a data-tooltip-position="top" aria-label="https://ocaml-multicore.github.io/kcas/doc/kcas_data/Kcas_data/Hashtbl/index.html" rel="noopener" class="external-link" href="https://ocaml-multicore.github.io/kcas/doc/kcas_data/Kcas_data/Hashtbl/index.html" target="_blank"><code></code> from<code></code></a>HashtblKcas_data.<br>As a final word of warning, Domains are so fast that in a too simple test runner, one Domain may complete before the second has even started up yet! This is problematic, as there will be no apparent parallelism for TSan to observe and check. In the above example, the calls to Unix.sleepf help ensure that the test runner is indeed parallel. A useful alternative trick is to coordinate on an Atomic to make sure both Domains are up and running before the parallel test code proceeds. To do so, we can adapt our parallel test runner as follows:<br>let _ =
  let wait = Atomic.make 2 in
  let t = Bank.init ~num_accounts ~init_balance:100 in
  (* run the simulation and the debug view in parallel *)
  [| Domain.spawn (fun () -&gt;
         Atomic.decr wait; while Atomic.get wait &gt; 0 do () done; money_shuffle t);
     Domain.spawn (fun () -&gt;
         Atomic.decr wait; while Atomic.get wait &gt; 0 do () done; print_balances t);
  |]
  |&gt; Array.iter Domain.join
Copy<br>With that warning in mind and TSan in hand, you should now be equipped to hunt for data races.]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/ocaml/transitioning-to-multicore-with-threadsanitizer.html</link><guid isPermaLink="false">Computer Science/Programming Language/OCaml/Transitioning to Multicore with ThreadSanitizer.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:30 GMT</pubDate></item><item><title><![CDATA[Rescript @genType ç”Ÿæˆçš„ TypeScript ä»£ç ä¸­çš„ import çš„é—®é¢˜]]></title><description><![CDATA[ 
 <br>Rescript 11 ä¹‹åï¼Œ@genType è¢«åˆå¹¶è¿›ç¼–è¯‘å™¨ï¼Œæ— éœ€ä»»ä½•ä¾èµ–å°±èƒ½ä½¿ç”¨ï¼Œå½“åœ¨ Rescript ä¸­ @genType äº†ä½¿ç”¨æŸäº› Rescript built-in çš„åŸºæœ¬ç±»å‹æ—¶ï¼Œå¯èƒ½ä¼šç”Ÿæˆæœ‰é—®é¢˜çš„ import ç›¸å…³ä»£ç ï¼Œä¾‹å¦‚ï¼š<br>@genType
module LoginResponse = {
  let status = response =&gt; {
    response
    -&gt;Js.Json.decodeObject
    -&gt;Option.flatMap(response =&gt; {
      response-&gt;Js_dict.get("status")
    })
  }
}
Copy<br>status å‡½æ•°å…·æœ‰ Js.Json.t =&gt; option&lt;Js.Json.t&gt; ç±»å‹ï¼Œé‚£ä¹ˆåœ¨ç”Ÿæˆçš„ TypeScript æ–‡ä»¶ä¸­ï¼Œä¼šå‡ºç°è¿™æ ·çš„ import:<br>import type { Json_t as Js_Json_t } from "./Js.gen.tsx"
Copy<br>è€Œ Js.gen.tsx è¿™ä¸ªæ–‡ä»¶æ˜¯ä¸å­˜åœ¨çš„ï¼Œè§£å†³æ–¹æ¡ˆæ˜¯ä½¿ç”¨ @genType çš„ shimï¼š<br>
<br>åœ¨ rescript.json ä¸­çš„ gentypeconfig ä¸­æ·»åŠ  shim é…ç½®:
<br>...
"gentypeconfig": {
...
  "shims": {
    "Js": "Js"
  },
...
}
...
Copy<br>
<br>ç„¶åæ–°å»º Js.shim.ts:
<br>export type Json_t = unknown;

export type t = unknown;

export type Exn_t = Error;
Copy<br>
<br>åˆ é™¤åŸæ¥ç”± @genType ç”Ÿæˆçš„ TypeScript æ–‡ä»¶å¹¶é‡æ–°ç”Ÿæˆ
<br>ç°åœ¨ç”Ÿæˆçš„ TypeScript æ–‡ä»¶å°†ä¼šä» Js.shim.ts import ç±»å‹:<br>import type {Json_t as Js_Json_t} from '../../src/model/Js.shim.ts';
Copy]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/rescript/rescript-@gentype-ç”Ÿæˆçš„-typescript-ä»£ç ä¸­çš„-import-çš„é—®é¢˜.html</link><guid isPermaLink="false">Computer Science/Programming Language/Rescript/Rescript @genType ç”Ÿæˆçš„ TypeScript ä»£ç ä¸­çš„ import çš„é—®é¢˜.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Mon, 20 May 2024 11:04:46 GMT</pubDate></item><item><title><![CDATA[Rust NewType æ¨¡å¼]]></title><description><![CDATA[ 
 <br>New Typeæ¨¡å¼æ˜¯ä¸€ç§è½¯ä»¶è®¾è®¡æ¨¡å¼ï¼Œç”¨äºåœ¨å·²æœ‰ç±»å‹çš„åŸºç¡€ä¸Šåˆ›å»ºä¸€ä¸ªæ–°çš„ç±»å‹ã€‚åœ¨Rustä¸­ï¼Œè¿™é€šå¸¸æ˜¯é€šè¿‡å®šä¹‰ä¸€ä¸ªç»“æ„ä½“ï¼Œå…¶ä¸­åªåŒ…å«ä¸€ä¸ªå•ä¸€æˆå‘˜ã€‚è¿™ä¸ªç»“æ„ä½“ï¼ˆNew Typeï¼‰å¯¹å¤–æä¾›äº†ä¸€ä¸ªæ–°çš„ã€ç‹¬ç«‹çš„ç±»å‹ï¼Œç”¨äºå¯¹åŸå§‹ç±»å‹å¢åŠ é¢å¤–çš„è¯­ä¹‰æˆ–é™åˆ¶ã€‚<br><br>struct Meters(f64);
struct Feet(f64);

let length_in_meters = Meters(100.0);
let length_in_feet = Feet(328.084);

// ç¼–è¯‘å™¨ä¼šé˜²æ­¢ä»¥ä¸‹ä»£ç æ‰§è¡Œï¼Œå› ä¸ºç±»å‹ä¸åŒ¹é…
// let wrong_length = Meters(length_in_feet); // ç¼–è¯‘é”™è¯¯

// æ­£ç¡®çš„æ„é€ 
fn add_lengths(length1: Meters, length2: Meters) -&gt; Meters {
    Meters(length1.0 + length2.0)
}
Copy<br>è¿™ä¸ªä¾‹å­ä½¿ç”¨ newtype æ¨¡å¼é¿å…å°†åŸå§‹ç±»å‹f64ç”¨äºä¸åŒçš„é‡åº¦ï¼Œä»è€Œå¢å¼ºäº†ç±»å‹çš„å®‰å…¨æ€§ã€‚<br><br>struct Kilometers(f64);

impl Kilometers {
    fn to_miles(&amp;self) -&gt; f64 {
        self.0 * 0.621371
    }
}

let distance = Kilometers(10.0);
println!("The distance in miles is {}", distance.to_miles());
Copy<br>è¿™é‡Œï¼ŒKilometersæœ‰ä¸€ä¸ªæ–¹æ³•to_milesï¼Œè¯¥æ–¹æ³•æ˜¯ä¸ä¼šå½±å“å…¶ä»–f64æ•°æ®çš„ã€‚å¦‚æœæˆ‘ä»¬æœ‰å¦ä¸€ä¸ªè¡¨ç¤ºæ¸©åº¦çš„f64ç±»å‹ï¼Œå°±ä¸ä¼šæ„å¤–è°ƒç”¨åˆ°ä¸è·ç¦»ç›¸å…³çš„æ–¹æ³•ã€‚<br>New Typeæ¨¡å¼åŒæ ·é€‚ç”¨äºå¯¹Box&lt;dyn SomeTrait&gt;ç±»å‹çš„åŒ…è£…ï¼Œè¿™å¯ä»¥åœ¨éœ€è¦åŠ¨æ€åˆ†æ´¾ï¼ˆåŠ¨æ€è°ƒç”¨å®ç°äº†æŸä¸ªæ¥å£çš„ä¸åŒç±»å‹çš„å¯¹è±¡çš„æ–¹æ³•ï¼‰çš„æ—¶å€™æä¾›ä¾¿åˆ©ã€‚é€šè¿‡åˆ›å»ºä¸€ä¸ªNew Typeæ¥åŒ…è£…è¿™æ ·çš„Box&lt;dyn SomeTrait&gt;ç±»å‹ï¼Œå¯ä»¥æä¾›è‡ªå®šä¹‰çš„æ–¹æ³•æˆ–å®ç°æ›´å¤šçš„traitï¼ŒåŒæ—¶ä¹Ÿå¯ä»¥è®©APIæ›´åŠ æ¸…æ™°å’Œæ˜“äºä½¿ç”¨ã€‚<br><br>åœ¨Rustä¸­ï¼ŒNew Typeæ¨¡å¼ä¸ä»…æ˜¯ç±»å‹å®‰å…¨çš„ï¼Œè¿˜æ˜¯ä¸€ç§é›¶æˆæœ¬æŠ½è±¡ã€‚è¿™æ˜¯å› ä¸ºRustç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶æœŸä¼šè¿›è¡Œè¶³å¤Ÿçš„ä¼˜åŒ–ï¼Œä»¥ç¡®ä¿New Typeçš„ä½¿ç”¨æ²¡æœ‰è¿è¡Œæ—¶å¼€é”€ã€‚ Rustçš„é›¶æˆæœ¬æŠ½è±¡åŸåˆ™ç¡®ä¿äº†æŠ½è±¡ä¸ä¼šå¼•å…¥é¢å¤–çš„è¿è¡Œæ—¶æˆæœ¬ã€‚ä¾‹å¦‚ï¼Œå½“ä½ ä½¿ç”¨Metersè¿™æ ·çš„New Typeæ—¶ï¼ŒRustç¡®ä¿ï¼š<br>
<br>æ— é¢å¤–å†…å­˜å¼€é”€ï¼šMetersåªåŒ…å«ä¸€ä¸ªf64ï¼Œåœ¨å†…å­˜ä¸­çš„è¡¨ç°å’Œå•ç‹¬çš„f64æ˜¯ä¸€æ ·çš„ã€‚
<br>æ— é¢å¤–è¿è¡Œæ—¶å¼€é”€ï¼šä½¿ç”¨Metersæ—¶ï¼Œæ€§èƒ½å’Œç›´æ¥ä½¿ç”¨f64å®Œå…¨ç›¸åŒã€‚ç¼–è¯‘å™¨ä¼šç§»é™¤ä»»ä½•å…³äºNew Typeçš„åŒ…è£…å’Œè§£åŒ…çš„ä»£ç ã€‚
]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/rust/rust-newtype-æ¨¡å¼.html</link><guid isPermaLink="false">Computer Science/Programming Language/Rust/Rust NewType æ¨¡å¼.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sat, 11 May 2024 03:01:07 GMT</pubDate></item><item><title><![CDATA[Rust Partial è¯­ä¹‰]]></title><description><![CDATA[ 
 <br>
åœ¨Rustä¸­ï¼ŒPartialEqå’ŒPartialOrd traitå¤„ç†äº†ä¸æ˜¯æ‰€æœ‰å€¼éƒ½å¯ä»¥ç›¸äº’æ¯”è¾ƒçš„æƒ…å†µã€‚
<br><br>PartialEq traitç”¨äºå®šä¹‰å€¼ç›¸ç­‰æ€§çš„æ¯”è¾ƒã€‚å®ƒçš„è®¾è®¡å…è®¸ç±»å‹çš„å€¼ä¹‹é—´è¿›è¡Œç›¸ç­‰ï¼ˆ==ï¼‰å’Œä¸ç­‰ï¼ˆ!=ï¼‰çš„æ¯”è¾ƒã€‚ä¸å…¶å¯¹åº”çš„ Eq trait ç¡®ä¿ä¸€ä¸ªç±»å‹çš„æ‰€æœ‰å€¼éƒ½æ˜¯å¯ä»¥å¯é æ¯”è¾ƒçš„ï¼Œå³æ»¡è¶³ç­‰ä»·å…³ç³»çš„ç‰¹æ€§ï¼Œå¦‚è‡ªåæ€§ã€å¯¹ç§°æ€§å’Œä¼ é€’æ€§ã€‚<br>fn eq(&amp;self, other: &amp;Self) -&gt; bool;
fn ne(&amp;self, other: &amp;Self) -&gt; bool;
Copy<br>åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œç±»å‹çš„å€¼éƒ½èƒ½å¤Ÿå®Œå…¨æ¯”è¾ƒç›¸ç­‰æ€§ï¼Œè¿™æ—¶å¯ä»¥å®ç°Eqã€‚ç„¶è€Œï¼Œå¯¹äºä¸€äº›ç‰¹æ®Šç±»å‹çš„å€¼ï¼Œå¦‚æµ®ç‚¹æ•°ï¼Œç”±äºå­˜åœ¨æ— ç©·å¤§çš„æ­£è´Ÿå€¼å’ŒNaNå€¼ï¼Œå¯¼è‡´å®ƒä»¬çš„æ¯”è¾ƒæ›´åŠ å¤æ‚ã€‚ä¾‹å¦‚ï¼Œæ ¹æ®IEEEæµ®ç‚¹æ•°çš„æ ‡å‡†ï¼ŒNaNä¸ä»»ä½•å€¼ï¼ˆåŒ…æ‹¬å®ƒè‡ªå·±ï¼‰æ¯”è¾ƒéƒ½ä¸ç›¸ç­‰ã€‚<br><br>PartialOrd traitç”¨äºå®šä¹‰å€¼ä¹‹é—´çš„å¤§å°æ¯”è¾ƒã€‚ç±»ä¼¼äºPartialEqï¼Œå®ƒå…è®¸éƒ¨åˆ†æ¯”è¾ƒå¤§å°ï¼Œè¿”å›ä¸€ä¸ªOptionï¼Œè¡¨ç¤ºæ¯”è¾ƒç»“æœå¯èƒ½å­˜åœ¨ï¼Œä¹Ÿå¯èƒ½ä¸å­˜åœ¨ï¼ˆå³æ¯”è¾ƒæ— æ³•è¿›è¡Œæ—¶è¿”å›Noneï¼‰:<br>fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt;;
Copy<br>åœ¨å…¨éƒ¨æ¯”è¾ƒå¯èƒ½çš„åœºæ™¯ï¼Œæˆ‘ä»¬ä¼šä½¿ç”¨Ord traitï¼Œå®ƒè¦æ±‚å®ç°cmpæ–¹æ³•ï¼Œæ€»æ˜¯è¿”å›ä¸€ä¸ªOrderingï¼Œè¡¨ç¤ºä¸¤ä¸ªå€¼ä¹‹é—´çš„ç¡®åˆ‡æ¯”è¾ƒå…³ç³»ã€‚Ordæ˜¯åœ¨æ‰€æœ‰å€¼éƒ½èƒ½å¤Ÿæ¯”è¾ƒæ—¶ä½¿ç”¨çš„ï¼Œä¾‹å¦‚æ•´æ•°å’Œå­—ç¬¦ä¸²ã€‚<br><br>Rust è®¾è®¡ PartialEq å’Œ PartialOrd trait ä¸»è¦å‡ºäºä»¥ä¸‹å‡ ä¸ªç†ç”±ï¼š<br>
<br>éæ€»åºç†å¿µï¼šå¹¶ä¸æ˜¯æ‰€æœ‰ç±»å‹éƒ½æœ‰ä¸€ä¸ªå…¨å±€çš„æ’åºæ–¹æ³•ã€‚ä¾‹å¦‚ï¼Œå¤æ•°ä¹‹é—´å°±æ²¡æœ‰ä¸€ä¸ªè‡ªç„¶çš„å¤§å°é¡ºåºã€‚ä¸ºäº†é¿å…ä¸ºè¿™äº›ç±»å‹äººä¸ºåœ°èµ‹äºˆä¸€ä¸ªæ’åºæ–¹æ³•ï¼ŒRust æä¾›äº†ä¸€ä¸ªåªéœ€éƒ¨åˆ†å®ç°åºåˆ—æ“ä½œçš„é€‰æ‹©ã€‚
<br>IEEE æµ®ç‚¹æ•°æ ‡å‡†ï¼šç”±äºæµ®ç‚¹æ•°æ ‡å‡†å®šä¹‰äº†ç‰¹æ®Šå€¼ï¼ˆNaN, æ­£è´Ÿæ— ç©·ï¼‰ï¼Œä»¥åŠNaNä¸ç­‰äºè‡ªèº«çš„è§„åˆ™ï¼Œæµ®ç‚¹æ•°åœ¨ä¸€äº›æƒ…å†µä¸‹ä¸èƒ½è¿›è¡Œç›¸ç­‰æ€§æˆ–å¤§å°æ¯”è¾ƒã€‚
<br>æå‡é”™è¯¯å¤„ç†èƒ½åŠ›å’Œå®‰å…¨æ€§ï¼šé€šè¿‡è¿”å› Option&lt;Ordering&gt;ï¼Œpartial_cmp æ–¹æ³•æ˜ç¡®æŒ‡å‡ºäº†å¤±è´¥çš„å¯èƒ½æ€§ï¼Œä»è€Œè¿«ä½¿ç¨‹åºå‘˜åœ¨ä½¿ç”¨æ—¶è€ƒè™‘å¹¶å¤„ç†è¿™ç§æƒ…å†µï¼Œå¢åŠ äº†ä»£ç çš„æ­£ç¡®æ€§å’Œç¨³å¥æ€§ã€‚
<br>è¡¨è¾¾æ€§å’Œçµæ´»æ€§ï¼šè¿™äº› trait å…è®¸å¼€å‘è€…ä¸ºè‡ªå®šä¹‰ç±»å‹å®šä¹‰é€‚å½“çš„ç›¸ç­‰æ€§å’Œæ’åºè¡Œä¸ºï¼Œä»è€ŒåŠ å¼ºäº† Rust ç±»å‹ç³»ç»Ÿçš„è¡¨è¾¾æ€§å’Œçµæ´»æ€§ã€‚
<br>PartialEq å’Œ PartialOrd trait çš„è®¾è®¡å…è®¸ç¨‹åºå‘˜é€‰æ‹©ç²¾å‡†çš„ç›¸ç­‰æ€§å’Œæ’åºè¯­ä¹‰ï¼ŒåŒæ—¶æ˜ç¡®äº†å¯¹äºæŸäº›ç±»å‹ç›¸ç­‰æ€§æ¯”è¾ƒå’Œå¤§å°æ’åºå¹¶ä¸æ€»æ˜¯å¯èƒ½çš„äº‹å®ã€‚é€šè¿‡å¼•å…¥é€‚åº¦çš„å¤æ‚æ€§ï¼Œè®© Rust çš„ç±»å‹ç³»ç»Ÿæ›´åŠ å®‰å…¨ã€‚]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/rust/rust-partial-è¯­ä¹‰.html</link><guid isPermaLink="false">Computer Science/Programming Language/Rust/Rust Partial è¯­ä¹‰.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 12 May 2024 13:32:23 GMT</pubDate></item><item><title><![CDATA[Rust è™šè¡¨å¸ƒå±€è§„åˆ™ä»‹ç»]]></title><description><![CDATA[ 
 <br>åœ¨ Rust ä¸­ï¼Œä¸€ä¸ªæŒ‡å‘æœªçŸ¥å¤§å°å¯¹è±¡ï¼ˆ!Sizedï¼‰çš„å¼•ç”¨æˆ–æŒ‡é’ˆè¢«å®ç°ä¸ºä¸€ä¸ªç”±ä¸¤ä¸ª usize å¤§å°çš„åŸŸæ„æˆçš„èƒ–æŒ‡é’ˆã€‚è¿™ä¸¤ä¸ªåŸŸä¸­ï¼Œå…¶ä¸­ä¸€ä¸ªåŸŸä¿å­˜äº†è¢«å¼•ç”¨æˆ–è¢«æŒ‡å‘çš„å¯¹è±¡çš„åœ°å€ï¼Œå¦ä¸€ä¸ªåŸŸä¿å­˜äº†ä¸€ä¸ªåä¸º metadata çš„æ•°æ®ã€‚å¯¹äº slice çš„å¼•ç”¨æˆ–æŒ‡é’ˆæ¥è¯´ï¼Œå…¶ metadata ä¸º slice çš„é•¿åº¦ã€‚å¯¹äº trait object çš„å¼•ç”¨æˆ–æŒ‡é’ˆæ¥è¯´ï¼Œå…¶ metadata ä¸ºè™šè¡¨ï¼ˆvtableï¼‰åœ°å€ã€‚ä¸ C++ è™šè¡¨ç±»ä¼¼ï¼ŒRust è™šè¡¨çš„å­˜åœ¨ä½¿å¾—è¯¸å¤šåŠ¨æ€è¯­è¨€ç‰¹æ€§å¾—ä»¥å®ç°ï¼Œä¾‹å¦‚åŠ¨æ€æ´¾å‘ï¼ˆdynamic dispatchï¼‰ã€å‘ä¸Šè½¬æ¢ï¼ˆupcastingï¼‰ã€å‘ä¸‹è½¬æ¢ï¼ˆdowncastï¼‰ç­‰ã€‚æœ¬æ–‡å°†å¯¹ Rust ä¸­è™šè¡¨çš„å¸ƒå±€è§„åˆ™è¿›è¡Œç®€è¦ä»‹ç»ï¼Œå¹¶åœ¨æ­¤è¿‡ç¨‹ä¸­å¯¹ Rust ä¸­è‹¥å¹²åŠ¨æ€ç‰¹æ€§çš„å®ç°æ–¹æ³•è¿›è¡Œç®€è¦ä»‹ç»ã€‚<br>
æ³¨æ„ï¼šRust è™šè¡¨åŠå…¶ç»“æ„å±äº Rust è¯­è¨€çš„å†…éƒ¨å®ç°ç»†èŠ‚ï¼Œä¸ä¿è¯ç¨³å®šæ€§ã€‚æœ¬æ–‡æ‰€ä»‹ç»çš„è™šè¡¨å¸ƒå±€ä»…åæ˜ æœ¬æ–‡åˆ›ä½œæ—¶æœ€æ–°çš„ Rust è™šè¡¨ç»“æ„[1]ï¼Œåœ¨å°†æ¥ Rust è™šè¡¨ç»“æ„å¯èƒ½ä¼šå‘ç”Ÿå˜åŒ–ã€‚ä¸€ä¸ª Rust ç¨‹åºçš„æ­£ç¡®æ€§ä¸åº”è¯¥ä»¥ä»»ä½•æ–¹å¼ä¾èµ–äº Rust è™šè¡¨çš„ç»“æ„ã€‚
<br><br>Rust ç¨‹åºä¸­çš„æ‰€æœ‰è™šè¡¨å‡ä»¥ä¸€ä¸ªå›ºå®šç»“æ„çš„ header å¼€å¤´ã€‚Header ä¸­æŒ‰é¡ºåºåŒ…å«ä¸‰ä¸ªusize å¤§å°çš„å­—æ®µï¼šdrop_in_place ï¼Œsize å’Œ align ã€‚åœ¨ header ä¹‹åæ˜¯ä¸€ç³»åˆ—çš„ usize å¤§å°å­—æ®µï¼Œå…¶æ•°é‡ä»¥åŠå«ä¹‰åœ¨æ¯ä¸ªè™šè¡¨ä¸­å¯èƒ½éƒ½ä¸åŒã€‚<br>+---------------+
| drop_in_place |
+---------------+
| size          |
+---------------+
| align         |
+---------------+
| entry1        |
+---------------+
| entry2        |
+---------------+
| entry3        |
+---------------+
Copy<br>è™šè¡¨ header ä¸­çš„drop_in_place æ˜¯ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆï¼Œå…¶æŒ‡å‘çš„å‡½æ•°èƒ½å¤ŸåŸåœ° drop å½“å‰èƒ–æŒ‡é’ˆæ‰€å¼•ç”¨çš„å¯¹è±¡ã€‚size å’Œ align ä¸¤ä¸ªåŸŸåˆ†åˆ«ç»™å‡ºå¯¹è±¡çš„å¤§å°å’Œå†…å­˜å¯¹é½ï¼Œè¿™ä¸¤ä¸ªåŸŸå…±åŒæ„æˆä¸€ä¸ª std::alloc::Layout ç»“æ„ï¼Œå¯ç”¨äºé‡Šæ”¾å½“å‰èƒ–æŒ‡é’ˆæ‰€å¼•ç”¨çš„å¯¹è±¡æ‰€å æ®çš„å†…å­˜ã€‚è™šè¡¨ header çš„å­˜åœ¨ä½¿å¾— trait object æ€»æ˜¯èƒ½è¢«é”€æ¯å’Œé‡Šæ”¾ã€‚ä¾‹å¦‚å½“é”€æ¯ä¸€ä¸ª Box&lt;dyn Trait&gt; æ—¶ï¼ŒBox::&lt;dyn Trait&gt;::drop ä¼šé¦–å…ˆè°ƒç”¨è™šè¡¨ä¸­çš„ drop_in_place å‡½æ•°åŸåœ°é”€æ¯ Box æ‰€å¼•ç”¨çš„å¯¹è±¡ï¼Œç„¶åå†è°ƒç”¨ dealloc å‡½æ•°å¹¶ä¼ é€’è™šè¡¨ä¸­çš„ size å’Œ align é‡Šæ”¾å †ç©ºé—´ã€‚<br>åœ¨è™šè¡¨ header ä¹‹åæ˜¯ä¸€ç³»åˆ—çš„å­—æ®µã€‚åœ¨æœ€æ™®éçš„æƒ…å†µä¸‹ï¼Œæ¯ä¸ªå­—æ®µä»£è¡¨ä¸€ä¸ªæŒ‡å‘ trait æ‰€å®šä¹‰çš„å‡½æ•°çš„æŒ‡é’ˆã€‚ä¾‹å¦‚ï¼Œå¯¹äºä¸‹åˆ— object safe çš„ trait:<br>pub trait Trait {
    fn fun1(&amp;self);
    fn fun2(&amp;self);
    fn fun3(&amp;self);
}
Copy<br>å¦‚æœç±»å‹T å®ç°äº† Traitï¼Œé‚£ä¹ˆä¸º T ç”Ÿæˆçš„ Trait è™šè¡¨çš„ç»“æ„ä¸ºï¼š<br>+--------------------------+
| fn drop_in_place(*mut T) |
+--------------------------+
| size of T                |
+--------------------------+
| align of T               |
+--------------------------+
| fn &lt;T as Trait&gt;::fun1    |
+--------------------------+
| fn &lt;T as Trait&gt;::fun2    |
+--------------------------+
| fn &lt;T as Trait&gt;::fun3    |
+--------------------------+
Copy<br>Trait ä¸­çš„å‡½æ•°æŒ‰ç…§å£°æ˜é¡ºåºä¾æ¬¡æ’åˆ—åœ¨è™šè¡¨ header ä¹‹åã€‚å½“é€šè¿‡ä¸€ä¸ªæŒ‡å‘ T å¯¹è±¡çš„ &amp;dyn Trait è°ƒç”¨ fun2 å‡½æ•°æ—¶ï¼Œç¨‹åºä¼šå…ˆä»è™šè¡¨çš„ç¬¬ 5 ä¸ªåŸŸä¸­å¾—åˆ°ä¸º T å®ç°çš„ Trait::fun2 å‡½æ•°çš„åœ°å€ï¼Œç„¶åå†è°ƒç”¨ä¹‹ã€‚<br><br>Object safe çš„ trait å¯ä»¥æœ‰ super traitã€‚ä¾‹å¦‚ï¼š<br>pub trait Grand {
    fn grand_fun1(&amp;self);
    fn grand_fun2(&amp;self);
}

pub trait Parent : Grand {
    fn parent_fun1(&amp;self);
    fn parent_fun2(&amp;self);
}

pub trait Trait : Parent {
    fn fun(&amp;self);
}
Copy<br>å¦‚æœç±»å‹T å®ç°äº† Traitï¼Œé‚£ä¹ˆæ­¤æ—¶ä¸º T ç”Ÿæˆçš„ Trait è™šè¡¨çš„ç»“æ„ä¸ºï¼š<br>+-------------------------------+
| fn drop_in_place(*mut T)      |
+-------------------------------+
| size of T                     |
+-------------------------------+
| align of T                    |
+-------------------------------+
| fn &lt;T as Grand&gt;::grand_fun1   |
+-------------------------------+
| fn &lt;T as Grand&gt;::grand_fun2   |
+-------------------------------+
| fn &lt;T as Parent&gt;::parent_fun1 |
+-------------------------------+
| fn &lt;T as Parent&gt;::parent_fun2 |
+-------------------------------+
| fn &lt;T as Trait&gt;::fun          |
+-------------------------------+
Copy<br>å¯ä»¥çœ‹åˆ°ï¼Œæ­¤æ—¶Trait ä»¥åŠ Trait çš„æ‰€æœ‰ç›´æ¥æˆ–é—´æ¥çˆ¶ trait æ‰€å®šä¹‰çš„æ‰€æœ‰å‡½æ•°å‡åŒ…å«åœ¨è™šè¡¨ header ä¹‹åï¼Œä¸”é¡ºåºä¸ºååºï¼ˆå³å…ˆæ’å¸ƒ Trait çš„çˆ¶ trait æ‰€å®šä¹‰çš„æ‰€æœ‰å‡½æ•°ï¼Œæœ€åå†æ’å¸ƒ Trait æ‰€å®šä¹‰çš„æ‰€æœ‰å‡½æ•°ï¼‰ã€‚è¿™æ ·çš„æ’å¸ƒæ–¹å¼ä½¿å¾—åœ¨å¾—åˆ° T ç±»å‹çš„ Trait è™šè¡¨çš„åŒæ—¶ä¹ŸåŒæ—¶å¾—åˆ°äº† T ç±»å‹çš„ Parent è™šè¡¨å’Œ Grand è™šè¡¨ã€‚T ç±»å‹çš„ Grand è™šè¡¨æ°å¥½ç”± Trait è™šè¡¨çš„å‰äº”ä¸ªåŸŸæ„æˆï¼ŒT ç±»å‹çš„ Parent è™šè¡¨æ°å¥½ç”± Trait è™šè¡¨çš„å‰ä¸ƒé¡¹æ„æˆã€‚è¿™ä½¿å¾—å‘ä¸Šè½¬æ¢å˜å¾—éå¸¸ç®€å•ã€‚<br>æ‰€è°“å‘ä¸Šè½¬æ¢ï¼Œå³ Rust å…è®¸å°†&amp;dyn Trait è½¬æ¢ä¸º &amp;dyn Parent æˆ– &amp;dyn Grand ã€‚åœ¨å‘ä¸Šè½¬æ¢çš„è¿‡ç¨‹ä¸­ï¼Œèƒ–æŒ‡é’ˆçš„å¯¹è±¡åœ°å€åŸŸä¿æŒä¸å˜ï¼Œä½† metadata åŸŸå¯èƒ½éœ€è¦è¿›è¡Œè°ƒæ•´ï¼Œå› ä¸ºä¸åŒçš„ trait å¯èƒ½å…·æœ‰ä¸åŒçš„è™šè¡¨åœ°å€ã€‚ä½†åœ¨å½“å‰ç¤ºä¾‹ä¸­ï¼Œå‘ä¸Šè½¬æ¢ä¸éœ€è¦è°ƒæ•´ metadata åŸŸï¼Œå› ä¸ºä¸€ä¸ªæŒ‡å‘ Trait è™šè¡¨çš„æŒ‡é’ˆåŒæ—¶ä¹ŸæŒ‡å‘ Parent è™šè¡¨å’Œ Grand è™šè¡¨ã€‚åœ¨åæ–‡ä¸­æˆ‘ä»¬ä¼šè¿›ä¸€æ­¥ä»‹ç»éœ€è¦è°ƒæ•´ metadata åŸŸçš„å‘ä¸Šè½¬æ¢çš„æƒ…å†µã€‚<br>
æ³¨æ„ï¼šç›®å‰ stable Rust æš‚ä¸æ”¯æŒå‘ä¸Šè½¬æ¢ã€‚è¦ä½¿ç”¨å‘ä¸Šè½¬æ¢ç‰¹æ€§ï¼Œå¿…é¡»ä½¿ç”¨ nightly å·¥å…·é“¾ï¼Œå¹¶å‘æºæ–‡ä»¶ä¸­æ·»åŠ  #![feature(trait_upcasting)] ç‰¹æ€§å¼€å…³ã€‚
<br><br>Trait å¯ä»¥æœ‰å¤šä¸ª super traitã€‚ä¾‹å¦‚ï¼š<br>pub trait Base {
    fn base_fun1(&amp;self);
    fn base_fun2(&amp;self);
}

pub trait Left : Base {
    fn left_fun1(&amp;self);
    fn left_fun2(&amp;self);
}

pub trait Right : Base {
    fn right_fun1(&amp;self);
    fn right_fun2(&amp;self);
}

pub trait Trait : Left + Right {
    fn fun(&amp;self);
}
Copy<br>å¦‚æœç±»å‹T å®ç°äº† Traitï¼Œé‚£ä¹ˆæ­¤æ—¶ä¸º T ç”Ÿæˆçš„ Trait è™šè¡¨çš„ç»“æ„ä¸ºï¼š<br>+-----------------------------+
| fn drop_in_place(*mut T)    |
+-----------------------------+
| size of T                   |
+-----------------------------+
| align of T                  |
+-----------------------------+
| fn &lt;T as Base&gt;::base_fun1   |
+-----------------------------+
| fn &lt;T as Base&gt;::base_fun2   |
+-----------------------------+
| fn &lt;T as Left&gt;::left_fun1   |
+-----------------------------+
| fn &lt;T as Left&gt;::left_fun2   |
+-----------------------------+
| fn &lt;T as Right&gt;::right_fun1 |
+-----------------------------+
| fn &lt;T as Right&gt;::right_fun2 |
+-----------------------------+
| ptr to &lt;T as Right&gt;::vtable |
+-----------------------------+
| fn &lt;T as Trait&gt;::fun        |
+-----------------------------+
Copy<br>å¯ä»¥çœ‹åˆ°ï¼Œæ­¤æ—¶Trait åŠå…¶æ‰€æœ‰ç›´æ¥æˆ–é—´æ¥çˆ¶ trait æ‰€å®šä¹‰çš„æ‰€æœ‰å‡½æ•°ä»ç„¶åŒ…å«åœ¨è™šè¡¨å†…ï¼Œå› æ­¤é€šè¿‡ &amp;dyn Trait è°ƒç”¨çš„å‡½æ•°ä»ç„¶å¯ä»¥ç›´æ¥ä»è™šè¡¨å†…å¾—åˆ°å…¶å®é™…ç›®æ ‡å‡½æ•°çš„åœ°å€ã€‚å¦å¤–ï¼ŒTrait è™šè¡¨å†…ä»ç„¶åŒ…å«æœ‰æ•ˆçš„ Base è™šè¡¨å’Œ Left è™šè¡¨ã€‚å› æ­¤ï¼Œå°† &amp;dyn Trait å‘ä¸Šè½¬æ¢ä¸º &amp;dyn Left æˆ– &amp;dyn Base ä»ç„¶æ˜¯æå…¶ç®€å•çš„ï¼Œä¸éœ€è¦è°ƒæ•´èƒ–æŒ‡é’ˆçš„ metadata åŸŸã€‚ä½†æ˜¯ï¼Œå°† &amp;dyn Trait å‘ä¸Šè½¬æ¢ä¸º &amp;dyn Right å°±éœ€è¦è°ƒæ•´ metadata åŸŸäº†ï¼Œå› ä¸º Trait è™šè¡¨å†…å¹¶ä¸åŒ…å«ä¸€ä¸ªæœ‰æ•ˆçš„ Right è™šè¡¨ã€‚è¿™ä¹Ÿæ˜¯ Trait è™šè¡¨ä¸­ ptr to &lt;T as Right&gt;::vtable åŸŸçš„ä½œç”¨ï¼šåœ¨æ‰§è¡Œå‘ä¸Šè½¬æ¢æ—¶ï¼Œç¨‹åºä¼šè¯»å– Trait è™šè¡¨çš„è¿™ä¸ªåŸŸä½œä¸ºå¾—åˆ°çš„ &amp;dyn Right èƒ–æŒ‡é’ˆçš„ metadata ã€‚è¿™ä¹Ÿæ˜¯ Rust å‘ä¸Šè½¬æ¢ä¸ C++ å‘ä¸Šè½¬æ¢çš„ä¸€ä¸ªå¾ˆå¤§ä¸åŒï¼šåœ¨ C++ ä¸­çš„å‘ä¸Šè½¬æ¢é€šå¸¸å¹¶ä¸éœ€è¦è®¿é—®è™šè¡¨ï¼ˆé™¤ééœ€è¦æ‰§è¡Œè·¨è™šç»§æ‰¿è¾¹ç•Œçš„è½¬æ¢ï¼‰ï¼Œä½†åœ¨ Rust ä¸­å‘ä¸Šè½¬æ¢å¯èƒ½éœ€è¦è®¿é—®è™šè¡¨ã€‚<br>æ›´åŠ ä¸€èˆ¬åœ°ï¼Œå¯¹äºä¸€ä¸ª object safe çš„ traitTrï¼Œå°†å…¶ç¬¬ä¸€ä¸ªçˆ¶ traitã€ç¬¬ä¸€ä¸ªçˆ¶ trait çš„ç¬¬ä¸€ä¸ªçˆ¶ traitã€â€¦â€¦ è¿™ä¸€ç³»åˆ—ç›´æ¥æˆ–é—´æ¥çˆ¶ trait è®°ä¸ºè¿™ä¸ª trait çš„ PrefixTrait é›†åˆã€‚åœ¨å°† &amp;dyn Tr å‘ä¸Šè½¬æ¢æ—¶ï¼Œå¦‚æœè½¬æ¢åˆ°çš„ç›®æ ‡ trait åŒ…å«åœ¨ PrefixTrait é›†åˆå†…ï¼Œé‚£ä¹ˆè¿™ä¸ªå‘ä¸Šè½¬æ¢æ˜¯å¹³å‡¡çš„ï¼šä¸éœ€è¦è°ƒæ•´èƒ–æŒ‡é’ˆçš„ metadata åŸŸã€‚å¦åˆ™ï¼Œè¿™ä¸ªå‘ä¸Šè½¬æ¢éœ€è¦åœ¨ Tr çš„è™šè¡¨å†…è¯»å–ç›®æ ‡ trait çš„è™šè¡¨æŒ‡é’ˆä½œä¸ºè½¬æ¢ç»“æœçš„ metadata ã€‚åœ¨ Tr çš„è™šè¡¨ç»“æ„ä¸­ï¼Œä½äº PrefixTrait é›†åˆä¸­çš„çˆ¶ trait åªéœ€è¦æ’å¸ƒä»–ä»¬æ‰€å®šä¹‰çš„å‡½æ•°å³å¯ï¼›å¯¹äºå…¶ä»–çˆ¶ trait è¿˜éœ€è¦é¢å¤–åœ¨è™šè¡¨å†…æ’å¸ƒä¸€ä¸ªæŒ‡å‘å…¶è™šè¡¨çš„æŒ‡é’ˆç”¨äºå‘ä¸Šè½¬æ¢ã€‚<br><br>Rust æä¾›äº†ä¸€ä¸ªç‰¹æ®Šçš„ traitï¼šstd::any::Any ã€‚è¯¥ trait æ”¯æŒå‘ä¸‹è½¬æ¢ï¼Œå³å¯ä»¥å°† &amp;dyn Any è½¬æ¢ä¸º T ã€‚è½¬æ¢è¿‡ç¨‹ä¸­ä¼šå¯¹èƒ–æŒ‡é’ˆæ‰€æŒ‡å‘çš„å¯¹è±¡çš„å®é™…ç±»å‹è¿›è¡Œæ£€æŸ¥ï¼Œç¡®è®¤å…¶ç¡®å®æ˜¯ä¸€ä¸ª T ç±»å‹çš„å¯¹è±¡ã€‚Any trait çš„è™šè¡¨ç»“æ„æœ‰ä¸€äº›ç‰¹æ®Šï¼›åœ¨è™šè¡¨ header ä¹‹åï¼ŒAny è™šè¡¨ä»…åŒ…å«ä¸€ä¸ªåŸŸï¼Œè¿™ä¸ªåŸŸç›´æ¥ç»™å‡ºèƒ–æŒ‡é’ˆæŒ‡å‘çš„å¯¹è±¡çš„ç±»å‹æ ‡è¯†ï¼ˆç”±ä¸€ä¸ª std::any::TypeId ç±»å‹çš„å€¼è¡¨ç¤ºï¼‰ã€‚ä¾‹å¦‚ï¼Œå¯¹äºä»»æ„çš„ T: 'staticï¼Œç¼–è¯‘å™¨ä¸ºå…¶ç”Ÿæˆçš„ Any è™šè¡¨ä¸ºï¼š<br>+--------------------------+
| fn drop_in_place(*mut T) |
+--------------------------+
| size of T                |
+--------------------------+
| align of T               |
+--------------------------+
| TypeId of T              |
+--------------------------+
Copy<br>åœ¨æ‰§è¡Œå‘ä¸‹è½¬æ¢æ—¶ï¼Œç¨‹åºé¦–å…ˆæ£€æŸ¥è½¬æ¢åˆ°çš„ç±»å‹æ˜¯å¦ä¸è™šè¡¨ä¸­ç»™å‡ºçš„TypeId æ‰€æ ‡è¯†çš„ç±»å‹ä¸€è‡´ã€‚è‹¥ç±»å‹æ£€æŸ¥é€šè¿‡ï¼Œå‘ä¸‹è½¬æ¢æ“ä½œå¯ä»¥ç›´æ¥è¿”å›èƒ–æŒ‡é’ˆä¸­çš„æŒ‡é’ˆåŸŸä½œä¸ºè½¬æ¢ç»“æœã€‚<br><br>
<br>Vtable format to support dyn upcasting coercion <a rel="noopener" class="external-link" href="https://rust-lang.github.io/dyn-upcasting-coercion-initiative/design-discussions/vtable-layout.*html" target="_blank">https://rust-lang.github.io/dyn-upcasting-coercion-initiative/design-discussions/vtable-layout.*html</a>*
]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/rust/rust-è™šè¡¨å¸ƒå±€è§„åˆ™ä»‹ç».html</link><guid isPermaLink="false">Computer Science/Programming Language/Rust/Rust è™šè¡¨å¸ƒå±€è§„åˆ™ä»‹ç».md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Fri, 22 Mar 2024 09:03:05 GMT</pubDate></item><item><title><![CDATA[Rust é—­åŒ… lifetime may not live long enough é—®é¢˜]]></title><description><![CDATA[ 
 <br>ä»£ç ï¼š<br>...
    fn handlers(self) -&gt; crate::server::request::Handlers {
        vec![(
            "/tree",
            routing::get(move || async {
                (
                    StatusCode::OK,
                    Json(json!(self.clone().tree(self.clone().root))),
                )
            }),
        )]
    }
...
Copy<br>ç¼–è¯‘é”™è¯¯ï¼š<br>error: lifetime may not live long enough
  --&gt; src/storage/filesystem/mod.rs:45:34
   |
45 |               routing::get(move || async {
   |  __________________________-------_^
   | |                          |     |
   | |                          |     return type of closure `{async block@src/storage/filesystem/mod.rs:45:34: 50:14}` contains a lifetime `'2`
   | |                          lifetime `'1` represents this closure's body
46 | |                 (
47 | |                     StatusCode::OK,
48 | |                     Json(json!(self.clone().tree(self.clone().root))),
49 | |                 )
50 | |             }),
   | |_____________^ returning this value requires that `'1` must outlive `'2`
   |
   = note: closure implements `Fn`, so references to captured variables can't escape the closure
Copy<br>è¿™æ˜¯å› ä¸º handlers é‡Œé¢çš„é—­åŒ…æ•è·äº†ä¸€ä¸ªå¼•ç”¨ï¼Œå¹¶ä¸”å°è¯•è¿”å›ä¸€ä¸ªåŒ…å«è¯¥å¼•ç”¨çš„å€¼å¯¼è‡´çš„ã€‚<br>ç»†è¯´å°±æ˜¯ï¼šé—­åŒ…å†…éƒ¨ä½¿ç”¨äº† self.clone() æ¥è·å–ä¸€ä¸ªæ–°çš„å®ä¾‹ï¼Œç„¶ååœ¨å¼‚æ­¥å—ä¸­è¿”å›ä¸€ä¸ª JSON å¯¹è±¡ï¼Œè¿™ä¸ª JSON å¯¹è±¡ä¾èµ–äº self.tree() çš„ç»“æœã€‚å› ä¸ºé—­åŒ…æ•è·äº† self çš„å¼•ç”¨ï¼Œæ‰€ä»¥å®ƒå¿…é¡»ä¿è¯ self åœ¨é—­åŒ…æ‰§è¡Œå®Œæ¯•åä»ç„¶æœ‰æ•ˆã€‚<br>è§£å†³è¿™ä¸ªé—®é¢˜çš„æ€è·¯æ˜¯ï¼šç¡®ä¿é—­åŒ…ä¸­çš„æ‰€æœ‰å¼•ç”¨éƒ½åœ¨é—­åŒ…æ‰§è¡Œå®Œæ¯•ä¹‹å‰å°±ä¸å†è¢«ä½¿ç”¨ã€‚<br>
å°±æ˜¯è¯´ï¼Œè¦å°†é—­åŒ…çš„ä½œç”¨åŸŸé™åˆ¶åœ¨ä¸€ä¸ªæ›´çŸ­çš„ç”Ÿå‘½å‘¨æœŸå†…ï¼Œæˆ–è€…ä½¿ç”¨å…¶ä»–æ–¹å¼æ¥é¿å…é—­åŒ…æ•è·é•¿æœŸå­˜åœ¨çš„å¼•ç”¨:<br>
...
    fn handlers(self) -&gt; crate::server::request::Handlers {
        let tree = json!(self.clone().tree(self.clone().root));
        vec![(
            "/tree",
            routing::get(move || async { (StatusCode::OK, Json(tree)) }),
        )]
    }
...
Copy]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/rust/rust-é—­åŒ…-lifetime-may-not-live-long-enough-é—®é¢˜.html</link><guid isPermaLink="false">Computer Science/Programming Language/Rust/Rust é—­åŒ… lifetime may not live long enough é—®é¢˜.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Fri, 24 May 2024 10:03:50 GMT</pubDate></item><item><title><![CDATA[æœ‰å…³ Axum ä¸­ WebSocket çš„ä½¿ç”¨]]></title><description><![CDATA[ 
 <br><br>åˆ›å»ºä¸€ä¸ªé¡¹ç›®ï¼Œå¹¶å°† axum æ·»åŠ åˆ°ä¾èµ–ä¸­ï¼š<br>cargo new axum-ws-test
cd axum-ws-test
cargo add tokio -F full
cargo add serde_json
cargo add axum -F ws
cargo add rand
Copy<br>ç„¶åç”¨è‡ªå·±å–œæ¬¢çš„ç¼–è¾‘å™¨/IDE æ‰“å¼€æ•´ä¸ªé¡¹ç›®ï¼Œæ‰¾åˆ° Cargo.tomlï¼Œå¯ä»¥çœ‹åˆ° Cargo.toml å¦‚ä¸‹ï¼š<br>[dependencies]
axum = { version = "0.6.20", features = ["ws"] }
rand = "0.8.5"
serde_json = "1.0.107"
tokio = { version = "1.33.0", features = ["full"] }
Copy<br>
ä»¥ä¸Šä¾èµ–ç‰ˆæœ¬ä¸ºæœ¬æ–‡ç¼–å†™æ—¶çš„æœ€æ–°ç¨³å®šç‰ˆï¼Œéœ€è¦æ³¨æ„å’Œè‡ªå·±çš„ç‰ˆæœ¬åŒºåˆ«ï¼Œaxum çš„åŠŸèƒ½åŸºæœ¬éƒ½æœ‰è§£é‡Šï¼Œå¯ä»¥æŸ¥çœ‹ <a data-tooltip-position="top" aria-label="https://docs.rs/axum/latest/axum/#feature-flags" rel="noopener" class="external-link" href="https://docs.rs/axum/latest/axum/#feature-flags" target="_blank"><code></code> æ–‡æ¡£</a>axum
<br><br>ä»å®˜æ–¹æ–‡æ¡£å¯ä»¥çœ‹åˆ°ï¼Œä¸€ä¸ª axum ç¨‹åºï¼ŒåŒ…å«äº†ç¨‹åºå…¥å£ã€è·¯ç”±ã€è·¯ç”±æœåŠ¡å’Œ axum æœåŠ¡ç«¯ï¼ˆå³ axum::Serverï¼‰ï¼Œæˆ‘ä»¬å…ˆå°†å…¶åŸºæœ¬ç»“æ„å†™å…¥åˆ° main.rs çš„æ–‡ä»¶ä¸­ï¼ˆä»£ç æ¥è‡ªå®˜æ–¹æ–‡æ¡£ï¼‰ï¼š<br>use axum::{routing::get, Router};

// ä¸»å‡½æ•°å…¥å£
#[tokio::main]
async fn main() {
    // è·¯ç”±
    let app = Router::new().route("/", get(|| async { "Hello, World!" }));

    // axum çš„ Server
    axum::Server::bind(&amp;"0.0.0.0:8081".parse().unwrap())
        .serve(app.into_make_service())
        .await
        .unwrap();
}
Copy<br>è¿è¡Œç¨‹åºåï¼Œæ‰“å¼€ <a rel="noopener" class="external-link" href="https://muqiuhan.github.io/wiki/localhost:8081" target="_blank">localhost:8081</a>ï¼Œåº”è¯¥å¯ä»¥çœ‹è§ç½‘é¡µä¸Šæœ‰ Hello, World!ã€‚<br><br>å‰ç«¯ä½¿ç”¨ Vueï¼Œå»ºè®®é€‰æ‹©å¦ä¸€ä¸ªæ–‡ä»¶å¤¹æ¥åˆ›å»ºå‰ç«¯é¡¹ç›®ã€‚è¾“å…¥ä¸‹é¢çš„æŒ‡ä»¤æ¥åˆ›å»ºå‰ç«¯é¡¹ç›®ï¼Œé¡¹ç›®åç§°å‘½åä¸º axum-test-frontï¼š<br>npm create vue@latest
cd axum-test-front
npm install
npm run dev
Copy<br><br>æˆ‘ä»¬æ¨¡æ‹Ÿçš„æƒ…å†µè¯•è¯•ï¼Œå‰ç«¯æ¯æ¬¡ç‚¹å‡»æŒ‰é’®éƒ½ä¼šè·å–åç«¯çš„ä¸€ä¸ªéšæœºæ•°ã€‚ä¸€å¼€å§‹æˆ‘ä»¬å…ˆä¸ä½¿ç”¨ WebSocketï¼Œæ¥æµ‹è¯•ä¸€ä¸‹æ•ˆæœã€‚<br><br>æ·»åŠ ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºå‰ç«¯è·å–éšæœºæ•°ï¼š<br>use axum::{response::Json, routing::get, Router};
use rand::Rng;
use serde_json::{json, Value};

#[tokio::main]
async fn main() {
    let app = Router::new()
        .route("/", get(|| async { "Hello, World!" }))
        // add here
        .route("/random", get(get_rand));

    // Server
}
// handler
async fn get_rand() -&gt; Json&lt;Value&gt; {
    let mut rng = rand::thread_rng();
    Json(json! ({"num": rng.gen_range(1..=100)}))
}
Copy<br>å¯ä»¥åœ¨æµè§ˆå™¨ä¸­è¾“å…¥ <a rel="noopener" class="external-link" href="https://muqiuhan.github.io/wiki/localhost:8081/random" target="_blank">localhost:8081/random</a>æ¥æµ‹è¯•ï¼Œæ¯ä¸ªåˆ·æ–°åº”è¯¥éƒ½å¯ä»¥å¾—åˆ°ä¸€ä¸ªæ–°çš„ num å€¼ã€‚<br><br>å‰ç«¯åœ¨ App.vue ä¸­æ·»åŠ ä¸€ä¸ªæŒ‰é’®å’Œä¸€ä¸ªç”¨äºæ˜¾ç¤ºè·å–åˆ°çš„éšæœºæ•°çš„èŠ‚ç‚¹ï¼Œä»£ç å¦‚ä¸‹ï¼š<br>&lt;script&gt;
  export default {
    data() {
      return {
        num: null,
      };
    },
    methods: {
      get_random() {
        // ä»åç«¯çš„å¯¹åº”åœ°å€è·å–éšæœºæ•°
        fetch("http://localhost:8081/random", {
          mode: "cors",
          headers: {
            accpet: "application/json",
          },
        })
          .then((response) =&gt; response.json())
          .then((data) =&gt; {
            this.num = data.num;
          });
      },
    },
  };
&lt;/script&gt;

&lt;template&gt;
  &lt;main&gt;
    &lt;button @click="get_random()"&gt;click to get num&lt;/button&gt;
    &lt;div&gt;num is {{ num }}&lt;/div&gt;
  &lt;/main&gt;
&lt;/template&gt;
Copy<br>æ‰§è¡Œçš„æ—¶å€™ä¼šå‘ç°æ— æ³•ä»åç«¯æ‹¿åˆ°æ•°æ®ï¼Œè¿™æ˜¯å› ä¸ºåç«¯æ²¡æœ‰é…ç½®è·¨åŸŸè¯·æ±‚ã€‚<br><br>é¦–å…ˆéœ€è¦æ·»åŠ ä¸€ä¸ªä¾èµ–ï¼Œè¾“å…¥ä¸‹é¢çš„æŒ‡ä»¤æ·»åŠ ï¼š<br>cargo add tower-http -F cors
Copy<br>ç„¶ååœ¨åˆ›å»ºè·¯ç”±ä¹‹å‰ï¼Œå…ˆæ–°å»ºä¸€ä¸ªè·¨åŸŸçš„è®¸å¯ï¼š<br>use axum::{http::HeaderValue, response::Json, routing::get, Router};
use rand::Rng;
use serde_json::{json, Value};
use tower_http::cors::{Any, CorsLayer};

#[tokio::main]
async fn main() {
    // è·¨åŸŸé…ç½®
    let cors = CorsLayer::new()
        .allow_methods(Any)
        .allow_headers(Any)
        .allow_origin("http://localhost:5173".parse::&lt;HeaderValue&gt;().unwrap());

    let app = Router::new()
        .route("/", get(|| async { "Hello, World!" }))
        // ä¸ºè·¯ç”±æ–¹æ³•å¤„ç†æ·»åŠ è·¨åŸŸè®¸å¯
        .route("/random", get(get_rand).layer(cors));

    // Server
}
Copy<br>è¿™æ—¶å†è¿è¡Œåç«¯å’Œå‰ç«¯ï¼Œæ‰“å¼€å‰ç«¯çš„ç½‘é¡µï¼Œç‚¹å‡»æŒ‰é’®åº”è¯¥å¯ä»¥æ¯æ¬¡è·å–åˆ°ä¸åŒçš„æ•°å­—ã€‚æ‰“å¼€å¼€å‘è€…æ§åˆ¶å°ï¼Œå¹¶é€‰æ‹©ç½‘ç»œï¼ˆæ²¡æœ‰çš„è¯ç‚¹åŠ å·æˆ–è€… ã€‹ å¯ä»¥æ‰¾åˆ°ï¼‰ï¼Œå†å¤šæ¬¡ç‚¹å‡»æŒ‰é’®ï¼Œå¯ä»¥çœ‹åˆ°æ¯æ¬¡ç‚¹å‡»æŒ‰é’®éƒ½å‘é€äº†ä¸€æ¬¡ Http è¯·æ±‚ã€‚<br>
å¦‚æœå‰ç«¯å¼€å‘è€…æ§åˆ¶å°æŠ¥ Uncaught (in promise) ReferenceError: num is not defined è¿™ç§é”™è¯¯ï¼Œåº”è¯¥æ˜¯åœ¨ç»™ Vue ä¸­ data é‡Œçš„å­—æ®µèµ‹å€¼çš„æ—¶å€™æ²¡æœ‰åŠ  this å…³é”®å­—ï¼ŒæŠŠ num æ”¹ä¸º this.num å³å¯
<br><br><br>æ·»åŠ ä¸€ä¸ªæ–°çš„å‡½æ•°ï¼Œå‡½æ•°åä¸º handle_randomï¼Œå†æ·»åŠ ä¸€ä¸ªå‡½æ•°åä¸º handle_random_socketï¼š<br>async fn handle_random(ws_upgrade: WebSocketUpgrade) -&gt; Response {
    ws_upgrade.on_upgrade(handle_random_socket)
}

async fn handle_random_socket(mut socket: WebSocket) {
    while let Some(msg) = socket.recv().await {
        let msg = if let Ok(msg) = msg {
            msg
        } else {
            println!("Web Socket Closed");
            return;
        };

    }
}
Copy<br>åœ¨ handle_random ä¸­ï¼Œè°ƒç”¨ ws_upgrade çš„ on_upgrade å‡½æ•°å¯ä»¥å»ºç«‹ Web Socket è¿æ¥ã€‚handle_random_socket å°±æ˜¯ç”¨äºå¤„ç†è¿æ¥æ—¶çš„å‡½æ•°ï¼Œæ­¤å¤„å…ˆä½¿ç”¨å¾ªç¯æ¥æ¥æ”¶æ¥è‡ªè¿æ¥å¦ä¸€ç«¯çš„æ¶ˆæ¯ï¼Œå¦‚æœæ¥æ”¶å‘ç”Ÿé”™è¯¯æˆ–è€…æ— æ³•æ¥æ”¶åˆ°ï¼Œåˆ™è§†ä¸ºè¿æ¥å…³é—­ã€‚WebSocket::recv() å‡½æ•°åœ¨è¿æ¥å…³é—­åï¼Œæ‰ä¼šè¿”å› Noneã€‚<br>è®¾æƒ³å»ºç«‹è¿æ¥åï¼Œå‰ç«¯å‘é€ä¸€ä¸ª get å­—ç¬¦ä¸²ï¼Œåç«¯æ”¶åˆ°è¿™ä¸ªå­—ç¬¦ä¸²ï¼Œå¦‚æœæ”¶åˆ°çš„ç¡®å®æ˜¯ getï¼Œåˆ™è¿”å›ç»™å‰ç«¯ä¸€ä¸ªéšæœºæ•°ã€‚é‚£ä¹ˆè¦åšçš„äº‹æƒ…å°±å¾ˆç®€å•äº†ï¼Œé¦–å…ˆè¦åŒ¹é…å‘é€è¿‡æ¥çš„æ¶ˆæ¯æ˜¯å¦æ˜¯å­—ç¬¦ä¸²ä¸”å†…å®¹æ˜¯å¦ä¸º getã€‚<br>async fn handle_random_socket(mut socket: WebSocket) {
    while let Some(msg) = socket.recv().await {
        let msg = if let Ok(msg) = msg {...};
        // åŒ¹é…å­—ç¬¦ä¸²
        if let Message::Text(text) = msg {
            if text.eq("get") {
                todo!()
            }
        }
    }
}
Copy<br>åœ¨åŒ¹é…æˆåŠŸåï¼Œå°†ç”Ÿæˆä¸€ä¸ªéšæœºæ•°ï¼Œå¹¶è¿”å›ç»™å‰ç«¯ã€‚è¿™é‡Œä¼šç”¨åˆ° WebSocket çš„ Send å‡½æ•°æ¥è¿”å›å“åº”ï¼Œè·å–éšæœºæ•°å¯ä»¥ç”¨åˆ°ä¹‹å‰å†™çš„å‡½æ•°ã€‚å‰ç«¯å¯¹æ•°æ®çš„å®½å®¹æ€§è¾ƒå¤§ï¼Œæ‰€ä»¥å¯ä»¥è€ƒè™‘ç›´æ¥è¿”å› JSON æ ¼å¼çš„æ–‡æœ¬ï¼š<br>async fn handle_random_socket(mut socket: WebSocket) {
    while let Some(msg) = socket.recv().await {
        let msg = if let Ok(msg) = msg {...};

        if let Message::Text(text) = msg {
            if text.eq("get") {
                if socket
                    // è¿”å›éšæœºæ•°
                    .send(Message::Text(get_rand().await.to_string()))
                    .await
                    .is_err()
                {
                    // å¦‚æœå‡ºé”™äº†å°±å…³é—­è¿æ¥
                    println!("Web Socket Closed");
                    return;
                }
            }
        }
    }
    println!("Web Socket Closed");
}
Copy<br>ç¼–å†™å®Œæˆï¼Œæœ€åå°† handle_random æ·»åŠ åˆ°è·¯ç”±ä¸­ã€‚<br>#[tokio::main]
async fn main() {
    // è·¨åŸŸé…ç½®
    // ...
    // è·¯ç”±
    let app = Router::new()
        .route("/", get(|| async { "Hello, World!" }))
        .route("/random", get(get_rand).layer(cors));
        .route("/ws/random", get(handle_random));

    // axum çš„ Server
    // ...
}
Copy<br><br>åœ¨ç»„ä»¶æŒ‚è½½æ—¶ï¼Œä¼šå°è¯•åˆ›å»ºä¸€ä¸ª WebSocket çš„è¿æ¥ï¼Œå¹¶ä¸”ç»‘å®šä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºåœ¨æ”¶åˆ°æ¶ˆæ¯åï¼Œè®¾ç½® num çš„å€¼ï¼š<br>&lt;script&gt;
export default {
  data() {
    return {
      num: null,
      ws: null,
    };
  },
  methods: {
    build_connect() {
      // é˜²æ­¢å­åŸŸçš„ this ä¸ vue çš„ this å†²çª
      var that = this;
      that.ws = new WebSocket("ws://localhost:8081/ws/random");
      // æ”¶åˆ°æ¶ˆæ¯åï¼Œè®¾ç½® num çš„å€¼
      that.ws.addEventListener("message", function (event) {
        that.num = JSON.parse(event.data).num;
      });
    },
  },
  mounted() {
    this.build_connect();
    window.onclose = () =&gt; {
      this.ws.close();
    };
  },
};
Copy<br>ä¹‹åçš„æ¯æ¬¡ç‚¹å‡»éƒ½ä¼šå˜ä¸ºé€šè¿‡è¿æ¥æ¥å‘åç«¯å‘é€æ¶ˆæ¯ã€‚æŒ‰ç…§é€»è¾‘ä¿®æ”¹åçš„ä»£ç å¦‚ä¸‹ï¼š<br>get_random() {
  // é€šè¿‡è¿æ¥å‘åç«¯å‘é€ä¿¡æ¯
  this.ws.send("get");
},
Copy<br><br>é¦–å…ˆå¯åŠ¨åç«¯ï¼š<br>cargo run
Copy<br>ç„¶åå¯åŠ¨å‰ç«¯ï¼š<br>npm run dev
Copy<br>æ‰“å¼€å‰ç«¯é¡µé¢ï¼Œç‚¹å‡»æŒ‰é’®å°±å¯ä»¥çœ‹åˆ°æ¯æ¬¡éƒ½èƒ½å¤Ÿä»åç«¯è·å–åˆ°ä¸åŒçš„éšæœºæ•°çš„æ•ˆæœäº†ã€‚<br><br>
<br><a data-tooltip-position="top" aria-label="https://docs.rs/axum" rel="noopener" class="external-link" href="https://docs.rs/axum" target="_blank">axum</a>

<br><a data-tooltip-position="top" aria-label="https://docs.rs/axum/latest/axum/extract/ws/index.html" rel="noopener" class="external-link" href="https://docs.rs/axum/latest/axum/extract/ws/index.html" target="_blank">axum::extract::ws - Rust</a>


<br><a data-tooltip-position="top" aria-label="https://cn.vuejs.org/" rel="noopener" class="external-link" href="https://cn.vuejs.org/" target="_blank">vue</a>
<br><a data-tooltip-position="top" aria-label="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket" rel="noopener" class="external-link" href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket" target="_blank">WebSocket - Web API æ¥å£å‚è€ƒ | MDN</a>
]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/rust/æœ‰å…³-axum-ä¸­-websocket-çš„ä½¿ç”¨.html</link><guid isPermaLink="false">Computer Science/Programming Language/Rust/æœ‰å…³ Axum ä¸­ WebSocket çš„ä½¿ç”¨.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 19 May 2024 03:24:56 GMT</pubDate></item><item><title><![CDATA[F-bounded polymorphism in Scala]]></title><description><![CDATA[ 
 <br>When we talk about polymorphism in programming, we're referring to the ability of an entity to take on several forms. Among the various approaches to polymorphism, F-bounded polymorphism (or F-bounded quantification) is a particularly advanced technique in the context of object-oriented programming languages. It is characterized by its emphasis on relations between types, thereby combining the advantages of polymorphism and genericity. This concept plays a crucial role in maintaining coherent type hierarchies and promoting consistency in software development. As we explore the depths of type theory and programming, understanding F-bounded polymorphism opens doors to crafting more robust and dependable software systems.<br>In this article, I will start by explaining how I discovered F-bounded polymorphism (somewhat by coincidence) and how it helped me in a specific case. Then, we'll take a closer look at the theory behind polymorphism with quantification (basic and bounded), then F-bounded polymorphism, which we'll finally illustrate with a practical example. Although this concept (and polymorphism in general) exists in many languages, this article uses Scala for the examples.<br><br><br>Let's start with a true story. I recently worked for a client who wanted a platform where multiple versions of information could co-exist. After developing a git-like versioning library (honourable mention to my Scala mentor who will recognize himself) that wasn't perfectly suited to the business, my team and I restarted from scratch with a new history-like approach. For reasons of confidentiality and code propriety, the code examples shown here have nothing to do with the original code, either in terms of naming or implementation (details of which are omitted to focus on F-bounded polymorphism only). Let's start by defining:<br>trait Info[T] {
  def update(t: T): Info[T]

  ...
}
Copy<br>The idea is that Info can remember changes to an object T, and that for any T that needs to be versioned, Info is extended by a concrete class containing these changes field by field. An example would be:<br>case class Foo(foo: String)

case class Bar(foo: Foo, foos: List[Foo])

// definition of class Memory[T] does not matter here
case class FooInfo(fooMemory: Memory[String]) extends Info[Foo] {
  ... // implementation does not matter
}

case class BarInfo(
    fooInfo: FooInfo, 
    foosInfo: ListInfo[Foo]
) extends Info[Bar]
Copy<br>Let's now look at ListInfo, which, as its name suggests, represents the information of a list. To define such a class, we could imagine the following:<br>case class ListInfo[T](
    infos: List[Info[T]]
) extends Info[List[T]] {
  ...
}
Copy<br>However, as the line foosInfo: ListInfo[Foo] suggests, having a single parameter type T is not sufficient here, since the Info[T] type in infos: List[Info[T]] gives no information about the concrete class used. We can therefore modify the class as follows:<br>case class ListInfo[T, InfoType &lt;: Info[T]](
    infos: List[InfoType]
) extends Info[List[T]]
Copy<br>We now know which Info type is used for the item informations. In our example, BarInfo becomes:<br>case class BarInfo(
    fooInfo: FooInfo, 
    foosInfo: ListInfo[Foo, FooInfo]
) extends Info[Bar]
Copy<br>Now imagine that, in ListInfo, we have a method for updating a particular information:<br>case class ListInfo[T, InfoType &lt;: Info[T]](
    infos: List[InfoType]
) extends Info[List[T]] {
  def update(values: List[T]): Info[List[T]] = ???

  // imagine that update() uses this function to update the infos
  def updateInfoAtIndex(index: Int, t: T): ListInfo[T, InfoType] = {
    val updatedInfo = infos(index).update(t)
    copy(infos = infos.updated(index, updatedInfo))
  }
  ...
}
Copy<br>This code doesn't compile. Can you see the problem?<br>Here's the explanation. In the function updateInfoAtIndex(), the type of updatedInfo is the type of the Info trait's update() function, which, as a reminder, is:<br>def update(t: T): Info[T]
Copy<br>However, infos is of type List[InfoType], not List[Info[T]]. The compiler therefore returns the following error:<br>[error]  type mismatch;
[error]  found   : updatedInfo.type (with underlying type Info[T])
[error]  required: InfoType
[error]     copy(infos = infos.updated(index, updatedInfo))
[error]                                       ^
Copy<br>We're faced here with a <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Type_erasure" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Type_erasure" target="_blank">type erasure</a> of the type InfoType in its wider type Info[T], which the compiler cannot resolve by itself. Now let's see what solutions are available to us.<br><br><br>The most obvious solution to our problem is type casting:<br>def updateInfoAtIndex(index: Int, t: T): ListInfo[T, InfoType] = {
  val updatedInfo: Info[T] = infos(index).update(t)
  copy(infos = infos.updated(index, updatedInfo.asInstanceOf[InfoType]))
}
Copy<br>However, this solution is sorely lacking in robustness and elegance.<br><br><br>Let's put the problem back at the centre of the table. Here, we lose information on the type of an object of type InfoType &lt;: Info[T], which goes back to its more general nature Info[T]. Intuitively, then, we might wonder whether there is a way of storing this lost information in Info[T] itself, at the type level. A first approach might be to use ClassTag's, but we won't cover this solution in this article. Another approach is to rewrite Info as follows:<br>trait Info[T, InfoType &lt;: Info[T, InfoType]] {
  def update(t: T): InfoType
}
Copy<br>The most remarkable thing here is the recursive definition of Info. Morally, InfoType remains a subtype of Info. However, with recursion, it is also a subtype of the type that "defines" it. This allows us to change the return of the update() function from Info[T] to InfoType. Let's look at the repercussions of this change on the ListInfo class:<br>case class ListInfo[T, InfoType &lt;: Info[T, InfoType]](
    infos: List[InfoType]
) extends Info[List[T], ListInfo[T, InfoType]] {
  def update(values: List[T]): ListInfo[T, InfoType] = ???

  def updateAtIndex(index: Int, t: T): ListInfo[T, InfoType] = {
    val updatedInfo: InfoType = infos(index).update(t) // expected type
    copy(infos = infos.updated(index, infos(index).update(t)))
  }
  ...
}
Copy<br>This code now compiles. Regarding the subtypes of Info[T], these need to be adapted slightly. In our example, we have<br>case class FooInfo(
    fooMemory: Memory[String]
) extends Info[Foo, FooInfo]

case class BarInfo(
    fooInfo: FooInfo, 
    foosInfo: ListInfo[Foo, FooInfo]
) extends Info[Bar, BarInfo]
Copy<br>Without really realizing it, we've just used F-bounded polymorphism. Let's talk about it in more detail.<br><br><br>F-bounded polymorphism is based on relationships between types. It is also nothing other than a special form of polymorphism. This concept is closely linked to that of type in programming languages. Now, you may ask: What is a type? Why do we need them in programming languages? A particularly appealing (and funny) answer comes from the article "On understanding types, data abstraction, and polymorphism" by L. Cardelli and P. Wegner, published in 1986:<br>
A type may be viewed as a set of clothes (or a suit of armor) that protects an underlying untyped representation from arbitrary or unintended use. It provides a protective covering that hides the underlying representation and constrains the way objects may interact with other objects. In an untyped system untyped objects are naked in that the underlying representation is exposed for all to see. Violating the type system involves removing the protective set of clothing and operating directly on the naked representation.
<br>The article concludes, among other things, that types are sets of values. So there are two types of language: those that are not typed, i.e. have only one type, known as monomorphic, and those that are typed, known as polymorphic. Within polymorphic languages, polymorphism can take several forms with which you're no doubt familiar: when a function works or appears to work on several different types (potentially every type), overloading, coercion, subtyping and so on. I urge you to delve into this magnificent article.<br>We'll now take a closer look at some common forms of polymorphism.<br><br><br>In type theory, quantification refers to universally or existentially quantifying type variables:<br>
<br>
Universal Quantification (âˆ€) indicates that a property holds for all permissible types. Type specifications for variables of a universally quantified type have the following form (for any type expression Ïƒ(t)): p: âˆ€t.Ïƒ(t). This expresses the property that for every type t, p has the type Ïƒ(t).
  In Scala, universal quantification is typically used via generic types, allowing functions and data structures to operate over all types T. For instance, a generic function might be represented as:

<br>
    def identity[T](x: T): T = x
Copy
  Here, T is universally quantified: the function should work for any type T. Using the notation above, the identity function is written as: âˆ€t. t â†’ t.<br>


<br>
Existential Quantification (âˆƒ) denotes that there exists at least one type for which a property holds. Formally, existential quantification is written as:
  p: âˆƒt.Ïƒ(t). In Scala, existential types, declared using a wildcard type (placeholder syntax), signify that a type exists without specifying it:<br>


<br>  def printFirst(list: List[_]): Unit = println(list.headOption)
Copy<br>In this function, the type of the list elements is existentially quantified. The function knows there exists some type, but it doesnâ€™t specify or use it explicitly.<br>In reality, the wildcard type (placeholder syntax) is a syntactic sugar for the formal expression of existential types in Scala, which has the form<br>T forSome { Q } where Q is a sequence of type declarations. Type List[_] can therefore be rewritten as:<br>
<br>
    type L = List[t forSome { type t }]
Copy

<br>Note that replacing L with L[_] in the left-hand member is also valid. Quick question for you: how would you write the type List[List[_]] with this syntax? Or List[Int]? Or even the type representing any type? Hint: you'll find the answer in one of the sources of this article.<br>

<br>Let's end our explanation of basic quantification with these few wonderful lines, which I found while wandering through the code of the <a data-tooltip-position="top" aria-label="https://github.com/milessabin/shapeless" rel="noopener" class="external-link" href="https://github.com/milessabin/shapeless" target="_blank">shapeless</a> library:<br>type Â¬[T] = T =&gt; Nothing

type âˆƒ[P[_]] = P[T] forSome { type T }
type âˆ€[P[_]] = Â¬[âˆƒ[({ type Î»[X] = Â¬[P[X]]})#Î»]]
Copy<br>Reading and reflecting on these lines convinces me that Scala is and always will be my favourite programming language.<br><br><br>Bounded quantification is a conceptual extension of the idea of universal and existential quantification. In essence, it is the notion of constraining the range over which a quantification applies.<br>Bounded quantification essentially introduces a restrictive layer atop basic quantification, enabling explicit definition of permissible type range:<br>
<br>Upper-bounded (Tâ‰¤B): âˆ€T: T â‰¤B Indicates "for all types T that are subtypes of B. In Scala, you can express upper-bounded quantification using the &lt;: symbol in type parameterization:
<br>def maxElement[T &lt;: Ordered[T]](a: T, b: T): T = if (a &lt; b) b else a
Copy<br>Here, T is constrained to be a subtype of Ordered[T], ensuring the elements can be ordered. More generally, if we have types A and B, and A is a subtype of B, it means that any value of type A can also be used in a context that expects type B.<br>
<br>Lower-bounded (Bâ‰¤T): âˆ€T: B â‰¤T Denotes "for all types T that are supertypes of B". Scala represents lower-bounded quantification using the &gt;: symbol:
<br>def prependToSuperTypeList[B, T &gt;: B](element: B, list: List[T]): List[T] = element :: list
Copy<br>Here, T is a supertype of B, ensuring that an element of type B can be prepended to a list of type T.<br>Of course, an existentially quantified parameter type can also be constrained by bounded quantification, for example:<br>def compareElements[A &lt;: Seq[_ &lt;: Comparable[_]]](seq1: A, seq2: A): Boolean = {
  // Comparison logic here
  true
}
Copy<br><br><br>A key concept in F-Bounded Polymorphism is the F-Bound. In bounded quantification, when a type A is F-Bounded with respect to a type B, this means that instances of A are linked by a particular semantic relation to those of B. A formalization of F-bounded polymorphism appeared in 1989 in the article "F-Bounded Polymorphism for Object-Oriented Programming" by Peter Canning et al. This article presents F-bounded polymorphism (or quantification) as a natural extension of bounded quantification.<br>In this article, we can read this definition:<br>
We say that a universally quantified type is F-bounded if it has the form
âˆ€t âŠ† F[t].Ïƒ
where F[t] is an expression, generally containing the type variable t.
<br>Let's now break this definition into its components:<br>
<br>âˆ€t: This part represents universal quantification over a type variable t. As stated previously, in programming languages, it means that the statement applies to all possible values of the type variable t.
<br>âŠ†: This symbol represents the subtype relationship or upper-bounded quantification explained before.
<br>F[t]: This is the type bound associated with the type variable t. It defines a set of types that t must belong to. Importantly, F[t] is expressed in terms of the type variable t itself. This creates a recursive relationship, where the type bound refers to the type variable it is bounding.
<br>Ïƒ: This is the actual type expression that is being quantified over and constrained by the F-bounded type system. It represents the type structure that we are trying to define and apply constraints to.
<br>In summary, âˆ€t âŠ† F[t].Ïƒ means that for any type t, the type expression Ïƒ is constrained to be a subtype of the type bound F[t] which is defined in terms of the type t itself. In other words, if F[t] is a type of the form F[t] = {aáµ¢: Ïƒáµ¢[t]}, then the condition A âŠ† F[A] says that A must have the methods aáµ¢ and these methods must have arguments as specified by Ïƒáµ¢ [A], which are defined in terms of A.<br>In Scala, probably the simplest example of F-bounded polymorphism is this one:<br>trait T[U &lt;: T[U]]
Copy<br>Please take a few seconds to admire this.<br><br><br>Let's now explain F-bounded polymorphism with the analogy of musical instruments.<br>
<br>t: A specific musical instrument (e.g., a Guitar)<br>

<br>F[t]: When applied to t, results in an instrument constrained to harmonize with instruments of its own type<br>

<br>Ïƒ: { age: InstrumentAge, produceSound: () =&gt; Sound, playInTuneWith: (F[t]) =&gt; Harmony }<br>

<br>In simpler terms, any instrument t is valid only if it can play in tune with another instrument of the same type t and is capable of producing sound.<br>Let's now express the formâˆ€t âŠ† F[t].Ïƒ in terms of Scala code:<br>enum Sound {
  case Strumming(instrumentAge: InstrumentAge)
  case Whistling(instrumentAge: InstrumentAge)
  case Harmony(sound1: Sound, sound2: Sound)
  // note that a recursive type is inherently polymorphic in nature,
  // as well as a sum type
}

import Sound._

enum InstrumentAge {
  case New,    // Crisp and clear sound.
         Old,    // Deep and resonating sound.
       Ancient // Faint and mellow sound.
}

trait Instrument[T &lt;: Instrument[T]] {
  val age: InstrumentAge
  def produceSound(): Sound
  def playInTuneWith(instrument: T): Harmony
}

case class Guitar(age: InstrumentAge) extends Instrument[Guitar] {
  def produceSound(): Sound = Strumming(age)

  def playInTuneWith(instrument: Guitar): Harmony = Harmony(produceSound(), instrument.produceSound())
}

case class Flute(age: InstrumentAge) extends Instrument[Flute] {
  def produceSound(): Sound = Whistling(age)

  def playInTuneWith(instrument: Flute): Harmony = Harmony(produceSound(), instrument.produceSound())
}
Copy<br>Here, Instrument is F-bounded. It ensures that a Guitar can only play in tune with another Guitar and a Flute can only play in tune with another Flute. Thus the following code does not compile because the playInTuneWith method expects a Piano.<br>// compilation error
case class Piano(val age: InstrumentAge) extends Instrument[Piano] {
  def produceSound(): Sound = Whistling(age)

  def playInTuneWith(instrument: Guitar): Harmony = Harmony(produceSound(), instrument.produceSound())
}
Copy<br>Tighter constraint with self-type annotation<br>Finally, in our example, the strength of the Scala type system allows us to go even further in our constraints with self-type annotation:<br>trait Instrument[T &lt;: Instrument[T]] { self: T =&gt;
    ...
}
Copy<br>This definition not only asserts that T is a subtype of Instrument[T] but also guarantees that any concrete class or trait extending Instrument[T] is itself of type T . This creates a tighter constraint than the first trait definition. With this annotation, the following code does not compile anymore<br>class BlueBird extends Instrument[Guitar] {
    ...
}
Copy<br>because BlueBird is not of type Guitar.<br><br><br>We have seen that bounded quantification is a powerful tool that helps in expressing more refined and precise relationships between types.<br>In particular, F-bounded polymorphism offers a sophisticated way of shaping type systems and ensuring logical constraints within programming languages and programs. The concept becomes simpler when seen in light of our musical analogy. It is a powerful concept in type theory that lets us constrain a type parameter based on the type itself. This recursive constraint ensures that subclasses adhere to specific type restrictions.<br>Using F-bounded polymorphism in Scala, we achieved a type-safe way to model real-world scenarios, like musical instruments playing in tune. This ensures that mistakes like trying to tune a guitar with a flute are caught during compilation, thus eliminating potential runtime errors.<br>In essence, F-bounded polymorphism offers an expressive and robust way to encapsulate and ensure type relations. It's like the maestro of a symphony, ensuring each instrument plays in perfect harmony, creating a melody that's both beautiful and error-free.<br><br><br>
<br>P. Canning, W. Cook, W. Hill and W. Olthof. F-Bounded Polymorphism for Object-Oriented Programming. Proceedings of the fourth international conference on Functional programming languages and computer architecture. 1989. <a rel="noopener" class="external-link" href="https://www.cs.utexas.edu/~wcook/papers/FBound89/CookFBound89.pdf" target="_blank">https://www.cs.utexas.edu/~wcook/papers/FBound89/CookFBound89.pdf</a><br>

<br>L. Cardelli and P. Wegner. On understanding types, data abstraction, and polymorphism. Computing Surveys, 17(4):471â€“522, 1986. <a rel="noopener" class="external-link" href="http://lucacardelli.name/papers/onunderstanding.a4.pdf" target="_blank">http://lucacardelli.name/papers/onunderstanding.a4.pdf</a><br>

<br>The Scala 2.11 specification of existential types. <a rel="noopener" class="external-link" href="https://www.scala-lang.org/files/archive/spec/2.11/03-types.html#existential-types" target="_blank">https://www.scala-lang.org/files/archive/spec/2.11/03-types.html#existential-types</a><br>

<br>The Curiously Recurring Template Pattern (CRTP) in C++. See for example <a rel="noopener" class="external-link" href="https://en.cppreference.com/w/cpp/language/crtp" target="_blank">https://en.cppreference.com/w/cpp/language/crtp</a>.
]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/scala/f-bounded-polymorphism-in-scala.html</link><guid isPermaLink="false">Computer Science/Programming Language/Scala/F-bounded polymorphism in Scala.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:33 GMT</pubDate></item><item><title><![CDATA[Overview]]></title><description><![CDATA[ 
 <br><br>This is the second post in a series about inference of machine learning models using scala. The first post can be found <a data-tooltip-position="top" aria-label="https://mattlangsenkamp.github.io/posts/scala-machine-learning-deployment-entry-0/" rel="noopener" class="external-link" href="https://mattlangsenkamp.github.io/posts/scala-machine-learning-deployment-entry-0/" target="_blank">here</a>. This post will detail how to use a functional streaming library (<a data-tooltip-position="top" aria-label="https://fs2.io/#/" rel="noopener" class="external-link" href="https://fs2.io/#/" target="_blank">fs2</a>) to perform machine learning model inference using the <a data-tooltip-position="top" aria-label="https://github.com/triton-inference-server/server" rel="noopener" class="external-link" href="https://github.com/triton-inference-server/server" target="_blank">Triton Inference Server</a> and <a data-tooltip-position="top" aria-label="https://grpc.io/" rel="noopener" class="external-link" href="https://grpc.io/" target="_blank">gRPC</a>. The post will be broken up into a few different parts. First we will set up our scala, python and docker dependencies. Then we will get Triton up and running using Docker. Finally we will set up fs2 to read from a text file containing image paths. We will use <a data-tooltip-position="top" aria-label="https://opencv.org/" rel="noopener" class="external-link" href="https://opencv.org/" target="_blank">opencv</a> to format our images into the representation Triton expects. Finally we will load images and send them to Triton in batches, displaying the result to the console.<br>The github repo for these tutorials can be found <a data-tooltip-position="top" aria-label="https://github.com/MattLangsenkamp/scala-machine-learning-deployment" rel="noopener" class="external-link" href="https://github.com/MattLangsenkamp/scala-machine-learning-deployment" target="_blank">here</a><br><br>It is expected that you have the following tools installed:<br>
<br>scala build tool <a data-tooltip-position="top" aria-label="https://www.scala-sbt.org/" rel="noopener" class="external-link" href="https://www.scala-sbt.org/" target="_blank">sbt</a>
<br>python build tool <a data-tooltip-position="top" aria-label="https://python-poetry.org/" rel="noopener" class="external-link" href="https://python-poetry.org/" target="_blank">poetry</a>
<br>Cuda toolkit and Nvidia Docker. More detailed installation tips can be found in the <a data-tooltip-position="top" aria-label="https://github.com/MattLangsenkamp/scala-machine-learning-deployment" rel="noopener" class="external-link" href="https://github.com/MattLangsenkamp/scala-machine-learning-deployment" target="_blank">github readme</a>
<br><br>First create a new project using the scala 3 giter template/sbt and move to the newly created directory.<br>sbt new scala/scala3.g8 
#   name [Scala 3 Project Template]: scalamachinelearningdeployment 
#   Template applied in ./scalamachinelearningdeployment cd scalamachinelearningdeployment`
Copy<br>Next we will add the fs2 gRPC plugin. Add the following to project/plugins.sbt. This is what will turn our .proto files into code we can use to talk with Triton. We will talk more about .proto files and gRPC later.<br>addSbtPlugin("org.typelevel" % "sbt-fs2-grpc" % "2.7.4")`
Copy<br>We then need to create a module to store our .proto files in, and to run code generation from.<br>mkdir -p protobuf/src/main/protobuf/`
Copy<br>Create a file called downloadprotos.sh and add the following content. These are the proto files provided by the Triton Inference Server. They allow for us to communicate with Triton in any language that can generate code from .proto files.<br>for PROTO in 'grpc_service' 'health' 'model_config' 
do     
  wget -O ./protobuf/src/main/protobuf/$PROTO.proto https://raw.githubusercontent.com/triton-inference-server/common/main/protobuf/$PROTO.proto 
done
Copy<br>Then run the script to download the files.<br>chmod +x downloadprotos.sh
./downloadprotos.sh`
Copy<br>Finally we need to configure our build.sbt. There are a couple key steps to make note of:<br>
<br>Create variables to manage our dependencies
<br>Create a module for the protobuf subdirectory, explicitly stating we depend on the gRPC plugin
<br>Add our dependencies to our root module and make the root module depend to the protobuf module
<br>Copy]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/scala/inference-of-machine-learning-models-using-scala.html</link><guid isPermaLink="false">Computer Science/Programming Language/Scala/Inference of machine learning models using scala.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:30 GMT</pubDate></item><item><title><![CDATA[Refinement types in Scala 3]]></title><description><![CDATA[ 
 <br>When familiarizing myself with additions in Scala 3, it was improvements in meta-programming capabilities that caught my eye. I wondered what it would take to implement a simple refinement types library. It is definitely not my plan to end up with a full-blown refinement library as <a data-tooltip-position="top" aria-label="https://github.com/fthomas/refined" rel="noopener" class="external-link" href="https://github.com/fthomas/refined" target="_blank">refined</a>, but only to understand if the language's new version can offer some improvements in the process.<br>We will use literal types as a basic construct. The introduction of literal types was a subject of <a data-tooltip-position="top" aria-label="https://docs.scala-lang.org/sips/42.type.html" rel="noopener" class="external-link" href="https://docs.scala-lang.org/sips/42.type.html" target="_blank">SIP-23</a>, and they've been already included in Scala 2.13. They enable you to use literals of primitive types at places where types are expected:<br>val a: 4 = 4
// val b: 5 = a // fails compilation with: 
// Found:    (a : (4 : Int))
// Required: (5 : Int)
Copy<br>What Scala 3 adds to the mix are compile-time operators on literal types. You can found them in the scala.compiletime package:<br>type PlusTwo[T &lt;: Int] = scala.compiletime.ops.int.+[2, T]

val a: PlusTwo[4] = 6
// val bb: PlusTwo[4] = 7 // fails compilation with:
// Found:    (7 : Int)
// Required: (6 : Int)
Copy<br>In the definition of PlusTwo I wanted to stress that + is a type operator, hence the prefix notation. In practice infix operator might be more convenient:<br>import scala.compiletime.ops.int.*

type PlusTwo[T &lt;: Int] = 2 + T
Copy<br>One of operators available in compiletime is comparison operator &lt; which looks particularly useful in scope of refinement types:<br>type &lt;[X &lt;: Int, Y &lt;: Int] &lt;: Boolean
Copy<br>Here are some examples of its usage:<br>val a: 5 &lt; 10 = true
// val b: 15 &lt; 10 = true // fails compilation with:
// Found:    (true : Boolean)
// Required: (false : Boolean)
Copy<br>However, in context of refinement types we would like to use &lt; as a kind of type bound as opposed to just an operator returning Boolean. Therefore, while &lt; is definitely helpful, it's not sufficient by itself to express refinement types. We're striving for something akin to:<br>// val a: Int &lt; 10 = 5 // fails compilation
Copy<br><br>To be able to use comparison operators as a type bound we have to build some minimal structure:<br>trait Validated[PredRes &lt;: Boolean]
given Validated[true] = new Validated[true] {}

trait RefinedInt[Predicate[_ &lt;: Int] &lt;: Boolean]
def validate[V &lt;: Int, Predicate[_ &lt;: Int] &lt;: Boolean]
    (using Validated[Predicate[V]]): RefinedInt[Predicate] = new RefinedInt {}
Copy<br>The idea behind this is that code invoking validate will compile only if Predicate[V] evaluates to type true. Therefore, the whole business of validation will be offloaded to the second type parameter of validate.<br>Such minimal structure is enough to express something like this:<br>type LowerThan10[V &lt;: Int] = V &lt; 10
val lowerThan10: RefinedInt[LowerThan10] = validate[4, LowerThan10]
Copy<br>An equivalent written with type lambda:<br>val lowerThan10: RefinedInt[[V &lt;: Int] =&gt;&gt; V &lt; 10] = validate[4, [V &lt;: Int] =&gt;&gt; V &lt; 10]
Copy<br>I must admit the latter looks uglier, but in general, it is preferred as it allows us to avoid coming up with an unnecessary type name.<br>If you want to see how type lambdas are being used in the wild, I recommend taking a look at <a data-tooltip-position="top" aria-label="https://github.com/lampepfl/dotty/blob/master/library/src/scala/Tuple.scala#L139" rel="noopener" class="external-link" href="https://github.com/lampepfl/dotty/blob/master/library/src/scala/Tuple.scala#L139" target="_blank">type-level implementations</a> of scala.Tuple higher kinded types of Filter or Fold.<br>This encoding, while very simplistic and not the most convenient to use, is quite flexible. Thanks to operators in compiletime.ops.bool we can build more complicated predicates as the following:<br>import scala.compiletime.ops.boolean.*

validate[7, [V &lt;: Int] =&gt;&gt; V &gt; 5 &amp;&amp; V &lt; 10]
Copy<br>If we try to pass incorrect input we will get a compilation error:<br>validate[4, [V &lt;: Int] =&gt;&gt; V &gt; 5 &amp;&amp; V &lt; 10]
// no implicit argument of type iteration1.Validated[(false : Boolean)] was found for parameter x$2 of method validate in package iteration1
// L25:   validate[4, [V &lt;: Int] =&gt;&gt; V &gt; 5 &amp;&amp; V &lt; 10]
Copy<br>The compilation error is not very helpful, especially compared to the message produced by <a data-tooltip-position="top" aria-label="https://github.com/fthomas/refined" rel="noopener" class="external-link" href="https://github.com/fthomas/refined" target="_blank">refined</a>:<br>Left predicate of ((4 &gt; 5) &amp;&amp; (4 &lt; 10)) failed: Predicate failed: (4 &gt; 5).
Copy<br>It's something we will work on in iteration 2. That being said, with just a few lines of code we were able to get that basic version working.<br><br>Mechanisms we've used so far, compiletime operators and implicit resolution, are not enough to implement friendly validation errors. That's because the result of implicit resolution is binary - either the implicit had been found or not. We need richer information in case of failure.<br>To do that, we will explore another new feature of Scala 3, which is inline.<br>First, we need to define an ADT for predicates:<br>sealed trait Pred
class And[A &lt;: Pred, B &lt;: Pred]         extends Pred
class Leaf                              extends Pred
class LowerThan[T &lt;: Int &amp; Singleton]   extends Leaf
class GreaterThan[T &lt;: Int &amp; Singleton] extends Leaf
Copy<br>The only notable thing in the above is mixing in Singleton. It restricts type T into being a singleton type, so that LowerThan[Int] will not compile.<br>Then, we have to interpret this ADT at compile-time:<br>import scala.compiletime.*
import scala.compiletime.ops.int.*

trait Validated[E &lt;: Pred]

implicit inline def mkVal[V &lt;: Int &amp; Singleton, E &lt;: Pred](v: V): Validated[E] =
  inline erasedValue[E] match
    case _: LowerThan[t] =&gt;
      inline if constValue[V] &lt; constValue[t]
        then new Validated[E] {}
        else
          inline val vs    = constValue[ToString[V]]
          inline val limit = constValue[ToString[t]]
          error("Validation failed: " + vs + " &lt; " + limit)
    case _: GreaterThan[t] =&gt; // ommited here since it's symmetrical to LowerThan
    case _: And[a, b] =&gt;
      inline mkVal[V, a](v) match
        case _: Validated[_] =&gt;
          inline mkVal[V, b](v) match
            case _: Validated[_] =&gt; new Validated[E] {}
Copy<br>There are a few things worth noting here:<br>
<br>
mkVal has an inline modifier which tells the compiler that it should inline any invocation of this method at compile-time. If it's not possible, compiler will fail the compilation

<br>
erasedValue comes from compiletime package. It's usually used in tandem with inline match. It allows us to match on the expression type, but we cannot access extracted value as that code is executed at compile-time

<br>
You could have noticed a lower-case letter used for the type parameter in case _: LowerThan[t], something against the usual convention. That was not a choice though. In Scala 3 you must use a lower-case identifier for a type being extracted from a pattern match. Using case _: LowerThan[T] would mean that the match would succeed only if LowerThan is parametrized with an already known type T. I like to compare that to term-level pattern match in which there's also a distinction between case a =&gt; and case `a` =&gt;, which in regards to types becomes case _: V[a] and case _: V[A] respectively

<br>
constValue comes from compiletime too. It returns the value of a singleton type

<br>
ToString is a type-level counterpart of toString available only for singleton types of Int, so that val a: ToString[5] = "5" holds

<br>
Calling error fails the compilation with provided message. In Scala 3.0.0 it cannot be invoked with interpolated string, yet it might be <a data-tooltip-position="top" aria-label="https://github.com/lampepfl/dotty/issues/10315" rel="noopener" class="external-link" href="https://github.com/lampepfl/dotty/issues/10315" target="_blank">possible in future</a>.

<br>
mkVal is defined as an implicit conversion so it will never be called explicitly

<br>Once you got acquainted with these new Scala constructs, the code should not be hard to follow. The great news is that it's all it takes to have reasonable refinements types for Int <a data-tooltip-position="top" aria-label="https://msitko.pl/blog/build-your-own-refinement-types-in-scala3.html#footnote1" rel="noopener" class="external-link" href="https://msitko.pl/blog/build-your-own-refinement-types-in-scala3.html#footnote1" target="_blank">1</a>. Let's try it out:<br>val a: Validated[LowerThan[10]] = 6
val b: Validated[GreaterThan[5] And LowerThan[10]] = 6

// val y: Validated[GreaterThan[5] And LowerThan[10]] = 1
// fails with:
// Validation failed: 1 &gt; 5
Copy<br><br>Since the core functionality of refined boils down to preventing some code from being compiled, we have to specify negative test cases as code snippets that do not compile. In Scala 3 there's a built-in operation for that: scala.compiletime.testing.typeCheckErrors. We can employ it to write assertions:<br>import scala.compiletime.testing.typeCheckErrors

class IntSpec extends munit.FunSuite:
  test("Those should not compile") {
    val errs = typeCheckErrors("val x: Validated[LowerThan[10]] = 16")
    assertEquals(errs.map(_.message), List("Validation failed: 16 &lt; 10"))
  }
Copy<br>If you're interested in cross-compiling your code you would be better off using munit's compilerErrors which for Scala 3 <a data-tooltip-position="top" aria-label="https://github.com/scalameta/munit/blob/7761b08fcf34396d90b22b1d086bdfd05bb733b0/munit/shared/src/main/scala-3/munit/internal/MacroCompat.scala#L38" rel="noopener" class="external-link" href="https://github.com/scalameta/munit/blob/7761b08fcf34396d90b22b1d086bdfd05bb733b0/munit/shared/src/main/scala-3/munit/internal/MacroCompat.scala#L38" target="_blank">uses</a> said built-in.<br>Once we have an implementation for Int, it would be interesting to do the same for String.<br><br>We will use the following as a motivating example:<br>val a: String Refined StartsWith["abc"] = "abcd"
Copy<br>We had to add another type parameter in addition to the predicate. To express that that Refined[T, Predicate] type was introduced. You can find the whole code of that <a data-tooltip-position="top" aria-label="https://github.com/note/blog-examples/tree/master/build-your-own-refinement-types-in-scala3/src/main/scala/iteration3" rel="noopener" class="external-link" href="https://github.com/note/blog-examples/tree/master/build-your-own-refinement-types-in-scala3/src/main/scala/iteration3" target="_blank">iteration</a> in the accompanying repository. However, most of it is a straightforward structure not related to metaprogramming so we will jump right to the relevant bits instead.<br>What's interesting is how to actually implement StartsWith predicate at compile-time.<br>The first attempt might be to do the same thing that was done with Int:<br>transparent inline def checkPredString[V &lt;: String &amp; Singleton, E &lt;: Pred]: Boolean =
    inline erasedValue[E] match
      case _: StartsWith[t] =&gt;
        inline if constValue[V].startsWith(constValue[t])
        ...
Copy<br>If we try to invoke it, it will end up with such compilation error:<br>Cannot reduce `inline if` because its condition is not a constant value: "abcd".startsWith("abc")
Copy<br>The problem is that we're trying to call non-inline method startsWith from an inline method. Since compiler cannot reduce startsWith it just cannot be invoked there.<br>The solution to that problem is writing a simple macro:<br>transparent inline def startsWith(inline v: String, inline pred: String): Boolean =
    ${ startsWithC('v, 'pred)  }

def startsWithC(v: Expr[String], pred: Expr[String])(using Quotes): Expr[Boolean] =
    val res = v.valueOrError.startsWith(pred.valueOrError)
    Expr(res)
Copy<br>In the macro implementation (i.e. startsWithC) we are not limited to calling only inline methods; therefore, we can call String.startsWith. From my limited experience with Scala 3 macros, the tricky part is to get a value of type T from Expr[T] for non-primitive types.<br>We can freely call macro startsWith from the inline method checkPredString which completes our exercise.<br><br>Another new Scala 3 feature used in the macro definition is modifier transparent. When it's used in inline method signature <a data-tooltip-position="top" aria-label="https://msitko.pl/blog/build-your-own-refinement-types-in-scala3.html#footnote2" rel="noopener" class="external-link" href="https://msitko.pl/blog/build-your-own-refinement-types-in-scala3.html#footnote2" target="_blank">2</a>, it allows compiler to specialize return type to a more precise type.<br>Getting back to our example, let's take a look at how checkPredString is used:<br>implicit inline def mkValString[V &lt;: String &amp; Singleton, E &lt;: Pred](v: V): Refined[V, E] =
    inline if checkPredString[V, E]
    then Refined.unsafeApply(v)
    else error("Validation failed")
Copy<br>If we remove transparent from checkPredString signature the above code would fail compilation with that message:<br>Cannot reduce `inline if` because its condition is not a constant value: (true:Boolean).&amp;&amp;(true:Boolean):Boolean
Copy<br>Without transparent compiler sees return type of checkPredString as a Boolean which is not enough to inline the code. In contrast to that, with transparent, it would be a concrete type true or false depending on the validation result.<br><br>We've ended up with a code supporting simple compile-time predicates for Int and String with very few lines of code. If you're familiar with Scala 3 metaprogramming building blocks such as inline, the code is straigforward to read. Of course, compared to real refinement types libraries there are many capabilities missing, like predicates inference or runtime lifting to refined types. This is something I explore in <a data-tooltip-position="top" aria-label="https://github.com/note/mini-refined" rel="noopener" class="external-link" href="https://github.com/note/mini-refined" target="_blank">mini-refined</a>.<br>If you're interested more in Scala 3 metaprogramming capabilities, explore links in the next section.<br><br>
<br><a data-tooltip-position="top" aria-label="https://github.com/note/blog-examples/tree/master/build-your-own-refinement-types-in-scala3" rel="noopener" class="external-link" href="https://github.com/note/blog-examples/tree/master/build-your-own-refinement-types-in-scala3" target="_blank">full source code</a> of examples presented in this article
<br><a data-tooltip-position="top" aria-label="http://dotty.epfl.ch/docs/reference/metaprogramming/toc.html" rel="noopener" class="external-link" href="http://dotty.epfl.ch/docs/reference/metaprogramming/toc.html" target="_blank">Scala 3 documentation</a> on metaprogramming
<br><a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=OPBuCQRgyV4" rel="noopener" class="external-link" href="https://www.youtube.com/watch?v=OPBuCQRgyV4" target="_blank">talk</a> by Josh Suereth on inline
<br><a data-tooltip-position="top" aria-label="https://github.com/note/mini-refined" rel="noopener" class="external-link" href="https://github.com/note/mini-refined" target="_blank">mini-refined</a> - project exploring further ideas proposed in this article
<br>1: One thing might bother you in the method signature itself:<br>implicit inline def mkVal[V &lt;: Int &amp; Singleton, E &lt;: Pred](v: V): Validated[E]
Copy<br>Why do we provide value being validated both on type-level and on term-level? Wouldn't such signature suffice:<br>implicit inline def mkVal[E &lt;: Pred](v: Int &amp; Singleton): Validated[E]
Copy<br>Given the new signature we just need to replace all constValue[V] in the previous implementation with v and that's it, right?<br>The answer is mostly yes. It would compile indeed but whenever you call mkVal with a value failing validation, instead of a nice error message you would get:<br>"A literal string is expected as an argument to `compiletime.error`. Got \"Validation failed: \".+(4).+(\" &lt; \").+(limit)
Copy<br>The issue, again, is lack of <a data-tooltip-position="top" aria-label="https://github.com/lampepfl/dotty/issues/10315" rel="noopener" class="external-link" href="https://github.com/lampepfl/dotty/issues/10315" target="_blank">constant folding</a> which occurs in this line:<br>error("Validation failed: " + v + " &lt; " + limit)
Copy<br>Reminder - in the previous version we used constValue[V] instead of just v. Therefore, at least for now, we have to duplicate validated value on both type- and term-level. <a data-tooltip-position="top" aria-label="https://msitko.pl/blog/build-your-own-refinement-types-in-scala3.html#afootnote1" rel="noopener" class="external-link" href="https://msitko.pl/blog/build-your-own-refinement-types-in-scala3.html#afootnote1" target="_blank">â†©</a><br>2: transparent can be also used in <a data-tooltip-position="top" aria-label="https://dotty.epfl.ch/docs/reference/other-new-features/transparent-traits.html#transparent-traits" rel="noopener" class="external-link" href="https://dotty.epfl.ch/docs/reference/other-new-features/transparent-traits.html#transparent-traits" target="_blank">conjunction with traits</a>, in which case it has entirely]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/scala/refinement-types-in-scala-3.html</link><guid isPermaLink="false">Computer Science/Programming Language/Scala/Refinement types in Scala 3.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:33 GMT</pubDate></item><item><title><![CDATA[Overview]]></title><description><![CDATA[ 
 <br><br>This is the first in series of posts which will cover how one might setup a server to perform efficient inference of neural network models on both CPUs and GPUs using the <a data-tooltip-position="top" aria-label="https://www.scala-lang.org/" rel="noopener" class="external-link" href="https://www.scala-lang.org/" target="_blank">Scala</a> programming language. This entry will introduce key concepts at a high level as well as introduce the baseline neural network model we will use throughout the series.<br>Note that throughout this series certain concept or technologies will be mentioned but not explained in detail. This is because most of these technologies are deep and complex in their own right and there is simply not enough time to discuss them here. Instead we will provide a brief description, a link to find more information and a justification as to why that technology is important.<br>One such topic is machine learning and neural networks as a whole. The motivation of this series is not to become an expert on machine learning or neural networks. In fact the training of neural networks will not be covered in any capacity. We are simply interested with the integration of a pre-trained network into a live application. We model a given network as a <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Pure_function" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Pure_function" target="_blank">pure function</a> which accepts an input tensor A as well as weights W, and returns an output B.<br><br>These posts will be geared towards those with some experience with Scala, specifically with experience with the <a data-tooltip-position="top" aria-label="https://typelevel.org/" rel="noopener" class="external-link" href="https://typelevel.org/" target="_blank">Typelevel</a> ecosystem. The idea is that this series will help provide a happy path to getting started with high performance machine learning inference, for developers using this stack. However if you do not have a ton of experience with Scala or Typelevel, you should still be able to follow along as we will link to relevant documentation, and tools like Triton, gRPC and ONNX are language agnostic, so the knowledge you gain on these topics will be transferable to other languages.<br><br>The motivation for these posts is two-fold. First is that neural networks are increasingly common part of solutions in just about every technical domain, and thus it is important to leverage them in a efficient manner. Solutions such as <a data-tooltip-position="top" aria-label="https://aws.amazon.com/pm/sagemaker/" rel="noopener" class="external-link" href="https://aws.amazon.com/pm/sagemaker/" target="_blank">AWS Sagemaker</a>, <a data-tooltip-position="top" aria-label="https://www.paperspace.com/" rel="noopener" class="external-link" href="https://www.paperspace.com/" target="_blank">Digital Ocean Paperspace</a> and <a data-tooltip-position="top" aria-label="https://azure.microsoft.com/en-us/products/machine-learning/" rel="noopener" class="external-link" href="https://azure.microsoft.com/en-us/products/machine-learning/" target="_blank">Azure Machine Learning</a> exist to fill this gap, but there are reasons you would not want to use those services, whether it be organization rules on <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Data_governance" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Data_governance" target="_blank">data governance</a>, the avoidance of vendor lock or simply that those services arenâ€™t an appropriate solution to your specific problem. The second motivation is simply to learn. Taking a problem, approaching it from multiple angles and then continuously refining and analyzing our solutions is a great way to gain a deep understanding of a certain domain.<br><br>We will use the well studied problem of image classification as our baseline problem. Image classification has uses in everywhere from self-driving vehicles to <a data-tooltip-position="top" aria-label="https://arxiv.org/abs/2202.08546" rel="noopener" class="external-link" href="https://arxiv.org/abs/2202.08546" target="_blank">medical image analysis</a>. <a data-tooltip-position="top" aria-label="https://arxiv.org/abs/1506.02640" rel="noopener" class="external-link" href="https://arxiv.org/abs/1506.02640" target="_blank">YOLO</a> (You Only Look Once) is a family of vision models can be used to address tasks such as <a data-tooltip-position="top" aria-label="https://docs.ultralytics.com/tasks/" rel="noopener" class="external-link" href="https://docs.ultralytics.com/tasks/" target="_blank">classification, detection and segmentation</a>. At the time of writing the most recent version of YOLO is YOLOv8 and that is the model we will use throughout this series. <a data-tooltip-position="top" aria-label="https://arxiv.org/abs/2305.09972" rel="noopener" class="external-link" href="https://arxiv.org/abs/2305.09972" target="_blank">YOLOv8</a> was trained on the <a data-tooltip-position="top" aria-label="https://www.image-net.org/" rel="noopener" class="external-link" href="https://www.image-net.org/" target="_blank">ImageNet</a>, which is a dataset of hierarchically organized concepts into nodes in a tree. Each node has around 1000 images that relate to it. Our systems will take an image as input and return the top K predictions for the label that best describes the image, along with the probability assigned to that label. The diagram below shows an example of the inference process at a high level. A user sends a picture of a golden retriever as an HTTP request via curl, the service processes the request and returns a map from the image name to an ordered list of tuples where the first element is the assigned probability that the image belongs to the label, which is the second element.<br>Simplified Inference Process. A request is made to our live service and a mapping of the image to a sorted list of pairs is returned.<br><br><br>The total amount of requests that a system can process over a period of time. Systems are often measured using throughput as high throughput systems scale better in general. Consider a case in which you expect to be be receiving ~1000 requests/second for a sustained period of time and you want each request to take no more than one second. If your system has a measured throughput of 100 requests/second you now know that you will need to run and load balance along at least 10 instances of your hypothetical service. Increasing the throughput of your system will reduce the number of instances you need to run.<br><br>The total time in-between when a network request is sent to a system, and when a response is received. As programmers we generally want to develop low latency systems. What is determined as low enough depends on a use case. For a search engine like google or an internet database like <a data-tooltip-position="top" aria-label="https://www.imdb.com/" rel="noopener" class="external-link" href="https://www.imdb.com/" target="_blank">IMDB</a>, a few fractions of a second of latency is often low enough, as humans tend to perceive that as instantaneous. However for something like a self driving car or an application that deals with high frequency financial data, a few milliseconds of latency may be the target. We care about latency as that will be one of the metrics we use to benchmark our systems.<br><br>Central Processing Unit. The main processor on a given machine. Unless explicitly specified otherwise the instructions generated by a programming language will run on this processor.<br><br>Graphical Processing Unit. A multi-core processor capable of efficiently performing <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Embarrassingly_parallel" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Embarrassingly_parallel" target="_blank">embarrassingly parallel</a> tasks.&nbsp; We care about them as tensor operations commonly found in neural networks are often embarrassingly parallel and thus the training and evaluation of neural networks is greatly accelerated by a GPU.<br><br><a data-tooltip-position="top" aria-label="https://protobuf.dev/" rel="noopener" class="external-link" href="https://protobuf.dev/" target="_blank">Protocol Buffers are language-neutral, platform-neutral extensible mechanisms for serializing structured data</a>. We care about them as they are a building block for both gRPC and the ONNX file format, and they allow for type safe network RPC calls.<br><br><a data-tooltip-position="top" aria-label="https://grpc.io/" rel="noopener" class="external-link" href="https://grpc.io/" target="_blank">Googles Remote Procedure Call framework</a> is a generalized method for different systems to communicate with each other. Data is serialized using Protocol Buffers and is then sent across network boundaries in an extremely efficient way. Aside from being very performant gRPC is also driven by a specification language designed to have code generation tools built around it. This means that you can expose a gRPC server written in Scala and then generate a client (stub) in python, Ruby, Go or any other language to interact with the Scala service. It is important to note that gRPC is not supported by browsers and is generally used by back-end services to communicate with each other.<br><br><a data-tooltip-position="top" aria-label="https://onnx.ai/" rel="noopener" class="external-link" href="https://onnx.ai/" target="_blank">Open Neural Network Exchange</a> is an open format used to describe a neural network. This format is de-coupled from the actual runtime that executes the network. The ability to swap out back-ends is very powerful as different problems will have different hardware constraints. If you do not have GPUs available you can use the default CPU runtime. If you do have access to GPUs then you can use TensorRT or a <a data-tooltip-position="top" aria-label="https://developer.nvidia.com/cuda-toolkit" rel="noopener" class="external-link" href="https://developer.nvidia.com/cuda-toolkit" target="_blank">CUDA</a> runtime. As advances in the machine learning field advance more performant runtimes may be developed and if they choose to support ONNX then you will be able to use them with little to no refactoring.&nbsp; Most frameworks for developing and training neural networks such as PyTorch, TensorFlow or MXNet support exporting to ONNX format. This means you can have multiple different projects using different frameworks to develop your deliverables and by exporting them to ONNX you wont have to change your deployment strategy.<br><br>An SDK developed by Nvidia to optimize and accelerate inference on GPUs. Built on top of CUDA libraries. We want to use it as it can provide state of the art latency and throughput.<br><br>When performing model inference a neural network can either process one tensor at a time, or it can process a batch of tensors. Due to the parallel nature of neural computation processing a batch of tensors is often much more efficient. When deploying a live service that can take requests from multiple sources, we may not have enough data to â€œfillâ€ a batch with any given request. In-flight batching is the process of taking requests that arrive at roughly the same time and dynamically batch them together.<br><br>A model deployment server developed by Nvidia. It takes a model and creates either HTTP or gRPC endpoints to serve requests. It can target different back-ends such as ONNX or TensorRT. It also has the ability to perform inflight batching.]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/scala/setup-a-server-to-perform-efficient-inference-of-neural-network-models.html</link><guid isPermaLink="false">Computer Science/Programming Language/Scala/Setup a server to perform efficient inference of neural network models.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:14:29 GMT</pubDate></item><item><title><![CDATA[Type checking algorithm]]></title><description><![CDATA[ 
 <br><br><br><br><br><br><br><br><br>]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/type-theory/type-checking-algorithm.html</link><guid isPermaLink="false">Computer Science/Programming Language/Type Theory/Type checking algorithm.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Mon, 15 Jan 2024 12:10:29 GMT</pubDate></item><item><title><![CDATA[TypeScript With Rust Errors, No Try Catch, Heresy.]]></title><description><![CDATA[ 
 <br>
Itâ€™s hard to miss things when you donâ€™t know different things exist
<br>The first problem is, and personally, I believe itâ€™s the biggest JavaScript problem ever: we donâ€™t know what can throw an error. From a JavaScript error perspective, itâ€™s the same as the following:<br>try {
  let data = â€œHelloâ€;
} catch (err) {
  console.error(err);
}
Copy<br>JavaScript doesnâ€™t know; JavaScript doesnâ€™t care. You should know.<br>Second thing, this is perfectly viable code:<br>const request = { name: â€œtestâ€, value: 2n };
const body = JSON.stringify(request);
const response = await fetch("https://example.com", {
  method: â€œPOSTâ€,
  body,
});
if (!response.ok) {
  return;
}
Copy<br>No errors, no linters, even though this can break your app.<br>Right now, in my head, I can hear, â€œWhatâ€™s the problem, just use try/catch everywhere.â€ Here comes the third problem: we donâ€™t know which one is thrown. Of course, we can somehow guess by the error message, but what about bigger services/functions with many places where errors can happen? Are you sure you are handling all of them properly with one try/catch?<br><br>let greeting_file_result = File::open(â€œhello.txtâ€);  
let greeting_file = match greeting_file_result {  
  Ok(file) =&gt; file,  
  Err(error) =&gt; panic!("Problem opening the file: {:?}", error),  
};
Copy<br>The most verbose of the three shown here and, ironically, the best one. So, first of all, Rust handles the errors using its amazing enums (they are not the same as TypeScript enums!). Without going into detail, what is important here is that it uses an enum called Result with two variants: Ok and Err. As you might guess, Ok holds a value and Err holdsâ€¦surprise, an error :D.<br>The summary here is that Rust always know where there might be an error. And it force you to deal with it right where it appears (mostly). No hidden ones, no guessing, no breaking app with a surprise face.<br>And this approach is just better. By A MILE.<br>We cannot make TypeScript errors work like the Rust. The limiting factor here is the language itself; it doesnâ€™t have the proper tools to do that.<br>But what we can do is try to make it similar. And make it simple:<br>export type Safe&lt;T&gt; =  
  | {  
    success: true;  
    data: T;  
  }  
  | {  
    success: false;  
    error: string;  
  };
Copy<br>we do need a few try/catches. The good thing is we only need about two, not 100,000:<br>export function safe&lt;T&gt;(promise: Promise&lt;T&gt;, err?: string): Promise&lt;Safe&lt;T&gt;&gt;;
export function safe&lt;T&gt;(func: () =&gt; T, err?: string): Safe&lt;T&gt;;
export function safe&lt;T&gt;(
  promiseOrFunc: Promise&lt;T&gt; | (() =&gt; T),
  err?: string,
): Promise&lt;Safe&lt;T&gt;&gt; | Safe&lt;T&gt; {
  if (promiseOrFunc instanceof Promise) {
    return safeAsync(promiseOrFunc, err);
  }
  return safeSync(promiseOrFunc, err);
}

async function safeAsync&lt;T&gt;(
  promise: Promise&lt;T&gt;, 
  err?: string
): Promise&lt;Safe&lt;T&gt;&gt; {
  try {
    const data = await promise;
    return { data, success: true };
  } catch (e) {
    console.error(e);
    if (err !== undefined) {
      return { success: false, error: err };
    }
    if (e instanceof Error) {
      return { success: false, error: e.message };
    }
    return { success: false, error: "Something went wrong" };
  }
}

function safeSync&lt;T&gt;(
  func: () =&gt; T, 
  err?: string
): Safe&lt;T&gt; {
  try {
    const data = func();
    return { data, success: true };
  } catch (e) {
    console.error(e);
    if (err !== undefined) {
      return { success: false, error: err };
    }
    if (e instanceof Error) {
      return { success: false, error: e.message };
    }
    return { success: false, error: "Something went wrong" };
  }
}
Copy<br>This is just a wrapper with our Safe type as the return one. But sometimes simple things are all you need. Letâ€™s combine them with the example from above.<br>const request = { name: â€œtestâ€, value: 2n };  
const body = safe(  
  () =&gt; JSON.stringify(request),  
  â€œFailed to serialize requestâ€,  
);  
if (!body.success) {  
  // handle error (body.error)  
  return;  
}  
const response = await safe(  
  fetch("https://example.com", {  
    method: â€œPOSTâ€,  
    body: body.data,  
  }),  
);  
if (!response.success) {  
  // handle error (response.error)  
  return;  
}  
if (!response.data.ok) {  
  // handle network error  
  return;  
}  
// handle response (body.data)
Copy<br>New solution is longer, but it performs better because of the following reasons:<br>
<br>no try/catch
<br>we handle each error where it occurs
<br>we can specify an error message for a specific function
<br>we have a nice top-to-bottom logic, all errors on top, then only the response at the bottom
]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/typescript/typescript-with-rust-errors,-no-try-catch,-heresy..html</link><guid isPermaLink="false">Computer Science/Programming Language/Typescript/TypeScript With Rust Errors, No Try Catch, Heresy..md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sat, 11 May 2024 10:07:24 GMT</pubDate></item><item><title><![CDATA[WebAssemblyåŸç†ä¸æ ¸å¿ƒæŠ€æœ¯]]></title><description><![CDATA[ 
 <br>â€œWebAssemblyåŸç†ä¸æ ¸å¿ƒæŠ€æœ¯.epubâ€ could not be found.]]></description><link>https://muqiuhan.github.io/wiki/computer-science/programming-language/webassmbly/webassemblyåŸç†ä¸æ ¸å¿ƒæŠ€æœ¯.html</link><guid isPermaLink="false">Computer Science/Programming Language/WebAssmbly/WebAssemblyåŸç†ä¸æ ¸å¿ƒæŠ€æœ¯.md</guid><dc:creator><![CDATA[éŸ©æš®ç§‹]]></dc:creator><pubDate>Sun, 07 Jan 2024 11:20:53 GMT</pubDate></item></channel></rss>